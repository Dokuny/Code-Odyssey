INSERT INTO problem (problem_id,platform,href,no,title,runtime,memory,difficulty,content,input,output,type) VALUES

                                                                                                                (6265,'BAEKJOON','https://www.acmicpc.net/problem/1021',1021,'회전하는 큐','2초','128 MB',8,'<p>지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다.</p>

<p>지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다.</p>

<ol>
	<li>첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 a<sub>1</sub>, ..., a<sub>k</sub>이었던 것이 a<sub>2</sub>, ..., a<sub>k</sub>와 같이 된다.</li>
	<li>왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a<sub>1</sub>, ..., a<sub>k</sub>가 a<sub>2</sub>, ..., a<sub>k</sub>, a<sub>1</sub>이 된다.</li>
	<li>오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a<sub>1</sub>, ..., a<sub>k</sub>가 a<sub>k</sub>, a<sub>1</sub>, ..., a<sub>k-1</sub>이 된다.</li>
</ol>

<p>큐에 처음에 포함되어 있던 수 N이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 큐의 크기 N과 뽑아내려고 하는 수의 개수 M이 주어진다. N은 50보다 작거나 같은 자연수이고, M은 N보다 작거나 같은 자연수이다. 둘째 줄에는 지민이가 뽑아내려고 하는 수의 위치가 순서대로 주어진다. 위치는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 문제의 정답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 3
1 2 3
','0
','DATA_STRUCTURE'),
                                                                                                                (6269,'BAEKJOON','https://www.acmicpc.net/problem/1043',1043,'거짓말','2초','128 MB',12,'<p>지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 지민이는 그 이야기를 말할 때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 당연히 과장해서 이야기하는 것이 훨씬 더 재미있기 때문에, 되도록이면 과장해서 이야기하려고 한다. 하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수 밖에 없다. 당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 지민이는 이런 일을 모두 피해야 한다.</p>

<p>사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 사람의 수 N과 파티의 수 M이 주어진다.</p>

<p>둘째 줄에는 이야기의 진실을 아는 사람의 수와 번호가 주어진다. 진실을 아는 사람의 수가 먼저 주어지고 그 개수만큼 사람들의 번호가 주어진다. 사람들의 번호는 1부터 N까지의 수로 주어진다.</p>

<p>셋째 줄부터 M개의 줄에는 각 파티마다 오는 사람의 수와 번호가 같은 방식으로 주어진다.</p>

<p>N, M은 50 이하의 자연수이고, 진실을 아는 사람의 수는 0 이상 50 이하의 정수, 각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 문제의 정답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
0
2 1 2
1 3
3 2 3 4
','3
','DATA_STRUCTURE'),
                                                                                                                (6267,'BAEKJOON','https://www.acmicpc.net/problem/1088',1088,'케이크','2초','128 MB',19,'<p>지민이는 케이크를 N조각 사왔다. 각 조각은 무게가 서로 다르다. 지민이는 케이크를 최대 M번 자르려고 하는데, 한 조각을 한 번 자를 때마다 두 개의 서로 다른 조각으로 나누어진다. 최대 M번 잘라서 가장 무게가 많이 나가는 조각과 적게 나가는 조각의 무게 차이를 가장 작게 만들었을 때, 그 차이를 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 케이크 조각의 개수 N이 주어진다. N은 50보다 작거나 같다. 둘째 줄에 각 조각의 무게가 주어진다. 이 값은 1,000,000,000보다 작거나 같은 자연수이다. 셋째 줄에는 M이 주어진다. M은 100,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가장 무게가 많이 나가는 조각과 적게 나가는 조각의 최소 무게 차이를 출력한다. 절대/상대 오차는 10<sup>-9</sup>까지 허용한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
1 3
1
','0.5
','DATA_STRUCTURE'),
                                                                                                                (6266,'BAEKJOON','https://www.acmicpc.net/problem/1108',1108,'검색 엔진','2초','128 MB',18,'<p>새로운 검색 엔진을 만들었다. 이 검색 엔진은 구글을 뛰어넘는 세계 최고의 검색 엔진이기 때문에, 신뢰도가 높은 결과를 보여줘야 한다. 하지만, 사용자가 검색어를 입력했을 때, 이것에 맞는 결과가 수천, 수만개가 될 수 있으므로, 이 중에 어떤 것이 중요하고, 어떤 사이트를 보여줘야 하는지가 큰 문제이다.</p>

<p>구글은 이러한 것을 사이트를 크롤링해서 자체 알고리즘을 이용해서 사이트의 순위를 매긴다.</p>

<p>우리의 검색 엔진은 다음과 같은 방법을 사용할 것이다.</p>

<p>일단 모든 웹사이트에 1점을 준다. 만약에 웹사이트 A에 웹사이트 B로 가는 링크가 있다면, 웹사이트 B의 점수에 웹사이트 A의 점수를 더한다.</p>

<p>예를 들어, 웹사이트가 총 3개가 있다. A, B, C이다. 일단 모든 웹사이트의 점수는 1이다. 이제, 웹사이트 A와 B에 모두 C로 가는 링크가 있다고 하면, C의 점수는 3이 되고, A와 B의 점수는 그대로 1이다. 만약 어떤 검색어가 입력 되었는데, 이 웹사이트 A B C에 모두 해당하는 것이었다면, C가 가장 위에 표시된다.</p>

<p>이런 웹사이트에 점수를 매기는 일이 어려운 이유는 바로, 링크를 교환하는 사이트 들이 있기 때문이다. 이 말은 A가 B를 링크하고, B가 A를 링크하는 것이다. 따라서, 이런 현상으로 점수가 무한대로 늘어나는 것을 방지하기 위해서, A의 점수를 B에 더할 때는, B에서 A로의 링크가 직접적으로 또는 간접적으로 없을 때이다.</p>

<p>링크가 어떻게 되어있는 지가 주어지고, 웹사이트의 이름이 주어질 때, 그 웹사이트의 점수를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 링크 정보의 개수 N이 주어진다. 이 N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 링크의 정보가 주어진다. 링크의 정보에 처음 등장하는 문자열은 웹사이트의 이름이고, 그 다음에 등장하는 수는 그 웹사이트를 가리키고 있는 웹사이트 이름의 수이다. 예를 들어, "C 2 A B"는 A에서 C로 가는 링크, B에서 C로 가는 링크가 있다는 의미이다. 마지막 줄에는 점수를 조사해야 할 웹사이트의 이름이 주어진다.</p>

<p>모든 웹사이트의 이름은 길이가 50보다 작거나 같은 알파벳 대문자로 이루어진 문자열이다. 한 웹사이트를 가리키고 있는 웹사이트 이름의 수는 24보다 작거나 같은 음이 아닌 정수이다. 한 웹사이트를 가르키고 있는 웹사이트에 대한 정보는 여러 번 등장하지 않는다. 점수를 조사해야 할 웹사이트의 이름은 반드시 링크의 정보에 등장한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 문제의 정답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
A 3 B C D
B 2 C D
C 1 D
A
','8
','DATA_STRUCTURE'),
                                                                                                                (6274,'BAEKJOON','https://www.acmicpc.net/problem/1150',1150,'백업','2초','128 MB',22,'<p>당신은 큰 회사들의 컴퓨터 자료를 백업하여주는 정보통신회사를 운영한다. 자료 백업이 즐거운 일이 아니므로, 당신은 서로 다른 두 회사의 자료를 서로 백업하여 주는 시스템을 개발하여 당신이 집에서 게임을 즐기는 동안 백업이 이루어지게 하려 한다.</p>

<p>모든 회사들은 직선인 길을 따라 위치하고 있다. 당신은 서로 백업을 하여 줄 두 회사를 짝 지어 주어야 하는데, 두 회사 사이에 네트워크 케이블을 연결 사용하여야 한다.</p>

<p>네트워크 케이블은 대단히 비쌀 뿐 아니라, 지역 통신 회사에서는 당신에게 오직 k개의 네트워크 케이블을 제공한다 ?이 말은 당신이 오직 k 쌍의 회사에만 백업을 할 수 있다는 뜻이다 (전체 2k 개의 회사). 어떤 회사도 두 개 이상의 쌍에 속할 수는 없다 (즉, 여기 2k 개의 회사가 모두 다른 회사라는 것을 뜻한다).</p>

<p>통신 회사는 네트워크 케이블의 길이를 km 단위로 경비를 부과한다. 따라서 당신은 가장 짧은 길이의 케이블을 사용하도록 회사들을 k 쌍으로 짝지어야 한다. 다시 말하자면, 회사들을 짝짓기 하는데, 짝지어진 두 회사간의 거리들의 전체 합을 최소화 하도록 짝을 지어야 한다는 것이다.</p>

<p>예를 들어, 아래 그림과 같이 다섯 개의 고객회사들이 같은 길 위에 위치한다고 하자. 이 회사들은 각각 길의 출발점에서 기준하여 1 km, 3 km, 4 km, 6 km 그리고 12 km 에 위치하고 있다. 통신회사에서는 오직 k = 2 케이블만을 제공한다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/backup.png" style="height: 132.5px; width: 374.167px;"></p>

<p>예에서 최선의 짝 짓기 방법은 첫 번째와 두 번째 회사, 그리고 세 번째와 네 번째 회사를 묶어 주는 것이다. k = 2 케이블 만을 사용하게 되며, 첫 번째 케이블의 길이는 3 km ?1 km = 2 km 이고, 두 번째 케이블의 길이는 6 km ?4 km = 2 km 이다. 이와 같은 짝짓기는 전체 4 km 의 네트워크 케이블을 사용하게 되며, 실제 가능한 가장 짧은 경우이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에는 정수 n 과 k 가 주어지는데, 각각 길 위의 회사 수(2 ≤ n≤ 100 000), 그리고 제공되는 네트워크 케이블 수(1 ≤ k ≤ ½ n)를 의미한다. 그 다음 n 줄에는 각각 하나의 정수 s (0 ≤ s ≤ 1 000 000 000) 가 주어지며, 이 정수는 길의 출발점에서 각 회사까지의 거리를 의미한다. 이 정수들은 가장 작은 것에서 가장 큰 것 까지 순서대로 나타난다. 어떤 두 개의 회사도 같은 지점에 있지 않다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 반드시 하나의 양의 정수로 표현되어야 하는데, 이것은 2k 의 서로 다른 회사를 k 쌍으로 묶었을 때 필요한 가장 짧은 전체 네트워크 케이블의 길이이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
1
3
4
6
12
','4
','DATA_STRUCTURE'),
                                                                                                                (6270,'BAEKJOON','https://www.acmicpc.net/problem/1156',1156,'장난감','2초','128 MB',21,'<p>정문이는 생일을 맞아 $D$일동안 생일파티를 열기로 하였다. 이에 정문이 친구들은 시간을 내어 정문이 생일파티에 참석하기로 하였다. 그리고 정문이는 이번 생일파티는 친구들과 함께 장난감을 갖고 노는 것으로 시간을 보내기로 계획하였다. 좀 더 구체적으로 $i$번째 날에는 $T_i$개의 장난감을 갖고 놀기로 계획을 세웠다.</p>

<p>장난감 가게에는 장난감 하나를 $T_c$원에 판다. 정문이는 적당히 장난감을 사서 이 장난감들을 계속 재활용하여 파티를 하려고 했으나, 결벽증이 있는 친구들은 새 장난감이나 살균장에서 소독된 장난감이 아니면 안 갖고 놀겠다고 하는 탓에 어쩔 수 없이 계획을 수정하기로 하였다.</p>

<p>정문이가 이용하는 살균장은 두 곳이다. 한 곳은 밤에 장난감을 맡기면 $N_1$일이 지난 아침에 찾아올 수 있고 비용은 한 개당 $C_1$이 든다. 다른 한 곳은 마찬가지로 $N_2$일이 지난 아침에 찾아올 수 있고 비용은 한 개당 $C_2$가 든다.</p>

<p>문제는 정문이를 도와 적당히 장난감을 사고 적당히 이 장난감을 살균장에 맡기는 방식으로 생일파티를 끝낼 수 있는 최소 비용을 구하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 정수 $D$, $N_1$, $N_2$, $C_1$, $C_2$, $T_c$가 공백으로 구분되어 주어진다. 두 번째 줄에는 $D+1$번째 줄까지 $i+1$번째 줄에는 $i$번째 날에 필요한 장난감의 수가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 생일파티를 끝내기 위한 최소비용을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<ul>
	<li>Day 1 - 8개의 장난감을 \$24에 구입한다. 이 날 장난감을 모두 갖고 놀고 밤에 2개는 1번 살균장에 6개는 2번 살균장에 맡긴다.</li>
	<li>Day 2 - 아침에 어제 1번 살균장에 맡겼던 2개를 \$4원을 주고 찾아온다. 그리고 갖고 논 후 1개의 장난감을 2번 살균장에 맡긴다.</li>
	<li>Day 3 - 이틀 전 2번 살균장에 맡겼던 6개의 장난감을 \$6를 지불하고 찾아온다.</li>
	<li>Day 4 - 이틀 전 2번 살균장에 맡겼던 1개의 장난감을 \$1을 지불하고 찾아온다. 이로써 총 지불액은 $35가 된다.</li>
</ul>

<p>※ Test case의 70%는 D가 500 이하이다.</p>

				</div>
				</div>','4 1 2 2 1 3
8
2
1
6
','35','DATA_STRUCTURE'),
                                                                                                                (6271,'BAEKJOON','https://www.acmicpc.net/problem/1158',1158,'요세푸스 문제','2초','256 MB',7,'<p>요세푸스 문제는 다음과 같다.</p>

<p>1번부터 N번까지 N명의 사람이 원을 이루면서&nbsp;앉아있고, 양의 정수 K(≤ N)가&nbsp;주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.</p>

<p>N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>예제와 같이 요세푸스 순열을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 3
','<3, 6, 2, 7, 5, 1, 4>
','DATA_STRUCTURE'),
                                                                                                                (6272,'BAEKJOON','https://www.acmicpc.net/problem/1161',1161,'버스','2초','128 MB',18,'<p>포천 주민들은 여러 버스 정류장에서 버스를 기다리고 있다. 하지만 안타깝게도 버스는 이 모든 사람들을 수용할 수 있는 크기가 되지 못한다.&nbsp;</p>

<p>문제는 정류장의 개수 N과 M개의 그룹에 대해 현재 기다리는 정류장 번호와 내릴 정류장 번호가 주어지면 1번 정류장에서 출발하여 N번 정류장까지 운행할 때 최대 태울 수 있는 인원을 구하는 것이다. 단, 버스는 1, 2, …, N번 정류장 순서로 방문한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 그룹의 수 K(1 ≤ K ≤ 50,000)와 정류장 개수 N(1 ≤ N ≤ 20,000)과 버스의 최대 수용 인원 C(1 ≤ C ≤ 100)가 공백으로 구분되어 주어진다. 두 번째 줄부터 K+1번째 줄까지 각 줄에 대해 K개의 그룹에 대한 정보가 담긴 Si, Ei, Mi가 주어지는데 이는 이 그룹은 총 Mi명이고 Si번 정류장에서 출발하여 Ei번 정류장에서 내릴려고 한다는 의미이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 최대 수송 인원을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>버스가 1번->5번으로 가는 2명인 그룹과 5번->8번으로 가는 3명인 그룹, 8번->14번으로 가는 2명인 그룹, 9번->12번으로 가는 1명인 그룹, 13번->14번으로 가는 1명인 그룹, 14번->15번으로 가는 1명인 그룹을 태우면 총 10명을 수송한 셈이 된다.</p>

				</div>
				</div>','8 15 3
1 5 2
13 14 1
5 8 3
8 14 2
14 15 1
9 12 1
12 15 2
4 6 1
','10','DATA_STRUCTURE'),
                                                                                                                (6275,'BAEKJOON','https://www.acmicpc.net/problem/1169',1169,'정사각형 진열','2초','128 MB',16,'<p>크기가 서로 다른 N개의 정사각형이 있다. 모든 정사각형의 한 변의 길이는 자연수이다. 이제 이 정사각형들을 아래와 같이 45도 기울여서 진열하려고 한다.</p>

<p><img alt="" height="149" src=https://www.acmicpc.net/upload/201003/sq.JPG" width="236"></p>

<p>먼저, 첫 번째 정사각형 S1을 x축과 y축에 접하게 놓는다. 이럴 때 x축과 정사각형이 만나는 위치를 b1이라고 생각한다.</p>

<p>이어서 S2부터 정사각형을 하나씩 순서대로 놓는데, i번째 정사각형 Si를 놓을 때, bi는 bi-1보다는 커야 하되 다른 정사각형과 겹치지 않으면서 최대한 bi가 작게 놓아야 한다.</p>

<p>이렇게 정사각형들을 진열하고 난 뒤에, 우리는 y축 방향에서 보이는 정사각형들을 구하고 싶다. 정사각형 위의 임의의 한 점에서 y축 방향으로 반직선을 그렸을 때, 다른 정사각형들과 만나지 않는 반직선이 존재하는 경우 "y축 방향에서 보이는 정사각형"으로 정의한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정사각형의 개수 N(1 ≤ N ≤ 100)이 주어진다. 이어서 둘째 줄에 각 정사각형의 한 변의 길이를 나타내는 N개의 자연수가 순서대로 주어진다. 각 정사각형의 길이는 1,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 y축 방향에서 보이는 정사각형의 번호를 빈 칸을 사이에 두고 증가하는 순서로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3 5 1 4
','1 2 4','DATA_STRUCTURE'),
                                                                                                                (6278,'BAEKJOON','https://www.acmicpc.net/problem/1180',1180,'선인장의 지름','1초','128 MB',23,'<p>Cactus란 그래프 상의 모든 에지가 최대 하나의 사이클에만 속한 연결된 양방향 그래프이다. 즉, Cactus는 몇몇 그래프를 포함하는 트리라고 생각하면 된다.</p>

<p>문제는 주어진 Cactus의 지름을 찾는 것이다. 지름이란 모든 두 점 사이의 최단 거리 중 최대 거리를 뜻한다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201003/ccc.JPG" style="height:253px; width:240px"></p>

<p>위의 Cactus의 예에서는 6번 정점에서 12번 정점까지의 최단경로가 8로 이 두 점 사이의 최단 경로가 Cactus 내에 존재하는 최단경로 중 최대가 되므로 지름은 8이 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 정점의 개수 N(1 ≤ N ≤ 50,000)과 간선의 집합 개수 M(0 ≤ M ≤ 10,000)이 주어진다. 다음 M개의 줄에 M개의 간선의 집합에 대한 정보가 주어지는데, 각 줄에 첫 번째 수 Ki(1 ≤ Ki ≤ 1,000)는 i번째 에지 집합의 개수를 나타낸다. 다음 Ki개의 수는 정점의 번호를 나타내는데 인접한 두 정점간의 에지가 집합에 포함되는 것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 Cactus의 지름을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','15 3
9 1 2 3 4 5 6 7 8 3
7 2 9 10 11 12 13 10
5 2 14 9 15 10
','8
','DATA_STRUCTURE'),
                                                                                                                (6276,'BAEKJOON','https://www.acmicpc.net/problem/1184',1184,'귀농','1초','256 MB',16,'<p>상근이와 선영이는 도심 속의 삶에 싫증을 느꼈고, 친구 현수가 있는 시골로 농사를 지으려 내려왔다. 현수의 땅은 크기가 N×N 인 정사각형이고, 땅은 단위 정사각형 1×1로 나누어져 있다. 각 단위 정사각형 (i,j)의 수익은 A<sub>ij</sub>이다. A<sub>ij</sub>는 음수가 될 수도 있다. (땅을 경작하지 않아 관리가 필요한 경우)</p>

<p>현수는 자신의 땅의 일부를 상근이와 선영이에게 빌려주려고 한다. 두 사람이 받게되는 땅은 항상 직사각형 모양이고, 변은 축에 평행하다.</p>

<p>현수는 두 사람이 농사지을 땅의 수익의 합이 같게 되도록 땅을 빌려주려고 한다. 또, 경쟁심을 유도하기위해 두 땅은 꼭짓점 하나에서만 만나게 하려고 한다. (변을 공유할 수는 없다)</p>

<p>현수 땅의 정보가 주어졌을 때, 땅을 나누어주는 방법의 수를 구하는 프로그램을 작성하시오.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 땅의 크기 N (1 ≤ N ≤ 50)이 주어진다.</p>

<p>다음 N개의 줄의 N번째 숫자 A<sub>ij</sub>는 부분 정사각형 (i,j)의 수익이다. (-1000 < A<sub>ij</sub> < 1000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>현수의 조건을 만족시키면서 땅을 빌려주는 방법의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>가능한 방법은 다음과 같다.</p>

<ul>
	<li>(0,0)-(1,1), (2,2)-(2,2)</li>
	<li>(1,0)-(1,0), (0,1)-(0,1)</li>
	<li>(2,0)-(2,0), (1,1)-(1,1)</li>
	<li>(1,1)-(1,1), (0,2)-(0,2)</li>
	<li>(2,1)-(2,1), (1,2)-(1,2)</li>
	<li>(2,0)-(2,1), (0,2)-(1,2)</li>
	<li>(1,0)-(2,0), (0,1)-(0,2)</li>
</ul>

				</div>
				</div>','3
1 2 3
2 3 4
3 4 8
','7
','DATA_STRUCTURE'),
                                                                                                                (6277,'BAEKJOON','https://www.acmicpc.net/problem/1191',1191,'게임','2초','128 MB',21,'<p>드록바와 셰브첸코가 첼시에서 같이 훈련하던 옛날 옛적 어느 날 두 선수는 훈련에 지쳐 다음과 같은 게임을 하며 쉬기로 한다.</p>

<p>편의상 두 플레이어를 A, B라고 부를 때, 두 플레이어는 N*N짜리 정사각형 보드의 한 점에서 시작하게 된다.</p>

<p>그래서 A, B는 각각 시작점을 가지게 되고 보드에는 흰 칸과 검은 칸이 있는데 검은 칸은 지나가지 못하는 칸이다.(물론 A, B의 시작점과 검은 칸이 겹치는 경우는 없다.)</p>

<p>플레이어들은 각 턴마다 상, 하, 좌, 우로 한 번씩 움직일 수 있다. 그리고 만약 플레이어가 움직여서 상대방의 현 위치와 겹치게 되면 그 플레이어는 상, 하, 좌, 우중 한 방향으로 한 번 더 움직일 수 있는 기회를 받는다.</p>

<p>A플레이어가 먼저 턴을 시작한다고 할 때 상대방의 시작점으로 먼저 도착하는 사람이 경기의 승자가 된다. 양 선수는 최선의 전략을 사용한다고 가정할 때 누가 승자가 될지 알아 보아라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 테스트 데이터의 개수 t (1 ≤ t ≤ 10)가 들어온다. 그리고 다음 t개의 세트에는 우선 맵의 크기 n(1 ≤ n ≤ 300)이 주어지고 다음에는 N×N짜리 지도가 주어지는데 A의 위치와 B의 위치가 표시되어있고 흰자리는 ‘.’, 검은 자리는 ‘#’으로 표시되어있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>누가 승리할지 테스트 케이스 순서대로 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 테스트 케이스의 경우인데 A가 어떤 방향으로 움직이던 B가 따라가게 된다면 A가 3칸을 움직이고 B가 3칸째 움직이게 될 때 A의 위치와 겹칠 수 있고 그때 B가 한 번의 추가 움직임을 허용 받아 더 먼저 상대의 시작장소로 갈 수 있다. 이는 두 번째 테스트 케이스의 경우인데 이 경우 B가 어떻게 가던 A가 피해간다면 만나지 않을 수 있고 서로 만나지 않는다면 먼저 시작한 A가 승리할 수 있다.</p>

				</div>
				</div>','2
4
A...
.#..
....
...B
4
A...
....
..#.
...B
','B
A
','DATA_STRUCTURE'),
                                                                                                                (6279,'BAEKJOON','https://www.acmicpc.net/problem/1202',1202,'보석 도둑','1초','256 MB',14,'<p>세계적인 도둑 상덕이는 보석점을 털기로 결심했다.</p>

<p>상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 M<sub>i</sub>와 가격 V<sub>i</sub>를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 C<sub>i</sub>이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.</p>

<p>상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)</p>

<p>다음 N개 줄에는 각 보석의 정보 M<sub>i</sub>와 V<sub>i</sub>가 주어진다. (0 ≤ M<sub>i</sub>, V<sub>i</sub> ≤ 1,000,000)</p>

<p>다음 K개 줄에는 가방에 담을 수 있는 최대 무게 C<sub>i</sub>가 주어진다. (1 ≤ C<sub>i</sub> ≤ 100,000,000)</p>

<p>모든 숫자는 양의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>두 번째 예제의 경우 첫 번째 보석을 두 번째 가방에, 세 번째 보석을 첫 번째 가방에 넣으면 된다.</p>

				</div>
				</div>','2 1
5 10
100 100
11
','10
','DATA_STRUCTURE'),
                                                                                                                (6280,'BAEKJOON','https://www.acmicpc.net/problem/1216',1216,'충무공 이순신','1.216초','512 MB',25,'<p>국토교통부 장관인 수현이는 올해도 다름없이 12월 16일을 맞이할 준비를 하고 있다. 이유는 가장 존경하는 위인이 충무공 이순신이기 때문이다. 그리고 충무공 이순신이 전사함과 동시에 임진왜란이 종전된 날짜가 1598년 12월 16일이므로 수현이에겐 12월 16일이 자신의 생일보다도 중요한 날이 되었다.</p>

<p>수현이는 ‘올해는 무엇으로 12월 16일을 맞이해 볼까?’라고 생각하다가 엄청난 아이디어가 떠올랐다. 바로 충무공 이순신 하면 가장 먼저 떠오르는 거북선을 직접 만들어 보기로 했다. 하지만 아직까지 거북선의 정확한 설계도가 밝혀지지 않아서 1000년 이상 된 소나무를 사용하여 모양만 흉내 내기로 하였다.</p>

<p>우리나라엔 1000년 이상 된 소나무가 있는 지역이 $n$개가 있으며 각 지역은 $1$번부터 $n$번까지 고유의 번호가 주어져 있으며, 거북선을 만들 공방은 $1$번 지역에 있다. 그리고 두 지역을 잇는 $m$개의 양방향 도로가 주어지며, 초기에 주어지는 모든 도로는 국도다. 도로의 종류는 국도와 고속도로로 2가지가 있다.</p>

<p>각 지역은 그곳으로 가기 위한 힘든 정도가 정해져 있다. 하지만 공방이 있는 $1$번 지역에서 도로를 이용해 갈 수 있는 지역의 힘든 정도는 편한 정도로 바뀌며, 공방이 있는 $1$번 지역에서 고속도로만을 이용해 갈 수 있는 지역의 편한 정도는 두 배가 된다. 물론, $1$번 지역에서 갈 수 있는 지역이란 뜻은 $1$번 지역에서 그 지역까지 경로가 있다는 뜻이며 당연히 공방이 있는 $1$번 지역도 해당된다.</p>

<p>이제부터 국토교통부 장관인 수현이는 거북선을 편하게 만들고자 직권을 행사해 임의의 두 지역을 양방향 도로로 연결하려고 한다. 단, 도로교통법에 의해 고속도로는 사이클을 이루지 않아야 하며, 두 지역을 고속도로로 연결하기 위해선 두 지역 사이에 국도로 이동할 수 있는 경로가 존재해야 한다.</p>

<p>한편, 수현이의 직권 남용을 알게 된 감사원장 민지는 화가 났다..! 그래서 민지는 수현이가 연결한 고속도로를 다시 철거하려고 한다. 민지의 친구 해린이는 민지가 화가 난 이유가 궁금해져서 민지를 따라왔다가, 각 지역의 힘든 정도나 편한 정도가 궁금해져서 조사하기로 했다. 하지만 수현이와 민지 그리고 해린이는 할 일이 너무 많아서 코딩의 달인으로 유명한 우리한테 부탁을 했다.</p>

<p>자, 이제 수현이와 민지 그리고 해린이의 부탁을 들어주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 지역의 개수 $n$, 도로의 개수 $m$이 공백으로 구분되어 주어진다. $(1 \le n, m \le 121\,600)$</p>

<p>두 번째 줄에는 각 지역으로 가기 위한 힘든 정도 $hard_i$가 1번 지역부터 차례대로 공백으로 구분되어 주어진다. $(1 \le hard_i \le 1\,216)$</p>

<p>세 번째 줄부터 $m$개의 줄에 걸쳐 $a$ 지역과 $b$ 지역을 잇는 국도를 나타내는 두 정수 $a$, $b$가 공백으로 구분되어 주어진다. $(1 \le a, b \le n; a \ne b)$</p>

<p>$3+m$번째 줄에는 수현이와 민지 그리고 해린의 작업 횟수의 총합 $q$가 주어진다. $(1 \le q \le 121\,600)$</p>

<p>$4+m$번째 줄부터 $q$개의 줄에 걸쳐 작업을 나타내는 $p$, $a$, $b$가 공백으로 구분되어 주어진다. $(1 \le p \le 6; 1 \le a, b \le n; a \ne b)$</p>

<p>$p$는 아래와 같은 내용의 작업을 나타낸다.</p>

<ul>
	<li>$p = 1$: $a$ 지역과 $b$ 지역을 국도로 잇는다.</li>
	<li>$p = 2$: $a$ 지역과 $b$ 지역을 고속도로로 잇는다. 만약 $a$ 지역에서 $b$ 지역까지 가는 국도 경로가 존재하지 않거나 새로 짓게 되는 고속도로 때문에 고속도로 사이클이 생기면 <code><span style="color:#e74c3c;">-1</span></code>을 출력하고 $a$ 지역과 $b$ 지역을 고속도로로 잇지 않는다.</li>
	<li>$p = 3$: $a$ 지역과 $b$ 지역을 잇는 고속도로를 철거한다. 만약 $a$ 지역과 $b$ 지역을 잇는 고속도로가 없다면 <code><span style="color:#e74c3c;">-1</span></code>을 출력한다.</li>
	<li>$p = 4$: $a$ 지역과 $b$ 지역을 포함한 모든 지역의 힘든 정도의 합을 구해 출력한다.</li>
	<li>$p = 5$: $a$ 지역과 $b$ 지역의 편한 정도의 합을 구해 출력한다.</li>
	<li>$p = 6$: $a$ 지역에서 $b$ 지역까지 가는 고속도로 경로에 있는 모든 지역의 편한 정도의 합을 구해 출력한다. 만약 $a$ 지역에서 $b$ 지역까지 가는 고속도로 경로가 없다면 <code><span style="color:#e74c3c;">-1</span></code>을 출력한다.</li>
</ul>

<p>모든 작업은 주어지는 순서대로 한 번에 하나씩 진행되며, 입력으로 주어지는 모든 수는 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$q$개의 작업 순서대로, 출력을 필요로 할 때마다 알맞게 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','ing','12
12
-1
-1
0
11
-1
10
12
','DATA_STRUCTURE'),
                                                                                                                (6287,'BAEKJOON','https://www.acmicpc.net/problem/1218',1218,'로봇','5초','128 MB',25,'<p>공장에서 작업을 하는 로봇은 고정 축 F, 한 개의 관절 A, 두개의 뼈대 B, C와 손 D로 구성되어 있다. 그림 1과 같이 고정축 F는 공장 내부의 한 점에 고정되어 있고, 뼈대 B는 고정축 F와 관절 A사이를 연결하고, 다른 뼈대 C는 관절 A와 손 D사이를 연결한다.</p>

<p style="text-align:center"><img alt="" src="https://upload.acmicpc.net/1929b6ac-51d9-4d68-9a04-83d7a6fdb94c/-/preview/" style="width: 120px; height: 90px;"></p>

<p style="text-align:center">그림 1</p>

<p style="text-align:left">단, 뼈대 B와 C는 그림 2와 같이 다음 조건을 만족하면서 움직일 수 있다.</p>

<ol>
	<li style="text-align: left;">뼈대 B는 고정축에서 왼쪽 또는 오른쪽 수평방향으로 나오거나, 고정 축에서 위쪽 또는 아래쪽 수직방향으로 나올 수 있다.</li>
	<li style="text-align: left;">뼈대 C는 관절 A에서 뼈대 B와 항상 수직을 이루면서 나온다.</li>
	<li style="text-align: left;">뼈대 B와 C는 길이를 0에서 얼마든지 자유자재로 연장할 수 있다.</li>
</ol>

<p style="text-align:center"><img alt="" src="https://upload.acmicpc.net/e34c1312-4654-4ee9-b6f6-691cdf18f6f5/-/preview/" style="width: 217px; height: 192px;"></p>

<p style="text-align:center">그림 2</p>

<p style="text-align:left">로봇의 고정축이 위치한 공장은 그림 3과 같이 수평 방향과 수직 방향의 벽들이 번갈아 가면서 연결되어 있는 하나의 다각형으로 구성되어 있다. 따라서, 이 공장의 내부에는 벽들이 존재하지 않는다. 이 공장 내부의 어떤 위치에 로봇의 고정축 F를 고정시켰을 때, 위의 세 가지 조건들을 만족하면서 뼈대 B와 C의 위치와 길이를 조절하더라도 로봇의 손 D가 미치지 못하는 공장 내부의 지점이 있을 수 있다.</p>

<p style="text-align:center"><img alt="" src="https://upload.acmicpc.net/fb4067f3-d007-421f-bc2c-51ffec816731/-/preview/" style="width: 193px; height: 166px;"></p>

<p style="text-align:center">그림 3</p>

<p style="text-align:left">그림 3의 예에서 로봇의 고정축이 P지점에 고정되어 있으면 공장 내부의 모든 위치에 로봇 손 D가 접근할 수 있지만, Q지점에 고정되어 있으면 로봇 손 D가 도달할 수 없는 지점(빗금 친 부분)이 존재한다.</p>

<p>공장의 경계를 나타내는 다각형의 꼭짓점과 로봇의 고정축의 위치가 주어질 때, 공장의 내부에 로봇 손이 도달하지 못하는 부분이 있는 지를 검사하는 프로그램을 작성하시오. 단, 고정축은 공장의 내부에 존재하며, 공장의 내부는 경계선을 포함하지 않는다. 뼈대 B, C는 공장의 경계선을 따라 움직일 수 있고, 고정축, 관절과 손은 점으로, 뼈대는 두께가 없는 선분으로 가정한다.</p>



					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 공장의 경계를 나타내는 꼭짓점의 개수 N이 주어진다. 단, 4 ≤ N ≤ 20,000이다. 다음 줄부터 N개의 꼭짓점의 좌표와 5개의 로봇 고정축의 좌표가 다음과 같이 주어진다: 둘째 줄부터 N개의 줄에 꼭짓점의 좌표 (X, Y)를 나타내는 두 개의 정수 X, Y가 한 줄에 하나씩 빈 칸을 사이에 두고 주어진다. 꼭짓점의 좌표는 다각형 경계선의 반시계방향 순서로 주어지고, 모든 좌표의 값은 0이상 1,000,000 이하의 정수이다. 이어서 다음 5개의 줄에 로봇의 고정축의 좌표 (X, Y)를 나타내는 두 개의 정수 X, Y가 한 줄에 하나씩 빈 칸을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력에서 주어진 5개 고정축의 각 위치에 대하여 로봇 손이 공장 내부의 모든 위치에 접근할 수 있는지 여부를 다음과 같이 차례대로 출력한다. 첫째 줄부터 k번째 줄에 입력에서 k번째 주어진 로봇의 고정축의 위치에 대하여 로봇 손이 공장 내부 전체에 접근할 수 있으면 YES를, 아니면 NO를 대문자로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p style="text-align:center"><img alt="" src="https://upload.acmicpc.net/aa0e1415-7bfc-4b35-888e-db1e31f1cbaf/-/preview/" style="width: 243px; height: 252px;">&nbsp;</p>

<p style="text-align:center">그림 4</p>

				</div>
				</div>','8
0 0
20 0
20 20
30 20
30 0
40 0
40 40
0 40
10 10
25 30
35 10
5 30
10 20','NO
YES
NO
YES
YES
','DATA_STRUCTURE'),
                                                                                                                (6282,'BAEKJOON','https://www.acmicpc.net/problem/1221',1221,'가까운 점','1초','128 MB',20,'<p>3차원 공간에 점 N개가 있다. 가장 가까운 점의 거리를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 점의 수 N이 주어진다. N은 150,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 점의 좌표가 주어진다. 좌표의 절댓값은 1,000,000보다 작거나 같은 정수이다. 두 점이 같은 좌표를 가질 수 있다. 같은 좌표를 갖는 점은 같은 점이다. 적어도 2개의 위치가 다른 점이 있는 경우만 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가장 가까운 점의 거리의 제곱을 출력한다. 둘째 줄에는 그러한 거리를 가지는 서로 다른 점의 쌍이 총 몇 개 있는지 개수를 출력한다.</p>

<p>가장 가까운 점의 거리의 제곱이&nbsp;1,000,000,000보다 작은 경우만 입력으로 주어진다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','to','9163
1
','DATA_STRUCTURE'),
                                                                                                                (6281,'BAEKJOON','https://www.acmicpc.net/problem/1228',1228,'전쟁','2초','128 MB',17,'<p>현재 W국은 N개의 나라와 전쟁 중이다. W국의 전력이 월등히 우세하여 전쟁에서 승리하는 것은 시간 문제이다. W국은 첩자를 통해, N개의 나라들 중 M개의 나라만을 정복하면 나머지 나라는 자동으로 항복한다는 정보를 입수했다.</p>
<p>이제 M개의 나라를 적당히 골라서 정복하려고 하는데, 각 나라마다 정복하는 데 걸리는 시간이 다르다. 어떤 나라는 오래 걸리고, 어떤 나라는 매우 순식간에 정복할 수도 있다. 단 그 나라를 정복하는 데 온 전력을 집중해야 하기 때문에, 매 순간 오직 한 나라와만 전쟁을 진행할 수 있다. 우리는 최대한 빨리 M개의 나라를 정복하려고 한다.</p>
<p>단, N개의 나라 사이에는 속국 관계가 존재할 수 있다. 나라 A가 나라 B의 속국인 경우, 나라 B를 정복하면 나라 B의 모든 속국들이 자동으로 항복하게 된다. 속국에는 서로 계층 관계가 존재해서, 나라 A가 나라 B의 속국이고, 나라 B가 나라 C의 속국인 경우, 나라 C를 정복하면 나라 A와 나라 B 모두 자동으로 정복하는 효과를 얻는다. 즉 자신의 속국과, 속국들의 속국과, 속국들의 속국들의 속국과, . . . 이렇게 모든 하위의 나라들이 자동으로 항복하게 된다.</p>
<p>나라 A가 나라 B의 속국이면서 동시에 나라 C의 속국일 수 없다. 즉 속국이라면 오직 한 나라의 속국일 뿐이다. 하지만 나라 A, 나라 B, ... 등 여러 나라가 한 나라의 속국일 수는 물론 있다.</p>
<p>N, M이 주어지고, 속국 관계가 주어지고, 각 나라를 정복하는 데 드는 일수가 주어지면, 최대한 빨리 M개의 나라를 정복할 수 있는 시간을 구하는 프로그램을 작성하시오.</p>

					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 나라의 개수 N(1≤N≤200)과 M(0≤M≤N)이 주어진다. 이어서 N개의 줄에 각 나라에 대한 정보가 주어지는데, 먼저 나라의 이름이 문자열로 주어진다. 문자열의 길이는 1 이상 100 이하이며 알파벳 대소문자로 이루어져 있다. 이어서 빈 칸 뒤에 이 나라를 정복하는 데 드는 일수가 주어진다. 이어서 빈 칸이 주어지고 여러 개의 나라 이름들이 빈 칸을 사이에 두고 주어질 수가 있는데, 이 뒤에 주어지는 나라들이 바로 현재 나라의 속국들이 된다.</p>
					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 M개의 나라를 최대한 빨리 정복하려고 할 때 며칠이 걸리는지 출력한다.</p>
					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				CountryB만 정복하면 자동으로 CountryB의 속국인 CountryA가 정복되어 2개 나라를 정복할 수 있다.

				</div>
				</div>','3 2
CountryA 10
CountryB 20 CountryA
CountryC 15','20','DATA_STRUCTURE'),
                                                                                                                (6283,'BAEKJOON','https://www.acmicpc.net/problem/1250',1250,'색칠된 공들','2초','128 MB',25,'<p>규완이는 N개의 순서대로 색칠된 공을 가지고 있다. (색은 영어 대문자로 이루어져 있다.) 당신은 이 공을 가지고 다음과 같은 재미있는 일을 하고자 한다.</p>

<ol>
	<li>가장 많은 개수로 같은 색이 연속된 공을 제거한다.</li>
	<li>만약 가장 많은 개수로 같은 색이 연속된 부분이 여럿 있다면, 그 중에서 맨 앞에 있는 부분을 제거한다.</li>
	<li>1, 2를 공이 모두 제거될 때 까지 반복한다.</li>
</ol>

<p>이 과정을 반복하던 도중, 규완이는 k 번째 공이 몇 번째 사라질지 궁금해졌다. 규완이를 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 공의 개수인 N과, 자신이 언제 없어지는지 알고 싶은 공의 번호 k가 주어진다.&nbsp;그 다음 줄에는 공의 색이 연속된 N개의 문자열로 주어진다. (1 ≤ N ≤&nbsp;10000000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>그 k번째 공이 사라지는 시행횟수가 몇 번째인지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<ul>
	<li>0 : AABAABBBCD</li>
	<li>1 : AABAACD</li>
	<li>2 : BAACD</li>
	<li>3 : BCD</li>
</ul>

				</div>
				</div>','10 4
AABAABBBCD
','3
','DATA_STRUCTURE'),
                                                                                                                (6284,'BAEKJOON','https://www.acmicpc.net/problem/1253',1253,'좋다','2초','256 MB',12,'<p>N개의 수 중에서 어떤 수가 다른 수 두 개의 합으로 나타낼 수 있다면 그 수를 “좋다(GOOD)”고 한다.</p>

<p>N개의 수가 주어지면 그 중에서 좋은 수의 개수는 몇 개인지 출력하라.</p>

<p>수의 위치가 다르면 값이 같아도 다른 수이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 수의 개수 N(1 ≤ N ≤ 2,000), 두 번째 줄에는 i번째 수를 나타내는 A<sub>i</sub>가 N개 주어진다. (|A<sub>i</sub>| ≤ 1,000,000,000, A<sub>i</sub>는 정수)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>좋은 수의 개수를 첫 번째 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>3,4,5,6,7,8,9,10은 좋다.</p>

				</div>
				</div>','10
1 2 3 4 5 6 7 8 9 10
','8
','DATA_STRUCTURE'),
                                                                                                                (6285,'BAEKJOON','https://www.acmicpc.net/problem/1269',1269,'대칭 차집합','2초','256 MB',7,'<p>자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 이때, 두 집합의 대칭 차집합의 원소의 개수를 출력하는 프로그램을 작성하시오. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다.</p>
<p> 예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때,&nbsp; A-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로, 대칭 차집합의 원소의 개수는 1 + 3 = 4개이다.</p>

					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 집합 A의 원소의 개수와 집합 B의 원소의 개수가 빈 칸을 사이에 두고 주어진다. 둘째 줄에는 집합 A의 모든 원소가, 셋째 줄에는 집합 B의 모든 원소가 빈 칸을 사이에 두고 각각 주어진다. 각 집합의 원소의 개수는 200,000을 넘지 않으며, 모든 원소의 값은 100,000,000을 넘지 않는다.</p>
					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 대칭 차집합의 원소의 개수를 출력한다.</p>
					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5
1 2 4
2 3 4 5 6
','4','DATA_STRUCTURE'),
                                                                                                                (6288,'BAEKJOON','https://www.acmicpc.net/problem/1270',1270,'전쟁 - 땅따먹기','10초','512 MB',8,'<p>드디어 전쟁은 전면전이 시작되었고, 서로 땅을 따먹기 시작했다.</p>

<p>현재 여러 지역은 한창 전쟁이 벌어지고 있는 상황인데, 어느 지역은 거의 전쟁이 마무리 단계로 가고 있다.</p>

<p>하지만 당신은 군대를 보낼 때 적군을 혼란시키기 위해서 우리 나라의 군대라는걸 표시하지 않고, 군대의 번호로 표시했다.</p>

<p>어느 땅에서 한 번호의 군대의 병사가 절반을 초과한다면 그 땅은 그 번호의 군대의 지배하에 놓이게 된다.</p>

<p>이때, 각 땅들을 지배한 군대의 번호를 출력하여라. 만약, 아직 전쟁이 한창중인 땅이라면 “SYJKGW”을 쌍 따옴표 없이 출력한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 땅의 개수 n(n<=200)이 주어진다. 그리고 두 번째 줄에서 n+1번째 줄에는 제일 처음에 숫자 Ti(i번째 땅의 병사수, Ti<=100,000)와, Ti개의 숫자 (각각 병사의 군대 번호)가 주어진다. i번째 땅의 j번째 병사 번호 Nij가 주어진다. ( | Nij | <= 2^31 )</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에는 각각의 땅의 상태를 순서대로 출력한다. 만약 땅이 지배가 되어있다면 그 지배한 병사의 번호를 출력하고, 아니라면 “SYJKGW”을 쌍 따옴표 없이 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
10 1 2 3 1 2 3 1 2 3 1
5 1 1 1 2 2
6 10 10 2 10 10 2
6 1 1 1 2 2 2
','SYJKGW
1
10
SYJKGW
','DATA_STRUCTURE'),
                                                                                                                (6295,'BAEKJOON','https://www.acmicpc.net/problem/1273',1273,'샷','2초','256 MB',18,'<p>준수는 생일선물을 맞아 새로운 공기총을 샀다. 그리고 공기총의 성능을 시험해보기 위해 맥주캔을 쌓았다.</p>

<p>맥주캔은 총 검은색, 회색, 흰색으로 총 3가지 종류가 있다. 그리고 이를 N개의 열에 따라 쌓아올렸다. 쌓아올릴 때 순서는 아래에서부터 검은색, 회색, 흰색&nbsp;순서이다. 한 열에 어느 색이 모두 없을 수는 있지만 색깔 순서를 위배하는 경우는 없다.</p>

<p>이렇게 맥주캔을 쌓아올린 뒤 준수는 높이를 정하고 공기총을 발사했다. 이 공기총은 성능이 뛰어나기에 한 높이를 쏘면 그 높이의 모든 캔은 모두 바깥으로 떨어지고 위쪽의 캔이 쓰러지지 않은&nbsp;그대로 내려온다.</p>

<p>준수는 성능 시험을 위해 각 높이를 쏘았을 때 점수를 구하려고 한다. 점수 구하는 법은 검은색은 1점, 회색은&nbsp;2점, 흰색은&nbsp;5점이고, 바깥으로 떨어진&nbsp;캔 점수의 총 합이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/f408f395-e2fe-4c22-be73-0e4636c8a31b/-/preview/" style="width: 132px; height: 100px;"></p>

<p>위 그림은 초기에 맥주캔을 쌓은 상태이다.&nbsp;여기서&nbsp;2번 높이를 총으로 쏜다면 아래와 같이 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3b3c6928-a273-434a-9e91-b828c5415087/-/preview/" style="width: 133px; height: 80px;"></p>

<p>검은색이 3개, 회색이 2개, 흰색이 1개 쓰러졌기 때문에&nbsp;12점을 얻게 된다. 이 상태에서 4번 높이에 총을 쏘면 아래와 같이 되고, 7점을 얻는다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/521c64b8-99d0-4f02-bd6c-3ef6e1b172a0/-/preview/" style="width: 133px; height: 60px;"></p>

<p>캔을 쌓은 정보와 쏘는 높이를 순서대로 알고있을 때, 각 높이를 쏠 때 얻어지는 점수를 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 열의 개수 N(1 ≤ N ≤ 300,000)이 주어진다. 두 번째 줄에는 각 열에 쌓인 검은색의 개수를 나타내는 N개의 정수가 주어진다. 세 번째 줄에는 각 열에 쌓인 회색의 개수를 나타내는 N개의 정수가 주어진다. 네 번째 줄에는 각 열에 쌓인 흰색의 개수를 나타내는 N개의 정수가 주어진다. 모든 수는 10<sup>6</sup>이하인 음이 아닌 정수이다. 다음 줄에는 준수가 쏘는 횟수 M(1 ≤ M ≤ 300,000)이 주어진다. 다음 줄에는 차례대로 준수가 쏘는 높이를 나타내는 M개의 정수가 입력된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 M번째 줄까지 해당 높이를 쐈을 때 얻게되는 점수를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
2 1 2 0 3 1
1 2 2 2 2 0
1 0 1 2 0 3
2
2 4
','12
7
','DATA_STRUCTURE'),
                                                                                                                (6289,'BAEKJOON','https://www.acmicpc.net/problem/1275',1275,'커피숍2','2초','256 MB',15,'<p>모두 알다시피&nbsp;동호는 커피숍의 마담이다. (마담이 무엇인지는 본인에게 물어보도록 하자.)</p>

<p>어느 날 커피숍의 손님 A씨가 동호에게 게임을 하자고 했다.</p>

<p>그 게임은 다음과 같은 규칙을 갖는다.</p>

<p>N개의 정수가 있으면, 동호는 다음과 같이 말한다. “3~7번째 수의 합은 무엇이죠?” 그러면 상대방은 “그 답은 000입니다. 그리고 8번째 수를 2로 고치도록 하죠” 그러면 동호는 “네 알겠습니다.”라고 한 뒤에 다시 상대방이 동호가 했던 것처럼 “8~9번째 수의 합은 무엇이죠?”라고 묻게된다. 이 것을 번갈아 가면서 반복하는 게임이다.</p>

<p>당신은 이 게임의 심판 역을 맡았다. 요컨대, 질문에 대한 답들을 미리 알아야 한다는 것이다.</p>

<p>당신의 머리가 출중하다면 10만개 가량 되는 정수와 10만턴 정도 되는 게임을 기억할 수 있을 것이다. 몇판 이 게임을 즐기던 동호는 많은 사람들이 이 게임을 하기를 바라게 되었고, 당신에게 심판 프로그램을 구현해달라고 요청했다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수의 개수 N과 턴의 개수 Q가 주어진다.(1 ≤&nbsp;N, Q ≤ 100,000) 둘째 줄에는 처음 배열에 들어가 있는 정수 N개가 주어진다. 세 번째 줄에서 Q+2번째 줄까지는 x y a b의 형식으로 x~y까지의 합을 구하여라, a번째 수를 b로 바꾸어라 라는 뜻의 데이터가 주어진다.</p>

<p>입력되는 모든 수는 -2<sup>31</sup>보다 크거나 같고, 2<sup>31</sup>-1보다 작거나 같은&nbsp;정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 턴마다 구한 합을 한 줄마다 한 개씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>x~y는 당연히 x번째 부터 y번째가 맞다. 하지만, 이 문제에서는 x > y인 경우 y번째 부터 x번째이다.</p>

				</div>
				</div>','5 2
1 2 3 4 5
2 3 3 1
3 5 4 1
','5
10
','DATA_STRUCTURE'),
                                                                                                                (6290,'BAEKJOON','https://www.acmicpc.net/problem/1280',1280,'나무 심기','2초','128 MB',17,'<p>1번부터 N번까지 번호가 매겨져 있는 N개의 나무가 있다. i번 나무는 좌표 X[i]에 심어질 것이다.</p>

<p>동호는 나무를 1번 나무부터 차례대로 좌표 X[i]에 심으려고 한다. 1번 나무를 심는 비용은 없고, 각각의 나무를 심는데 드는 비용은 현재 심어져있는 모든 나무 까지 거리의 합이다. 만약 3번 나무를 심는다면, 1번 나무와의 거리 + 2번 나무와의 거리가 3번 나무를 심는데 드는 비용이다.</p>

<p>2번 나무부터 N번 나무까지를 심는 비용의 곱을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 나무의 개수 N (2 ≤ N ≤ 200,000)이 주어진다. 둘째 줄부터 N개의 줄에 1번 나무의 좌표부터 차례대로 주어진다. 각각의 좌표는 200,000보다 작은 자연수 또는 0이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>문제의 정답을 1,000,000,007로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
3
4
5
6
7
','180','DATA_STRUCTURE'),
                                                                                                                (6291,'BAEKJOON','https://www.acmicpc.net/problem/1282',1282,'P-수열','2초','256 MB',19,'<p>서로 다른 정수로 이루어진 수열 S가 주어진다. 다음과 같은 조건을 만족하는 수열은 S의 P-수열이라고 말한다.</p>

<ol>
	<li>S의 원소를 정확하게 하나씩 포함해야 한다.</li>
	<li>임의의 인접한 두 원소 S<sub>1</sub>, S<sub>2</sub>가 있을 때, (S<sub>1</sub>-S<sub>2</sub>)는 P로 나누어 떨어지지 않아야 한다.</li>
</ol>

<p>S의 P-수열 개수를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>문제는 두 개의 테스트 케이스로 이루어져 있다. 각각의 테스트 케이스 첫째 줄에 S의 원소 개수 N과 P가 주어진다. N은 30보다 작거나 같은 자연수이다. P는 1,000보다 작거나 같은 자연수이다. 둘째 줄에 S의 원소 N개가 주어진다. 모든 원소는 서로 다르고, -1,000,000보다 크거나 같고 1,000,000보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄에 하나 씩 입력 받은 순서대로 S의 P-수열 개수를 1234567891로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 10
-1 0 1 2 3
2 1000
1 -1
','120
2
','DATA_STRUCTURE'),
                                                                                                                (6293,'BAEKJOON','https://www.acmicpc.net/problem/1306',1306,'달려라 홍준','2초','256 MB',16,'<p>홍준이는 러너이다. 그런데 어쩌다 보니 아무리 뛰어도 뛰어도 속도가 변하지 않는다. 1초에 딱 1칸을 움직인다.</p>

<p>그런데 홍준이가 뛰는 코스는 광고판으로 가득하다. 광고판은 빛의 세기가 다른데, 홍준이는 자신이 볼 수 있는 광고판들 중에서 가장 강렬한 빛의 광고판만이 눈에 들어온다.</p>

<p>홍준이는 눈이 안좋기 때문에 빛의 세기가 강한 지점에서는 안경을 쓰고 뛰려한다. 그래서 알아야 할 것이, 뛰어가면서 보이는 광고판의 빛의 세기를 알고 싶다.</p>

<p>홍준이가 뛰어갈 때, 1초마다 보이는 광고판의 빛의 세기를 출력하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 뛰는 코스의 길이, 즉 칸수 N과 홍준이의 시야의 범위 M이 주어진다. 시야가 M이라고 하면 현재 위치에서 앞뒤로 M-1칸까지 광고판이 보이는 것이다. (1 ≤ M&nbsp;≤&nbsp;N&nbsp;≤&nbsp;1,000,000) 두 번째 줄에는 각각 칸에 있는 광고판들의 빛의 세기가 주어진다. 빛의 세기는 1,000,000을 넘지 않는 자연수이다.</p>

<p>홍준이는 언제나 광고판을 2M-1개 보면서 뛰고 싶기 때문에(중심으로) M번째 칸에서 뛰기 시작해서 N-M+1번째 칸에서 멈춘다고 가정하자.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>뛰면서 보이는 광고판의 세기를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
1 1 1 3 2
','1 3 3
','DATA_STRUCTURE'),
                                                                                                                (6294,'BAEKJOON','https://www.acmicpc.net/problem/1321',1321,'군인','1초','256 MB',16,'<p>캠프 내내 그랬듯이, 여전히 옆 나라와의 전쟁이 한창이다.</p>

<p>전쟁에는 N개의 부대가 투입되었는데, 전쟁이 장기전이 되다 보니 군사의 적절한 배치를 위해 각 부대에 군인이 늘어나기도 하고 줄어들기도 하고 있다.</p>

<p>행정의 편의를 위해 각 군인들에겐 번호가 붙어 있는데, 군인들은 1번 부대부터 군번순서대로 차례차례 배치된다. 예를 들어 1번 부대에 4명, 2번 부대에 3명, 3번 부대에 7명의 군인이 있다면 군번이 6번인 군인은 2번 부대에 배치되게 된다.</p>

<p>문제는 어떤 부대의 인원이 늘어나거나 줄어들었을 때 i번 군인이 어디에 배치되는지 인데, 이럴 때에는 군인도 군번도 처음부터 다시 배치하게 된다. 위의 예에서와 같이 1번 부대에 4명, 2번 부대에 3명, 3번 부대에 7명의 군인이 있었는데, 1번 부대에서 3명의 감원이 일어난다면, 6번 군인은 3번 부대에 재배치 받게 된다.</p>

<p>전쟁 때는 부대의 감원과 증원이 많아 군사 재배치도 자주 일어나게 되는데, 이렇게 자주 배치가 바뀌자 군인들은 자기가 도대체 어떤 부대에 속하는 지 헷갈리게 되었다. 다행히도 바뀐 군번은 다들 정확하게 숙지하고 있다.</p>

<p>부대의 개수 N과 각 부대에 속해 있는 군인의 수가 N개 주어질 때, 부대의 감원과 증원을 한 후, 혹은 그 중에 군번 i번의 군인이 몇 번 부대에 속하는 지를 물어봤을 때, 그 질문에 대답을 해 줄 수 있는 프로그램을 작성하시오.</p>

<p>i번 부대에 증원이나 감원을 할 때엔 "1 i a"의 형태로 명령이 주어지고, 이는 i번 부대에 a명을 더한다는 뜻이다. 감원을 할 때엔 a가 0보다 작은 수로 주어진다. 감원을 해서 부대의 인원수가 0보다 작아지는 입력은 들어오지 않는다. a는 절댓값이 1보다 크거나 같고, 3,000보다 작거나 같은 정수이다.</p>

<p>군번 i번의 군인이 어떤 부대에 배치 받았는지 알고 싶을 때는 "2 i"의 형태로 명령이 주어지고, 이런 명령을 받았을 때는 i번 군인이 몇 번 부대에 배치 받았는지를 출력해야 한다. i는 전체&nbsp;군인 수보다 작거나 같은 자연수이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 부대의 개수 N(1 ≤ N ≤ 500,000)이 주어지고, 이어서 각 부대의 군사 수를 나타내는 정수가 N개 주어진다. 각 부대의 군사 수는 1000보다 작거나 같은 자연수이다.&nbsp;그 다음 줄에 명령의 개수 M(1 ≤ M ≤ 10,000)개가 주어지고, 이어서 M줄에 걸쳐 명령이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>질문한 군인이 몇 번 부대에 배치 받았는지를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 4 3 5 2
5
1 2 -3
1 4 2
2 5
1 2 4
2 5
','3
2
','DATA_STRUCTURE'),
                                                                                                                (6292,'BAEKJOON','https://www.acmicpc.net/problem/1327',1327,'소트 게임','2초','128 MB',12,'<p>홍준이는 소트 게임을 하려고 한다. 소트 게임은 1부터 N까지 정수로 이루어진 N자리의 순열을 이용한다. 이 게임에선 K가 주어진다. 어떤 수를 뒤집으면, 그 수부터 오른쪽으로&nbsp;K개의 수를 뒤집어야 한다. 예를 들어, 순열이 5 4 3 2 1 이었고, 여기서 K가 3일 때, 4를 뒤집으면 5 2 3 4 1이 된다. 반드시 K개의 수를 뒤집어야하기 때문에, 처음 상태에서 2나 1을 선택하는 것은 불가능하다.</p>

<p>입력으로 들어온 순열을 오름차순으로 만들려고 한다.&nbsp;게임을 최대한 빨리 끝내고 싶을 때, 수를 최소 몇 개 선택해야 하는지 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 순열의 크기 N과 K가 주어진다. 둘째 줄에 순열에 들어가는 수가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 정답을 출력한다. 만약 오름차순으로 만들 수 없으면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
3 2 1
','1
','DATA_STRUCTURE'),
                                                                                                                (6296,'BAEKJOON','https://www.acmicpc.net/problem/1351',1351,'무한 수열','2초','128 MB',11,'<p>무한 수열 A는 다음과 같다.</p>

<ul>
	<li>A<sub>0</sub> = 1</li>
	<li>A<sub>i</sub> = A<sub>?i/P?</sub> + A<sub>?i/Q?</sub> (i ≥ 1)</li>
</ul>

<p>N, P와 Q가 주어질 때, A<sub>N</sub>을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 3개의 정수 N, P, Q가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 A<sub>N</sub>을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>?x?는 x를 넘지 않는 가장 큰 정수이다.</p>

				</div>
				</div>','7 2 3
','7','DATA_STRUCTURE'),
                                                                                                                (6297,'BAEKJOON','https://www.acmicpc.net/problem/1354',1354,'무한 수열 2','10초','512 MB',11,'<p>무한 수열 A는 다음과 같다.</p>

<ul>
	<li>A<sub>i</sub> = 1 (i ≤ 0)</li>
	<li>A<sub>i</sub>&nbsp;= A<sub>?i/P?-X</sub> + A<sub>?i/Q?-Y</sub> (i ≥ 1)</li>
</ul>

<p>N, P, Q, X, Y가 주어질 때, A<sub>N</sub>을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 5개의 정수 N, P, Q, X, Y가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 A<sub>N</sub>을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>?x?는 x를 넘지 않는 가장 큰 정수이다.</p>

				</div>
				</div>','10000000 2 3 10000000 10000000
','2
','DATA_STRUCTURE'),
                                                                                                                (6299,'BAEKJOON','https://www.acmicpc.net/problem/1374',1374,'강의실','2초','128 MB',11,'<p>N개의 강의가 있다. 우리는 모든 강의의 시작하는 시간과 끝나는 시간을 알고 있다. 이때, 우리는 최대한 적은 수의 강의실을 사용하여 모든 강의가 이루어지게 하고 싶다.</p>

<p>물론, 한 강의실에서는 동시에 2개 이상의 강의를 진행할 수 없고, 한 강의의 종료시간과 다른 강의의 시작시간이 겹치는 것은 상관없다. 필요한 최소 강의실의 수를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 강의의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 줄마다 세 개의 정수가 주어지는데, 순서대로 강의 번호, 강의 시작 시간, 강의 종료 시간을 의미한다. 강의 번호는 1부터 N까지 붙어 있으며, 입력에서 꼭 순서대로 주어지지 않을 수 있으나 한 번씩만 주어진다. 강의 시작 시간과 강의 종료 시간은 0 이상 10억 이하의 정수이고, 시작 시간은 종료 시간보다 작다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 필요한 최소 강의실 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
6 15 21
7 20 25
1 3 8
3 2 14
8 6 27
2 7 13
4 12 18
5 6 20
','5
','DATA_STRUCTURE'),
                                                                                                                (6298,'BAEKJOON','https://www.acmicpc.net/problem/1376',1376,'민식우선탐색','1초','128 MB',19,'<p>DFS와 BFS는 아는가? DFS는 깊이우선탐색, BFS는 넓이우선탐색이다.</p>

<p>이번에는 mFS! 그래, 듣도 보도 못했던 듣보잡 탐색방법인, 민식우선탐색이다.</p>

<p>민식이는 DFS를 할 줄 모르기 때문에 다음과 이 탐색방법을 만들어냈다.</p>

<p>이 탐색방법을 설명하자면 다음과 같다.</p>

<p>기본틀은 DFS와 완전히 동일하다. 그런데 한가지 다른 점이 있다면, 한 점에서 다른 정점을 방문할 때 순서가 다르다. 현재 점에서 방문할 수 있는 정점(갈 수 있으면서 방문한 적 없는 정점들)들이 홀수개면 그 정점 번호들의 중간값인 정점으로 방문을 시작하고, 짝수개면 가장 작은 정점 번호로 방문을 시작한다.</p>

<p>당신의 임무는, 1번 정점에서 출발하여 민식우선탐색을 하는 순서를 찍는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 정점의 개수 N(<=100,000)과 간선의 개수 M(<=1,000,000)이 주어진다. 두 번째 줄부터 M+1번째 줄 까지는 a b의 형태로 a와 b가 간선으로 연결되어 있다는 의미의 입력이 들어온다. 모든 간선은 양방향이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>민식우선탐색의 순서를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>1->3->2->5->2->3->4의 순서로 움직인다.</p>

				</div>
				</div>','5 6
1 2
1 4
1 3
3 2
3 4
2 5
','1 3 2 5 4
','DATA_STRUCTURE'),
                                                                                                                (6301,'BAEKJOON','https://www.acmicpc.net/problem/1379',1379,'강의실 2','2초','128 MB',13,'<p>N개의 강의가 있다. 우리는 모든 강의의 시작하는 시간과 끝나는 시간을 알고 있다. 이때, 우리는 최대한 적은 수의 강의실을 사용하여 모든 강의가 이루어지게 하고 싶다.</p>

<p>물론, 한 강의실에서는 동시에 2개 이상의 강의를 진행할 수 없고, 한 강의의 종료시간과 다른 강의의 시작시간이 겹치는 것은 상관없다. 필요한 최소 강의실 수 K와, 각 강의마다 강의실을 배정하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 강의의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 줄마다 세 개의 정수가 주어지는데, 순서대로 강의 번호, 강의 시작 시간, 강의 종료 시간을 의미한다. 강의 번호는 1부터 N까지 붙어 있으며, 입력에서 꼭 순서대로 주어지지 않을 수 있으나 한 번씩만 주어진다. 강의 시작 시간과 강의 종료 시간은 0 이상 10억 이하의 정수이고, 시작 시간은 종료 시간보다 작다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 필요한 최소 강의실 개수 K를 출력한다. 둘째 줄부터 N개의 줄에 걸쳐 각 강의에 배정할 강의실 번호를 순서대로 출력한다. 편의상 강의실 번호는 1, 2, ..., K 로 매긴다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
6 15 21
7 20 25
1 3 8
3 2 14
8 6 27
2 7 13
4 12 18
5 6 20
','5
4
3
2
4
1
3
4
5
','DATA_STRUCTURE'),
                                                                                                                (6308,'BAEKJOON','https://www.acmicpc.net/problem/1391',1391,'종이접기','2초','128 MB',19,'<p>지훈이의 취미는 종이 접기이다. 지훈이는 직사각형의 종이에 정사각형 모양안에 N이하의 정수가 한 번씩 쓰여 있는 종이를 가지고 왔다. 아래 그림과 같이 정사각형을 이어서 붙인 모양이다. 지훈이는 이 종이를 접어서 위에서부터 차례대로 1, 2, 3, ..., N까지의 번호가 있는 정사각형이 오게 하는 것이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3b817035-e668-46dc-8872-872ae8c656ed/-/preview/"></p>

<p>예를 들어 3, 1, 5, 2, 4의 번호가 있는 직사각형 종이가 주어졌으면, 4와 5의 경계선을 접고, 1과 3의 경계선을 접고, 2와 4의 경계선을 접으면 위에서부터 차례대로 1, 2, 3, 4, 5의 순서로 종이가 놓이게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/51365bdd-6f9b-40df-a1f1-4db0fe8871c5/-/preview/"></p>

<p>종이에 쓰여 있는 정수 주어졌을 때, 그것을 접어서 위에서부터 차례대로 1, 2, 3, ..., N의 순서로 접을 수 있는지 없는지를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 입력으로 들어오는 데이터의 개수 T가 주어진다. 데이터는 각각 2줄로 이루어져 있다. 첫 줄에는 종이의 길이 N이 주어진다. 둘째 줄에는 종이에 쓰여 있는 정수가 공백을 사이에 두고 차례대로 주어진다. T는 10보다 작거나 같은 자연수이다. N은 2,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 데이터에 대해 종이를 위에서부터 차례대로 1, 2, 3, ..., N 순서대로 접을 수 있으면 YES를 접을 수 없으면 NO를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
5
3 1 5 4 2
4
1 3 2 4
','YES
NO
','DATA_STRUCTURE'),
                                                                                                                (6303,'BAEKJOON','https://www.acmicpc.net/problem/1395',1395,'스위치','1초','128 MB',18,'<p>준규네 집에는 총 N개의 스위치가 있고 이를 편하게 1번부터 N번까지 차례대로 번호를 매겼다. 그리고 준규의 취미는 이 스위치들을 켜고 끄는 것이다.</p>

<p>준규가 하는 스위치를 갖고 노는 일은 크게 두 가지이다. 하나는 A번부터 B번 사이의 스위치 상태를 반전시키는 것이고 다른 하나는 C번부터 D번 사이의 스위치 중 켜져 있는 상태의 스위치의 개수를 세는 것이다.</p>

<p>하지만 준규가 싫증을 느껴 우리가 이 귀찮은 일을 떠맡게 되었고 프로그래밍을 통해 일을 처리하도록 결정하였다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 스위치의 개수 N(2 ≤ N ≤ 100,000)과 처리할 일의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 M개의 줄에 대해 각 줄에 처리할 일에 대한 정보가 담겨진 세 개의 정수 O, S<sub>i</sub>, T<sub>i</sub>가 입력된다. O가 0이면 S<sub>i</sub>번 스위치부터 T<sub>i</sub>번 스위치까지 스위치 상태를 반전시키는 일이고 1이면 S<sub>i</sub>번 스위치부터 T<sub>i</sub>번 스위치까지 중 켜져 있는 상태의 스위치 개수를 묻는 일이다. 단, 초기에는 모든 스위치의 상태는 꺼져있는 상태로 되어있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력에서 켜진 스위치 개수에 대한 답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5
0 1 2
0 2 4
1 2 3
0 2 4
1 1 4
','1
2
','DATA_STRUCTURE'),
                                                                                                                (6302,'BAEKJOON','https://www.acmicpc.net/problem/1396',1396,'크루스칼의 공','2초','128 MB',20,'<p>어떤 그래프가 있다. 여기에 크루스칼이 공을 놓으려고 한다.</p>

<p>크루스칼의 공은 이상한 특성을 가지고 있다. 처음에는 아주 낮은 온도를 갖고 있다가 시간에 지남에 따라서 점점 온도가 올라가는 것이다.</p>

<p>그래프에도 이상한 특성이 있다. 크루스칼의 공이 어떤 간선을 지나서 다른 정점으로 이동할 때, 그 간선의 고유값보다 온도가 같거나 높아야만 그 간선을 통과할 수 있다는 것이다.</p>

<p>당신이 궁금한 것은 x정점에 크루스칼이 공을 놓았을 때, y정점으로 갈 수 있는 최소온도와 그 때 공이 움직일 수 있는 범위 안의 정점 개수를 출력하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 그래프의 정점의 개수 n과 간선의 개수 m이 주어진다. 그리고 두 번째 줄에서 m+1번째 줄까지는 a b c의 형태로 a와 b를 연결하는 간선의 고유값이 c라는 의미이다. m+2번째 줄에는 알고 싶은 쿼리의 개수 Q가 주어진다. m+3번째 줄에서 m+Q+2번째 줄에는 x y가 주어진다. (1 ≤ n, m, Q ≤ 100,000, 1 ≤ c ≤ 1,000,000, x ≠ y) 단, 어떠한 두 간선도 고유값이 같은 경우는 없다.</p>

<p>그래프 정점의 번호는 1부터 N까지 매겨져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에서 Q번째 줄까지 각각의 쿼리마다 x정점에 크루스칼의 공을 놓았을 때 y정점으로 갈 수 있게 되는 최소온도 c와 이때 공이 움직일 수 있는 범위에 포함되는 정점의 개수 v를 c v의 형태로 출력한다. 만약, x에서 y로 가는 경로가 없을 때는 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 4
1 2 1
2 3 2
3 4 4
4 5 3
2
1 5
2 3
','4 5
2 3
','DATA_STRUCTURE'),
                                                                                                                (6307,'BAEKJOON','https://www.acmicpc.net/problem/1406',1406,'에디터','0.3초(하단참고)','512 MB',9,'<p>한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다.</p>

<p>이 편집기에는 커서라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.</p>

<p>이 편집기가 지원하는 명령어는 다음과 같다.</p>

<table class="table table-bordered" style="width:100%">
	<tbody>
		<tr>
			<th style="width:20%">L</th>
			<td style="width:80%">커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨)</td>
		</tr>
		<tr>
			<th>D</th>
			<td>커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨)</td>
		</tr>
		<tr>
			<th>B</th>
			<td>커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨)<br>
			삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 실제로 커서의 오른쪽에 있던 문자는 그대로임</td>
		</tr>
		<tr>
			<th>P \$</th>
			<td>\$라는 문자를 커서 왼쪽에 추가함</td>
		</tr>
	</tbody>
</table>

<p>초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M&nbsp;≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','abcd
3
P x
L
P y
','abcdyx
','DATA_STRUCTURE'),
                                                                                                                (6304,'BAEKJOON','https://www.acmicpc.net/problem/1417',1417,'국회의원 선거','2초','128 MB',6,'<p>다솜이는 사람의 마음을 읽을 수 있는 기계를 가지고 있다. 다솜이는 이 기계를 이용해서 2008년 4월&nbsp;9일 국회의원 선거를 조작하려고 한다.</p>

<p>다솜이의 기계는 각 사람들이 누구를 찍을 지 미리 읽을 수 있다. 어떤 사람이 누구를 찍을 지 정했으면, 반드시 선거때 그 사람을 찍는다.</p>

<p>현재 형택구에 나온 국회의원 후보는 N명이다. 다솜이는 이 기계를 이용해서 그 마을의 주민 M명의 마음을 모두 읽었다.</p>

<p>다솜이는 기호 1번이다. 다솜이는 사람들의 마음을 읽어서 자신을 찍지 않으려는 사람을 돈으로 매수해서 국회의원에 당선이 되게 하려고 한다.&nbsp;다른&nbsp;모든&nbsp;사람의&nbsp;득표수&nbsp;보다&nbsp;<strong>많은</strong>&nbsp;득표수를&nbsp;가질&nbsp;때,&nbsp;그&nbsp;사람이&nbsp;국회의원에&nbsp;당선된다.</p>

<p>예를 들어서, 마음을 읽은 결과&nbsp;기호 1번이 5표, 기호 2번이 7표, 기호 3번이 7표 라고 한다면, 다솜이는 2번 후보를 찍으려고 하던 사람 1명과, 3번 후보를 찍으려고 하던 사람 1명을 돈으로 매수하면, 국회의원에 당선이 된다.</p>

<p>돈으로 매수한 사람은 반드시 다솜이를 찍는다고 가정한다.</p>

<p>다솜이가 매수해야하는 사람의 최솟값을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 후보의 수 N이 주어진다. 둘째 줄부터 차례대로 기호 1번을 찍으려고 하는 사람의 수, 기호 2번을 찍으려고 하는 수, 이렇게 총 N개의 줄에 걸쳐 입력이 들어온다. N은 50보다 작거나 같은 자연수이고, 득표수는 100보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 다솜이가 매수해야 하는 사람의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
5
7
7
','2
','DATA_STRUCTURE'),
                                                                                                                (6305,'BAEKJOON','https://www.acmicpc.net/problem/1426',1426,'카드 넣기','2초','128 MB',18,'<p>세준이는 N장의 카드를 가지고 있다. 각각의 카드에는 정수가 쓰여 있고, 문자도 하나 쓰여져 있다. 그리고, 세준이는 카드를 넣을 수 있는 통을 하나 가지고 있다.</p>

<p>세준이는 카드를 아무렇게나 통에 넣고는 했는데, 어느 날 다솜이가 세준이의 카드 통에 정수를 써놓고 도망갔다.</p>

<p>세준이는 정말 화가 나서 정수를 지우고 싶었지만, 지우는 방법을 몰라서 새로운 규칙을 만들어서 카드를 통에 넣으려고 한다.</p>

<p>카드를 통에 넣는 방법은 다음과 같다. 일단 카드 한 장을 고른다. 그리고 카드에 쓰여져 있는 번호보다 작거나 같은 통에 카드를 넣는다.</p>

<p>이렇게 카드를 넣는 방법은 여러 가지가 존재한다. 하지만 세준이는 앞에서부터 차례대로 카드에 쓰여져 있는 문자를 문자열로 만들어서 그 문자열이 가장 사전 순으로 앞서는 문자열을 알고 싶어한다.</p>

<p>예를 들면, 카드가 세 장이 있다. (1, A), (2, B), (3, C)가 있다. 그리고 통에 쓰여져 있는 정수는 2 2 1 이다. 그럼 일단 첫 번째 통에 2번 카드를 넣고, 두 번째 통에 3번 카드를 넣고, 세 번째 통에 1번 카드를 넣으면, 문자열은 BCA가 돼서 규칙에 맞게 넣으면서 가장 사전순으로 빠른 문자열이 나온다.</p>

<p>세준이가 가지고 있는 카드와 통에 쓰여져 있는 정수가 주어졌을 때, 사전순으로 가장 빠른 문자열을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 세준이가 가지고 있는 카드의 개수 N이 주어진다. 이 값은 50보다 작거나 같은 자연수이다. 둘째 줄에는 세준이가 가지고 있는 카드의 정보가 한 줄에 하나씩 주어진다. 카드의 정보는 정수와 문자 하나가 공백을 사이에 두고 주어진다. 정수는 1,000보다 작거나 같은 자연수이고, 문자는 알파벳 대문자이다. 마지막 줄에는 통에 쓰여 있는 정수가 공백을 사이에 두고 주어진다. 이 값은 1,000보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 사전순으로 제일 빠른 문자열을 출력한다. 만약 규칙대로 통에 넣을 수 없으면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 A
2 B
3 C
2 2 1
','BCA
','DATA_STRUCTURE'),
                                                                                                                (6306,'BAEKJOON','https://www.acmicpc.net/problem/1432',1432,'그래프 수정','2초','128 MB',17,'<p>N개의 정점이 있는 그래프가 주어지면, 다음과 같은 방법에 의해서 정점의 번호를 다시 매기고 싶다.</p>

<p>모든 그래프의 번호는 1보다 크거나 같고 N보다 작거나 같은 번호를 가져야 한다.</p>

<p>만약 V1에서 V2로 연결된 간선이 있다면, V2의 번호는 V1보다 커야 한다.</p>

<p>위와 같은 조건을 이용해서 그래프의 번호를 다시 매긴 후에, 1번 정점의 새로 고친 번호를 M1, 2번 정점의 새로 고친 번호를 M2, ..., N번 정점의 새로 고친 번호를 MN이라고 하면, N개의 수열이 만들어진다.</p>

<p>이 수열을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에는 인접행렬 형식으로 입력이 주어진다. 0은 연결되지 않았음을 의미하고, 1은 연결되었다는 것을 의미한다. N은 50보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 수열의 각 원소를 차례대로 공백을 사이에 두고 출력한다. 만약 그래프의 번호를 수정할 수 없다면 -1을 출력한다. 답이 여러 개일 경우에는 사전 순으로 제일 앞서는 것을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
00001
00010
00000
00001
00100
','1 2 5 3 4
','DATA_STRUCTURE'),
                                                                                                                (6286,'BAEKJOON','https://www.acmicpc.net/problem/1464',1464,'뒤집기 3','2초','128 MB',12,'<p>세준이는 어떤 문자열 S를 뒤집으려고 한다. 문자열을 뒤집는 방법은 문자열의 길이를 N이라고 하자. i만큼을 뒤집는다는 소리는 그 문자열의 처음부터 정확하게 i개의 문자를 역순으로 뒤집는 것이다. 세준이는 1부터 N까지 수를 차례대로 생각한다. 그리고, 뒤집을지 안 뒤집을지 선택할 수 있다.</p>

<p>예를 들어, S="BCDAF" 이고, 세준이가 길이 1만큼을 뒤집지 않고, 길이 2만큼도 뒤집지 않고 세준이가 길이 3만큼을 뒤집는다고 하면 문자열은 DCBAF가 된다. 다시 여기서 4만큼 뒤집으면 ABCDF가 된다. 그리고, 마지막으로 길이를 5만큼 뒤집지 않으면 주어진 문자열 S를 사전순으로 가장 앞서게 만들 수 있다.</p>

<p>문자열 S가 주어졌을 때, 위와같은 뒤집기 방법으로 만들 수 있는 문자열 중 사전순으로 제일 앞서는 것을 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 문자열 S가 주어진다. 문자열의 길이는 최대 50이다. 알파벳 대문자만 들어온다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 사전순으로 가장 앞서는 정답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','BCDAF
','ABCDF
','DATA_STRUCTURE'),
                                                                                                                (6268,'BAEKJOON','https://www.acmicpc.net/problem/1466',1466,'그림 고치기','2초','128 MB',14,'<p>세준이는 N*M크기의 그림을 그리려고 하는데 1*1크기의 정사각형마다 색을 다르게 칠한다. 세준이는 흰색과 검정색만을 이용하는데, 흰색을 . 검정색을 #이라고 한다.</p>

<p>만약 두 개의 검정색 칸이 서로 공통된 변을 공유하고 있다면, 두 칸은 직접 연결되어 있는 것이다. 두 개의 검정색 칸 A와 B가 간접적으로 연결되어 있다는 말은, A=P1 -> P2 -> ... -> Pk=B로 가는 경로가 있을 때 (Pi와 Pi+1은 직접 연결되어 있을 때) 간접적으로 연결되어 있다고 한다.</p>

<p>세준이의 그림에는 검정색 그룹이 몇 개 있는데, 그 그룹 속에 있는 모든 한 쌍의 검정색 칸은 직, 간접적으로 연결되어 있어야 한다. 다른 그룹과 연결되어 있는 것이 있으면 안 된다.</p>

<p>세준이의 그림에 존재하는 검정색 그룹의 특징은 그 그룹속의 모든 쌍의 경로의 길이가 그 쌍의 Manhattan Distance와 같다.</p>

<p>Manhattan Distance란 어떤 두 칸 A(Xa, Ya)와 B(Xb, Yb)가 있을 때, 두 칸의 거리는 |Xa-Xb| +|Ya-Yb|이다.</p>

<p>세준이가 그림을 다솜이에게 자랑을 하려고 보냈으나, 통신오류로 그림의 검정 칸중 일부가 흰색으로 변했다.</p>

<p>다솜이는 전송받은 그림을 고쳐서 원래 그림으로 만들려고 한다. 다솜이가 세준이의 그림의 특징을 지키면서 원래 그림으로 만들 때, 고쳐야 하는 칸의 회수를 최소로 하려고 한다.</p>

<p>다솜이가 고친 세준이의 원래 그림을 출력하는 프로그램을 작성하시오.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 그림의 세로크기 N과 가로크기 M이 들어온다. 둘째 줄부터 N개의 줄에 그림이 들어온다. (1 ≤ N, M ≤ 50)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>세준이의 원래 그림을 첫째 줄부터 N개의 줄에 걸쳐 출력한다. 최소로 고치는 원래 그림은 유일하다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 8
###.####
#.#.#..#
.#...#.#
.#####.#
......#.
########
','########
########
########
########
########
########
','DATA_STRUCTURE'),
                                                                                                                (6309,'BAEKJOON','https://www.acmicpc.net/problem/1517',1517,'버블 소트','1초','512 MB',16,'<p>N개의 수로 이루어진 수열 A[1], A[2], …, A[N]이 있다. 이 수열에 대해서 버블 소트를 수행할 때, Swap이 총 몇 번 발생하는지 알아내는 프로그램을 작성하시오.</p>

<p>버블 소트는 서로 인접해 있는 두 수를 바꿔가며 정렬하는 방법이다. 예를 들어 수열이 3 2 1 이었다고 하자. 이 경우에는 인접해 있는 3, 2가 바뀌어야 하므로 2 3 1 이 된다. 다음으로는 3, 1이 바뀌어야 하므로 2 1 3 이 된다. 다음에는 2, 1이 바뀌어야 하므로 1 2 3 이 된다. 그러면 더 이상 바꿔야 할 경우가 없으므로 정렬이 완료된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N(1 ≤ N ≤ 500,000)이 주어진다. 다음 줄에는 N개의 정수로 A[1], A[2], …, A[N]이 주어진다. 각각의 A[i]는 0 ≤ |A[i]| ≤ 1,000,000,000의 범위에 들어있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 Swap 횟수를 출력한다</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
3 2 1
','3
','DATA_STRUCTURE'),
                                                                                                                (6310,'BAEKJOON','https://www.acmicpc.net/problem/1525',1525,'퍼즐','1초','32 MB (하단 참고)',14,'<p>3×3 표에 다음과 같이 수가 채워져 있다. 오른쪽 아래 가장 끝 칸은 비어 있는 칸이다.</p>

<table class="table table-bordered" style="width:15%">
	<tbody>
		<tr>
			<td style="text-align: center;">1</td>
			<td style="text-align: center;">2</td>
			<td style="text-align: center;">3</td>
		</tr>
		<tr>
			<td style="text-align: center;">4</td>
			<td style="text-align: center;">5</td>
			<td style="text-align: center;">6</td>
		</tr>
		<tr>
			<td style="text-align: center;">7</td>
			<td style="text-align: center;">8</td>
			<td style="text-align: center;">&nbsp;</td>
		</tr>
	</tbody>
</table>

<p>어떤 수와 인접해 있는 네 개의 칸 중에 하나가 비어 있으면, 수를 그 칸으로 이동시킬 수가 있다. 물론 표 바깥으로 나가는 경우는 불가능하다. 우리의 목표는 초기 상태가 주어졌을 때, 최소의 이동으로 위와 같은 정리된 상태를 만드는 것이다. 다음의 예를 보자.</p>

<table class="table table-bordered" style="width:15%">
	<tbody>
		<tr>
			<td style="text-align: center;">1</td>
			<td style="text-align: center;">&nbsp;</td>
			<td style="text-align: center;">3</td>
		</tr>
		<tr>
			<td style="text-align: center;">4</td>
			<td style="text-align: center;">2</td>
			<td style="text-align: center;">5</td>
		</tr>
		<tr>
			<td style="text-align: center;">7</td>
			<td style="text-align: center;">8</td>
			<td style="text-align: center;">6</td>
		</tr>
	</tbody>
</table>

<table class="table table-bordered" style="width:15%">
	<tbody>
		<tr>
			<td style="text-align: center;">1</td>
			<td style="text-align: center;">2</td>
			<td style="text-align: center;">3</td>
		</tr>
		<tr>
			<td style="text-align: center;">4</td>
			<td style="text-align: center;">&nbsp;</td>
			<td style="text-align: center;">5</td>
		</tr>
		<tr>
			<td style="text-align: center;">7</td>
			<td style="text-align: center;">8</td>
			<td style="text-align: center;">6</td>
		</tr>
	</tbody>
</table>

<table class="table table-bordered" style="width:15%">
	<tbody>
		<tr>
			<td style="text-align: center;">1</td>
			<td style="text-align: center;">2</td>
			<td style="text-align: center;">3</td>
		</tr>
		<tr>
			<td style="text-align: center;">4</td>
			<td style="text-align: center;">5</td>
			<td style="text-align: center;">&nbsp;</td>
		</tr>
		<tr>
			<td style="text-align: center;">7</td>
			<td style="text-align: center;">8</td>
			<td style="text-align: center;">6</td>
		</tr>
	</tbody>
</table>

<table class="table table-bordered" style="width:15%">
	<tbody>
		<tr>
			<td style="text-align: center;">1</td>
			<td style="text-align: center;">2</td>
			<td style="text-align: center;">3</td>
		</tr>
		<tr>
			<td style="text-align: center;">4</td>
			<td style="text-align: center;">5</td>
			<td style="text-align: center;">6</td>
		</tr>
		<tr>
			<td style="text-align: center;">7</td>
			<td style="text-align: center;">8</td>
			<td>&nbsp;</td>
		</tr>
	</tbody>
</table>

<p>가장&nbsp;윗 상태에서 세 번의 이동을 통해 정리된 상태를 만들 수 있다. 이와 같이 최소 이동 횟수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>세 줄에 걸쳐서 표에 채워져 있는 아홉 개의 수가 주어진다. 한 줄에 세 개의 수가 주어지며, 빈 칸은 0으로 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소의 이동 횟수를 출력한다. 이동이 불가능한 경우 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1 0 3
4 2 5
7 8 6
','3
','DATA_STRUCTURE'),
                                                                                                                (6311,'BAEKJOON','https://www.acmicpc.net/problem/1539',1539,'이진 검색 트리','2초','256 MB',16,'<p>P는 크기가 N인 배열이다. P에는 0보다 크거나 같고, N-1보다 작거나 같은 정수가 중복 없이 채워져 있다. 이진 검색 트리는 루트가 있는 이진 트리로, 각각의 노드에 정수 값이 저장되어&nbsp;있는 트리이다. 이진 검색 트리를 P배열을 이용해서 만드는 법은 다음과 같다. 일단 root를 만들고 거기에 P[0]의 값을 넣은 후에 다음과 같은 과정을 거친다.</p>

<pre>for (int i=1; i<=n-1; i++) {
    insert(root, P[i]);
}
</pre>

<p>여기서 insert함수는 다음과 같다.</p>

<pre>void insert(Vertex V, int X) {
    if (x < V에 저장되어 있는 수) {
        if (V가 왼쪽 자식이 있으면) {
            insert(V의 왼쪽 자식, X);
        } else {
            V의 왼쪽 자식을 새로 만들고, 그 곳에 X를 저장함
        }
    } else {
        if (V가 오른쪽 자식이 있으면) {
            insert(V의 오른쪽 자식, X);
        } else {
            V의 오른쪽 자식을 새로 만들고, 그 곳에 X를 저장함
        }
    }
}
</pre>

<p>N과, 배열 P에 있는 수가 주어졌을 때, P로 이진 검색 트리를 만들었을 때, 모든 노드의 높이의 합을 출력하는 프로그램을 작성하시오. 트리의 높이는 루트에서 부터의 거리 + 1이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. N은 250,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 P[0]부터 P[N-1]의 원소가 한 줄에 하나씩 들어온다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>주어진 P배열로 이진 검색 트리를 만들었을 때, 높이의 합을 출력한다. 이 값은 2^63보다 작다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
9
1
4
3
2
5
6
7
8
0
','40
','DATA_STRUCTURE'),
                                                                                                                (6312,'BAEKJOON','https://www.acmicpc.net/problem/1558',1558,'그림의 개수','2초','128 MB',0,'<p>폴리라인 (Polyline)은 컴퓨터 그래픽에서 선분을 이어서 만든 도형이다. 폴리라인은 연속된 선분으로 이루어져 있는데, 폴리라인에서 모든 선분의 시작점은 바로 전 선분의 끝점과 같다.</p>

<p>만약, 두 개의 폴리라인이 같은 점을 공유한다면, 두 폴리라인은 같은 그림에 속한다고 말할 수 있다.</p>

<p>폴리라인의 정보가 주어졌을 때, 그림의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 폴리라인의 개수 T가 주어진다. T개 폴리라인의 정보는 첫째 줄에 이 폴리라인을 구성하는 점의 좌표의 N이 주어지고 둘째 줄부터 좌표가 주어진다. N=1일 수도 있다. T는 1,000보다 작고, N은&nbsp;500보다 작다. 좌표는&nbsp;10,000보다 작거나 같은 자연수 또는 0만 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 그림의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
2
0 0
10 5
4
5 0
15 5
10 10
5 5
','2
','DATA_STRUCTURE'),
                                                                                                                (6313,'BAEKJOON','https://www.acmicpc.net/problem/1572',1572,'중앙값','1초','128 MB',16,'<p>중앙값이란, 수열을 정렬했고, 그 크기가 N일 때, 1부터 시작해서 (N+1)/2번째 있는 원소가 그 수열의 중앙값이다. 예를 들어, {1, 2, 6, 5, 4, 3}에서는 3이고, {11, 13, 12, 15, 14}에서는 13이다.</p>

<p>오세준은 1초에 온도를 하나씩 재는 온도계를 만들었다. 이 온도계에는 작은 디스플레이 창이 하나 있는데, 이 창에는 지금부터 최근 K초 까지 온도의 중앙값을 표시해 준다. (온도를 재기시작한지 K초부터 표시한다. 그 전에는 아무것도 출력되지 않는다.)</p>

<p>오세준은 온도를 N초동안 쟀다. 그 시간 동안 온도계의 디스플레이 창에 뜨는 숫자의 합을 구하는 프로그램을 작성하시오.</p>

<p>다른 말로 하면, 길이가 N인 수열이 주어진다. 이 수열은 N-K+1 개의 길이가 K인 연속된 부분 수열이 존재한다. 이 부분 수열의 중앙값의 합을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 주어진다. N은 250,000보다 작거나 같은 자연수이고, K는 5,000보다 작거나 같은 자연수이다. N은 항상 K보다 크거나 같다. 둘째 줄부터 N개의 수가 한 줄에 하나씩 주어진다. 입력으로 주어지는 수는 65536보다 작거나 같은 자연수 또는 0이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 정답을 출력한다. 정답은 2<sup>63</sup>-1보다 작거나 같다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 3
3
4
5
6
7
8
9
10
11
12
','60
','DATA_STRUCTURE'),
                                                                                                                (6314,'BAEKJOON','https://www.acmicpc.net/problem/1615',1615,'교차개수세기','2초','128 MB',15,'<p>각각 N(1 ≤ N ≤ 2,000)개의 쌍으로 이루어진 2N개의 정점과 M(1 ≤ M ≤ N×(N-1)/2)개의 간선으로 구성된 이분그래프가 주어질 때 서로 교차하는 총 개수를 구하는 것이다.</p>

<ul>
	<li>교차 조건 : 한 독립 집합 A와 다른 독립 집합 B가 연결된 두 개의 간선을 (A<sub>1</sub>, B<sub>1</sub>), (A<sub>2</sub>, B<sub>2</sub>)라 한다면 A<sub>1</sub> < A<sub>2</sub>, B<sub>1</sub> > B<sub>2</sub> 또는 A<sub>1</sub> > A<sub>2</sub>, B<sub>1</sub> < B<sub>2</sub>를 만족한다면 두 간선을 교차한다고 한다.</li>
</ul>

<p style="text-align: center;"><img alt="" height="227" src=https://www.acmicpc.net/upload/201004/ryck.png" width="152"></p>

<p>예를 들어 위에 예에서 (3, 2)는 (1, 5)와 (5, 1)과 교차한다. 이 문제를 해결하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 N과 간선의 개수 M이 주어진다. 그 다음 줄부터 M+1번째 줄까지 두 개의 수(i, j)가 주어지는데 이는 왼쪽 그룹의 i번 정점과 오른쪽 그룹의 j번 정점을 연결하는 간선이 있다는 의미이다. 중복되는 간선이 입력으로 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력에서 주어진 간선이&nbsp;교차하는 총 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 6
1 5
2 2
3 2
4 3
5 1
5 3
','8
','DATA_STRUCTURE'),
                                                                                                                (6318,'BAEKJOON','https://www.acmicpc.net/problem/1620',1620,'나는야 포켓몬 마스터 이다솜','2초','256 MB',7,'<p><img alt="" src=https://www.acmicpc.net/upload/201004/p1.PNG" style="height:184px; width:274px"></p>

<p>안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어.</p>

<p>(뚜벅 뚜벅)</p>

<p>얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~</p>

<p>(펑!) 헐랭... 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가...ㅜㅠ</p>

<p>(터벅터벅)</p>

<p>어? 누구지?</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/p2.PNG" style="height:184px; width:274px"></p>

<p>오박사 : 나는 태초마을의 포켓몬 박사 오민식 박사라네. 다솜아, 포켓몬을 잡을 때는, 일단 상대 포켓몬의 체력을 적당히 바닥으로 만들어놓고 몬스터 볼을 던져야 한단다. 자, 내 포켓몬 이상해꽃으로 한번 잡아보렴. 포켓몬의 기술을 쓰는 것을 보고 포켓몬을 줄지 안줄지 결정을 하겠네. 자 한번 해보아라. 다솜아.</p>

<p>이다솜 : 이상해꽃이라...음.. 꽃이니깐 왠지 햇빛을 받아서 공격을 할 것 같은데... 음... 이상해꽃! 햇빛공격!!!</p>

<p>(꼬렛이 이상해꽃에게 공격을 받아 체력이 25 감소했다.) &nbsp;&nbsp; 가라! 몬스터 볼!!! &nbsp;&nbsp; (꼬렛을 잡았습니다.) &nbsp;&nbsp; 야호! 신난다. 꼬렛을 잡았다.</p>

<p>오박사 : 오우!! 방금 쓴 공격은 솔라빔이라고 하네.. 어떻게 공격을 한 건가? 솔라빔이란 공격에 대해서 공부를 한 건가?</p>

<p>이다솜 : 꽃이니깐 왠지 햇빛을 제대로 받으면 광합성을 해서 음.. 그냥 그럴 것 같아서요 ☞☜</p>

<p>오박사 : 다른 아이들은 넝쿨채찍이나, 나뭇잎 공격을 하는데, 다솜이는 역시 뭔가 다르구나. 그럼 나와 함께 연구소로 가자꾸나. 내가 포켓몬을 한 마리 줄 테니, 너의 꿈을 펼쳐보아라. 꿈은 이루어진단다.</p>

<p>이다솜 : 네! 오박사님, 고마워요.ㅜㅜ</p>

<p>오박사 : 가자. 나의 연구소는 너의 옆집의 아랫집이란다. 같이 가도록하자. 지금 포켓몬을 주마.</p>

<p>이다솜 : 네. 야호!!</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/p3.PNG" style="height:181px; width:274px"></p>

<p>오영식 : 어? 오박사님 얘는 누구인가요?</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/p4.PNG" style="height:182px; width:274px"></p>

<p>오박사 : 얘는 너의 라이벌이 될 친구 이다솜이라고 하네. 자, 포켓몬을 한 마리 골라보도록 해봐라 다솜아. 레이디퍼스트 네가 먼저 골라봐라.</p>

<p>이다솜 : 저는 생각해둔 포켓몬이 있어요. 피카츄 골라도 될까요?</p>

<p>오박사 : 그래 여기 피카츄가 한 마리 있단다. 피카츄를 가져가거라.</p>

<p>오영식 : 그럼 저는 이브이를 가져가겠어요. 그럼 나중에 보자 이다솜.</p>

<p>이다솜 : 그럼 꼬렛을 다시 잡으러 가야겠다. 영식아, 그리고 민식박사님 빠잉!</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/p5.PNG" style="height:179px; width:274px"></p>

<p>이다솜 : 피카츄 공격!</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/p6.PNG" style="height:182px; width:274px"></p>

<p>가라 몬스터 볼!</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/p7.PNG" style="height:184px; width:274px"></p>

<p>이다솜 : 야호! 신난다. 꼬렛을 잡았다!!!!!</p>

<p>이다솜 : 그럼! 일단 사천왕을 이기고 오겠어!</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/p8.PNG" style="height:181px; width:274px"></p>

<p>이다솜 : 여기가 사천왕과 대결하려면 가야하는 곳인가..</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/p9.PNG" style="height:181px; width:274px"></p>

<p>경비원 : 사천왕과 대결을 하려면, 마을의 체육관 리더를 이겨서 배지를 8개를 모아야 한다네... 배지를 모아서 오도록 하게</p>

<p>이다솜 : 잉ㅠㅜ... 그럼 배지부터 모아야 하는구나ㅠㅜㅠㅜ 나쁘당 그냥 좀 봐주지..</p>

<p><1 년 후></p>

<p>그동안의 줄거리 : 이다솜은 일단 상록 숲의 체육관 리더에게 도전을 했다. 하지만 상록숲 체육관의 리더는 실종된 상태. 따라서 회색마을부터 도전하기로 했다. 체육관의 리더를 이기면서, 로켓단을 해체시키기도 하고, 여러 가지 사건도 있었다. 결국 전설의 포켓몬도 잡고, 이제 사천왕을 이기려고 도전하기로 했다. 사천왕은 모두 가볍게 이기고, 이제 마지막 라이벌 오!영!식! 이다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/pa.PNG" style="height:183px; width:274px"></p>

<p>오영식 : 훗. 1년 전의 그 이다솜이 사천왕을 이기고 현재 포켓몬 마스터인 나에게 덤벼? 어디 한번 덤벼보시지.</p>

<p>이다솜 : 헐랭... 나를 우습게보네.... 한번 두고 보시지! 그럼 대결이닷!</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/pb.PNG" style="height:181px; width:274px"></p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/pc.PNG" style="height:183px; width:274px"></p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/pd.PNG" style="height:182px; width:274px"></p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/pe.PNG" style="height:183px; width:274px"></p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/pf.PNG" style="height:183px; width:274px"></p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/pg.PNG" style="height:181px; width:274px"></p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/ph.PNG" style="height:184px; width:274px"></p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/pi.PNG" style="height:184px; width:274px"></p>

<p>이다솜 : 휴... 이겼다.</p>

<p>오영식 : 내가 지다니 분하다. ㅜㅜ</p>

<p>오박사 : 그럼 다솜아 이제 진정한 포켓몬 마스터가 되기 위해 도감을 완성시키도록 하여라. 일단 네가 현재 가지고 있는 포켓몬 도감에서 포켓몬의 이름을 보면 포켓몬의 번호를 말하거나, 포켓몬의 번호를 보면 포켓몬의 이름을 말하는 연습을 하도록 하여라. 나의 시험을 통과하면, 내가 새로 만든 도감을 주도록 하겠네.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어.</p>

<p>둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음... 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 아참! 일부 포켓몬은 마지막 문자만 대문자일 수도 있어. 포켓몬 이름의 최대 길이는 20, 최소 길이는 2야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!!</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/pn.PNG" style="height:122px; width:141px"></p>

<p>이게 오박사님이 나에게 새로 주시려고 하는 도감이야. 너무 가지고 싶다ㅠㅜ. 꼭 만점을 받아줬으면 좋겠어!! 파이팅!!!</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','26 5
Bulbasaur
Ivysaur
Venusaur
Charmander
Charmeleon
Charizard
Squirtle
Wartortle
Blastoise
Caterpie
Metapod
Butterfree
Weedle
Kakuna
Beedrill
Pidgey
Pidgeotto
Pidgeot
Rattata
Raticate
Spearow
Fearow
Ekans
Arbok
Pikachu
Raichu
25
Raichu
3
Pidgey
Kakuna
','Pikachu
26
Venusaur
16
14
','DATA_STRUCTURE'),
                                                                                                                (6315,'BAEKJOON','https://www.acmicpc.net/problem/1626',1626,'두 번째로 작은 스패닝 트리','2초','128 MB',22,'<p>방향성이 없는 그래프 G가 주어진다. 문제는 G의 최소 스패닝 트리보다는 크면서 가장 작은 스패닝 트리인 The second minimum spanning tree를 구하는 것이다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201004/smst.PNG" style="height:128px; width:273px"></p>

<p style="text-align:center">MST와 second MST의 모습</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 그래프의 정점의 수 V(1 ≤ V ≤ 50,000)와 간선의 수 E(1 ≤ E ≤ 200,000)가 들어온다. 둘째 줄부터 E+1번째 줄까지 한 간선으로 연결된 두 정점과 그 간선의 가중치가 주어진다. 가중치는 100,000보다 작거나 같은 자연수 또는 0이고, 답은 2<sup>31</sup>-1을 넘지 않는다.</p>

<p>정점 번호는 1보다 크거나 같고, V보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>두 번째로 작은 스패닝 트리의 값을 출력한다. 만약 스패닝 트리나 두 번째로 작은 스패닝 트리가 존재하지 않는다면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 12
1 2 8
1 3 5
2 3 10
2 4 2
2 5 18
3 4 3
3 6 16
4 5 12
4 6 30
4 7 14
5 7 4
6 7 26
','44
','DATA_STRUCTURE'),
                                                                                                                (6316,'BAEKJOON','https://www.acmicpc.net/problem/1655',1655,'가운데를 말해요','0.1초(하단참고)','128 MB',14,'<p>백준이는 동생에게 "가운데를 말해요" 게임을 가르쳐주고 있다. 백준이가&nbsp;정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 백준이가 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해야 한다.</p>

<p>예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄에 하나씩 N줄에 걸쳐 백준이의 동생이 말해야 하는 수를 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1
5
2
10
-99
7
5
','1
1
2
2
2
2
5
','DATA_STRUCTURE'),
                                                                                                                (6317,'BAEKJOON','https://www.acmicpc.net/problem/1662',1662,'압축','2초','128 MB',11,'<p>압축되지 않은 문자열 S가 주어졌을 때, 이 문자열중 어떤 부분 문자열은 K(Q)와 같이 압축 할 수 있다. K는 한자리 정수이고, Q는 0자리 이상의 문자열이다. 이 Q라는 문자열이 K번 반복된다는 뜻이다. 압축된 문자열이 주어졌을 때, 이 문자열을 다시 압축을 푸는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 압축된 문자열 S가 들어온다. S의 길이는 최대 50이다. 문자열은 (, ), 0-9사이의 숫자로만 들어온다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 압축되지 않은 문자열의 길이를 출력한다. 이 값은 2,147,473,647 보다 작거나 같다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','33(562(71(9)))
','19
','DATA_STRUCTURE'),
                                                                                                                (6321,'BAEKJOON','https://www.acmicpc.net/problem/1666',1666,'최대 증가 직사각형 집합','2초','128 MB',19,'<p>N개의 직사각형이 좌표 위에 흩어져 있고 이 중 몇 개의 직사각형을 선택하여 집합 L을 구성하려 한다. 집합 L의 조건은 아래와 같다.</p>

<p style="text-align: center;"><img alt="" src="/JudgeOnline/upload/201005/rect.PNG" style="height:187px; width:302px"></p>

<p>왼쪽 아래의 점을 시작점, 오른쪽 위의 점을 끝점이라고 정의 할 때, 집합의 임의의 두 원소 p, q에 대하여 p의 끝점 x좌표가 q의 시작점 x좌표보다 작고 마찬가지로 y좌표도 작거나 또는 q의 끝점 x좌표가 p의 시작점 x좌표보다 작고 y좌표 역시 작아야 한다.</p>

<p>문제는 위의 조건을 만족하는 집합의 최대 원소 개수를 구하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 직사각형의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1번째 줄까지 i+1번째 줄에 i번째 직사각형의 왼쪽 아래 점의 x좌표, y좌표 오른쪽 위의 점의 x좌표, y좌표를 나타내는 4개의 정수가 공백으로 구분되어 주어진다. 왼쪽 아래 점의 x, y좌표는 오른쪽 위의 x, y좌표보다 항상 작다. (0 ≤ x, y ≤&nbsp;100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 집합의 최대 원소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
0 0 3 3
2 0 5 3
4 4 7 7
','2','DATA_STRUCTURE'),
                                                                                                                (6320,'BAEKJOON','https://www.acmicpc.net/problem/1675',1675,'팬더 밥주기','2초','128 MB',22,'<p>테디라는 팬더는 N개의 대나무 숲을 가진 숲속에 산다. 각각의 대나무 숲은 평면상의 점으로 표현된다. i번째 대나무 숲은 L<sub>i</sub>개의 대나무와 W<sub>i</sub>라는 맛있는 정도를 가진다.</p>

<p>테디는 매일 선택된 한 개의 대나무 숲의 모든 대나무들을 먹어치운다. 단 현재 대나무 숲이 그 전날 선택한 대나무 숲보다 맛있는 정도가 더 좋아야만 한다.</p>

<p>테디가 걷는 시간이 길면 길수록 그는 더 많은 대나무를 기대하게 되므로, 만약 그가 이전 대나무 숲으로부터 걸어온 거리가 현재 도달한 대나무 숲의 대나무 수보다 적다면 울음을 터뜨린다.</p>

<p>두 점(x<sub>0</sub>, y<sub>0</sub>)과 (x<sub>1</sub>, y<sub>1</sub>)사이의 거리는 |x<sub>0</sub>-x<sub>1</sub>| + |y<sub>0</sub>-y<sub>1</sub>|로 표현된다. 따라서 테디는 동서남북 방향으로만 움직인다.</p>

<p>문제는 테디를 하나의 대나무 숲에 데려다 놓으면, 그는 최대 며칠 동안 울음을 터뜨리지 않는지를 구하는 것이다. 테디가 처음 있는 대나무 숲은 당신이 정하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 대나무 숲의 개수 N이 주어진다. 두 번째 줄부터 N+1번째 줄까지 i+1번째 줄에는 i번째 대나무 숲의 위치를 나타내는 X<sub>i</sub>, Y<sub>i</sub>와 맛있는 정도를 나타내는 W<sub>i</sub>, 대나무의 개수 L<sub>i</sub>가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 울음을 터뜨리지 않는 최대 일 수를 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
0 0 3 4
2 2 2 3
5 5 1 3
','2
','DATA_STRUCTURE'),
                                                                                                                (6322,'BAEKJOON','https://www.acmicpc.net/problem/1715',1715,'카드 정렬하기','2초','128 MB',12,'<p>정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.</p>

<p>매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.</p>

<p>N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소 비교 횟수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
10
20
40
','100
','DATA_STRUCTURE'),
                                                                                                                (6323,'BAEKJOON','https://www.acmicpc.net/problem/1717',1717,'집합의 표현','2초','128 MB',11,'<p>초기에 $n+1$개의 집합 $\{0\}, \{1\}, \{2\}, \dots , \{n\}$이 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.</p>

<p>집합을 표현하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 $n$, $m$이 주어진다. $m$은 입력으로 주어지는 연산의 개수이다. 다음 $m$개의 줄에는 각각의 연산이 주어진다. 합집합은 $0$ $a$ $b$의 형태로 입력이 주어진다. 이는 $a$가 포함되어 있는 집합과, $b$가 포함되어 있는 집합을 합친다는 의미이다. 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산은 $1$ $a$ $b$의 형태로 입력이 주어진다. 이는 $a$와 $b$가 같은 집합에 포함되어 있는지를 확인하는 연산이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1로 시작하는 입력에 대해서 $a$와 $b$가 같은 집합에 포함되어 있으면 "<code>YES</code>" 또는 "<code>yes</code>"를, 그렇지 않다면 "<code>NO</code>" 또는 "<code>no</code>"를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 8
0 1 3
1 1 7
0 7 6
1 7 1
0 3 7
0 4 2
0 1 1
1 1 1
','NO
NO
YES
','DATA_STRUCTURE'),
                                                                                                                (6335,'BAEKJOON','https://www.acmicpc.net/problem/1725',1725,'히스토그램','0.7초','128 MB',16,'<p>히스토그램에 대해서 알고 있는가? 히스토그램은 아래와 같은 막대그래프를 말한다.</p>

<p style="text-align: center;"><img alt="" height="168" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201006/hist.PNG" width="231"></p>

<p>각 칸의 간격은 일정하고, 높이는 어떤 정수로 주어진다. 위 그림의 경우 높이가 각각 2 1 4 5 1 3 3이다.</p>

<p>이러한 히스토그램의 내부에 가장 넓이가 큰 직사각형을 그리려고 한다. 아래 그림의 빗금 친 부분이 그 예이다. 이 직사각형의 밑변은 항상 히스토그램의 아랫변에 평행하게 그려져야 한다.</p>

<p style="text-align: center;"><img alt="" height="166" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201006/histo.PNG" width="236"></p>

<p>주어진 히스토그램에 대해, 가장 큰 직사각형의 넓이를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 행에는 N (1 ≤ N ≤ 100,000) 이 주어진다. N은 히스토그램의 가로 칸의 수이다. 다음 N 행에 걸쳐 각 칸의 높이가 왼쪽에서부터 차례대로 주어진다. 각 칸의 높이는 1,000,000,000보다 작거나 같은 자연수 또는 0이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가장 큰 직사각형의 넓이를 출력한다. 이 값은 20억을 넘지 않는다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
2
1
4
5
1
3
3
','8','DATA_STRUCTURE'),
                                                                                                                (6327,'BAEKJOON','https://www.acmicpc.net/problem/1732',1732,'레이저','2초','128 MB',14,'<p>2차원 평면상에 N(1≤N≤100,000)개의 기둥이 설치되어 있다. 각각의 기둥의 꼭대기에는 레이저가 설치되어 있는데, 레이저는 (0, 0)의 위치에 있는 조각상을 비추고 있다. 각각의 건물의 높이는 다를 수 있는데, 이때문에 몇몇 레이저들은 다른 건물에 가려질 수도 있다. 두 개의 건물 A, B와 조각상이 일직선상에 순서대로 있을 때, 만약 A의 높이가 B의 높이 이하이면 A의 꼭대기에 설치되어 있는 레이저는 건물 B에 가려지게 된다.</p>
<p>각 건물들의 좌표가 주어졌을 때, 레이저가 가려지게 되는 건물들을 구하는 프로그램을 작성하시오.</p>

					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. 다음 N개의 줄에는 세 정수 x, y, z가 주어진다. 이는 (x, y)의 위치에 높이 z인 건물이 존재한다는 의미이다. 단 -100,000≤x≤100,000, 0≤y≤10,000, 0≤z≤10,000이 만족된다. 같은 위치에는 최대 한 개의 건물만 있을 수 있다.</p>
					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 가려지는 건물들의 좌표를 출력한다. 좌표를 출력할 때에는 x좌표가 증가하는 순서대로, x좌표가 같다면 y좌표가 증가하는 순서대로 출력한다.</p>
					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
-1 0 1
-1 1 2
-2 2 2
-3 3 3
-4 4 2
','-4 4
-2 2
','DATA_STRUCTURE'),
                                                                                                                (6328,'BAEKJOON','https://www.acmicpc.net/problem/1741',1741,'반 나누기','2초','128 MB',19,'<p>학생들이 너무 떠드는 것을 보다 못한 나머지, 원장님은 결단을 내리셨다. 반을 나누기로.</p>

<p>학생들은 친한 친구들과 떨어지는 것이 싫어서 몹시 거세게 반발했고, 원장님은 이를 잠재우기 위하여 한 가지 방안을 제시하셨다. 인터넷 메신저로 대화할 수 있게 허락해 주신 것이다.</p>

<p>단, 두 사람이 메신저로 대화를 나누기 위해서는 서로가 서로의 메신저 아이디를 알고 있어야 하는데, 모든 학생이 모든 학생의 아이디를 알고 있는 것은 아니다.</p>

<p>이러한 상황에서, 원장님은 최대한 반을 잘게 나누고자 하신다. 다른 반에 속한 학생들끼리는 메신저로 대화해야 하므로, 반드시 서로의 메신저 아이디를 알고 있어야만 한다.</p>

<p>어떤 학생들끼리 서로의 메신저 아이디를 알고 있는지 주어졌을 때, 가장 많은 반을 편성하려면 어떻게 해야 하는지 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄 학생들의 수 n과, 서로 메신저 아이디를 알고 있는 학생들 쌍의 수 m이 공백을 사이에 두고 주어진다. (2 ≤ n ≤ 100,000. 1 ≤ m ≤ 2,000,000) 이후 m개의 줄에는 서로 메신저 아이디를 알고 있는 학생들 번호의 쌍이 두 개의 정수로 주어진다. 두 학생의 번호는 1이상 n이하의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에, 최대로 편성할 수 있는 반이 몇 개인지 출력한다. 둘째 줄에는, 최대로 편성했을 때 각 반별 인원수를 오름차순으로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>4번 학생 혼자 한 반, 5번과 7번 학생 둘이서 한 반, 나머지 학생 네 명이서 한 반이 되도록 반을 편성하면 된다.</p>

				</div>
				</div>','7 16
1 3
1 4
1 5
2 3
3 4
4 5
4 7
4 6
5 6
6 7
2 4
2 7
2 5
3 5
3 7
1 7
','3
1 2 4
','DATA_STRUCTURE'),
                                                                                                                (6329,'BAEKJOON','https://www.acmicpc.net/problem/1763',1763,'트리 색칠','2초','128 MB',24,'<p>N개의 노드를 가지고 있으며, 루트가 있는 트리의 각 노드에 가중치가 부여돼 있다. 임의의 노드의 번호를 i라 하고, i번 노드에 부여된 가중치를 C[i]라 한다.</p>

<p>이 트리를 색칠한다고 상상해 보자. 한 노드를 색칠하는 데에는 비용이 드는데, i번 노드가 F[i]번째로 색칠되는 노드라면, i번 노드를 색칠하는 데 드는 비용은 C[i]*F[i]로 계산된다. 전체 트리를 색칠하는 데 드는 비용은 각 노드를 색칠하는 데 드는 비용의 합이다.</p>

<p>단, 어떤 노드를 색칠하기 위해서는 그 노드의 부모 노드가 이미 색칠되어 있어야 한다. 따라서 루트가 가장 먼저 색칠되어야 한다. 이러한 규칙에 따를 때, 최소의 비용으로 트리를 색칠하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 트리 내 노드의 수 N과, 루트의 번호 R이 공백을 사이에 두고 주어진다. (1 ≤ N ≤ 1,000. 1 ≤ R ≤ N) 둘째 줄에는 C[i]가 차례로 주어진다. 이후 N-1개의 줄에는 트리 내의 간선이 두 개의 자연수로 주어진다. 두 수가 U, V라면 U번 노드와 V번 노드 사이에 간선이 있으며, U가 V의 부모라는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에, 트리를 색칠하기 위한 최소 비용을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>1, 3, 5, 2, 4의 순서대로 색칠을 하면 차례로 1×1, 2×1, 3×4, 4×2, 5×2의 비용이 들어서 총 33의 비용이 들게 된다.</p>

				</div>
				</div>','5 1
1 2 1 2 4
1 2
1 3
2 4
3 5
','33
','DATA_STRUCTURE'),
                                                                                                                (6337,'BAEKJOON','https://www.acmicpc.net/problem/1765',1765,'닭싸움 팀 정하기','2초','256 MB',14,'<p>닭싸움은 월드의 전통이다. 이번 캠프에서도 어김없이 닭싸움 대회가 열렸다. 그런데, 닭싸움을 하기 위해서는 반드시 누가 우리 편이고, 누가 우리 편이 아닌지를 알아야 할 것이다. 닭싸움의 팀을 정하는 원칙은, 평소 학생들의 인간관계에 따라 다음과 같이 정리할 수 있다.</p>

<ol>
	<li>내 친구의 친구는 내 친구이다.</li>
	<li>내 원수의 원수도&nbsp;내 친구이다.</li>
</ol>

<p>이 때 두 학생이 친구이면 같은 팀에 속해있어야 하며, 같은 팀에 속해 있는 사람들끼리는 전부 친구여야 한다.</p>

<p>학생들의 인간관계가 주어지면, 닭싸움을 위한 팀 정하기를 할 때, 최대 얼마나 많은 팀이 만들어질 수 있는지 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 학생의 수 n이 주어진다. 각 학생들은 1부터 n까지 번호가 매겨져 있다. (2 ≤ n ≤ 1000)&nbsp;</p>

<p>둘째 줄에 학생 간의 인간관계 중 알려진 것의 개수 m이 주어진다. (1 ≤ m ≤ 5000)</p>

<p>다음 m개의 줄에는 한 줄에 한 개씩, 학생 간의 인간관계가 F p q 혹은 E p q의 형태로 공백으로 구분되어 주어진다. (1 ≤ p < q ≤ n)</p>

<p>첫 번째 글자가 F인 경우에는 p와 q가 친구인 것이고, E인 경우는 p와 q가 원수인 경우이다.&nbsp;</p>

<p>입력은 모순이 없음이 보장된다. 즉, 두 학생이 동시에 친구이면서 원수인 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에, 가능한 최대 팀 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>1번 학생 혼자 팀, 2, 4, 6번 학생 셋이서 팀, 3, 5번 학생 둘이서 팀일 때, 팀의 개수가 최대이다.</p>

				</div>
				</div>','6
4
E 1 4
F 3 5
F 4 6
E 1 2
','3
','DATA_STRUCTURE'),
                                                                                                                (6333,'BAEKJOON','https://www.acmicpc.net/problem/1766',1766,'문제집','2초','128 MB',14,'<p>민오는 1번부터 N번까지 총 N개의 문제로 되어 있는 문제집을 풀려고 한다. 문제는 난이도 순서로 출제되어 있다. 즉 1번 문제가 가장 쉬운 문제이고 N번 문제가 가장 어려운 문제가 된다.</p>

<p>어떤 문제부터 풀까 고민하면서 문제를 훑어보던 민오는, 몇몇 문제들 사이에는 먼저 푸는 것이 좋은 문제가 있다는 것을 알게 되었다. 예를 들어 1번 문제를 풀고 나면 4번 문제가 쉽게 풀린다거나 하는 식이다. 민오는 다음의 세 가지 조건에 따라 문제를 풀 순서를 정하기로 하였다.</p>

<ol>
	<li>N개의 문제는 모두 풀어야 한다.</li>
	<li>먼저 푸는 것이 좋은 문제가 있는 문제는, 먼저 푸는 것이 좋은 문제를 반드시 먼저 풀어야 한다.</li>
	<li>가능하면 쉬운 문제부터 풀어야 한다.</li>
</ol>

<p>예를 들어서 네 개의 문제가 있다고 하자. 4번 문제는 2번 문제보다 먼저 푸는 것이 좋고, 3번 문제는 1번 문제보다 먼저 푸는 것이 좋다고 하자. 만일 4-3-2-1의 순서로 문제를 풀게 되면 조건 1과 조건 2를 만족한다. 하지만 조건 3을 만족하지 않는다. 4보다 3을 충분히 먼저 풀 수 있기 때문이다. 따라서 조건 3을 만족하는 문제를 풀 순서는 3-1-4-2가 된다.</p>

<p>문제의 개수와 먼저 푸는 것이 좋은 문제에 대한 정보가 주어졌을 때, 주어진 조건을 만족하면서 민오가 풀 문제의 순서를 결정해 주는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 문제의 수 N(1 ≤ N ≤ 32,000)과 먼저 푸는 것이 좋은 문제에 대한 정보의 개수 M(1&nbsp;≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에 걸쳐 두 정수의 순서쌍 A,B가 빈칸을 사이에 두고 주어진다. 이는 A번 문제는 B번 문제보다 먼저 푸는 것이 좋다는 의미이다.</p>

<p>항상 문제를 모두 풀 수 있는 경우만 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 문제 번호를 나타내는 1 이상 N 이하의 정수들을 민오가 풀어야 하는 순서대로 빈칸을 사이에 두고 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2
4 2
3 1
','3 1 4 2
','DATA_STRUCTURE'),
                                                                                                                (6336,'BAEKJOON','https://www.acmicpc.net/problem/1771',1771,'카드 묶음','2초','128 MB',14,'<p>1 이상 N 이하의 자연수가 한 장에 하나씩 순서대로 적혀 있는 N장의 카드가 있다. 이 카드를 임의의 순서로 섞은 뒤 일렬로 배열하였다. 아래는 N = 6인 경우의 한 예이다.</p>

<pre style="text-align: center;">[6] [3] [2] [1] [4] [5]</pre>

<p>각각 N장의 카드는 하나의 묶음을 이루고 있다고 생각할 수 있다. 즉 초기에 N개의 카드 묶음이 순서대로 배열되어 있는 것이다.</p>

<p>만일 하나의 카드 묶음 속에 포함되어 있는 카드들이 서로 연속된 수들로만 이루어져 있으면, 그러한 묶음을 유효한 카드 묶음이라고 한다. [2], [4 5], [3 5 6 4] 등은 유효한 카드 묶음의 예이다.</p>

<p>인접한 두 개의 카드 묶음을 하나로 합쳤을 때 새로 생긴 카드 묶음도 유효한 카드 묶음이면, 두 카드 묶음을 하나로 합칠 수 있다. 이러한 과정을 N-1번 반복하면 N개의 카드를 하나의 카드 묶음으로 만들 수 있다. 아래는 이러한 과정의 한 예를 순서대로 보인 것이다.</p>

<pre style="text-align: center;">[6] [3] [2] [1] [4] [5]
[6] [3] [2 1] [4] [5]
[6] [3 2 1] [4] [5]
[6] [3 2 1] [4 5]
[6] [3 2 1 4 5]
[6 3 2 1 4 5]</pre>

<p>N장의 카드의 초기 배열이 주어졌을 때, 이러한 과정을 N-1번 반복하여 N개의 카드를 하나의 카드 묶음으로 만드는 과정을 구하는 프로그램을 작성하시오. 항상 가능한 경우만이 입력으로 주어지며, 여러 가지 해 중에서 하나만 출력하면 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 자연수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 카드의 초기 배열을 나타내는 N개의 정수가 빈 칸을 사이에 두고 순서대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 N-1개 줄에 걸쳐 합치는 과정을 표현해 줄 한 개의 정수를 출력한다. 합쳐질 두 개의 묶음 중, 앞 묶음의 마지막 카드가 몇 번째 카드인지를 출력하면 된다. 예를 들어, [6] [3 2 1] [4 5]의 경우, 앞 묶음인 [3 2 1]의 마지막 카드인 1은 네 번째이므로, 4를 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
6 3 2 1 4 5
','3
2
5
4
1
','DATA_STRUCTURE'),
                                                                                                                (6346,'BAEKJOON','https://www.acmicpc.net/problem/1777',1777,'순열복원','0.55초','128 MB',16,'<p>1부터 N번까지로 수로 이루어진 순열이 있다.</p>

<p>그리고 이 순열과 연관된 "Inversion sequence"라고 부르는 수열이 있다. 이 수열의 i번째 원소에는 순열에서 i보다 뒤에 나오면서 i보다 작은 수의 개수가 들어간다.</p>

<p>2&nbsp; 4&nbsp; 5&nbsp; 1&nbsp; 7&nbsp; 6&nbsp; 3&nbsp; 8</p>

<p>위의 순열이 있다면 이것의 Inversion sequence는</p>

<p>0&nbsp; 1&nbsp; 0&nbsp; 2&nbsp; 2&nbsp; 1&nbsp; 2&nbsp; 0 이 된다.</p>

<p>문제는 역으로 어떤 Inversion sequence가 주어지면 이것에 해당하는 순열을 찾는 프로그램을 작성하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>순열의 크기 N(1 ≤ N ≤ 100,000)이 주어진다. 두 번째 줄에는 순열 1, 2, …, N에 해당하는 Inversion sequence가 공백으로 구분되어 들어온다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력으로 주어진 Inversion sequence에 대응하는 순열을 공백으로 구분하여 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
0 1 0 2 2 1 2 0
','2 4 5 1 7 6 3 8
','DATA_STRUCTURE'),
                                                                                                                (6340,'BAEKJOON','https://www.acmicpc.net/problem/1781',1781,'컵라면','2초','256 MB',14,'<p>상욱 조교는 동호에게 N개의 문제를 주고서, 각각의 문제를 풀었을 때 컵라면을 몇 개 줄 것인지 제시 하였다. 하지만 동호의 찌를듯한 자신감에 소심한 상욱 조교는 각각의 문제에 대해 데드라인을 정하였다.</p>

<table class="table table-bordered" style="width:38%">
	<tbody>
		<tr>
			<th style="width:10%">문제 번호</th>
			<td style="width:4%">1</td>
			<td style="width:4%">2</td>
			<td style="width:4%">3</td>
			<td style="width:4%">4</td>
			<td style="width:4%">5</td>
			<td style="width:4%">6</td>
			<td style="width:4%">7</td>
		</tr>
		<tr>
			<th>데드라인</th>
			<td>1</td>
			<td>1</td>
			<td>3</td>
			<td>3</td>
			<td>2</td>
			<td>2</td>
			<td>6</td>
		</tr>
		<tr>
			<th>컵라면 수</th>
			<td>6</td>
			<td>7</td>
			<td>2</td>
			<td>1</td>
			<td>4</td>
			<td>5</td>
			<td>1</td>
		</tr>
	</tbody>
</table>

<p>위와 같은 상황에서 동호가 2, 6, 3, 1, 7, 5, 4 순으로 숙제를 한다면 2, 6, 3, 7번 문제를 시간 내에 풀어 총 15개의 컵라면을 받을 수 있다.</p>

<p>문제는 동호가 받을 수 있는 최대 컵라면 수를 구하는 것이다. 위의 예에서는 15가 최대이다.</p>

<p>문제를 푸는데는 단위 시간 1이 걸리며, 각 문제의 데드라인은 N이하의 자연수이다. 또, 각 문제를 풀 때 받을 수 있는 컵라면 수와 최대로 받을 수 있는 컵라면 수는 모두 2<sup>31</sup>보다 작은 자연수이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 숙제의 개수 N (1 ≤ N ≤ 200,000)이 들어온다. 다음 줄부터 N+1번째 줄까지 i+1번째 줄에 i번째 문제에 대한 데드라인과 풀면 받을 수 있는 컵라면 수가 공백으로 구분되어 입력된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 동호가 받을 수 있는 최대 컵라면 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1 6
1 7
3 2
3 1
2 4
2 5
6 1
','15
','DATA_STRUCTURE'),
                                                                                                                (6357,'BAEKJOON','https://www.acmicpc.net/problem/1797',1797,'균형잡힌 줄서기','2초','256 MB',14,'<p>소시갤 회장 항승이는 클럽에 회원들을 모아놓고 함께 소녀시대 춤을 추고 난 뒤 팬들에게 소녀시대 춤에서 마지막 부분에 나오는 멤버들이 한 줄로 모이는 부분을 안무 해주고 있었다.</p>

<p>안무를 하던 중 항승이는 한 줄로 선 상태에서 이들 중 연속된 사람들을 그룹 지었을 때, 이 그룹에 속한 남녀의 수가 같은 그룹이 가장 보기 좋다는 것을 알았다.</p>

<p>그래서 항승이는 팬들이 한 줄로 섰을 때 위의 조건을 만족하는 그룹 중 가장 길이가 긴 그룹을 찾고자 한다. 가장 길이가 길다는 의미는 그룹에서 x좌표가 가장 작은 사람과 큰 사람의 차이가 가장 크다는 것이다. 우리는 이런 항승이를 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 한 줄로 선 팬들의 수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 그 다음 N개의 줄에는 남녀의 성별을 나타내는 수(남자는 0, 여자는 1)와 이들이 서있는 x좌표가 공백으로 구분되어 주어진다. x좌표는 0 이상 1,000,000,000 이하이다.&nbsp;각 성별의 팬은 최소 1명 이상 존재하고, 같은 x좌표에 서 있는 팬은 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>조건을 만족하는 그룹 중 가장 긴 그룹의 길이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
0 11
1 10
1 25
1 12
1 4
0 13
1 22','11
','DATA_STRUCTURE'),
                                                                                                                (6351,'BAEKJOON','https://www.acmicpc.net/problem/1822',1822,'차집합','2초','256 MB',7,'<p>몇 개의 자연수로 이루어진 두 집합 A와 B가 있다. 집합 A에는 속하면서 집합 B에는 속하지 않는 모든 원소를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 집합 A의 원소의 개수 n(A)와 집합 B의 원소의 개수 n(B)가 빈 칸을 사이에 두고 주어진다. (1 ≤ n(A), n(B) ≤ 500,000)이 주어진다. 둘째 줄에는 집합 A의 원소가, 셋째 줄에는 집합 B의 원소가 빈 칸을 사이에 두고 주어진다. 하나의 집합의 원소는 2,147,483,647 이하의 자연수이며, 하나의 집합에 속하는 모든 원소의 값은 다르다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 집합 A에는 속하면서 집합 B에는 속하지 않는 원소의 개수를 출력한다. 다음 줄에는 구체적인 원소를 빈 칸을 사이에 두고 증가하는 순서로 출력한다. 집합 A에는 속하면서 집합 B에는 속하지 않는 원소가 없다면 첫째 줄에 0만을 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
2 5 11 7
9 7 4
','3
2 5 11
','DATA_STRUCTURE'),
                                                                                                                (6353,'BAEKJOON','https://www.acmicpc.net/problem/1826',1826,'연료 채우기','2초','128 MB',14,'<p>성경이는 트럭을 정글 속에서 운전하다가 트럭의 연료탱크에 갑자기 구멍이 나서 1km를 가는데 1L의 연료가 새 나가게 되었다. 이것을 고치기 위해서는 가장 가까운 마을에 가야 한다. 그런데 그냥 가다가는 중간에 연료가 다 빠질 수가 있다. 다행스럽게도 정글 곳곳에 연료를 채울 수 있는 주유소가 N개 있다. 그런데 정글 속에서 중간에 차를 멈추는 행위는 매우 위험한 행위이므로 주유소에서 멈추는 횟수를 최소화 하려 한다.</p>

<p>그리고 다행이도 성경이의 트럭은 매우 좋아서 연료 탱크에는 연료의 제한이 없이 많이 충분히 많이 넣을 수 있다고 한다. 각각의 주유소의 위치와, 각 주유소에서 얻을 수 있는 연료의 양이 주어져 있을 때, 주유소에서 멈추는 횟수를 구하는 프로그램을 작성하시오.</p>

<p>정글은 일직선이고, 성경이의 트럭과 주유소도 모두 일직선 위에 있다. 주유소는 모두 성경이의 트럭을 기준으로 오른쪽에 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 주유소의 개수 N(1 ≤ N ≤ 10,000)가 주어지고 두 번째 줄부터 N+1번째 줄 까지 주유소의 정보가 주어진다. 주유소의 정보는 두개의 정수 a,b로 이루어 져 있는데 a(1 ≤ a ≤ 1,000,000)는 성경이의 시작 위치에서 주유소 까지의 거리, 그리고 b(1 ≤ b ≤ 100)는 그 주유소에서 채울 수 있는 연료의 양을 의미한다. 그리고 N+2번째 줄에는 두 정수 L과 P가 주어지는데 L(1 ≤ L ≤ 1,000,000)은 성경이의 위치에서 마을까지의 거리, P(1 ≤ P ≤ 1,000,000)는 트럭에 원래 있던 연료의 양을 의미한다.</p>

<p>모든 주유소와 마을은 서로 다른 좌표에 있고, 마을은 모든 주유소보다 오른쪽에 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 주유소에서 멈추는 횟수를 출력한다. 만약 마을에 도착하지 못할경우 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
4 4
5 2
11 5
15 10
25 10','3','DATA_STRUCTURE'),
                                                                                                                (6366,'BAEKJOON','https://www.acmicpc.net/problem/1831',1831,'과수원','2초','64 MB',16,'<p>직사각형 모양의 과수원들이 옹기종기 모여 있는 넓은 벌판이 있다. 서로 다른 과수원들은 겹쳐 있지는 않지만, 변을 공유할 있을 수는 있다. 각각의 과수원에는 한 종류의 과일만이 심어져 있다. 물론 서로 다른 과수원에 같은 종류의 과일이 심어져 있을 수도 있다. 아래는 비행기를 타고 상공에서 바라본 두 개의 벌판을 그림으로 도식화한 것이다. 같은 색으로 그려진 직사각형은 같은 종류의 과일이 심어져 있는 과수원이 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/6c075da1-995e-4ee4-97d8-f72891ff1120/-/preview/" style="width: 364.167px; height: 90px;"></p>

<p>같은 색으로 칠해진 직사각형 중에서 가장 큰 것의 넓이를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 과수원의 개수 N(1 ≤ N ≤ 2,500)이 주어진다. 이어서 다음 N개 줄에는 다섯 개의 정수 X1, Y1, X2, Y2, C가 빈 칸을 사이에 두고 주어진다. (X1 < X2, Y1 < Y2) 이는 과수원이 (X1, Y1), (X2, Y2)를 두 꼭짓점으로 하는 직사각형이라는 뜻이다. 의미한다. 좌표는 0 이상 1,000,000,000 이하의 정수이다. C는 이 과수원에 심어져 있는 과일의 종류를 나타내는 번호이다. (1 ≤ C ≤ 100)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>같은 색으로 칠해진 직사각형 중에서 가장 큰 것의 넓이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 1 3 3 1
3 1 5 3 1
1 4 3 6 1
3 4 5 6 1
0 3 6 4 2','8
','DATA_STRUCTURE'),
                                                                                                                (6359,'BAEKJOON','https://www.acmicpc.net/problem/1835',1835,'카드','2초','128 MB',7,'<p>1부터 N까지의 숫자가 적힌 카드가 있다. 찬유는 이 카드를 가지고 마술을 하려 한다. 마술을 하는 순서는 다음과 같다.</p>

<ol>
	<li>먼저 1부터 N까지의 숫자가 적힌 카드에서 첫 번째 카드를 가장 뒤로 옮긴다. 그러고 나서 첫 번째 카드를 책상 위에 올려놓는다. 그런데 그 카드는 1이 되어야 한다.</li>
	<li>그리고 남은 카드 중에서 첫 번째 카드를 가장 뒤로 옮기고, 또 가장 앞에 있는 카드를 가장 뒤로 옮긴다.(2번 반복) 그리고 가장 앞에 있는 카드를 책상 위에 올려놓는다. 그런데 그 카드는 2가 되어야 한다.</li>
	<li>또 남은 카드 중에서 첫 번째 카드를 가장 뒤로 옮기고... (3번 반복) 그리고 가장 앞에 있는 카드를 책상위에 올려놓는데 그것은 3이 된다.</li>
	<li>또 남은 카드 중에서 첫 번째 카드를 가장 뒤로 옮기고.. (4번 반복) 그리고 가장 앞에 있는 카드를 책상 위에 올려놓는데 그것은 4이다.</li>
	<li>위 과정을 계속 반복하여 N번 카드만 남을 때 까지 반복한다.</li>
</ol>

<p>위와 같은 카드를 하려면 미리 카드의 순서를 알고 있어야 한다. 카드의 개수 N이 주어져 있을 때 위의 마술을 하기 위한 카드의 초기 순서를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 카드의 개수 N(1 ≤ N ≤ 1,000)이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄부터 N번째 줄까지 차례로 카드의 순서를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<ol>
	<li>2 1 4 3에서 2를 가장 뒤로 옮긴다. (1 4 3 2)</li>
	<li>1을 책상 위에 옮겨놓는다. (4 3 2)</li>
	<li>4 3 2 에서 4, 3을 뒤로 옮긴다. (2 4 3)</li>
	<li>2를 책상 위로 옮겨놓는다. (4 3)</li>
	<li>4 3 에서 가장 앞에 있는 것을 뒤로 3번 옮긴&nbsp;&nbsp;&nbsp; 다. (3 4)</li>
	<li>3을 책상 위로 옮겨놓는다. (4)</li>
	<li>4를 책상 위로 옮겨놓는다. (완료)</li>
</ol>

				</div>
				</div>','4
','2 1 4 3
','DATA_STRUCTURE'),
                                                                                                                (6361,'BAEKJOON','https://www.acmicpc.net/problem/1849',1849,'순열','0.5초(추가시간없음)','512 MB',16,'<p>1부터 N까지의 수들이 한 번씩 쓰인 수열이 있다. 그 수열에서 i 앞에 있는 수 들 중, i보다 큰 수들의 개수를 A[i]라고 정의하자. A[i]가 주어져 있을 때, 원래 수열을 구하는 프로그램을 작성하여라.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열 원소의 개수 (1 ≤ N ≤100,000)이 주어진다. 그리고 두 번째 줄부터 N+1 번째 줄까지 차례로 A[i]가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>N개의 줄에 걸쳐서 수열을 출력한다. (i번째 줄에는 i번째 원소를 의미한다)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
5
0
1
2
1
2
0
0
','2
7
3
5
4
1
8
6
','DATA_STRUCTURE'),
                                                                                                                (6367,'BAEKJOON','https://www.acmicpc.net/problem/1859',1859,'성적','2초','128 MB',23,'<p>동호는 월드 고등학교의 학생이다. 동호는 학교에서 N개의 시험을 봤다. 시험 점수는 T<sub>i</sub>와 P<sub>i</sub>로 주어진다. T<sub>i</sub>는 i번째 시험에서 동호가 받은 점수를 의미하고, P<sub>i</sub>는 i번째 시험의 토탈 점수를 의미한다.</p>

<p>이제 이 N개의 점수를 가지고 성적을 매겨야 하는데 성적은 T<sub>i</sub>의 합을 P<sub>i</sub>의 합으로 나눈 값을 의미한다. 만약에 동호가 1/2, 5/9, 3/8, 4/10, 1/3 의 점수를 얻었다면 (T<sub>i</sub>/P<sub>i</sub>의 형식) 동호가 받을 성적은 1+5+3+4+1/2+9+8+10+3 = 14/32 ≒ 0.44가 될 것이다.</p>

<p>그런데 동호의 담임 선생님은 그냥 이렇게 점수를 주면 동호의 성적이 너무 형편없기 때문에 동호가 본 N개의 시험 중, T<sub>i</sub>를 P<sub>i</sub>로 나눈 값, 즉 백분율이 작은 D개의 시험을 빼서 N-D개의 시험에 대해서만 성적을 합산하려 한다. 예를 들어 위에서 D가 1일 경우에는 1/3이 가장 작기 때문에 동호의 성적은 1/3을 뺀 1/2, 5/9, 3/8, 4/10을 더한 1+5+3+4/ 2+9+8+10 = 13/29 ≒ 0.45가 된다.</p>

<p>그런데 동호는 이러한 선생님의 선택에 반발을 하였다. 어차피 D개의 성적을 뺄 거면 다른 것을 빼지 왜 백분율이 작은 것을 빼냐는 것이다. 만약에 D가 1일 경우 1/3을 빼지 않고 3/8을 빼면 점수가 11/24 ≒ 0.46이 되어 위의 경우보다 점수가 더 높게 된다는 것이다.</p>

<p>동호의 담임선생님은 점수를 올려준다는데도 이에 반발한 동호에게 매우 화가 났다. 그래서 동호의 담임선생님은 즉석에서 다음과 같은 문제를 동호에게 내 주었다. 동호의 시험 점수가 주어져 있을 때, 동호의 이론이 성립하는 D를 모두 구하라는 것이다. 즉, 백분율이 작은 D개를 빼는 것 보다 다른 D개를 빼서 점수를 더 높이는 것이 가능한 D를 모두 구하라는 것이다. 동호는 매우 당황하였다. 점수를 올리려다가 큰 난관에 부딪힌 것이다. 여러분은 동호를 도와서 위의 조건은 만족하는 D를 모두 구하는 프로그램을 작성하여야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 동호가 시험을 본 개수 N(1 ≤ N ≤ 50,000). 그리고 두 번째 줄부터 N+1번째 줄까지 N개의 줄에 걸쳐 T<sub>i</sub>와 P<sub>i</sub>가 (0 ≤ T<sub>i</sub> ≤ P<sub>i</sub> ≤ 40,000&nbsp; 0 < P<sub>i</sub>) 공백을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 가능한 D의 개수 K(0 ≤ K ≤ N) 를 출력한다. 그리고 두 번째 줄부터 K+1번째 줄까지 가능한 D를 오름차순으로 모두 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
5 9
3 8
4 10
1 3
','2
1
2
','DATA_STRUCTURE'),
                                                                                                                (6368,'BAEKJOON','https://www.acmicpc.net/problem/1863',1863,'스카이라인 쉬운거','2초','128 MB',12,'<p>도시에서 태양이 질 때에 보이는 건물들의 윤곽을 스카이라인이라고 한다. 스카이라인만을 보고서 도시에 세워진 건물이 몇 채인지 알아 낼 수 있을까? 건물은 모두 직사각형 모양으로 밋밋하게 생겼다고 가정한다.</p>

<p>정확히 건물이 몇 개 있는지 알아내는 것은 대부분의 경우에 불가능하고, 건물이 최소한 몇 채 인지 알아내는 것은 가능해 보인다. 이를 알아내는 프로그램을 작성해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 50,000) 다음 n개의 줄에는 왼쪽부터 스카이라인을 보아 갈 때 스카이라인의 고도가 바뀌는 지점의 좌표 x와 y가 주어진다. (1 ≤ x ≤ 1,000,000. 0 ≤ y ≤ 500,000) 첫 번째 지점의 x좌표는 항상 1이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 최소 건물 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>입력은 다음과 같은 스카이라인을 나타낸다.</p>

<pre>..........................
.....XX.........XXX.......
.XXX.XX.......XXXXXXX.....
XXXXXXXXXX....XXXXXXXXXXXX</pre>

<p>다음과 같이 여섯 개의 빌딩이 있을 때가 최소 개수의 빌딩이 있는 상황이다.</p>

<pre>..........................
.....22.........333.......
.111.22.......XX333XX.....
X111X22XXX....XX333XXXXXXX</pre>

<pre>..........................
.....XX.........XXX.......
.XXX.XX.......5555555.....
4444444444....5555555XXXXX</pre>

<pre>..........................
.....XX.........XXX.......
.XXX.XX.......XXXXXXX.....
XXXXXXXXXX....666666666666</pre>

				</div>
				</div>','10
1 1
2 2
5 1
6 3
8 1
11 0
15 2
17 3
20 2
22 1','6','DATA_STRUCTURE'),
                                                                                                                (6369,'BAEKJOON','https://www.acmicpc.net/problem/1874',1874,'스택 수열','2초','128 MB',9,'<p>스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다.</p>

<p>1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 n (1 ≤ n ≤ 100,000)이 주어진다. 둘째 줄부터 n개의 줄에는 수열을 이루는 1이상 n이하의 정수가 하나씩 순서대로 주어진다. 물론 같은 정수가 두 번 나오는 일은 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력된 수열을 만들기 위해 필요한 연산을 한 줄에 한 개씩 출력한다. push연산은 +로, pop 연산은 -로 표현하도록 한다. 불가능한 경우 NO를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>1부터 n까지에 수에 대해 차례로 [push, push, push, push, pop, pop, push, push, pop, push, push, pop, pop, pop, pop, pop] 연산을 수행하면 수열 [4, 3, 6, 8, 7, 5, 2, 1]을 얻을 수 있다.</p>

				</div>
				</div>','8
4
3
6
8
7
5
2
1
','+
+
+
+
-
-
+
+
-
+
+
-
-
-
-
-
','DATA_STRUCTURE'),
                                                                                                                (6371,'BAEKJOON','https://www.acmicpc.net/problem/1889',1889,'선물 교환','2초','128 MB',12,'<p>캠프의 마지막 날에 선물 교환 이벤트를 하려고 한다. 모든 학생들이 각자 두 개씩 선물을 준비해 와서 두 명의 친구에게 주는 것이다. 이벤트를 준비하던 중, 조교들은 이러한 이벤트가 불화를 일으킬 수 있음을 알게 되었다. 참석한 학생들 중 일부 학생들은 선물을 못 받거나 하나만 받게 되는 데 비해, 인기가 많은 학생들은 선물을 세 개 또는 그 이상 받게 되는 것이다.</p>

<p>그래서 조교들은 모든 학생들이 두 개의 선물을 주고, 또한 모든 학생들이 정확히 두 개의 선물만을 받도록 이벤트를 준비하고자 한다. 이를 위해 각각의 학생이 선물을 주고자 하는 두 명의 학생이 누구인지를 미리 알아내었다. 리스트를 살펴보던 조교들은, 몇 명의 학생을 추려 내면 모든 학생이 정확히 두 개의 선물을 받을 수 있다는 것을 알게 되었다.</p>

<p>참여한 모든 학생이 정확히 선물을 두 개씩 받도록 이벤트에 참여할 학생들을 결정하는 프로그램을 작성하시오. 단, 이벤트에 참여하는 학생의 수가 최대가 되도록 해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 학생의 수 N(3 ≤ N ≤ 200,000)이 주어진다. 학생은 1부터 N까지 번호가 매겨진다. 이어서 다음 N개 줄에는 각 학생이 선물을 주고자 하는 두 학생의 번호가 빈 칸을 사이에 두고 주어진다. 자기 자신에게 선물을 주는 경우는 없으며, 두 사람의 번호는 항상 다르다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최대로 참여시킬 수 있는 학생의 수를 출력한다. 둘째 줄에는 참여할 학생들의 번호를 증가하는 순서대로 빈 칸을 사이에 두고 출력한다. 가능한 방법이 둘 이상인 경우 그 중 한 가지만 출력한다. 만일 한 명의 학생도 참여시킬 수 없는 경우 첫째 줄에 0만을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
2 3
3 5
1 5
3 5
1 2
','4
1 2 3 5
','DATA_STRUCTURE'),
                                                                                                                (6373,'BAEKJOON','https://www.acmicpc.net/problem/1905',1905,'상자 쌓기','3초','128 MB',12,'<p>넓은 창고에 상자들을 쌓으려고 한다. 상자는 하나씩 창고에 입고되며, 입고되는 순서대로 쌓아 나가야 한다. 또, 각 상자마다 그 상자를 쌓아야 하는 위치가 정확히 지정되어 있으며, 쌓을 때 회전시킬 수도 없다. 상자들은 직육면체 모양으로, 가로, 세로, 높이의 길이가 다양하다. 상자를 쌓아 둘 창고 역시 직육면체 모양이지만, 그 높이는 충분히 높다고 가정하자.</p>

<p>편의상 창고 바닥의 남서쪽 코너를 원점으로 하여 좌표계를 구성하도록 한다. 창고의 각 모서리는 x, y, z 각 좌표축에 평행하거나 수직하다. x축은 동쪽 방향, y축은 북쪽 방향, z축은 하늘 방향으로 잡는다. 물론 상자들도 각 모서리가 x, y, z축에 평행하거나 수직하게 되도록 쌓을 것이다.</p>

<p>여러분이 할 일은, 주어진 순서대로 각 상자들을 쌓았을 때, 가장 높은 위치의 고도를 알아내는 것이다. 이를 위한 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 세 정수 Lx, Ly, N이&nbsp;주어진다. (1 ≤ Lx, Ly ≤ 1,000,&nbsp;1 ≤ N ≤ 20,000) Lx와 Ly는 창고의 가로, 세로 길이이며, N은 입고되는 상자의 개수이다. 이후 N개의 줄에 각 상자의 정보가 입고되는 순서로 주어진다. 이는 다섯 개의 정수 lx, ly, lz, px,&nbsp;py 로 이루어진다. (1 ≤ lx, 0 ≤ px, px+lx ≤ Lx, 1 ≤ ly, 0 ≤ py, py+ly ≤ Ly, 1 ≤ lz ≤ 100,000) lx, ly, lz는 각각 상자의 가로, 세로, 높이 길이를 나타낸다. px, py는 상자를 쌓아야 하는 위치를 나타낸다. 상자 바닥의 네 꼭짓점 중 가장 남서쪽에 있는 것의 x, y좌표를 px, py에 맞추어 쌓으면 된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 상자를 모두 쌓았을 때, 가장 높은 곳의 고도를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>네 개의 상자를 순서대로 모두 쌓고 난 뒤, 각 상자의 꼭짓점 좌표는 다음과 같다.</p>

<ul>
	<li>첫 번째 상자 : (0,0,0), (4,0,0), (4,3,0), (0,3,0), (0,0,2), (4,0,2), (4,3,2), (0,3,2)</li>
	<li>두 번째 상자 : (3,0,2), (6,0,2), (6,3,2), (3,3,2), (3,0,3), (6,0,3), (6,3,3), (3,3,3)</li>
	<li>세 번째 상자 :(0,3,0), (7,3,0), (7,4,0), (0,4,0), (0,3,2), (7,3,2), (7,4,2), (0,4,2)</li>
	<li>네 번째 상자 : (2,2,3), (4,2,3), (4,5,3), (2,5,3), (2,2,6), (4,2,6), (4,5,6), (2,5,6)</li>
</ul>

				</div>
				</div>','7 5 4
4 3 2 0 0
3 3 1 3 0
7 1 2 0 3
2 3 3 2 2
','6
','DATA_STRUCTURE'),
                                                                                                                (6374,'BAEKJOON','https://www.acmicpc.net/problem/1918',1918,'후위 표기식','2초','128 MB',14,'<p>수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 <code>a+b</code>는 전위 표기법으로는 <code>+ab</code>이고, 후위 표기법으로는 <code>ab+</code>가 된다.</p>

<p>이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 <code>a+b*c</code>를 후위 표기식으로 바꾸면 <code>abc*+</code>가 된다.</p>

<p>중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.</p>

<p>예를 들어 <code>a+b*c</code>는 <code>(a+(b*c))</code>의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 <code>*</code>를 괄호 밖으로 꺼내게 되면 <code>(a+bc*)</code>가 된다. 마지막으로 또 <code>+</code>를 괄호의 오른쪽으로 고치면 <code>abc*+</code>가 되게 된다.</p>

<p>다른 예를 들어 그림으로 표현하면 <code>A+B*C-D/E</code>를 완전하게 괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/5aad2feb-d9fc-430a-954d-73a06ba0215f/-/preview/" style="width: 166px; height: 50px;"></p>

<p style="text-align: center;">결과: <code>ABC*+DE/-</code></p>

<p>이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 알파벳 대문자로 이루어지며 수식에서 한 번씩만 등장한다. 그리고 <code>-A+B</code>와 같이 <code>-</code>가 가장 앞에 오거나 <code>AB</code>와 같이 <code>*</code>가 생략되는 등의 수식은 주어지지 않는다. 표기식은 알파벳 대문자와 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>(</code>, <code>)</code>로만 이루어져 있으며, 길이는 100을 넘지 않는다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','A*(B+C)
','ABC+*
','DATA_STRUCTURE'),
                                                                                                                (6372,'BAEKJOON','https://www.acmicpc.net/problem/1920',1920,'수 찾기','1초','128 MB',7,'<p>N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -2<sup>31</sup> 보다 크거나 같고 2<sup>31</sup>보다 작다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4 1 5 2 3
5
1 3 7 9 5
','1
1
0
0
1
','DATA_STRUCTURE'),
                                                                                                                (6343,'BAEKJOON','https://www.acmicpc.net/problem/1927',1927,'최소 힙','1초(추가시간없음)(하단참고)','128 MB',9,'<p>널리 잘 알려진 자료구조 중 최소 힙이 있다. 최소 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.</p>

<ol>
	<li>배열에 자연수 x를 넣는다.</li>
	<li>배열에서 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다.</li>
</ol>

<p>프로그램은 처음에 비어있는 배열에서 시작하게 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. x는 2<sup>31</sup>보다 작은 자연수 또는 0이고, 음의 정수는 입력으로 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9
0
12345678
1
2
0
0
0
0
32
','0
1
2
12345678
0
','DATA_STRUCTURE'),
                                                                                                                (6397,'BAEKJOON','https://www.acmicpc.net/problem/1933',1933,'스카이라인','2초','128 MB',15,'<p>N개의 직사각형 모양의 건물들이 주어졌을 때, 스카이라인을 구해내는 프로그램을 작성하시오. 스카이라인은 건물 전체의 윤곽을 의미한다. 즉, 각각의 건물을 직사각형으로 표현했을 때, 그러한 직사각형들의 합집합을 구하는 문제이다.</p>

<p><img alt="" height="247" src="/JudgeOnline/upload/201007/sk.png" width="359"></p>

<p>예를 들어 직사각형 모양의 건물들이 위와 같이 주어졌다고 하자. 각각의 건물은 왼쪽 x좌표와 오른쪽 x좌표, 그리고 높이로 나타난다. 모든 건물들은 편의상 같은 높이의 지면(땅) 위에 있다고 가정하자. 위의 예에서 스카이라인을 구하면 아래와 같다.</p>

<p><img alt="" height="247" src="/JudgeOnline/upload/201007/sksk.png" width="375"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 건물의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 N개의 건물에 대한 정보가 주어진다. 건물에 대한 정보는 세 정수 L, H, R로 나타나는데, 각각 건물의 왼쪽 x좌표, 높이, 오른쪽 x좌표를 의미한다. (1 ≤ L < R ≤ 1,000,000,000, 1 ≤ H ≤ 1,000,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 스카이라인을 출력한다. 출력을 할 때에는 높이가 변하는 지점에 대해서, 그 지점의 x좌표와 그 지점에서의 높이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28
','1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0
','DATA_STRUCTURE'),
                                                                                                                (6386,'BAEKJOON','https://www.acmicpc.net/problem/1935',1935,'후위 표기식2','2초','128 MB',8,'<p>후위 표기식과 각 피연산자에 대응하는 값들이 주어져 있을 때, 그 식을 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 피연산자의 개수(1 ≤ N ≤ 26) 가 주어진다. 그리고 둘째 줄에는 후위 표기식이 주어진다. (여기서 피연산자는 A~Z의 영대문자이며, A부터 순서대로 N개의 영대문자만이 사용되며, 길이는 100을 넘지 않는다) 그리고 셋째 줄부터 N+2번째 줄까지는 각 피연산자에 대응하는 값이 주어진다. 3번째 줄에는 A에 해당하는 값, 4번째 줄에는 B에 해당하는값 , 5번째 줄에는 C ...이 주어진다, 그리고 피연산자에 대응 하는 값은 100보다 작거나 같은 자연수이다.</p>

<p>후위 표기식을 앞에서부터 계산했을 때, 식의 결과와 중간 결과가 -20억보다 크거나 같고, 20억보다 작거나 같은 입력만 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>계산 결과를 소숫점 둘째 자리까지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
ABC*+DE/-
1
2
3
4
5
','6.20
','DATA_STRUCTURE'),
                                                                                                                (6395,'BAEKJOON','https://www.acmicpc.net/problem/1939',1939,'중량제한','1초','128 MB',13,'<p>N(2 ≤ N ≤ 10,000)개의 섬으로 이루어진 나라가 있다. 이들 중 몇 개의 섬 사이에는 다리가 설치되어 있어서 차들이 다닐 수 있다.</p>

<p>영식 중공업에서는 두 개의 섬에 공장을 세워 두고 물품을 생산하는 일을 하고 있다. 물품을 생산하다 보면 공장에서 다른 공장으로 생산 중이던 물품을 수송해야 할 일이 생기곤 한다. 그런데 각각의 다리마다 중량제한이 있기 때문에 무턱대고 물품을 옮길 순 없다. 만약 중량제한을 초과하는 양의 물품이 다리를 지나게 되면 다리가 무너지게 된다.</p>

<p>한 번의 이동에서 옮길 수 있는 물품들의 중량의 최댓값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N, M(1 ≤ M ≤ 100,000)이 주어진다. 다음 M개의 줄에는 다리에 대한 정보를 나타내는 세 정수 A, B(1 ≤ A, B ≤ N), C(1 ≤ C ≤ 1,000,000,000)가 주어진다. 이는 A번 섬과 B번 섬 사이에 중량제한이 C인 다리가 존재한다는 의미이다. 서로 같은 두 섬 사이에 여러 개의 다리가 있을 수도 있으며, 모든 다리는 양방향이다. 마지막 줄에는 공장이 위치해 있는 섬의 번호를 나타내는 서로 다른 두 정수가 주어진다. 공장이 있는 두 섬을 연결하는 경로는 항상 존재하는 데이터만 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
1 2 2
3 1 3
2 3 2
1 3
','3
','DATA_STRUCTURE'),
                                                                                                                (6396,'BAEKJOON','https://www.acmicpc.net/problem/1960',1960,'행렬만들기','2초','128 MB',14,'<p>n×n 크기의 행렬이 있다. 이 행렬은 0과 1로 이루어 져 있다. 예를 들어 다음과 같은 행렬이 있다고 하자.</p>

<table class="table table-bordered" style="width:12%;">
	<tbody>
		<tr>
			<td style="width:3%;">1</td>
			<td style="width:3%;">1</td>
			<td style="width:3%;">0</td>
			<td style="width:3%;">0</td>
		</tr>
		<tr>
			<td>1</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
		</tr>
	</tbody>
</table>

<p>그런데 행렬이 그려진 종이를 잃어버리고 말았다. 그래서 행렬에 대한 자세한 정보는 잃어버렸고 각 행과 열에 있는 1의 개수만을 알고 있다. 위 예에는 1행에는 1이 두 개, 2행에는 3개, 3행에 1개, 4행에 1개, 그리고 1열에 2개, 2열에 2개, 3열에 2개, 4열에 1개가 있는 것이다. 이와 같은 데이터가 주어져 있을 때, 원래의 행렬을 만드는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n(1 ≤ n ≤ 500)이 주어진다. 다음 줄에는 각 행에 있는 1의 개수가 1행부터 n행까지 차례로 주어진다. 그 다음 줄에는 각 열에 있는 1의 개수가 1열부터 n열까지 차례로 주어진다. 행 또는 열에 있는 1의 개수는 n보다 작거나 같은 음이 아닌 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>만약 행렬을 구할 수 있으면 첫째 줄에 1을 출력한다. 그리고 n개의 줄에 행렬의 수들을 붙여서 출력한다. 만약 구할 수 없다면 첫째 줄에 -1을 출력한다. 가능한 행렬이 여러 개 존재할 경우에는 그 중 임의의 한 개를 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2 3 1 1
2 2 2 1
','1
1100
1011
0100
0010
','DATA_STRUCTURE'),
                                                                                                                (6398,'BAEKJOON','https://www.acmicpc.net/problem/1966',1966,'프린터 큐','2초','128 MB',8,'<p>여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.</p>

<ol>
	<li>현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.</li>
	<li>나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.</li>
</ol>

<p>예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.</p>

<p>여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.</p>

<p>테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M < N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 0
5
4 2
1 2 3 4
6 0
1 1 9 1 1 1
','1
2
5
','DATA_STRUCTURE'),
                                                                                                                (6399,'BAEKJOON','https://www.acmicpc.net/problem/1976',1976,'여행 가자','2초','128 MB',12,'<p>동혁이는 친구들과 함께 여행을 가려고 한다. 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도 있다. 동혁이의 여행 일정이 주어졌을 때, 이 여행 경로가 가능한 것인지 알아보자. 물론 중간에 다른 도시를 경유해서 여행을 할 수도 있다. 예를 들어 도시가 5개 있고, A-B, B-C, A-D, B-D, E-A의 길이 있고, 동혁이의 여행 계획이 E C B C D 라면 E-A-B-C-B-C-B-D라는 여행경로를 통해 목적을 달성할 수 있다.</p>

<p>도시들의 개수와 도시들 간의 연결 여부가 주어져 있고, 동혁이의 여행 계획에 속한 도시들이 순서대로 주어졌을 때 가능한지 여부를 판별하는 프로그램을 작성하시오. 같은 도시를 여러 번 방문하는 것도 가능하다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 도시의 수 N이 주어진다. N은 200이하이다. 둘째 줄에 여행 계획에 속한 도시들의 수 M이 주어진다. M은 1000이하이다. 다음 N개의 줄에는 N개의 정수가 주어진다. i번째 줄의 j번째 수는 i번 도시와 j번 도시의 연결 정보를 의미한다. 1이면 연결된 것이고 0이면 연결이 되지 않은 것이다. A와 B가 연결되었으면 B와 A도 연결되어 있다. 마지막 줄에는 여행 계획이 주어진다. 도시의 번호는 1부터 N까지 차례대로 매겨져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 가능하면 YES 불가능하면 NO를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
3
0 1 0
1 0 1
0 1 0
1 2 3
','YES
','DATA_STRUCTURE'),
                                                                                                                (6400,'BAEKJOON','https://www.acmicpc.net/problem/1989',1989,'부분배열 고르기 2','2초','128 MB',16,'<p>크기가 N(1 ≤ N ≤ 100,000)인 1차원 배열 A[1], …, A[N]이 있다. 어떤 i, j(1 ≤ i ≤ j ≤ N)에 대한 점수는, (A[i] + … + A[j]) × min{A[i], …, A[j]}가 된다. 즉, i부터 j까지의 합에&nbsp;i부터 j까지의 최솟값을 곱한 것이 점수가 된다.</p>

<p>배열이 주어졌을 때, 최대의 점수를 갖는 부분배열을 골라내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 N이 주어진다. 다음 줄에는 A[1], …, A[N]을 나타내는 정수들이 주어진다. 각각의 정수들은 음이 아닌 값을 가지며, 1,000,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최대 점수를 출력하고, 둘째 줄에 그 구간의 시작 위치(i)와 끝 위치(j)를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
3 1 6 4 5 2
','60
3 5
','DATA_STRUCTURE'),
                                                                                                                (6401,'BAEKJOON','https://www.acmicpc.net/problem/1994',1994,'등차수열','1초','128 MB',15,'<p>N개의 음 아닌 정수들이&nbsp;있다. 이들 중 몇 개의 정수를 선택하여 나열하면 등차수열을 만들 수 있다. 예를 들어 4, 3, 1, 5, 7이 있을 때 1, 3, 5, 7을 선택하여 나열하면 등차수열이 된다. 이와 같이 했을 때, 등차수열의 길이가 최대 얼마까지 가능한지 알아내시오.</p>

<p>등차수열은 일정한 값만큼 증가하는 수열을 말한다. 이 일정한 값은 음수나 0도 될 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 숫자의 개수 N(1 ≤ N ≤ 2,000)이 주어지고, 다음 N개의 줄에는 정수들이 주어진다. 정수들은 1,000,000,000보다 작은 음이 아닌 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가장 긴 등차수열의 길이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1
4
3
5
7
','4
','DATA_STRUCTURE'),
                                                                                                                (6404,'BAEKJOON','https://www.acmicpc.net/problem/1998',1998,'이미지 압축','2초','128 MB',15,'<p>흰색과 검은색으로 이루어진 이미지는 쿼드트리를 이용하여 표현할 수 있다. 쿼드트리의 루트는 이미지의 전체를 나타낸다. 만약 전체 이미지가 한 색깔로 이루어져 있으면, 그 색깔에 해당하는 정점을 루트로 한다. 그 외의 경우에는 그림을 넷으로 나누고, 각각의 나눠진 그림을 루트의 네 자식 정점으로 표현하면 된다. 이때 첫 번째 자식이 왼쪽 위의 그림을, 두 번째 자식이 오른쪽 위의 그림을, 세 번째 자식이 왼쪽 아래의 그림을, 네 번째 자식이 오른쪽 아래의 그림을 표현하게 된다. 각각의 작은 이미지를 표현할 때도 같은 방법을 재귀적으로 적용한다.</p>

<p style="text-align: center;"><img alt="" height="117" src="/JudgeOnline/upload/201007/qqq.png" width="432" style="width: 360px; height: 97.5px;"></p>

<p>위의 예는 4×4 크기의 이미지와 그에 해당하는 쿼드트리이다. 위의 예에서는 이미지의 크기(사각형의 변의 길이)가 2의 k승이라서 상관이 없었지만, 그 외의 경우에는 문제가 된다. 만약에 이미지의 크기가 2의 k승이 아닐 경우에는, 이미지의 크기를 오른쪽과 아래쪽으로 가장 가까운 2의 k승으로 늘린 뒤, 흰색으로 나머지 공간을 채우면 된다. 이때 이미지가 정사각형 모양이 되도록 한다. 예를 들어 5×13의 이미지는 16×16 크기의 이미지가 되고, 원래의 이미지가 왼쪽 위에 들어가고 나머지 공간은 흰색으로 채우면 된다.</p>

<p>쿼드트리 자체가 이미지를 압축적으로 표현하는 방법이지만, 우리는 압축된 쿼드트리를 이용하여 좀 더 효율적으로 표현하려 한다. 만약 쿼드트리에서 같은 모양의 부분 트리가 여러 개 나올 경우, 이를 한 번만 저장한 뒤 나머지는 포인터로 연결할 수 있다. 위의 예는 다음과 같은 압축된 쿼드트리로 표현할 수 있다.</p>

<p style="text-align: center;"><img alt="" height="111" src="/JudgeOnline/upload/201007/qqqqqqq.png" width="305"></p>

<p>원래의 쿼드트리는 17개의 정점을 갖지만, 압축된 쿼드트리는 12개의 정점을 갖는다. 12개의 정점을 갖는 압축된 쿼드트리가 몇 개 더 있기는 하지만, 11개 이하의 정점을 갖는 압축된 쿼드트리는 존재하지 않는다. 따라서 위의 경우가 가장 효율적(정점 개수가 최소)이다.</p>

<p>주의할 것은, B나 W로 표현되는 정점은 포인터가 아니가 값 자체이므로 이를 연결할 경우는 압축하는 것이 아니다. 즉, 정점이 하나인 경우(높이가 1인 경우)에는 포인터를 이용하여 연결할 필요가 없다. 또, 실제 이미지의 크기가 다르더라도 트리의 모양이 같다면, 같은 쿼드트리로 표현될 수 있는데, 이런 경우에도 포인터로 연결할 수 있다.</p>

<p>이미지가 주어졌을 때, 쿼드트리의 정점의 개수와 가장 효율적인 압축된 쿼드트리의 정점의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 이미지의 크기를 나타내는 두 정수 n(1 ≤ n ≤ 128), m(1 ≤ m ≤ 128)이 주어진다. 이는 이미지의 크기가 n×m이라는 의미이다. 다음 n개의 줄에는 m개의 숫자로 이미지가 주어진다. 흰색은 0으로, 검은색은 1로 표현된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 쿼드트리의 정점의 개수와 가장 효율적인 압축된 쿼드트리의 정점의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 4
1011
0111
1010
0111
','17 12
','DATA_STRUCTURE'),
                                                                                                                (6403,'BAEKJOON','https://www.acmicpc.net/problem/1999',1999,'최대최소','2초','128 MB',13,'<p>N×N의 행렬이 있다(1 ≤ N ≤ 250). 행렬의 각 성분은 250보다 작거나 같은 음이 아닌 정수이다. 당신에게는 K(1 ≤ K ≤ 100,000)개의 질문이 주어진다. 각 질문은, 주어진 행렬의 B×B 크기의 부분행렬의&nbsp;최댓값과 최솟값의 차이를 묻는 질문들이다(1 ≤ B ≤ N). 각 질문에 대해서, 부분행렬의 가장 왼쪽 위의 위치가 주어지며, 모든 질문들은 같은 B값을 갖는다. 질문에 답하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 세 정수 N, B, K가 주어진다. 다음 N개의 줄에는 행렬이 주어진다. 차례로 1행, 2행, …, N행이 된다. 각 줄에는 N개의 정수가 주어지며, 이는 차례로 1열의 성분, 2열의 성분, …, N열의 성분이 된다. 다음 K개의 줄에는 질문들이 주어진다. 각 질문들은 두 정수 i, j로 주어진다. i는 부분행렬의 가장 윗쪽의 행 번호이며, j는 부분행렬의 가장 왼쪽의 열 번호이다(1 ≤ i, j ≤ N-B+1)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>K개의 줄에, 차례로 각 질문의 답변(부분행렬의 최댓값과 최솟값의 차이값)을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3 1
5 1 2 6 3
1 3 5 2 7
7 2 4 6 1
9 9 8 6 5
0 6 9 3 9
1 2
','5
','DATA_STRUCTURE'),
                                                                                                                (6405,'BAEKJOON','https://www.acmicpc.net/problem/2013',2013,'선그리기','2초','128 MB',14,'<p>정문이는 2차원 평면에 N개의 선을 그리려 한다. 그런데 선이 너무 많아 하나하나 다 그리려면 매우 힘들다는 것을 깨달았다. 그래서 서로 이어진 선 같은 경우에는 하나의 선으로 생각하여서 그리려 한다.</p>

<p>예를 들어 (1,1) 에서 (3,3)로 가는 선이 있고 (2,2)에서 (4,4)으로 가는 선이 있다면 이는 이어서 그릴 수 있으므로 하나의 선으로 생각할 수 있을 것이다. N개의 선의 정보가 주어져 있을 때, 몇 개의 선으로 그릴 수 있는지 판단하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 선분의 개수 N(1<=N<=10000) 이 주어지고 그리고 둘째 줄부터 N+1번째 줄까지 네 개의 소수가(x1, y1, x2, y2) 주어진다(최대 소숫점 둘째 자리까지). 이 말은 (x1,y1) 에서 (x2,y2)까지 선이 이어진다는 것이다. (좌표는 0 이상 1000 이하이고 선의 길이는 0보다 크다.)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>선의 개수를 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1.0 10.0 3.0 14.0
0.0 0.0 20.0 20.0
10.0 28.0 2.0 12.0','2','DATA_STRUCTURE'),
                                                                                                                (6406,'BAEKJOON','https://www.acmicpc.net/problem/2015',2015,'수들의 합 4','2초','128 MB',12,'<p>A[1], A[2], ..., A[N]의 N개의 정수가 저장되어 있는 배열이 있다. 이 배열 A의 부분합이란 1 ≤ i ≤ j ≤ N인 정수 i와 j에 대해 A[i]부터 A[j]까지의 합을 말한다.</p>

<p>N과 A[1], A[2], ..., A[N]이 주어졌을 때, 이러한 N×(N+1)/2개의 부분합 중 합이 K인 것이 몇 개나 있는지를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 N과 K가 주어진다. (1 ≤ N ≤ 200,000, |K| ≤ 2,000,000,000) N과 K 사이에는 빈칸이 하나 있다. 둘째 줄에는 배열 A를 이루는 N개의 정수가 빈 칸을 사이에 두고 A[1], A[2], ..., A[N]의 순서로 주어진다. 주어지는 정수의 절댓값은 10,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 합이 K인 부분합의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 0
2 -2 2 -2
','4
','DATA_STRUCTURE'),
                                                                                                                (6408,'BAEKJOON','https://www.acmicpc.net/problem/2027',2027,'가장 큰 L','2초','128 MB',18,'<p>n×m 크기의 도화지에 그림이 그려져 있다. 그 중 L자 모양인 그림이 있을 것이다. L자 모양은 왼쪽 아래 점을 공유하는 두 직사각형이 합쳐진 모양이다. 아래 조각의 너비는 위의 조각의 너비보다 넓어야 하며, 위의 조각은 아래 조각보다 상하로 길어야 한다. L자를 회전하거나 대칭시키는 ‘ㄱ’자 등은 생각하지 않기로 하며, 단순한 직사각형은 L자 모양이 아니다. 예를 들어서&nbsp; L자 모양을 몇 개 그려보면 아래와 같다.</p>

<p style="text-align: center;"><img alt="" height="184" src="/JudgeOnline/upload/201007/llll.png" width="601" style="width: 348.333px; height: 106.667px;"></p>

<p>L 모양을 가진 그림 중 가장 넓이가 큰 것을 찾아 그 넓이를 출력하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 정수 n, m이 주어진다. 다음 n개의 줄에는 m개의 정수(0 또는 1)가 붙어서 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 L자 모양 조각의 최대 넓이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9 7
1101111
0111111
1110001
1111111
0110101
1111111
1111111
0111110
1101011
','23','DATA_STRUCTURE'),
                                                                                                                (6412,'BAEKJOON','https://www.acmicpc.net/problem/2032',2032,'피라미드','2초','128 MB',18,'<p>전쟁의 승리를 기념하여 전쟁터에 피라미드를 세우려고 한다. 피라미드는 가로로 a칸, 세로로 b줄인 직사각형 형태로 면적을 차지하며, 또한 피라미드 안에는 가로로 c칸, 세로로 d줄인 작은 방을 하나 만들어 전사자들의 시신과 유품 무기를 안치할 예정이다.</p>

<p>왕의 건축가들은 전쟁터의 지형을 가로로 m칸, 세로로 n줄인 직사각형 격자로 나누고, 각 정사각형 칸의 고도를 정수로 측량해 냈다. 피라미드와 내부 방은 모두 이 격자의 칸에 정확히 맞춰진 형태로 지을 것이다. 내부 방이 차지하는 칸은 고도를 바꿀 수 없지만, 그 외에 피라미드의 터가 차지하는 칸들은 본격적인 건축 작업을 위해 고도를 평준화하게 된다. 즉, 높은 곳의 모래를 낮은 곳에다 부어서 모든 칸들의 고도를 고도의 전체 평균값으로 바꾼다. (물론 방이 차지하는 칸의 고도는 제외한 평균) 방은 크기만 정해져 있기 때문에, 사방으로 피라미드와 외부 사이에 한 칸 이상의 간격만 확보된다면, 피라미드 내부의 어느 위치에다 만들어도 괜찮다. 즉, 꼭 중심부가 아니어도 된다는 것이다.</p>

<p>건축가들은 피라미드를 전쟁터의 어디에다 짓고 내부 방은 그 안의 어디에다 만들면, 피라미드 터의 최종 평균 고도가 가장 높아질 수 있는지를 고심하고 있다. 전쟁터, 피라미드, 내부 방의 크기와 전쟁터의 각 칸의 고도가 주어지면, 터의 평균 고도를 최대화할 수 있는 피라미드와 방 위치를 계산하는 프로그램을 작성하시오.</p>

<p style="text-align: center;"><img alt="" height="173" src="/JudgeOnline/upload/201007/pm.png" width="346"></p>

<p>위의 그림은 m=8, n=5인 전쟁터의 한 예이다. 각 칸의 숫자들은 전쟁터의 위치별 고도이다. 그리고 회색 영역은 피라미드가 지어질 터이며, 그 안의 흰색 영역은 내부 방이 들어가는 공간으로, a=5, b=3, c=2, d=1인 경우이다. 전쟁터의 크기와 고도 정보가 그림과 같고, 만들고자 하는 피라미드와 방의 크기와 그림과 같을 때, 그림과 같이 위치를 선정하는 것이 평균 고도가 약 5.4로 최대가 되는 경우이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 m(3 ≤ m ≤ 1,000)과 n(3 ≤ n ≤ 1,000), 그리고 a(3 ≤ a ≤ m)와 b(3 ≤ b ≤ n), 마지막으로 c(1 ≤ c ≤ a-2)와 d(1 ≤ d ≤ b-2)가 빈 칸을 사이에 두고 순서대로 주어진다. 이어서 둘째 줄부터는 n개의 줄에 걸쳐 각 칸의 고도를 나타내는 m개의 자연수가 빈 칸을 사이에 두고 주어진다. 고도의 크기는 100을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에는 피라미드를 지을 터의 좌측 상단 위치를, 둘째 줄에는 피라미드 내부의 방의 좌측 상단 위치를 출력한다. 위치는 가로, 세로를 나타내는 두 좌표를 빈 칸을 사이에 두고 순서대로 출력하면 된다. 최적해가 여러 개 존재하더라도 그 중 하나만 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8 5 5 3 2 1
1 5 10 3 7 1 2 5
6 12 4 4 3 3 1 5
2 4 3 1 6 6 19 8
1 1 1 3 4 2 4 5
6 6 3 3 3 2 2 2
','4 1
6 2
','DATA_STRUCTURE'),
                                                                                                                (6409,'BAEKJOON','https://www.acmicpc.net/problem/2042',2042,'구간 합 구하기','2초','256 MB',15,'<p>어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b(1 ≤ b ≤ N)번째 수를 c로 바꾸고 a가 2인 경우에는 b(1 ≤ b ≤ N)번째 수부터 c(b ≤ c ≤ N)번째 수까지의 합을 구하여 출력하면 된다.</p>

<p>입력으로 주어지는 모든 수는 -2<sup>63</sup>보다 크거나 같고, 2<sup>63</sup>-1보다 작거나 같은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -2<sup>63</sup>보다 크거나 같고, 2<sup>63</sup>-1보다 작거나 같은 정수이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2 2
1
2
3
4
5
1 3 6
2 2 5
1 5 2
2 3 5
','17
12
','DATA_STRUCTURE'),
                                                                                                                (6411,'BAEKJOON','https://www.acmicpc.net/problem/2062',2062,'곱하기 게임','2초','128 MB',15,'<p>Nils와 Mikael은 곱하기 게임을 하고 있다. 이 게임은 K(1 ≤ K ≤ 6)개의 카드와 한 개의 실수 X(1 < X < 10,000)를 가지고 진행된다. 각각의 카드에는 0.9 이하의 양의 실수가 적혀 있고, 두 사람은 이 카드를 함께 사용하게 된다.</p>

<p>게임은 두 사람이 번갈아가며 진행하는데, 각 턴에서 각 사람은 한 장의 카드를 선택할 수 있다. 카드를 선택하면 그 카드에 적혀 있는 실수를 X에 곱해서 새로운 X를 얻게 된다. 그러면 그 다음 사람도 한 장의 카드를 선택하고, 그 카드에 적혀 있는 실수를 이전 단계에서 만들어진 X에 곱하고, 또 새로운 X를 얻게 된다. 카드를 선택할 때에는 K개의 카드 중에서 반드시 하나를 선택해야 하며, 이전 단계에서 사용되었던 카드도 얼마든지 선택할 수 있다.</p>

<p>이와 같이 게임이 진행되면, 실수 X의 값이 점점 줄어들게 된다. 이와 같이 X를 줄여 나가다가, 먼저 X가 1 이하가 되도록 만드는 사람이 이 게임의 승자가 된다.</p>

<p>게임은 Nils가 먼저 시작하게 된다. 두 사람은 모두 이 게임에 익숙하기 때문에, 각 단계에서 최선을 다해 게임을 진행하게 된다. 이러한 상황에서 이 게임의 승자를 가려내는 프로그램을 작성하시오.</p>

<p>실수 연산을 하다 보면 오차(rounding-error)가 발생할 수 있는데, 채점을 할 때에는 이러한 문제가 생기는 입력 데이터는 사용하지 않는다. 즉, 입력 값을 미세하게 조절했을 때 답이 바뀌는 경우는 입력으로 주어지지 않는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 채점 데이터의 개수 T(1 ≤ T ≤ 55)가 주어진다. 다음 T개의 줄에는 각 데이터가 주어진다. 먼저 실수 X와 정수 K가 주어지고, 다음에는 각 카드에 적혀있는 실수들이 K개 주어진다. 각 실수들은 유효 숫자가 6개를 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 데이터에 대해 승자를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
6 2 0.25 0.5
10 2 0.25 0.5
29.29 4 0.3 0.7 0.43 0.54
29.30 4 0.3 0.7 0.43 0.54
','Mikael
Nils
Nils
Mikael
','DATA_STRUCTURE'),
                                                                                                                (6410,'BAEKJOON','https://www.acmicpc.net/problem/2065',2065,'나룻배','2초','128 MB',14,'<p>강을 사이에 두고 위치한 두 정박장 사이를 한 대의 나룻배가 오가고 있다. 두 정박장은 강을 기준으로 왼쪽(left), 오른쪽(right)으로 구분한다. 제일 처음에는 나룻배가 왼쪽 정박장에 위치해 있다. 이 나룻배는 한번에 최대 M명의 사람을 태울 수 있으며, 한 쪽 정박장에서 다른 쪽 정박장으로 이동하는데 양쪽 방향 모두 t만큼의 시간이 걸린다. 나룻배는 손님을 한 쪽 정박장에서 다른 쪽 정박장으로 실어 나르며 두 정박장 사이를 움직인다.</p>

<p>나룻배가 어떤 정박장에 도착하게 되면, 그 정박장으로 가고자 하는 사람들을 우선 모두 내려준다. 그 다음에는, 그 정박장에서 기다리고 있던 손님들을 배에 태울 수 있는 데까지 태운다. 손님이 배에 타는데 드는 시간은 없다고 가정하며, 가장 오래 기다린 사람이 먼저 배를 타게 된다. 손님을 다 태운 후에는 반대쪽 정박장으로 이동하게 된다. 만약 기다리던 손님이 없다면, 나룻배가 그 정박장에서 다음 손님을 기다리게 된다. 만약 기다리던 중 반대 쪽 정박장에 손님이 도착하면, 그 쪽 정박장으로 이동하게 된다.</p>

<p>각각의 손님들이 어느 정박장에 언제 도착하는지에 대한 정보가 주어질 때, 각 손님들이 원하는 곳에 도착하게 되는 시간을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 세 정수 M, t, N이 주어진다. 다음 N개의 줄에는 각각의 손님이 정박장에 도착하는 시간과 도착하는 정박장의 위치가 주어진다. 손님이 정박장에 도착하는 시간은 10만 이하의 음이 아닌 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>N개의 줄에, 입력받은 순서대로 각 손님이 목적지에 도착하게 되는 시간을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 10 10
0 left
10 left
20 left
30 left
40 left
50 left
60 left
70 left
80 left
90 left
','10
30
30
50
50
70
70
90
90
110
','DATA_STRUCTURE'),
                                                                                                                (6414,'BAEKJOON','https://www.acmicpc.net/problem/2075',2075,'N번째 큰 수','1초','12 MB (하단 참고)',9,'<p>N×N의 표에 수&nbsp;N<sup>2</sup>개 채워져 있다. 채워진 수에는 한 가지 특징이 있는데, 모든 수는 자신의 한 칸 위에 있는 수보다&nbsp;크다는 것이다. N=5일 때의 예를 보자.</p>

<table class="table table-bordered" style="width:15%">
	<tbody>
		<tr>
			<td style="width:3%">12</td>
			<td style="width:3%">7</td>
			<td style="width:3%">9</td>
			<td style="width:3%">15</td>
			<td style="width:3%">5</td>
		</tr>
		<tr>
			<td>13</td>
			<td>8</td>
			<td>11</td>
			<td>19</td>
			<td>6</td>
		</tr>
		<tr>
			<td>21</td>
			<td>10</td>
			<td>26</td>
			<td>31</td>
			<td>16</td>
		</tr>
		<tr>
			<td>48</td>
			<td>14</td>
			<td>28</td>
			<td>35</td>
			<td>25</td>
		</tr>
		<tr>
			<td>52</td>
			<td>20</td>
			<td>32</td>
			<td>41</td>
			<td>49</td>
		</tr>
	</tbody>
</table>

<p>이러한 표가 주어졌을 때, N번째 큰 수를 찾는 프로그램을 작성하시오. 표에 채워진 수는 모두 다르다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N(1 ≤ N ≤ 1,500)이 주어진다. 다음 N개의 줄에는 각 줄마다 N개의 수가 주어진다. 표에 적힌 수는 -10억보다 크거나 같고, 10억보다 작거나 같은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 N번째 큰 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
12 7 9 15 5
13 8 11 19 6
21 10 26 31 16
48 14 28 35 25
52 20 32 41 49
','35
','DATA_STRUCTURE'),
                                                                                                                (6415,'BAEKJOON','https://www.acmicpc.net/problem/2094',2094,'강수량','2초','128 MB',18,'<p>기상청에서는 매 해마다 그 해에 내린 비의 양을 측정하여 발표하는데, 이를 그 해의 강수량이라 한다. 이를 토대로 사람들은 어느 해에 몇 년 만에 비가 가장 많이 왔다는 식의 이야기를 하곤 한다. 하지만 사람은 자신의 경험과 감각에 의존하여 이야기하기 때문에, 이러한 이야기가 때론 거짓이 되기도 한다. 따라서 당신은, 기상청의 공식적인 측정 결과를 바탕으로 이러한 이야기들의 진실 여부를 가려내려 한다. 때로는 기상청의 공식적인 발표 자료를 구할 수 없기 때문에, 참과 거짓을 가려내지 못하는 경우도 생길 수도 있다.</p>

<p>편의를 위해 사람들의 이야기를 “X년도에는 Y년도 이후 가장 많은 비가 내렸다”는 형태로 한정하기로 하자. 이러한 이야기는 다음의 조건들이 만족될 때 참이 된다.</p>

<ol>
	<li>Y년도, X년도, 그리고 그 사이의 모든 년도들의 강수량에 대한 정보가 알려져 있다.</li>
	<li>X년도의 강수량은 Y년도의 강수량 이하이다.</li>
	<li>Y < Z < X를 만족하는 모든 Z들에 대해서, Z년도의 강수량은 X년도보다 적다.</li>
</ol>

<p>강수량에 대한 정보가 알려져 있지 않은 년도에 대해서 강수량을 잘 가정할 경우에 위의 세 조건이 만족된다면, 이러한 경우는 사람들의 이야기가 가능한 경우가 된다. 그 외의 경우는 거짓이 된다.</p>

<p>강수량에 대한 정보와 사람들의 이야기에 대한 정보가 주어졌을 때, 참, 가능, 거짓 여부를 가려내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 n(1 ≤ n ≤ 50,000)이 주어진다. 다음 n개의 줄에는 두 정수 y(0 ≤ |y| ≤ 1,000,000,000), r(1 ≤ r ≤ 1,000,000,000)이 주어지는데, 이는 y년도의 강수량이 r이라는 의미이다. 이러한 정보는 y가 증가하는 순서대로 주어진다. 그 다음 줄에는 정수 m(1 ≤ m ≤ 10,000)이 주어진다. 그 다음 m개의 줄에는 사람들의 이야기에 대한 정보를 나타내는 두 정수 Y, X(-1,000,000,000 ≤ Y < X ≤ 1,000,000,000)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>m개의 줄에 각 사람들의 이야기에 대한 답을 출력한다. 참일 경우에는 true를, 가능할 경우에는 maybe를, 불가능한 경우에는 false를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2002 4920
2003 5901
2004 2832
2005 3890
2
2002 2005
2003 2005
','false
true
','DATA_STRUCTURE'),
                                                                                                                (6418,'BAEKJOON','https://www.acmicpc.net/problem/2104',2104,'부분배열 고르기','2초','128 MB',16,'<p>크기가 N(1 ≤ N ≤ 100,000)인 1차원 배열 A[1], …, A[N]이 있다. 어떤 i, j(1 ≤ i ≤ j ≤ N)에 대한 점수는, (A[i] + … + A[j]) × min{A[i], …, A[j]}가 된다. 즉, i부터 j까지의 합에&nbsp;i부터 j까지의 최솟값을 곱한 것이 점수가 된다.</p>

<p>배열이 주어졌을 때, 최대의 점수를 갖는 부분배열을 골라내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 N이 주어진다. 다음 줄에는 A[1], …, A[N]을 나타내는 정수들이 주어진다. 각각의 정수들은 음이 아닌 값을 가지며, 1,000,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최대 점수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>i = 3, j = 5일 때, 점수는 (6 + 4 + 5) × 4 = 60이 된다.</p>

				</div>
				</div>','6
3 1 6 4 5 2
','60
','DATA_STRUCTURE'),
                                                                                                                (6419,'BAEKJOON','https://www.acmicpc.net/problem/2105',2105,'꼬리달린 박성원숭이','2초','128 MB',18,'<p>양 손을 사용할 수 있는 박성원숭이 N마리가 나무에 매달려 있다. 1번 박성원숭이는 꼬리로 나뭇가지에 매달려 있고 다른 박성원숭이들은 다른 박성원숭이를 손에 붙들고 있거나/고 다른 박성원숭이들의 손에 붙들려 있다(붙들리면서 붙들 수도 있음). 그런데 이 박성원숭이들은 0초부터 매 초마다 어떤 박성원숭이하나가 왼손 혹은 오른손을 놓게 된다. 그렇게 되면 의지할 곳이 없는 박성원숭이들은 ‘즉시’ 바닥으로 떨어지게 된다. 우리는 각각의 박성원숭이들이 ‘언제’ 땅에 떨어지는지 알고 싶다. 물론 떨어지지 않는 박성원숭이(이를테면 1번 박성원숭이)들도 있을 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 박성원숭이들의 수 N(1 ≤ N ≤ 200,000)과 박성원숭이들이 손을 놓게 되는 가짓수 M(1 ≤ M ≤ 400,000)이 주어진다. 다음 N개의 줄에 걸쳐서 각 박성원숭이의 ‘왼손’에 잡혀있는 다른 박성원숭이의 번호와(없을 경우 -1) ‘오른손’에 잡혀있는 박성원숭이의 번호(없을 경우 -1)가 각각 순서대로 주어진다. 다음 M개의 줄에 걸쳐서 손을 놓는 박성원숭이의 번호와 왼손을 놓는지 오른손을 놓는지 나타내는 숫자 1(왼손) 혹은 2(오른손)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 줄에 각 박성원숭이가 언제 땅에 떨어지는지 출력한다. 떨어지지 않는다면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>0초에 1번 박성원숭이가 오른손을 놓지만 아직 3번이 1번을 잡고 있어서 떨어지지 않고 1초에 3번&nbsp; 박성원숭이가 왼손을 놓게 되면서 비로소 3번과 2번이 땅에 떨어지게 된다.</p>

				</div>
				</div>','3 2
-1 3
3 -1
1 2
1 2
3 1
','-1
1
1
','DATA_STRUCTURE'),
                                                                                                                (6422,'BAEKJOON','https://www.acmicpc.net/problem/2109',2109,'순회강연','2초','128 MB',13,'<p>한 저명한 학자에게 n(0 ≤ n ≤ 10,000)개의 대학에서 강연 요청을 해 왔다. 각 대학에서는 d(1 ≤ d ≤ 10,000)일 안에 와서 강연을 해 주면 p(1 ≤ p ≤ 10,000)만큼의 강연료를 지불하겠다고 알려왔다. 각 대학에서 제시하는 d와 p값은 서로 다를 수도 있다. 이 학자는 이를 바탕으로, 가장 많은 돈을 벌 수 있도록 순회강연을 하려 한다. 강연의 특성상, 이 학자는 하루에 최대 한 곳에서만 강연을 할 수 있다.</p>

<p>예를 들어 네 대학에서 제시한 p값이 각각 50, 10, 20, 30이고, d값이 차례로 2, 1, 2, 1 이라고 하자. 이럴 때에는 첫째 날에 4번 대학에서 강연을 하고, 둘째 날에 1번 대학에서 강연을 하면 80만큼의 돈을 벌 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 각 대학에서 제시한 p값과 d값이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최대로 벌 수 있는 돈을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
20 1
2 1
10 3
100 2
8 2
5 20
50 10
','185','DATA_STRUCTURE'),
                                                                                                                (6420,'BAEKJOON','https://www.acmicpc.net/problem/2119',2119,'프로그래밍 언어 L','2초','128 MB',19,'<p>다음과 같은 가상의 프로그래밍 언어 L이 있다.</p>

<ol>
	<li>L 프로그램의 각 줄은 순서대로 1부터 N(1 ≤ N ≤ 100,000)의 번호가 붙어 있다.</li>
	<li>각 줄에는 정확히 한 개의 명령어만 들어간다.</li>
	<li>프로그램은 첫 번째 줄부터 수행된다.</li>
	<li>가능한 명령은 ifgo, jump, pass, loop, die의 다섯 가지만 있다.</li>
	<li>각 줄을 수행할 때마다 그 줄의 번호가 출력된다. 그 명령이 입력을 받는 명령일 경우에도 줄 번호가 먼저 출력된다.</li>
	<li>ifgo 명령은 다른 명령의 줄 번호를 의미하는 한 개의 인자를 갖는다. 이 명령을 수행하면 한 비트의 입력을 받는다. 만약 입력이 1이면 명령에 지시된 줄 번호로 이동한다. 만약 입력이 0이면 다음 줄로 이동한다.</li>
	<li>jump 명령은 다른 명령의 줄 번호를 의미하는 한 개의 인자를 갖는다. 이 명령을 수행하면 명령에 지시된 줄 번호로 이동한다.</li>
	<li>pass 명령은 인자가 없는 명령이다. 이 명령을 수행하면 아무 것도 하지 않고, 줄 번호만 출력한 다음에 다음 줄로 이동한다.</li>
	<li>die 명령은 인자가 없는 명령이다. 이 명령을 수행하면 줄 번호를 출력한 다음에 프로그램이 끝난다. 이 명령은 반복문 안에서는 사용되지 않는다.</li>
	<li>loop 명령은 반복문을 수행할 때 사용되는데, 두 개의 인자 l, c를 갖는다. l은 반복문이 시작되는 줄 번호이고, c는 반복 회수이다. l은 항상 loop 명령이 있는 줄 번호보다 작은 값을 갖는다. 이 명령을 수행하면 l번째 줄부터 loop 명령이 있는 줄까지를 c-1번 수행한다. 반복문이 끝난 다음에는 그 다음 줄로 이동한다.</li>
	<li>ifgo, jump 명령은 그 명령이 있는 반복문의 범위에서만 이동할 수 있다. 즉, 두 명령이 반복문 안에 있는 경우, 그 반복문의 범위 밖으로 이동할 수 없다. 또한, 반복문 안에 두 명령어가 있고, 그 다음 줄에 또다른 반복문이 있는 경우, 안쪽 반복문 안으로 이동할 수는 없다. 예를 들면 다음과 같은 경우는 잘못된 프로그램이다.</li>
	<li>반복문 안에 반복문이 들어갈 경우, 안쪽 반복문이 바깥쪽 반복문에 완전히 포함되어야 한다. 즉, 안쪽 반복문의 시작 줄 번호가 바깥쪽 반복문의 시작 줄 번호보다 커야 한다(같은 경우도 안 됨). 그 외의 형태로 두 반복문이 겹치는 경우는 없다.</li>
	<li>프로그램의 제일 마지막 줄이 수행되었을 때, 그 명령이 die가 아닌 경우 프로그램은 첫 번째 줄부터 다시 수행된다.</li>
	<li>프로그램을 알아보기 쉽게 하기 위해 각 줄에 스페이스나 탭이 여러 개 들어갈 수도 있다.</li>
	<li>각 줄의 최대 길이는 스페이스나 탭을 포함하여 80자를 넘지 않는다.</li>
</ol>

<p>L로 짠 프로그램이 주어졌을 때, 그 프로그램이 최대 몇 번이나 줄 번호를 출력하는지 계산하는 프로그램을 작성하시오. Ifgo 명령의 경우, 입력값에 따라서 출력 회수가 변할 수 있는데, 출력 회수가 최대가 되는 입력이 주어진다고 가정한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. 다음 N개의 줄에 L 프로그램이 첫째 줄부터 차례대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최대 출력 회수를 출력한다. 답은 항상 1,000,000,000이하이며, 이를 넘어가는 경우는 무한 번 수행되는 경우로 infinity를 출력하도록 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
	pass
		ifgo 4
		jump 5
		ifgo 3
	loop 2 2
	pass
loop 1 2
die
','23
','DATA_STRUCTURE'),
                                                                                                                (6421,'BAEKJOON','https://www.acmicpc.net/problem/2121',2121,'넷이 놀기','2초','128 MB',8,'<p>네 사람이서 2차원 평면상의 N개의 점을 이용해서 할 수 있는 놀이가 있다. 바로 각 사람이 1개씩의 점을 적절히 선택해서 변이 x축 혹은 y축에 평행한 직사각형을 만드는 일이다. 물론 그냥 만들면 재미가 없기 때문에 가로의 길이가 A 세로의 길이가 B인 직사각형을 몇 가지나 만들 수 있는지 알아보기로 했다.</p>

<p>예를 들어 점이 A(0, 0), B(2, 0), C(0, 3), D(2, 3), E(4, 0), F(4, 3)의 6개가 있고, 만들고 싶은 직사각형이 가로가 2, 세로가 3인 직사각형이라면 (A, B, C, D), (B, D, E, F)의 두 가지 경우가 가능하다. 모든 경우의 수를 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 점들의 개수 N(5 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에 만들고 싶은 직사각형의 가로 길이 A(1 ≤ A ≤ 1,000)와 세로 길이 B(1 ≤ B ≤ 1,000)가 주어진다. 다음 N줄에 걸쳐서 점들의 좌표가 정수로 주어진다. 이 값의 범위는 -1,000,000,000이상 1,000,000,000이하이다. N개 점들의 좌표는 각각 다르다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 가능한 모든 경우의 수를 출력한다. 경우의 수는 2<sup>31</sup>-1보다 작거나 같다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
2 3
0 0
2 0
2 3
0 3
4 0
4 3
','2
','DATA_STRUCTURE'),
                                                                                                                (6428,'BAEKJOON','https://www.acmicpc.net/problem/2143',2143,'두 배열의 합','2초','64 MB',13,'<p>한 배열 A[1], A[2], …, A[n]에 대해서, 부 배열은 A[i], A[i+1], …, A[j-1], A[j] (단, 1 ≤ i ≤ j ≤ n)을 말한다. 이러한 부 배열의 합은 A[i]+…+A[j]를 의미한다. 각 원소가 정수인 두 배열 A[1], …, A[n]과 B[1], …, B[m]이 주어졌을 때, A의 부 배열의 합에 B의 부 배열의 합을 더해서 T가 되는 모든 부 배열 쌍의 개수를 구하는 프로그램을 작성하시오.</p>

<p>예를 들어 A = {1, 3, 1, 2}, B = {1, 3, 2}, T=5인 경우, 부 배열 쌍의 개수는 다음의 7가지 경우가 있다.</p>

<pre>T(=5) = A[1] + B[1] + B[2]
      = A[1] + A[2] + B[1]
      = A[2] + B[3]
      = A[2] + A[3] + B[1]
      = A[3] + B[1] + B[2]
      = A[3] + A[4] + B[3]
      = A[4] + B[2] </pre>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 T(-1,000,000,000 ≤ T ≤ 1,000,000,000)가 주어진다. 다음 줄에는 n(1 ≤ n ≤ 1,000)이 주어지고, 그 다음 줄에 n개의 정수로&nbsp;A[1], …, A[n]이 주어진다. 다음 줄에는 m(1 ≤ m ≤ 1,000)이 주어지고, 그 다음 줄에 m개의 정수로 B[1], …, B[m]이 주어진다. 각각의 배열 원소는 절댓값이 1,000,000을 넘지 않는 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 답을 출력한다. 가능한 경우가 한 가지도 없을 경우에는 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4
1 3 1 2
3
1 3 2
','7
','DATA_STRUCTURE'),
                                                                                                                (6427,'BAEKJOON','https://www.acmicpc.net/problem/2161',2161,'카드1','2초','128 MB',6,'<p>N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.</p>

<p>이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.</p>

<p>예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 버린 카드들은 순서대로 1 3 2가 되고, 남는 카드는 4가 된다.</p>

<p>N이 주어졌을 때, 버린 카드들을 순서대로 출력하고, 마지막에 남게 되는 카드를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 N(1 ≤ N ≤ 1,000)이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 버리는 카드들을 순서대로 출력한다. 제일 마지막에는 남게 되는 카드의 번호를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
','1 3 5 7 4 2 6
','DATA_STRUCTURE'),
                                                                                                                (6429,'BAEKJOON','https://www.acmicpc.net/problem/2162',2162,'선분 그룹','2초','128 MB',16,'<p>N개의 선분들이 2차원 평면상에 주어져 있다. 선분은 양 끝점의 x, y 좌표로 표현이 된다.</p>

<p>두 선분이 서로 만나는 경우에, 두 선분은 같은 그룹에 속한다고 정의하며, 그룹의 크기는 그 그룹에 속한 선분의 개수로 정의한다. 두 선분이 만난다는 것은 선분의 끝점을 스치듯이 만나는 경우도 포함하는 것으로 한다.</p>

<p>N개의 선분들이 주어졌을 때, 이 선분들은 총 몇 개의 그룹으로 되어 있을까? 또, 가장 크기가 큰 그룹에 속한 선분의 개수는 몇 개일까? 이 두 가지를 구하는 프로그램을 작성해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N(1 ≤ N ≤ 3,000)이 주어진다. 둘째 줄부터 N+1번째 줄에는 양 끝점의 좌표가 x1, y1, x2, y2의 순서로 주어진다. 각 좌표의 절댓값은 5,000을 넘지 않으며, 입력되는 좌표 사이에는 빈칸이 하나 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 그룹의 수를, 둘째 줄에 가장 크기가 큰 그룹에 속한 선분의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 1 2 3
2 1 0 0
1 0 1 1
','1
3
','DATA_STRUCTURE'),
                                                                                                                (6432,'BAEKJOON','https://www.acmicpc.net/problem/2164',2164,'카드2','2초(추가시간없음)','128 MB',7,'<p>N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.</p>

<p>이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.</p>

<p>예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.</p>

<p>N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 남게 되는 카드의 번호를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
','4
','DATA_STRUCTURE'),
                                                                                                                (6434,'BAEKJOON','https://www.acmicpc.net/problem/2171',2171,'직사각형의 개수','2초','128 MB',11,'<p>2차원 평면 위에 N(1 ≤ N ≤ 5,000)개의 점들이 있다. 이런 점들 중 서로 다른 네 개의 점을 잡아서 연결하면 사각형이 만들어진다. 이러한 사각형들 중에서, x축과 y축에 평행한&nbsp;직사각형의 개수를 구하는 프로그램을 작성하시오. 직사각형의 넓이는 양수이어야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. 다음 N개의 줄에는 각 점의 x, y좌표가 주어진다. 좌표의 범위는 -1,000,000,000 이상 1,000,000,000 이하이며, 두 점의 좌표가 같은 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 직사각형의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
0 0
0 1
0 2
1 0
1 1
1 2
','3
','DATA_STRUCTURE'),
                                                                                                                (6436,'BAEKJOON','https://www.acmicpc.net/problem/2185',2185,'직사각형의 합집합','2초','128 MB',19,'<p>2차원 평면상에 N(0 ≤ N ≤ 5,000)개의 직사각형들이 주어졌을 때, 이 직사각형들의 합집합을 구하는 프로그램을 작성하시오.</p>

<p><img alt="" height="161" src="/JudgeOnline/upload/201008/rect.PNG" width="533" style="width: 370px; height: 111.667px;"></p>

<p>예를 들어 왼쪽은 7개의 직사각형이 주어진 모습이고, 오른쪽 그림은 그 직사각형의 합집합을 구한 예이다. 이러한 합집합을 구하면 하나의 다각형이 나오는데, 이 다각형의 둘레의 길이를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 직사각형의 개수 N이 주어진다. 다음 N개의 줄에는 각 사각형의 정보를 나타내는 네 정수 x1, y1, x2, y2가 주어진다. 이는 사각형의 대각선으로 마주 보는 두 꼭짓점의 좌표가 (x1, y1), (x2, y2)라는 의미이다. 좌표의 범위는 -10,000이상 10,000이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
-15 0 5 10
-5 8 20 25
15 -4 24 14
0 -6 16 4
2 15 10 22
30 10 36 20
34 0 40 16
','228
','DATA_STRUCTURE'),
                                                                                                                (6435,'BAEKJOON','https://www.acmicpc.net/problem/2220',2220,'힙 정렬','2초','128 MB',17,'<p>힙은 자료의 추가, 우선순위가 제일 높은 자료의 삭제가 가능한 자료구조이다. 이와 같은 힙에는 두 종류가 있는데, 각각 최소-힙, 최대-힙이다. 이 문제에서는 최대-힙을 다루기로 하자.</p>

<p>이와 같은 최대-힙을 이용하면 O(n log n)정렬인 힙 정렬을 할 수 있다. 우리가 다루기로 한 최대-힙을 이용하면 오름차순 정렬을 할 수 있다. 힙 정렬은 크게 두 개의 단계로 나뉘는데, 첫 번째 단계는 주어진 자료들로 힙을 구성하는 단계이고, 두 번째 단계는 이렇게 구성된 힙에서 최댓값을 계속 제거하는 단계이다.</p>

<p>예를 들어 (5, 4, 2, 1, 3)과 같은 힙을 살펴보자. 이 힙에서 최댓값을 삭제하면 (3, 4, 2, 1)이 되고, 힙의 조건을 맞추기 위해 Swap을 한 번 하면 (4, 3, 2, 1)의 힙을 얻는다. 이 힙에서 최댓값을 삭제하면 (1, 3, 2)이 되고, 힙의 조건을 맞추기 위해 Swap을 한 번 하면 (3, 1, 2)가 된다. 다음 단계에서는 (2, 1), (1)이 되고 힙 정렬이 종료된다. 즉, 힙이 (5, 4, 2, 1, 3)과 같이 구성되어 있었다면, 정렬을 위해 Swap을 두 번 사용하게 된다. 하지만 (5, 4, 3, 2, 1)과 같은 힙은 총 네 번의 Swap을 해야 한다.</p>

<p>n이 주어졌을 때, 1부터 n까지의 수를 한 번씩 사용하여 만들 수 있는 힙들 중에서, 위와 같은 Swap 회수가 최대가 되도록 하는 힙을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 n개의 정수로 힙을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
','6 5 3 2 4 1
','DATA_STRUCTURE'),
                                                                                                                (6441,'BAEKJOON','https://www.acmicpc.net/problem/2233',2233,'사과나무','2초','128 MB',14,'<p>사과나무는 나무(tree)의 일종으로, 각각의 정점에 정확히 한 개의 사과가 있고, 모든 내부 정점(자식이 있는 정점)이 최소 두 개의 자식을 갖는 나무이다. 예를 들면 아래의 그림은 사과나무의 예이다. 나무같이 보이기 위해서 그림은 루트를 아래에 그린다.</p>

<p style="text-align: center;"><img alt="" src="/JudgeOnline/upload/201008/at.PNG" style="height:237px; width:216px"></p>

<p>이러한 사과나무에 서식하는 벌레를 생각해 보자. 이 벌레는 이 사과나무의 루트에서 DFS 순서로 탐색을 하게 된다. 자식이 여러 개인 경우에는 (뒤집혀진 그림에서) 왼쪽을 먼저 방문하게 된다. 이러한 탐색을 하면서, 새로운 노드를 방문할 때 0을, 모든 자식 노드를 방문하고 리턴할 때 1을 나열하면 하나의 이진 수열이 된다. 위의 그림으로 이진 수열을 만들면 다음과 같다.</p>

<table class="table table-bordered table-center-30">
	<thead>
		<tr>
			<th style="width:3%;">0</th>
			<th style="width:3%;">0</th>
			<th style="width:3%;">0</th>
			<th style="width:3%;">1</th>
			<th style="width:3%;">0</th>
			<th style="width:3%;">1</th>
			<th style="width:3%;">1</th>
			<th style="width:3%;">0</th>
			<th style="width:3%;">1</th>
			<th style="width:3%;">1</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>a</td>
			<td>b</td>
			<td>c</td>
			<td>&nbsp;</td>
			<td>d</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>e</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>c</td>
			<td>&nbsp;</td>
			<td>d</td>
			<td>b</td>
			<td>&nbsp;</td>
			<td>e</td>
			<td>a</td>
		</tr>
	</tbody>
</table>

<p>이진수의 각 숫자들은 그 숫자가 0이든 1이든 하나의 정점에 대응되게 된다. 즉 0의 경우에는 새로 방문되는 정점에 대응되고, 1의 경우에는 리턴하기 전에 있었던 정점에 대응된다. 위의 표에서는 각 숫자에 대응되는 정점도 표시하였다.</p>

<p>이러한 사과나무에서 썩은 사과가 발견된 경우에는 가지를 잘라 내어야 한다. 만약 우리가 어떤 정점을 제거하면, 그 정점과 그 자손 정점들이 모두 제거되게 된다. 위의 예에서 b를 제거하면 b, c, d가 모두 제거되게 된다.</p>

<p>만약 한 개의 사과가 썩은 경우라면 그 사과를 제거하면 되지만, 두 개의 사과가 썩은 경우라면 문제가 복잡해진다. 사과나무의 성질을 유지하기 위해서, 우리는 오직 한 개의 사과만 제거할 수 있다. 이 경우 루트를 제거하면 되지만, 루트를 제거하게 되면 멀쩡한 사과들을 많이 잃게 된다(제거되는 것은 잃는 것). 따라서 우리는 한 개의 사과를 제거하되, 이를 통해 두 개(이하)의 썩은 사과를 함께 제거하고, 그러면서도 가장 적은 개수의 멀쩡한 사과를 잃도록 잘라야 한다. 위의 예에서 c, d의 사과가 썩은 경우에는 b를 제거하면 된다.</p>

<p>사과나무에 대한 정보가 주어졌을 때, 제거해야 하는 사과를 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 N(1 ≤ N ≤ 2,000)이 주어진다. 둘째 줄에는 벌레가 만드는 2×N자리의 이진수가 주어진다. 셋째 줄에는 썩은 사과의 위치를 나타내는 두 정수 X, Y가 주어진다. 이는 2×N자리의 이진수에서 X번째의 숫자에 대응되는 정점과, Y번째 숫자에 대응되는 정점에 있는 사과가 썩었다는 의미이다. 이때 두 정점이 서로 같을 수도 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 제거해야 할 사과를 나타내는 두 정수 i, j를 출력한다. 제거해야 할 사과를 Z라고 했을 때, 이는 Z를 방문할 때의 0의 위치와 Z에서 리턴될 때의 1의 위치가 이진수에서 각각 i, j 번째임을 나타낸다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
0001011011
4 5
','2 7
','DATA_STRUCTURE'),
                                                                                                                (6438,'BAEKJOON','https://www.acmicpc.net/problem/2243',2243,'사탕상자','2초','128 MB',16,'<p>수정이는 어린 동생을 달래기 위해서 사탕을 사용한다. 수정이는 평소에 여러 개의 사탕을 사서 사탕상자에 넣어두고, 동생이 말을 잘 들을 때면 그 안에서 사탕을 꺼내서 주곤 한다.</p>

<p>각각의 사탕은 그 맛의 좋고 나쁨이 1부터 1,000,000까지의 정수로 구분된다. 1이 가장 맛있는 사탕을 의미하며, 1,000,000은 가장 맛없는 사탕을 의미한다. 수정이는 동생이 말을 잘 들은 정도에 따라서, 사탕상자 안에 있는 사탕들 중 몇 번째로 맛있는 사탕을 꺼내주곤 한다. 예를 들어 말을 매우 잘 들었을 때에는 사탕상자에서 가장 맛있는 사탕을 꺼내주고, 말을 조금 잘 들었을 때에는 사탕상자에서 여섯 번째로 맛있는 사탕을 꺼내주는 식이다.</p>

<p>수정이가 보관하고 있는 사탕은 매우 많기 때문에 매번 사탕상자를 뒤져서 꺼낼 사탕을 골라내는 일은 매우 어렵다. 수정이를 도와주는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수정이가 사탕상자에 손을 댄 횟수 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 두 정수 A, B, 혹은 세 정수 A, B, C가 주어진다. A가 1인 경우는 사탕상자에서 사탕을 꺼내는 경우이다. 이때에는 한 정수만 주어지며, B는 꺼낼 사탕의 순위를 의미한다. 이 경우 사탕상자에서 한 개의 사탕이 꺼내지게 된다. 또, A가 2인 경우는 사탕을 넣는 경우이다. 이때에는 두 정수가 주어지는데, B는 넣을 사탕의 맛을 나타내는 정수이고 C는 그러한 사탕의 개수이다. C가 양수일 경우에는 사탕을 넣는 경우이고, 음수일 경우에는 빼는 경우이다. 맨 처음에는 빈 사탕상자에서 시작한다고 가정하며, 사탕의 총 개수는 2,000,000,000을 넘지 않는다. 또한 없는 사탕을 꺼내는 경우와 같은 잘못된 입력은 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>A가 1인 모든 입력에 대해서, 꺼낼 사탕의 맛의 번호를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
2 1 2
2 3 3
1 2
1 2
2 1 -1
1 2
','1
3
3
','DATA_STRUCTURE'),
                                                                                                                (6439,'BAEKJOON','https://www.acmicpc.net/problem/2268',2268,'수들의 합 7','2초','256 MB',15,'<p>N개의 수 A[1], A[2], …, A[N] 이 주어졌을 때, 함수 Sum(i, j)는 A[i] + A[i+1] + … + A[j]를 구하는 함수이다. (i > j일 경우에는 A[j] + A[j+1] + ... + A[i]) A가 주어졌을 때, Sum(i, j)를 구하는 것은 매우 쉬운 문제이다. 이러한 (i, j)가 여러 개 주어졌을 때도 별로 어려운 문제는 아니다.</p>

<p>Sum함수와 더불어 Modify라는 함수를 정의하자. Modify(i, k)를 수행하면 A[i] = k가 되는 함수이다. Sum함수와 Modify 함수의 사용 목록이 주어졌을 때, 이에 해당하는 연산을 하는 프로그램을 작성하시오. 두 함수를 섞어서 사용할 수도 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 N(1 ≤ N ≤ 1,000,000), M(1 ≤ M ≤ 1,000,000)이 주어진다. M은 수행한 명령의 개수이며 다음 M개의 줄에는 수행한 순서대로 함수의 목록이 주어진다. 첫 번째 숫자는 어느 함수를 사용했는지를 나타내며, 0일 경우에는 Sum 함수를, 1일 경우에는 Modify 함수를 나타낸다. 다음 두 수는 각 함수의 인자 (i, j)나 (i, k)를 나타낸다. 처음에는 A[1] = A[2] = … = A[N] = 0이다. Modify인 경우에 1 ≤ k ≤ 100,000 이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Sum 함수의 개수만큼 각 줄에 Sum 함수의 리턴값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5
0 1 3
1 1 2
1 2 3
0 2 3
0 1 3
','0
3
5
','DATA_STRUCTURE'),
                                                                                                                (6440,'BAEKJOON','https://www.acmicpc.net/problem/2271',2271,'암호화 알고리즘의 약점','2초','128 MB',17,'<p>암호문을 만드는 방법에는 여러 가지가 있는데, 보통 이를 위해서 암호화 하려는 글(혹은 파일 등)을 하나의 수열로 나타내게 된다. 이 문제에서는 A[1], A[2], …, A[n]의 수열을 암호화 하려 한다고 하자.</p>

<p>이 수열을 암호화 하는 대단히 효율적인 알고리즘을 발견하였는데, 이 알고리즘에는 약점이 하나 있다. 바로 수열이 특정 조건을 만족할 경우에는 복호화(암호문을 다시 원래의 글로 바꾸는 것)가 유일하지 않게 된다는 점이다.</p>

<p>수열이 주어졌을 때, 이 수열이 우리가 사용하려는 암호화 알고리즘의 약점인지 아닌지를 판별하는 프로그램을 작성하여라.</p>

<p>수열이 1 ≤ p < q < r < s ≤ n 을 만족하는 p, q, r, s 에 대해서 A[q] < A[s] < A[p] < A[r]이나 A[q] > A[s] > A[p] > A[r]를 만족하는 경우가 있다면 이러한 경우가 약점이 된다. 즉, 1 ≤ p < q < r < s ≤ n 이 되도록 p, q, r, s를 어떻게 잘 선택했는데, 이때 A[q] < A[s] < A[p] < A[r]이 만족되거나, A[q] > A[s] > A[p] > A[r]이 만족되는 경우가 약점이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 데이터의 개수 T(1 ≤ T ≤ 10)가 주어진다. 각각의 데이터의 첫째 줄에는 n(4 ≤ n ≤ 5,000)이 주어진다. 그 다음 줄에는 차례로 A[1], A[2], …, A[n]이 주어진다. 각각의 A[i]는 1이상 10,000 이하이다. 모든 A[i]는 서로 다르다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>T개의 줄에 각각의 데이터에 대한 결과를 출력한다. 약점인 경우에는 Yes를, 아닌 경우에는 No를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
6
10 30 60 40 20 50
8
30 40 10 20 80 50 60 70
4
1 2 20 9
','Yes
No
No
','DATA_STRUCTURE'),
                                                                                                                (6445,'BAEKJOON','https://www.acmicpc.net/problem/2276',2276,'물 채우기','2초','128 MB',17,'<p>N×M 크기의 물통이 있다. 이 물통의 각 칸은 높이가 다를 수도 있다. 이와 같은 물통에 물을 부었을 때, 담을 수 있는 물의 최대량을 계산하는 프로그램을 작성하시오. 물통의 테두리도 높이가 다를 수 있고, 테두리가 물통의 안쪽보다 높이가 낮을 수도 있다.</p>

<p style="text-align: center;"><img alt="" height="219" src="/JudgeOnline/upload/201008/wt.PNG" width="478" style="width: 398.333px; height: 182.5px;"></p>

<p>왼쪽 표는 물통의 높이를 나타낸 것이고, 오른쪽은 각 칸에 담은 물의 양을 나타낸 것이다. 이 경우가 답이 12로 최대인 경우가 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 M, N(1 ≤ N,&nbsp;M ≤ 300)이 주어진다. 다음 N개의 줄에는 M개의 자연수로 각 칸의 높이가 주어진다. 각각의 높이는 1,000,000,000를 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 답을 출력한다. 답은 int 범위 이내이다. 이 값은 0이 될 수도 있다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5
5 8 7 7
5 2 1 5
7 1 7 1
8 9 6 9
9 8 9 9
','12
','DATA_STRUCTURE'),
                                                                                                                (6446,'BAEKJOON','https://www.acmicpc.net/problem/2284',2284,'레이스','2초','128 MB',17,'<p>N개의 우주선이 레이스를 하고 있다. i번째 우주선은 순식간에(0초에) 최대 속도인 V[i]에 도달할 수 있고, 이 속도를 레이스가 끝날 때까지 유지할 수 있다. 또한 각 우주선은 지난 대회의 결과에 따라서 X[i]라는 출발점에서 출발하게 된다. 레이스 장은 무한히 길고 X축에 평행하다. 각각의 우주선은 X축에만 평행하게 움직인다.</p>

<p>이렇게 레이스를 하다 보면 우주선이 다른 우주선을 추월하는 경우도 발생하게 된다. 각각의 우주선은 X[i]좌표와는 별도로 Y, Z 좌표도 가지고 있기 때문에 충돌에 대해서는 생각할 필요가 없다.</p>

<p>경기가 끝날 때까지 발생하는 추월들을 알아내는 프로그램을 작성하시오. 경기는 더 이상 추월이 발생하지 않을 때까지 반복된다. 우선 추월의 회수를 알아내야 하고, 연대순으로 처음 10,000개의 추월이 구체적으로 어떤 추월인지(몇 번이 몇 번을 추월하는지)를 알아내야 한다. 편의상 모든 X[i]가 다르다고 가정하자. 또한, 매 순간에 한 x좌표에는 최대 두 개의 우주선만 있을 수 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/e164b7d2-dbbf-48ba-b2c2-03f80373f714/-/preview/" style="width: 352px; height: 179px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 우주선의 개수 N(1 ≤ N ≤ 250,000)이 주어진다. 다음 N개의 줄에는 차례로 X[1], V[1], X[2], V[2], …, X[N], V[N]이 주어진다. 이때 X[i]와 V[i]는 정수이고, 0 ≤ X[i] ≤ 1,000,000과 1 ≤ V[i] ≤ 99를 만족한다. 또, X[1] < X[2] < … < X[N]을 만족한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 추월의 회수를 1,000,000으로 나눈 나머지를 출력한다. 다음 줄들에는 각 추월에 대한 정보를 연대순으로(시간 순으로) 출력한다. 만약 추월 회수가 10,000을 넘어가면 처음의 10,000개만 출력하도록 한다. 각 줄은 두 개의 정수 i, j로 출력하는데, i번 우주선이 j번 우주선을 추월한다는 의미이다. 여러 추월이 동시에 일어나면 추월이 일어나는 위치가 출발점에 가까운(x좌표가 작은) 것을 먼저 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
0 2
2 1
3 8
6 3
','2
3 4
1 2
','DATA_STRUCTURE'),
                                                                                                                (6444,'BAEKJOON','https://www.acmicpc.net/problem/2287',2287,'모노디지털 표현','2초','128 MB',15,'<p>몇 개의 숫자 K(K는 1, 2, …, 9중 하나)와 사칙 연산(덧셈, 뺄셈, 곱셈, 나눗셈)만을 사용하여 어떤 자연수 X를 수식으로 표현한 것을 X의 K-표현이라 부른다. 수식에는 괄호가 포함될 수 있으며, 나눗셈은 나눈 몫만을 취한다.</p>

<p>예를 들어 12의 5-표현을 몇 개 써 보면 5+5+(5/5)+(5/5), 55/5+5/5, (55+5)/5 등이 있다. K-표현의 길이를 사용한 K의 개수라 하면, 각각의 길이는 6, 5, 4가 된다.</p>

<p>K가 주어졌을 때, 어떤 자연수의 K-표현 중 가장 짧은 길이를 알아보려 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 K가 주어진다. 다음 줄에는 표현 식을 찾을 수의 개수 n(1 ≤ n ≤ 1,000)이 주어진다. 다음 줄에는 K-표현 중 가장 짧은 길이를 알아보려 하는 자연수 a(1 ≤ a ≤ 32,000)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력되는 순서대로 K-표현의 최소 길이를 n개의 줄에 출력한다. 만약 K-표현의 최소 길이가 8보다 크다면 “NO"를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
2
12
31168
','4
NO
','DATA_STRUCTURE'),
                                                                                                                (6443,'BAEKJOON','https://www.acmicpc.net/problem/2295',2295,'세 수의 합','1초','128 MB',12,'<p>N(5 ≤ N ≤ 1,000)개의 자연수들로 이루어진 집합 U가 있다. 이 중에서 적당히 세 수를 골랐을 때, 그 세 수의 합 d도 U안에 포함되는 경우가 있을 수 있다. 이러한 경우들 중에서, 가장 큰 d를 찾으라.</p>

<p>예를 들어 {2, 3, 5, 10, 18}와 같은 집합이 있다고 하자. 2+3+5 = 10이 되고, 이 수는 집합에 포함된다. 하지만 3+5+10 = 18이 되고, 이 경우가 세 수의 합이 가장 커지는 경우이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 자연수 N이 주어진다. 다음 N개의 줄에 차례로 U의 원소가 하나씩 주어진다. 주어진 U는 집합이 되므로 입력되는 두 수가 같아서는 안 된다. U의 원소는 200,000,000보다 작거나 같은 자연수이다. 답이 항상 존재하는 경우만 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>우리가 x번째 수, y번째 수, z번째 수를 더해서 k번째 수를 만들었다라고 하자. 위의 예제에서 2+3+5=10의 경우는 x, y, z, k가 차례로 1, 2, 3, 4가 되며, 최적해의 경우는 2, 3, 4, 5가 된다. k번째 수가 최대가 되도록 하는 것이 목적이다. x, y, z, k가 서로 같아도 된다. 이때, k번째 수를 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
2
3
5
10
18
','18
','DATA_STRUCTURE'),
                                                                                                                (6447,'BAEKJOON','https://www.acmicpc.net/problem/2304',2304,'창고 다각형','2초','128 MB',9,'<p>N 개의 막대 기둥이 일렬로 세워져 있다. 기둥들의 폭은 모두 1 m이며 높이는 다를 수 있다. 이 기둥들을 이용하여 양철로 된 창고를 제작하려고 한다. 창고에는 모든 기둥이 들어간다. 이 창고의 지붕을 다음과 같이 만든다.</p>

<ol>
	<li>지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다.</li>
	<li>지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.</li>
	<li>지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.</li>
	<li>지붕의 가장자리는 땅에 닿아야 한다.</li>
	<li>비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다.</li>
</ol>

<p>그림 1은 창고를 옆에서 본 모습을 그린 것이다. 이 그림에서 굵은 선으로 표시된 부분이 지붕에 해당되고, 지붕과 땅으로 둘러싸인 다각형이 창고를 옆에서 본 모습이다. 이 다각형을 창고 다각형이라고 하자.</p>

<p style="text-align: center;"><img alt="" src="/JudgeOnline/upload/201011/cd.png" style="height: 230px; width: 335.833px;"></p>

<p style="text-align: center;">그림1 . 기둥과 지붕(굵은 선)의 예</p>

<p>창고 주인은 창고 다각형의 면적이 가장 작은 창고를 만들기를 원한다. 그림 1에서 창고 다각형의 면적은 98 ㎡이고, 이 경우가 가장 작은 창고 다각형이다.</p>

<p>기둥들의 위치와 높이가 주어질 때, 가장 작은 창고 다각형의 면적을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 그 다음 N 개의 줄에는 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과 높이를 나타내는 정수 H가 한 개의 빈 칸을 사이에 두고 주어진다. L과 H는 둘 다 1 이상 1,000 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 창고 다각형의 면적을 나타내는 정수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
2 4
11 4
15 8
4 6
5 3
8 10
13 6
','98
','DATA_STRUCTURE'),
                                                                                                                (6402,'BAEKJOON','https://www.acmicpc.net/problem/2318',2318,'상사 찾기','2초','128 MB',17,'<p>주식회사 월드에서는 오랫동안 열심히 일을 하면 그에 따라 승진할 수도 있고, 그만큼 많은 급료를 받을 수도 있다.</p>

<p>즉, 어떤 사원의 상사는 적어도 그 사원만큼은 회사에서 근무한 것이고, 그 사원보다 많은 급료를 받는다. 또, 어느 사원의 직속 상사는, 적어도 그 사원만큼 회사에서 근무했고, 그 사원보다 많은 급료를 받는 사람들 중에서 가장 적은 급료를 받는 사람이다.</p>

<p>어느 사원의 직속 상사에게 있어서, 그 사원은 부하가 된다. 어떤 사원의 부하의 부하들도 모두 그 사원의 부하라 하자. 만약에 어느 사원이 누구의 상사도 아니면 그 사원은 부하가 없다.</p>

<p>주식회사 월드의 상사-부하 관계가 위와 같이 정의될 때, 몇몇 사원의 직속 상사와 부하의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 정수 n(1 ≤ n ≤ 30,000), m(1 ≤ m ≤ 200)이 주어진다. n은 사원의 수고, m은 우리가 직속 상사와 부하의 수를 알아보려는 사원의 수이다. 다음 n개의 줄에는 각 사원의 정보를 나타내는 세 정수 a, b, c가 주어진다. a(1 ≤ a ≤ 2,147,483,647)는 사원의 ID, b(0 ≤ b ≤ 10,000,000)는 급료, c(1,000,000 ≤ c ≤ 2,500,000)는 근무한 시간(분 단위)을 나타낸다. 사원의 ID는 중복되지 않는다.</p>

<p>다음 m개의 줄에는 직속 상사와 부하의 수를 알아보려는 사원의 ID가 주어진다. 사원의 정보로&nbsp;주어진 사원의 ID만 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>m개의 줄에 입력된 순서대로 해당 사원의 직속 상사의 ID와 부하의 수를 출력한다. 만약 입력으로 주어진 ID가 사장일 경우, 즉 가장 오래 근무하였고 가장 많은 급료를 받는 사원의 ID일 경우에는 직속 상사의 ID 대신에 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
123456 14323 1700000
123458 41412 1900000
123457 15221 1800000
123456
123458
123457
','123457 0
0 2
123458 1
','DATA_STRUCTURE'),
                                                                                                                (6324,'BAEKJOON','https://www.acmicpc.net/problem/2330',2330,'미생물 연구실','2초','128 MB',18,'<p>초라기 연구소에서는 N종류의 미생물을 이용한 실험을 하고 있다. 주된 실험 내용은 같은 미생물을 여러 다른 온도에서 길러 보면서 각각 어떤 모습으로 자라는지 관찰하는 것이다.</p>

<p>i번째 미생물(편의상 미생물에 1부터 N까지의 번호를 붙이자)은 A[i]이상 B[i]이하의 온도에서만 기를 수 있다. 또, 원활한 실험을 위해서는 최소한 C[i]개의 서로 다른 온도의 실험실에서 i번째 미생물을 길러봐야 한다. 이와 같은 조건이 주어졌을 때, 필요한 실험실의 최소 개수를 구하는 프로그램을 작성하시오.</p>

<p>각각의 실험실은 어떤 특정한, 그리고 서로 다른 온도로 관리된다. 어떤 실험실의 온도가 T도일 때, A[i] ≤ T ≤ B[i]를 만족하는 미생물은 몇 개라도, 몇 종류라도 그 실험실에서 기를 수 있다고 하자. 또한 월드 연구소에서는 특별한 단위의 온도를 사용하는데, A[i], B[i], T등 모든 온도가 0이상 50,000 이하의 정수로 표현되는 단위를 사용한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. 다음 N개의 줄에는 A[i], B[i], C[i]가 i = 1, 2, ..., N의 순서로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 필요한 최소 개수의 실험실을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>온도가 1인 실험실, 3인 실험실 두 개가 있으면 된다.</p>

				</div>
				</div>','3
1 2 1
3 4 1
1 4 2
','2
','DATA_STRUCTURE'),
                                                                                                                (6326,'BAEKJOON','https://www.acmicpc.net/problem/2336',2336,'굉장한 학생','2초','192 MB',19,'<p>N명의 학생이 참여하여 세 번의 시험을 치렀다. N명의 학생들은 세 번의 시험에 모두 응시하였다. 조교는 각각의 시험에서 같은 등수의 학생이 한 명도 없도록 성적을 매겼다.</p>

<p>A라는 학생이 B라는 학생보다 세 번의 시험에서 모두 성적이 좋다면, A가 B보다 대단하다고 한다. 또, C라는 학생보다 대단한 학생이 한 명도 없으면, C를 굉장하다고 한다.</p>

<p>세 번의 시험에서 각 학생의 성적이 주어졌을 때, 굉장한 학생의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N(1 ≤ N ≤ 500,000)이 주어진다. 다음 세 개의 줄에는 각 시험에서 1등인 학생부터 N등인 학생이 순서대로 주어진다. 학생의 번호는 1부터 N까지 매겨져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 굉장한 학생의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
2 5 3 8 10 7 1 6 9 4
1 2 3 4 5 6 7 8 9 10
3 8 7 10 5 4 1 2 6 9
','4
','DATA_STRUCTURE'),
                                                                                                                (6325,'BAEKJOON','https://www.acmicpc.net/problem/2346',2346,'풍선 터뜨리기','2초','4 MB',8,'<p>1번부터 N번까지 N개의 풍선이 원형으로 놓여 있고. i번 풍선의 오른쪽에는 i+1번 풍선이 있고, 왼쪽에는 i-1번 풍선이 있다. 단, 1번 풍선의 왼쪽에 N번 풍선이 있고, N번 풍선의 오른쪽에 1번 풍선이 있다. 각 풍선 안에는 종이가 하나 들어있고, 종이에는 -N보다 크거나 같고, N보다 작거나 같은 정수가 하나 적혀있다. 이&nbsp;풍선들을 다음과 같은 규칙으로 터뜨린다.</p>

<p>우선, 제일 처음에는 1번 풍선을 터뜨린다. 다음에는 풍선 안에 있는 종이를 꺼내어 그 종이에 적혀있는 값만큼 이동하여 다음 풍선을 터뜨린다. 양수가 적혀 있을 경우에는 오른쪽으로, 음수가 적혀 있을 때는 왼쪽으로 이동한다. 이동할 때에는 이미 터진 풍선은 빼고 이동한다.</p>

<p>예를 들어 다섯 개의 풍선 안에 차례로 3, 2, 1, -3, -1이 적혀 있었다고 하자. 이 경우 3이 적혀 있는 1번 풍선, -3이 적혀 있는 4번 풍선, -1이 적혀 있는 5번 풍선, 1이 적혀 있는 3번 풍선, 2가 적혀 있는 2번 풍선의 순서대로 터지게 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 자연수 N(1 ≤ N ≤ 1,000)이 주어진다. 다음 줄에는 차례로 각 풍선 안의 종이에 적혀 있는 수가 주어진다. 종이에 0은 적혀있지 않다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 터진 풍선의 번호를 차례로 나열한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
3 2 1 -3 -1
','1 4 5 3 2
','DATA_STRUCTURE'),
                                                                                                                (6330,'BAEKJOON','https://www.acmicpc.net/problem/2350',2350,'대운하','1초','128 MB',14,'<p>4대강 사업의 성공에 힘입은 정부는 대한민국의 도시들을 모두 운하로 연결하여 뱃길로&nbsp;KTX를 대체하려는 계획을 세웠다.</p>

<p>대한민국에는 N개의 도시가 있고, 이들을 연결하는 M개의 운하를 건설하려고 한다. 하지만 지형의 문제로 운하의 폭을 제한할 수 밖에 없었기 때문에, 문제가 생겼다. 배의 폭이&nbsp;운하의 폭보다 작거나 같아야 운하를 무사히 통과할 수 있기 때문이다.</p>

<p>정부는 K개의 노선을 준비했다. 각 노선의 도시 i와 j간을 운행하는 배는 도시 i와 j 간의 경로에 포함되는 운하를 통과할 수 있어야 한다. (이 경로는 여러 개가 존재할 수 있다.) 배가 클수록 많은 사람을 실을 수 있으므로, 정부는 배의 폭을 최대화하기를 원한다.</p>

<p>N개의 도시는 운하로 서로 연결되어 있음이 보장되며, 운하는 양방향으로 통행이 가능하다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에는 도시의 수 N, 운하의 수 M, 노선의&nbsp;수 K가 주어진다.&nbsp;<span style="line-height:1.6em">(N ≤ 1000, M ≤ 100000, K ≤ 10000)</span></p>

<p>다음 M개의 줄에는 세 정수 i,&nbsp;j, w가 주어지며, 이는 도시 i와 j 사이에 폭이 w인 운하를 건설할 것임을 의미한다. (1 ≤ i, j ≤ N, w ≤ 200)</p>

<p>다음 K개의 줄에는 각 노선이 연결하는&nbsp;도시&nbsp;i, j가 주어진다. (1 ≤ i, j ≤N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>K개의 줄에 각 노선을 운행할 수 있는 최대 배의 폭을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 9 4
1 2 2
1 4 3
1 6 1
2 3 3
2 5 2
3 4 4
3 6 2
4 5 5
5 6 4
2 6
3 5
1 2
4 6
','3
4
3
4
','DATA_STRUCTURE'),
                                                                                                                (6331,'BAEKJOON','https://www.acmicpc.net/problem/2357',2357,'최솟값과 최댓값','2초','192 MB',15,'<p>N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째&nbsp;정수까지 중에서 제일 작은 정수, 또는 제일 큰 정수를 찾는 것은 어려운 일이 아니다.&nbsp;하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해&nbsp;보자.</p>

<p>여기서 a번째라는 것은 입력되는 순서로 a번째라는 이야기이다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중에서 최소, 최댓값을 찾아야 한다. 각각의 정수들은 1이상 1,000,000,000이하의 값을 갖는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N, M이 주어진다. 다음 N개의 줄에는 N개의 정수가 주어진다. 다음 M개의 줄에는 a, b의 쌍이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>M개의 줄에 입력받은 순서대로 각 a, b에 대한 답을 최솟값, 최댓값 순서로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 4
75
30
100
38
50
51
52
20
81
5
1 10
3 5
6 9
8 10
','5 100
38 100
20 81
5 81
','DATA_STRUCTURE'),
                                                                                                                (6332,'BAEKJOON','https://www.acmicpc.net/problem/2358',2358,'평행선','2초','128 MB',7,'<p>평면에 n개의 점이 있다. 그중 두 개 이상의 점을 지나면서 x축 또는 y축에 평행한 직선이 몇 개인지 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 각 점의 좌표가 주어진다. 같은 좌표가 여러 번 주어질 수 있으며, 그런 경우 서로 다른 점으로 간주한다. 좌표는 절댓값이 2<sup>31</sup>보다 작은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
0 0
10 10
0 10
10 0
','4
','DATA_STRUCTURE'),
                                                                                                                (6334,'BAEKJOON','https://www.acmicpc.net/problem/2359',2359,'드라이브','2초','128 MB',17,'<p>n(3 ≤ n ≤ 500)개의 도시로 이루어진 나라가 있다. 이들 중 몇 개의 도시들은 서로 도로로 연결되어 있다. 당신은 당신의 취미 생활인 자동차 드라이브를 즐기려고 한다. 각각의 도시는 1, 2, 3, …, N의 번호가 붙어 있고, 현재 당신은 S번 도시에 위치하고 있다. 당신은 T번 도시로 가려고 한다.</p>

<p>각각의 도로를 지날 때에는 특정한 비용을 지불하여야 한다. 드라이브를 시작하면 처음으로 도로를 지날 때에는, 0원을 지불한다. 그 외의 경우에는 다음과 같은 방법을 이용하여 지불 비용을 계산한다. 우선, 현재까지 지난 도로들 중에서 최소인 비용을 m, 최대인 비용을 M이고, 현재 지나려는 도로의 비용이 x라고 하자. 만약 x가 m보다 작다면 m-x만큼의 비용을 추가로 지불하여야 한다. 만약 x가 M보다 크다면, x-M의 비용을 추가로 지불하여야 한다.</p>

<p>예를 들어, 비용이 3, 1, 5, 4, 2, 7인 도로들을 차례로 지났다고 하자. 그러면 각각을 지날 때 지불하는 비용은 0, 2, 2, 0, 0, 2가 되어, 총 6의 비용을 지불하게 된다.</p>

<p>도로에 대한 정보가 주어졌을 때, 지불하게 되는 총 비용을 최소로 하는 드라이브 경로를 찾는 것이 목적이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 네 정수 n, m(1 ≤ m ≤ 2,000), S, T가 주어진다. m은 도로의 개수를 나타낸다. 다음 m개의 줄에는 도로에 대한 정보를 나타내는 세 정수 a, b, c가 주어진다. 이는 a번 도시와 b번 도시를 연결하는 도로의 비용이 c(1 ≤ c ≤ 1,000,000,000)임을 나타낸다. a와 b는 항상 다르고, 두 도시는 오직 한 개의 도로(경로가 아님)로만 연결되어 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 지불하는 비용을 출력한다. 다음 줄에는 방문하는 도시들을 차례로 출력한다. 답이 없는 경우는 입력으로 주어지지 않는다고 가정하자.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 6 1 6
1 2 3
2 3 1
3 6 5
1 4 2
4 5 3
5 6 4
','2
1 4 5 6
','DATA_STRUCTURE'),
                                                                                                                (6338,'BAEKJOON','https://www.acmicpc.net/problem/2371',2371,'파일 구별하기','2초','128 MB',8,'<p>메모리에 N개의 파일이 저장되어 있다. 이 문제에서는 편의상 각각의 파일을 수열과 같이 생각하자. 이와 같은 파일들을 구별하기 위해서는 두 개의 파일을 맨 끝까지 읽어보는 작업을 수행해야 한다. 이와 같은 작업을 좀 더 효율적으로 수행하기 위해서, 파일의 앞에서부터 차례로 K번째 수 까지만 읽어보는 방법이 있다. 만약 파일의 크기가 K보다 작다면 파일의 뒤에 0이 여러 개 붙어서 총 길이를 K로 만드는 것으로 생각하면 된다.</p>

<p>예를 들어 {1, 2, 3}, {1, 2, 3, 4}, {1, 2, 4, 5}과 같은 세 개의 파일이 있다고 해 보자. K=3일 경우 각 파일의 앞에서부터 K번째 수 까지 읽으면 {1, 2, 3}, {1, 2, 3}, {1, 2, 4}이 된다. 이 경우에는 서로 같은 경우가 있으므로 파일들을 완전히 구별할 수 없다. 하지만 K=4일 경우 {1, 2, 3, 0}, {1, 2, 3, 4}, {1, 2, 4, 5}가 되어 모든 파일들을 완전히 구별할 수 있게 된다.</p>

<p>N개의 파일에 대한 정보가 주어졌을 때, 모든 파일들을 구별할 수 있게 해 주는 최소의 K값을 찾는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다. 다음 N개의 줄에는 각각의 파일의 정보를 나타내는 자연수가 주어진다. 각 줄의 맨 마지막에는 -1이 주어진다. 두 파일의 길이와 내용이 모두 동일한 경우는 없다고 가정하자. 파일은 2<sup>31</sup>-1 이하의 자연수로 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 K의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2 3 -1
1 2 3 4 -1
1 2 4 5 -1
','4
','DATA_STRUCTURE'),
                                                                                                                (6339,'BAEKJOON','https://www.acmicpc.net/problem/2374',2374,'같은 수로 만들기','2초','128 MB',12,'<p>n(1 ≤ n ≤ 1,000)개의 자연수 A[1], A[2], A[3], …, A[n]이 있다. 이 자연수에 Add(i)라는 연산을 하면, A[i]가 1만큼 증가한다. 이때, A[i]만 증가하는 것이 아니고, A[i]의 좌우로 인접한 같은 수의 그룹이 한번에 1씩 증가한다. A[1]과 A[n]은 인접해 있지 않다.</p>

<p>예를 들어 수가&nbsp;{1, 1, 1, 1, 3, 3, 1} 이었다고 해 보자. Add(2)를 하면 A[2]의 좌우로 인접한 같은 수가&nbsp;1씩 증가하니까 {2, 2, 2, 2, 3, 3, 1}이 된다. 여기서 Add(4)를 하면 {3, 3, 3, 3, 3, 3, 1}이 되고, 여기서 Add(1)을 하면 {4, 4, 4, 4, 4, 4, 1}이 된다.</p>

<p>이와 같이 Add라는 연산을 사용하여 A[1] = A[2] = A[3] = … = A[n]이 되도록 하려 한다. 이때, 최소 회수로 Add연산을 사용하는 방법을 찾는 것이 문제이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 차례로 A[1], A[2], …, A[n]이 주어진다. 모든 입력은 1,000,000,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소의 Add연산 사용 회수를 출력한다. 이 값은 10<sup>25</sup>을 넘지 않는다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1
5
10
','9
','DATA_STRUCTURE'),
                                                                                                                (6342,'BAEKJOON','https://www.acmicpc.net/problem/2402',2402,'거짓말','2초','128 MB',14,'<p>어느 두 사람이 질문자와 답변자가 되어 게임을 하고 있다. 게임을 위해 답변자에게 길이 N(1 ≤ N ≤ 1,000,000,000)의 이진 수열(0과 1로만 이루어진 수열)이 주어진다.</p>

<p>질문자는 M(1 ≤ M ≤ 5,000)번에 걸쳐 답변자에게 수열의 i번째 항부터 j번째 항까지 1이 짝수 번 나타나는지 홀수 번 나타나는지를 물어본다. 이는 i번째 항과 j번째 항을 포함시켜서 생각하는 것으로 한다. 1이 짝수 번 나타나는 경우에는 0이라고, 홀수 번 나타나는 경우에는 1이라고 답변자가 답한다.</p>

<p>이 게임의 목적은, 이런 식으로 질문과 답변을 진행하다가, 답변자가 몇 번째 질문에서 거짓말을 하였는지를 알아내는 것이다. 질문자와 답변자의 질문과 답이 주어졌을 때, 답변자가 몇 번째 질문에 대해 거짓말을 했는지를 알아내는 프로그램을 작성하시오.</p>

<p>답변자가 어느 질문에 대해 거짓말을 했다는 것은, 그 전 질문까지의 답변과 그 질문의 답변을 동시에 만족하는 이진 수열이 존재하지 않음을 의미한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 두 정수 N과 M이 주어진다. 다음 M개의 줄에는 질문과 답을 나타내는 3개의 정수가 주어진다. 첫 번째 정수는 i이며, 두 번째 정수는 j이다. 세 번째 정수는 그 질문에 대한 답변자의 답을 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 몇 번째 질문에 대해 답변자가 거짓말을 했는지를 출력한다. 만약 답변자가 모든 질문에 대해 거짓말을 하지 않았다면 M+1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 5
1 2 0
3 4 1
5 6 0
1 6 0
7 10 1
','4
','DATA_STRUCTURE'),
                                                                                                                (6344,'BAEKJOON','https://www.acmicpc.net/problem/2412',2412,'암벽 등반','2초','128 MB',12,'<p>어떤 암벽에 n(1 ≤ n ≤ 50,000)개의 홈이 파져 있다. 각각의 홈의 좌표는 (x, y)와 같이 표현되는데, |a - x| ≤ 2이고 |b - y| ≤ 2이면 (x, y)에서 (a, b)로 이동할 수 있다. 이와 같이 홈들을 이용하여 이동하면서 y = T(1 ≤ T ≤ 200,000)일 때까지, 즉 암벽의 정상까지 오르려고 한다.</p>

<p>현재 당신이 있는 위치는 (0, 0)이다. 이 위치에서 시작하여 이동 회수를 최소로 하면서 정상에 오르려고 한다. 정상에 오를 때의 x좌표는 아무 것이나 되어도 상관이 없다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n, T가 주어진다. 다음 n개의 줄에는 각 점의 x, y좌표가 주어진다. 두 좌표는 모두 0이상이며, x좌표는 1,000,000이하, y좌표는 T이하이다. 입력에 현재 위치인 (0, 0)은 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소 이동 회수를 출력한다. 만약, 정상에 오를 수 없으면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
1 2
6 3
4 1
3 2
0 2
','4
','DATA_STRUCTURE'),
                                                                                                                (6345,'BAEKJOON','https://www.acmicpc.net/problem/2426',2426,'세계적인 석유 재벌','1초','128 MB',20,'<p>세계적인 석유 재벌 "규현 조 압둘 티크리티 안드레스 후세인 리오넬 솔레르 살라 마리우 두스 산투스 펠리스 빈 자이드 술탄 친나왓 뱅거 7세"는 집 앞에 정원이 있다. 정원의 관리인은 그냥 홍태석이다. 이 석유 재벌은 앱등이 출신으로, 애플제품이면 모두 사모은다. 그의 집에는 아이팟 터치, 아이팟 나노, 아이폰, 맥북, 애플 티비, 아이패드 등등 전세계의 모든 애플 제품이 있다. 애플을 너무 좋아하기 때문에 정원에는 N개의 사과 나무가 있다.</p>

<p>홍태석은 나무에 비료를 주는 일과, 나무에 대한 통계를 내는 일 2가지만 한다. 다른 일은 해봤자 망치기 때문에, 전혀 하지 않는다.</p>

<p>나무에 비료를 주기 위해서 세계적인 비료 회사 "Telcontar"에서 만든 "BbuRiJaMaJaJaRam"을 사용한다. 이 비료를 나무에 뿌리면, 그 나무는 즉시 1cm 자란다. 이 비료는 병에 담겨져서 나오는데, 모든 병은 제한된 용량 Ci가 있다. 이 C<sub>i</sub>는 몇 개의 나무에 비료를 뿌릴지에 쓰인다. 게다가 모든 병에는 나무의 최소 높이 H<sub>i</sub>가 있다. 규현 조 압둘 티크리티 안드레스 후세인 리오넬 솔레르 살라 마리우 두스 산투스 펠리스 빈 자이드 술탄 친나왓 뱅거 79세는 가능하면 모든 트리를 크게 만들라고 그냥 홍태석에게 시켰다. 홍태석은 나무 중에 적어도 높이가 H<sub>i</sub> 센치미터인 서로 다른 C<sub>i</sub>개의 가장 작은 나무를 골라서 비료를 뿌린다.</p>

<p>통계를 낼 때는, 주어진 구간에 속하는 높이의 나무의 개수를 구하는 것이다. 세계적인 석유 재벌 규현 조 압둘 티크리티 안드레스 후세인 리오넬 솔레르 살라 마리우 두스 산투스 펠리스 빈 자이드 술탄 친나왓 뱅거 7세는 홍태석에게 일처리좀 빨리 하라고 강요했기 때문에, 홍태석은 결국 이 일을 대신하는 프로그램을 작성하기로 했다. 홍태석이 해야 하는 일의 목록이 주어졌을 때, 홍태석을 위해 통계를 구해주는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫째 줄에는 N과 M이 있다. N은 나무의 개수이고, M은 홍태석이 해야 하는 일의 개수이다. 둘째 줄에는 각 나무의 처음 높이가 주어진다. 이 높이는 모두 1보다 크거나 같고, N보다 작거나 같은 정수이다. 다음 M개의 줄에는 홍태석이 해야 하는 일이 시간 순서대로 주어진다. 각각의 입력은 문자 T<sub>i</sub> (홍태석이 해야 하는 일의 타입)로 시작된다. (T<sub>i</sub> = F 또는 T<sub>i</sub> = c)</p>

<p>만약, T<sub>i</sub> = F라면, 두 개의 정수 C<sub>i</sub>와 H<sub>i</sub>가 주어진다. 이 줄이 의미하는 것은 홍태석이 높이가 적어도 H<sub>i</sub>센치미터인 가장 작은 나무 C<sub>i</sub>개를 골라서 "BbuRiJaMaJaJaRam" 비료를 뿌리는 것이다. 만약, 높이가 적어도 H<sub>i</sub>센치미터인 나무의 개수가 C<sub>i</sub>개 보다 작으면, 남은 비료는 버린다. (한 번 비료를 뿌릴 때면, 하나의 나무에 두번 뿌릴 수 없다.)</p>

<p>만약, T<sub>i</sub> = C이면, min<sub>i</sub>와 max<sub>i</sub>가 입력으로 주어진다. 이것은 홍태석이 통계를 내야 하는 개수이다. 나무의 높이 H가 min<sub>i</sub>와 max<sub>i</sub> 사이에 있는 나무의 개수를 구하면 된다. (min<sub>i</sub>&nbsp;≤&nbsp;H ≤ max<sub>i</sub>) (1 ≤ N, M ≤ 100,000, 1 ≤ C<sub>i</sub>&nbsp;≤ N, 0 ≤ H<sub>i</sub>&nbsp;≤ 1,000,000,000, 1 ≤ min<sub>i</sub>&nbsp;≤ max<sub>i</sub>&nbsp;≤ 1,000,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>홍태석이 해야 하는 일의 타입이 C일때 마다, 해당하는 나무의 개수를 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 7
1 3 2 5 2
F 2 1
C 3 6
F 2 3
C 6 8
F 2 1
F 2 2
C 3 5','3
0
5','DATA_STRUCTURE'),
                                                                                                                (6349,'BAEKJOON','https://www.acmicpc.net/problem/2453',2453,'부서 배치','1초','128 MB',19,'<p>게임업체인 KOI (Kernel Operation International)는 2011년 신입사원을 두 개의 개발부서 A, B에 적절히 나누어서 배치하려고 한다. 그런데 사원들 중에는 같이 일을 하고 싶어 하는 “친구관계”인 사람들과 같은 부서에서 일하기를 싫어하는 “경쟁관계”인 사람들이 있다.</p>

<p>x와 y가 친구 관계이면 +(x,y)로 표시하고, 경쟁관계이면 -(x,y)로 표시한다. 단 두 사람 x와 y가 +(x,y)와 -(x,y)를 동시에 만족할 수는 없다. 그리고 친구관계와 경쟁관계에는 대칭성이 있어서 +(x,y)이면 +(y,x)도 성립하고, -(x,y)이면 -(y,x)도 항상 성립된다. &nbsp;</p>

<p>신입사원 전체를 A, B 두 부서에 배치하는 KOI식 배정 원칙은 다음과 같다.</p>

<ol>
	<li>모든 신입사원은 두 부서 중 &nbsp;한 부서에는 반드시 배치되어야 한다.</li>
	<li>+(x,y) 관계인 x와 y는 &nbsp;반드시 같은 부서에 배치되어야 한다.&nbsp;</li>
	<li>-(x,y) 관계인 x와 y는 반드시 서로 다른 부서에 배치되어야 한다.</li>
	<li>두 부서 A와 B에 배정된 인원수의 차이는 최소가 되어야 한다.</li>
</ol>

<p>3명의 신입사원 {1,2,3}이 있고 이들의 관계가 다음 표의 R1과 같다면 이들은 KOI식 배치가 가능하다. 왜냐하면 {1,2,3} 모두를 A나 B 한쪽 부서로 전부 배치하면 되기 때문이다.&nbsp;</p>

<table class="table table-bordered table-center-30 td-center th-center">
	<thead>
		<tr>
			<th>R1</th>
			<th>R2</th>
			<th>R3</th>
			<th>R4</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
			<p>+(1,2)</p>

			<p>+(2,3)</p>

			<p>+(1,3)</p>
			</td>
			<td>
			<p>+(1,2)</p>

			<p>-(2,3)</p>

			<p>-(3,1)</p>
			</td>
			<td>
			<p>-(1,2)</p>

			<p>-(2,3)</p>

			<p>-(3,1)</p>
			</td>
			<td>
			<p>+(1,2)</p>

			<p>+(2,3)</p>

			<p>-(3,1)</p>
			</td>
		</tr>
	</tbody>
</table>

<p>R2의 경우라면 A={1,2} B = {3}로 배치할 수 있다. 그런데 R3의 경우라면 경쟁관계인 어떤 두 사람은 같은 부서에 배치될 수밖에 없으므로 KOI식 배치가 불가능하다. R4의 경우도 KOI식 배치가 불가능한데, &nbsp;A={1,2}, B={3}로 배치하면 친구관계인 2와 3이 다른 부서에 배치되고, A={2,3}, B={1}로 나누면 친구관계인 1과 2가 서로 다른 부서로 분리 배치되기 때문이다.&nbsp;</p>

<p>신입사원이 4명인 경우를 생각해보자. 이 경우 아래 R5나 R6의 경우에는 모두 KOI식 배치는 가능하다. R5의 경우 &nbsp;KOI식 배치를 하면 양쪽 부서원의 차이는 2명이며, R6의 경우 그 두 부서원의 차이는 0, 즉 두 부서의 인원은 같다.&nbsp;</p>

<table class="table table-bordered table-center-20 td-center th-center">
	<thead>
		<tr>
			<th>R5</th>
			<th>R6</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
			<p>+(1,2)</p>

			<p>+(2,3)</p>
			</td>
			<td>
			<p>+(1,2)</p>

			<p>+(3,4)</p>
			</td>
		</tr>
	</tbody>
</table>

<p>여러분은 주어진 친구, 경쟁관계 데이터를 이용해서 KOI식 배치가 가능한지를 판단하는 프로그램을 작성해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>이 파일에는 항상 5개의 검사용 데이터가 주어진다.&nbsp;</p>

<p>각 검사용 데이터의 첫 줄에는 신입사원의 수 N, 그리고 친구 또는 경쟁 관계를 나타내는 자료의 수 M이 하나의 공백을 두고 나타난다.&nbsp;</p>

<p>이 문제에서 N명의 신입사원은 정수 1, 2,3,..., N으로 표시된다. 그리고 이어지는 M개의 줄에는 +(x,y)와 -(x,y)의 관계가 각각 1 x y 과 -1 x y 의 형식으로 &nbsp;주어진다. &nbsp;N과 M은 3 이상 10,000 이하의 정수이다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력 파일에 제시된 5개의 검사용 데이터에 대하여 KOI식 부서배치가 가능한지를 계산하여 그 결과를 5개의 줄에 각각 출력한다. 만일 KOI식 배치가 가능하면 두 부서 인원의 차이를 나타내는 음이 아닌 정수 값을 출력하고, 만일 KOI식 배치가 불가능하면 음수 ‘-1’을 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
-1 1 2
-1 2 3
-1 3 1
4 4
-1 1 3
1 1 2
1 3 4
-1 4 2
7 8
1 1 2
1 2 3
1 3 1
-1 3 4
-1 2 5
1 5 6
1 6 7
1 5 7
3 3
1 1 3
1 1 2
-1 2 3
5 3
1 4 5
1 4 3
1 4 2
','-1
0
1
-1
3
','DATA_STRUCTURE'),
                                                                                                                (6350,'BAEKJOON','https://www.acmicpc.net/problem/2461',2461,'대표 선수','2초','256 MB',15,'<p>KOI 중학교에는 N개의 학급이 있으며, 각 학급의 학생 수는 모두 M명으로 구성된다. 이 중학교에서는 체육대회에 새로운 종목의 경기를 추가하였다. 이 경기에 대해 모든 학생들은 저마다의 능력을 나타내는 능력치를 가지고 있으며, 이 능력치는 모든 학생이 서로 다르다.</p>

<p>이 경기는 한반에서 한 명의 대표선수를 선발하여 치른다. 경기의 형평성을 위하여, 각각의 반에서 대표로 선발된 모든 학생들의 능력치 중 최댓값과 최솟값의 차이가 최소가 되도록 선수를 선발하려고 한다. 예를 들어, N=3, M=4인 경우 학생들의 능력치가 1반=[12, 16, 67, 43], &nbsp;2반=[7, 17, 68, 48], 3반=[14, 15, 77, 54]로 주어질 때, 각 학급으로부터 능력치 16, 17, 15를 가진 학생을 각각 선택하면, 최댓값과 최솟값의 차이가 17-15=2로 최소가 된다.&nbsp;</p>

<p>대표로 선발된 모든 학생들 능력치의 최댓값과 최솟값 차이가 최소가 되는 경우의 값을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에는 학급의 수를 나타내는 N과 각 학급의 학생의 수를 나타내는 M이 하나의 빈칸을 사이에 두고 주어진다. 단, 1 ≤ N, M ≤ 1,000이다. 두 번째 줄부터 N개의 줄에는 각 줄마다 한 학급 학생들의 능력치를 나타내는 M개의 양의 정수가 하나의 빈칸을 사이에 두고 주어진다. 능력치는 0이상 10<sup>9</sup>이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>대표로 선발된 모든 학생들 능력치의 최댓값과 최솟값 차이가 최소가 되는 경우의 값을 하나의 정수로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
12 16 67 43
7 17 68 48
14 15 77 54
','2','DATA_STRUCTURE'),
                                                                                                                (6354,'BAEKJOON','https://www.acmicpc.net/problem/2463',2463,'비용','1초','128 MB',16,'<p>간선(혹은 에지)에 가중치가 주어진 그래프가 있다. 정점들의 수가 N일 때, 모든 정점은 1부터 N까지 번호가 붙여져 있고, 모든 간선들의 가중치는 서로 다르다. 이때 서로 다른 두 정점 u,v에 대하여, Cost(u,v)는 다음에서 제거되는 간선들의 가중치 합이다: u와 v사이의 경로가 있으면 이 그래프의 최소 가중치 간선을 그래프에서 제거한다. 이 과정을 u와 v사이의 경로가 없을 때까지 반복한다.</p>

<p>예를 들어, 6개의 정점으로 이루어진 다음 그래프를 고려해 보자.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/7b221c03-a670-4b02-936a-691209b66487/-/preview/" style="width: 332px; height: 150px;"></p>

<p>두 정점 2, 6에 대하여, Cost(2,6)을 구하는 과정에서 제거되는 간선들을 차례대로 나열하면 다음과 같다: (2, 3), (4, 5), (3, 5), (3, 4), (2, 6).</p>

<p>이들 간선들 중 (2, 6)이 제거될 때, 두 정점 2와 6사이의 경로가 없으므로 간선 제거가 끝나게 된다. 따라서 &nbsp;Cost(2,6) = 2 + 3 + 4 + 5 + 6 = 20이다.</p>

<p>간선에 가중치가 있는 그래프가 주어질 때, u < v인 모든 두 정점 u, v에 대한 Cost(u,v)들의 총 합을 구하는 프로그램을 작성하시오. 총 합이 10<sup>9</sup>보다 크거나 같으면 이를 10<sup>9</sup>으로 나눈 나머지를 출력한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정점의 수 N (1< ≤ N ≤ 100,000)과 간선의 수 M (1 ≤ M ≤ 100,000)이 빈칸을 사이에 두고 주어진다. 다음 M개의 각 줄에 간선 하나에 대한 정보를 나타내는 세 개의 양의 정수 x,y,w가 빈칸을 사이에 두고 주어진다. 이는 간선 (x,y)의 가중치가w 임을 의미한다. 1 ≤ w ≤ 100,000이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>u < v인 모든 두 정점 에 대한 Cost(u,v)들의 총 합을 첫째 줄에 출력한다. 단, 총 합이 10<sup>9</sup>보다 크거나 같으면&nbsp;이를 10<sup>9</sup>으로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 7
1 2 10
2 3 2
4 3 5
6 3 15
3 5 4
4 5 3
2 6 6
','256
','DATA_STRUCTURE'),
                                                                                                                (6352,'BAEKJOON','https://www.acmicpc.net/problem/2465',2465,'줄 세우기','1초','128 MB',18,'<p>N명의 사람들이 어떤 공연장에 입장하기 위해서 한 줄로 서 있다. 줄 서 있는 각 사람은 자기 앞에 서 있는 사람들 중에서 자기보다 키가 작거나 같은 사람들의 수를 알고 있다. 그러면, 이 수들을 표시하는 수열을 S라고 한다.</p>

<p>N명의 키 집합과 수열 S가 주어질 때, 원래 줄 서 있는 키 순서를 정확히 찾아내는 프로그램을 작성하시오.&nbsp;</p>

<p>예를 들어서, 사람들의 키 집합이 다음과 같이 주어진다 (여기서, 같은 키의 사람들이 여러 명 존재할 수 있어서 중복이 포함된다).&nbsp;</p>

<p style="text-align: center;">{120, 167, 163, 172, 145, 134, 182, 155,&nbsp;167, 120, 119, 156}</p>

<p>또한 각 사람이 자기 앞에 있는 사람들 중에서 자기보다 키가 작거나 같은 사람들의 수를 표시하는 수열 S는 다음과 같이 주어진다.&nbsp;</p>

<p style="text-align: center;">S : 0 1 0 0 3 2 6 7 4 6 9 4</p>

<p>그러면, 실제 줄 서 있는 사람들의 키 순서는 다음과 같다.&nbsp;</p>

<p style="text-align: center;">134 167 120 119 156 120 167 182 155 163 &nbsp;172 145</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 전체 사람의 수 N (1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에 사람들의 키를 나타내는 양의 정수가 하나씩 주어진다. 여기서 모든 키들은 2×10<sup>9</sup>이하이다. 그리고 마지막 줄에 수열 S가 한 줄로 주어진다. 단 그 수열의 수는 하나의 공백을 두고 나타난다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 N개의 줄로 구성된다. N개의 줄 각각에 원래 줄 서 있는 사람들의 키를 순서대로 하나씩 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12
120
167
163
172
145
134
182
155
167
120
119
156
0 1 0 0 3 2 6 7 4 6 9 4
','134
167
120
119
156
120
167
182
155
163
172
145
','DATA_STRUCTURE'),
                                                                                                                (6355,'BAEKJOON','https://www.acmicpc.net/problem/2466',2466,'책장','1초','128 MB',22,'<p>찬수는 1번에서 N번까지 번호가 매겨진 N권의 책을 가지고 있다. 찬수는 이 책을 꽂을 수 있는 책장을 설계하려고 한다. 찬수가 가지고 있는 i번 책의 두께는 t<sub>i</sub>이고, 높이는 h<sub>i</sub>이다. 단, 1 ≤ i ≤ N이다. 이 책들을 번호 순서대로 책장에 꽂아야하고 번호의 순서를 임의로 바꾸어 꽂을 수 없다.</p>

<p>이 책들을 책장의 가장 아래 칸부터 위 칸의 순서로, 같은 칸에서는 왼쪽부터 오른쪽으로 책의 번호 순서로 꽂는다. 한번 위 칸으로 옮겨와서 책을 꽂으면 다시 아래 칸으로 내려가서 책을 꽂을 수 없다. 책장의 칸의 높이는 그 칸에 꽂는 책들 중 가장 높이가 높은 책에 의해 결정되며 책이 꽂혀있는 칸들의 높이의 합이 책장의 높이가 된다. 책장의 폭은 꽂혀있는 책의 두께의 합이 가장 큰 칸에 의해 결정된다. 단, 책장을 구성하는 나무의 두께는 고려하지 않는다.&nbsp;</p>

<p>책을 모두 꽂은 후의 책장 전체의 높이를 H, 책장의 폭을 L이라고 할 때, 찬수는 H와 L중 최댓값을 최소로 하는 책장을 설계하려고 한다.</p>

<p>이 책장의 H와 L중 최댓값을 최소로 하는 책장을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에 책의 수를 나타내는 하나의 정수 N이 주어진다.&nbsp;두 번째 줄부터 N개의 줄에, 책들의 번호 순서대로 한 줄에 한권씩, 각 책에 대한 두께 t<sub>i</sub>와 높이 h<sub>i</sub>를 나타내는 두 정수가 하나의 빈칸을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 책을 모두 꽂은 후의 책장 전체의 높이와 책장의 폭 중에서 최댓값을 최소로 하는 값을 하나의 정수로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
8 6
2 3
6 5
4 5
5 7
1 2
5 4
','16
','DATA_STRUCTURE'),
                                                                                                                (6362,'BAEKJOON','https://www.acmicpc.net/problem/2493',2493,'탑','1.5초','128 MB',11,'<p>KOI 통신연구소는 레이저를 이용한 새로운 비밀 통신 시스템 개발을 위한 실험을 하고 있다. 실험을 위하여 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다.&nbsp;</p>

<p>예를 들어 높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 모든 탑에서는 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자. 그러면, 높이가 4인 다섯 번째 탑에서 발사한 레이저 신호는 높이가 7인 네 번째 탑이 수신을 하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신을 한다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신을 하지 못한다.</p>

<p>탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 탑의 수를 나타내는 정수 N이 주어진다. N은 1 이상 500,000 이하이다. 둘째 줄에는 N개의 탑들의 높이가 직선상에 놓인 순서대로 하나의 빈칸을 사이에 두고 주어진다. 탑들의 높이는 1 이상 100,000,000 이하의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 주어진 탑들의 순서대로 각각의 탑들에서 발사한 레이저 신호를 수신한 탑들의 번호를 하나의 빈칸을 사이에 두고 출력한다. 만약 레이저 신호를 수신하는 탑이 존재하지 않으면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
6 9 5 7 4
','0 0 2 2 4
','DATA_STRUCTURE'),
                                                                                                                (6363,'BAEKJOON','https://www.acmicpc.net/problem/2504',2504,'괄호의 값','1초','128 MB',11,'<p>4개의 기호 ‘<code>(</code>’, ‘<code>)</code>’, ‘<code>[</code>’, ‘<code>]</code>’를 이용해서 만들어지는 괄호열 중에서 올바른 괄호열이란 다음과 같이 정의된다.</p>

<ol>
	<li>한 쌍의 괄호로만 이루어진 ‘<code>()</code>’와 ‘<code>[]</code>’는 올바른 괄호열이다. </li>
	<li>만일 <code>X</code>가 올바른 괄호열이면 ‘<code>(X)</code>’이나 ‘<code>[X]</code>’도 모두 올바른 괄호열이 된다. </li>
	<li><code>X</code>와 <code>Y</code> 모두 올바른 괄호열이라면 이들을 결합한 <code>XY</code>도 올바른 괄호열이 된다.</li>
</ol>

<p>예를 들어 ‘<code>(()[[]])</code>’나 ‘<code>(())[][]</code>’ 는 올바른 괄호열이지만 ‘<code>([)]</code>’ 나 ‘<code>(()()[]</code>’ 은 모두 올바른 괄호열이 아니다. 우리는 어떤 올바른 괄호열 <code>X</code>에 대하여 그 괄호열의 값(괄호값)을 아래와 같이 정의하고 값(<code>X</code>)로 표시한다. </p>

<ol>
	<li>‘<code>()</code>’ 인 괄호열의 값은 2이다.</li>
	<li>‘<code>[]</code>’ 인 괄호열의 값은 3이다.</li>
	<li>‘<code>(X)</code>’ 의 괄호값은 2×값(<code>X</code>) 으로 계산된다.</li>
	<li>‘<code>[X]</code>’ 의 괄호값은 3×값(<code>X</code>) 으로 계산된다.</li>
	<li>올바른 괄호열 <code>X</code>와 <code>Y</code>가 결합된 <code>XY</code>의 괄호값은 값(<code>XY</code>)= 값(<code>X</code>)+값(<code>Y</code>) 로 계산된다.</li>
</ol>

<p>예를 들어 ‘<code>(()[[]])([])</code>’ 의 괄호값을 구해보자. ‘<code>()[[]]</code>’ 의 괄호값이 2 + 3×3=11 이므로 ‘<code>(()[[]])</code>’의 괄호값은 2×11=22 이다. 그리고 ‘<code>([])</code>’의 값은 2×3=6 이므로 전체 괄호열의 값은 22 + 6 = 28 이다.</p>

<p>여러분이 풀어야 할 문제는 주어진 괄호열을 읽고 그 괄호값을 앞에서 정의한대로 계산하여 출력하는 것이다. </p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 괄호열을 나타내는 문자열(스트링)이 주어진다. 단 그 길이는 1 이상, 30 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 그 괄호열의 값을 나타내는 정수를 출력한다. 만일 입력이 올바르지 못한 괄호열이면 반드시 0을 출력해야 한다. </p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','(()[[]])([])
','28
','DATA_STRUCTURE'),
                                                                                                                (6364,'BAEKJOON','https://www.acmicpc.net/problem/2517',2517,'달리기','1초','256 MB',17,'<p>KOI 장거리 달리기 대회가 진행되어 모든 선수가 반환점을 넘었다. 각 선수의 입장에서 자기보다 앞에 달리고 있는 선수들 중 평소 실력이 자기보다 좋은 선수를 남은 거리 동안 앞지르는 것은 불가능하다. 반대로, 평소 실력이 자기보다 좋지 않은 선수가 앞에 달리고 있으면 남은 거리 동안 앞지르는 것이 가능하다. 이러한 가정 하에서 각 선수는 자신이 앞으로 얻을 수 있는 최선의 등수를 알 수 있다. </p>

<p>각 선수의 평소 실력은 정수로 주어지는데 더 큰 값이 더 좋은 실력을 의미한다. 현재 달리고 있는 선수를 앞에서 부터 표시했을 때 평소 실력이 각각 2, 8, 10, 7, 1, 9, 4, 15라고 하면 각 선수가 얻을 수 있는 최선의 등수는 (같은 순서로) 각각 1, 1, 1, 3, 5, 2, 5, 1이 된다. 예를 들어, 4번째로 달리고 있는 평소 실력이 7인 선수는 그 앞에서 달리고 있는 선수들 중 평소 실력이 2인 선수만 앞지르는 것이 가능하고 평소실력이 8과 10인 선수들은 앞지르는 것이 불가능하므로, 최선의 등수는 3등이 된다.</p>

<p>선수들의 평소 실력을 현재 달리고 있는 순서대로 입력 받아서 각 선수의 최선의 등수를 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 선수의 수를 의미하는 정수 N이 주어진다. N은 3 이상 500,000 이하이다. 이후 N개의 줄에는 정수가 한 줄에 하나씩 주어진다. 이 값들은 각 선수들의 평소 실력을 앞에서 달리고 있는 선수부터 제시한 것이다. 각 정수는 1 이상 1,000,000,000 이하이다. 단, 참가한 선수들의 평소 실력은 모두 다르다.  </p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 선수의 최선의 등수를 나타내는 정수 N개를 입력에 주어진 선수 순서와 동일한 순서로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
2
8
10
7
1
9
4
15
','1
1
1
3
5
2
5
1
','DATA_STRUCTURE'),
                                                                                                                (6365,'BAEKJOON','https://www.acmicpc.net/problem/2534',2534,'카드 배열','1초','128 MB',21,'<p>하나의 숫자가 쓰여 있는 카드가 N장이 있다. 쓰여 있는 숫자는 0부터 N-1 사이의 숫자 중 하나이며, 모든 카드의 숫자는 서로 다르다.&nbsp;</p>

<p>이 카드들 중에서 k개의 카드를 선택하여 배열한 순서를 C<sub>k-1</sub>, C<sub>k-2</sub>, ..., C<sub>0</sub> 라고 하자. 이렇게 배열된 k장의 카드가 N진법의 수를 나타낸다고 하면, 카드 Ci는 N진법의 수에서의 한 자리수를 의미하며 그 자릿수의 값은 C<sub>i</sub>*N<sup>i</sup>이다. 그러므로 배열된 카드의 수의 값은 C<sub>k-1</sub>×N<sup>k-1</sup> + C<sub>k-2</sub>×N<sup>k-2</sup> + ... + C<sub>0</sub>×N<sup>0</sup>이 된다.</p>

<p>배열되는 카드들 사이에는 C<sub>i&nbsp;</sub>> C<sub>j</sub> 형태의 제약조건이 주어진다. 제약조건&nbsp;&nbsp;C<sub>i&nbsp;</sub>> C<sub>j</sub>는&nbsp;&nbsp;C<sub>i</sub>&nbsp;숫자가&nbsp;&nbsp;C<sub>j</sub>&nbsp;숫자보다 커야함을 의미한다. 단, i != j.</p>

<p>예를 들어, N=4, K=3인 경우에 C<sub>2</sub> > C<sub>0</sub>, C<sub>0</sub> > C<sub>1</sub>의 제약조건이 주어졌다고 하자. 이 경우 가능한 카드의 배열은 (2, 0, 1), (3, 1, 2), (3, 0, 1), 그리고 (3, 0, 2) 네 가지 경우가 있다.&nbsp;</p>

<p>이 네 개의 경우들 중에서 가장 큰 수가 되는 카드의 배열은 (3, 1, 2)이고 이 수의 값은 3*4<sup>2</sup> + 1*4<sup>1</sup> + 2 = 54 이다. 또한, 가장 작은 수가 되는 카드 배열은 (2, 0, 1)이고 이 수의 값은 2×4<sup>2</sup> + 0×4<sup>1</sup> + 1 = 33이다.</p>

<p>전체 카드의 수와 선택할 카드의 수 그리고 제약조건들이 주어질 때, 제약조건을 만족하는 카드배열 중에서 가장 큰 값을 갖는 카드배열과 가장 작은 값을 갖는 카드배열을 찾아서 그 값의 차이를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 전체 카드의 수를 나타내는 N과 선택하는 카드의 수 k와 제약조건의 수 P가 하나의 빈칸을 사이에 두고 주어진다. 단, 3 ≤ k ≤ N ≤ 300,000, 0 ≤ P ≤ 1,000,000이다. 두 번째 줄부터 P개의 줄에는 각 줄마다 하나의 제약조건을 나타내는 두 개의 정수 a, b가 하나의 빈칸을 사이에 두고 주어진다. 이는 제약조건 C<sub>a</sub> > C<sub>b</sub>를 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>제약조건을 만족하는 카드배열 중에서 가장 큰 값을 갖는 카드배열과 가장 작은 값을 갖는 카드배열을 찾고, 그 값의 차이를 1,000,000,007로 나눈 나머지를 출력한다. 단, 제약조건을 만족하는 카드의 배열이 존재하지 않는 경우는 없다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3 2
2 0
0 1
','21
','DATA_STRUCTURE'),
                                                                                                                (6380,'BAEKJOON','https://www.acmicpc.net/problem/2574',2574,'마법색종이','1초','128 MB',22,'<p>1 간격으로 수평선과 수직선이 그어진 직사각형 모양의 마법 색종이를 가로 방향과 세로 방향으로 잘라서 작은 직사각형 조각들로 나누려고 한다. 처음에는 흰색 색종이 한 조각이 주어진다. 이 후로 한 점씩 주어질 때마다 아래의 규칙을 따르면서 색종이 조각을 자른다.</p>

<ol>
	<li>주어진 점이 흰색 색종이 조각에 포함되면, 그 점을 지나는 ‘수평선’을 따라 자른다. 이때 잘려진 두 조각 모두 ‘검정색’으로 색깔이 변한다.&nbsp;</li>
	<li>주어진 점이 검정색 색종이 조각에 포함되면, 그 점을 지나는 ‘수직선’을 따라 자른다. 이때 잘려진 두 조각 모두 ‘흰색’으로 색깔이 변한다.</li>
</ol>

<p>흰색 마법 색종이의 가로 길이와 세로 길이, 그리고 색종이 안에 점들이 순서를 가지고 주어질 때, 위의 규칙을 따라 색종이를 모두 자른 후 만들어지는 색종이 조각들 중에서 넓이가 가장 큰 조각과 넓이가 가장 작은 조각의 넓이를 각각 구하는 프로그램을 작성하시오. 단, 입력으로 주어지는 점들 중 어떤 두 점도 같은 수평선 위에 놓이거나 같은 수직선 위에 놓이지 않는다. 또한 맨 처음 주어진 색종이의 둘레에 위치하는 점들도 입력되지 않는다.</p>

<p>색종이의 가로 길이와 세로 길이는 모두 양의 정수로 주어진다. 그리고 색종이를 자르기 위해서 주어지는 점들의 위치는 자르기 전 색종이의 왼쪽 아래 꼭짓점에서 가로 방향으로 떨어진 거리와 세로 방향으로 떨어진 거리를 나타내는 두개의 정수로 주어진다. 예를 들어 아래 그림들에서 점 1의 위치는 (5,4)이다.</p>

<p>만약 가로의 길이와 세로의 길이가 각각 8과 7인 색종이를 자르기 위한 점들의 위치가 (5,4), (2,3), (3,1), (7,6), (6,2)의 순서로 주어진다고 하자. 먼저 첫째 점에 의해서 색종이는 그림 1과 같이 두 검정색 조각으로 잘려진다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/2c8ae171-eebe-4c63-a0c9-d6a608b95ae9/-/preview/" style="width: 216px; height: 198px;"></p>

<p style="text-align: center;">그림 1</p>

<p>이어서 두 번째 점에 의해서 그림 1의 아래쪽 검정색 조각이 그림 2와 같이 두 흰색 조각으로 나누어진다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/c1fe6118-aafd-4559-843c-c5972997d8db/-/preview/" style="width: 216px; height: 197px;"></p>

<p style="text-align: center;">그림 2</p>

<p>나머지 점들에 대해서도 모두 위와 같은 방식으로 색종이를 자르면 그림 3과 같이 된다. 이 경우 가장 큰 색종이 조각의 넓이는 21이고 가장 작은 색종이 조각의 넓이는 3이다.</p>

<p style="text-align:center"><img alt="" src="https://upload.acmicpc.net/22d2b155-9878-486f-847f-7abbdb644ebc/-/preview/" style="width: 216px; height: 197px;"></p>

<p style="text-align:center">그림 3</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 색종이의 가로의 길이와 세로의 길이를 나타내는 양의 정수가 빈칸을 사이에 두고 주어진다. 가로와 세로의 길이는 모두 40,000 이하이다. 둘째 줄에는 색종이를 자르기 위한 점의 개수를 나타내는 양의 정수 N이 주어진다. N은 30,000 이하이다. 셋째 줄부터 마지막 줄까지 색종이를 자르기 위한 점들의 위치가 한 줄에 하나씩 순서대로 주어진다. 점들의 위치는 빈칸을 사이에 두고 가로 방향의 거리가 주어진 다음 세로 방향의 거리가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 잘려진 색종이 조각 중에서 가장 넓이가 큰 조각의 넓이와 가장 작은 조각의 넓이가 몇 인지를 빈칸을 사이에 두고 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8 7
5
5 4
2 3
3 1
7 6
6 2
','21 3
','DATA_STRUCTURE'),
                                                                                                                (6375,'BAEKJOON','https://www.acmicpc.net/problem/2601',2601,'도서실카펫','1초','128 MB',20,'<p>우리 학교는 다른 학교가 부러워하는 도서실을 가지고 있다. 장서를 다량 보유하고 있을 뿐 아니라 전자도서를 볼 수 있는 컴퓨터도 여러 대 설치되어 있고, 바닥에는 카펫이 깔려있다. 최근 도서실의 가구배치를 새로 하게 되었는데, 가구가 놓여있던 자리에는 얼룩이 져서 아주 보기가 흉하였다. 그래서 새로산 카펫 한 장으로 얼룩진 부분을 가리기로 하였다.</p>

<p>도서실은 직사각형 모양이고, 얼룩진 부분도 모두 직사각형 모양이며, 변은 도서실 벽과 평행하다. 새 카펫은 정사각형이다. 이 정사각형 카펫을 도서실의 벽과 평행하도록 놓는데, 완전히 가려지는 얼룩의 수를 최대화 하고자 한다.</p>

<p>예를 들어, 다음 그림과 같이 얼룩이 위치하고 있다고 하자. 점선으로 표시된 여분의 카펫으로 완전히 가릴 수 있는 얼룩의 최대 수는 4개가 되고, 이러한 카펫의 위치는 유일하지 않을 수 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/f258b2aa-c198-4498-83da-39ba9396301d/-/preview/" style="width: 267px; height: 205px;"></p>

<p>이러한 카펫으로 완전히 가려지는 최대 얼룩의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>모든 사각형의 좌표는 1,000,000 보다 작은 음이 아닌 정수이고 가로 세로의 길이는 1,000,000 보다 작은 양의 정수이다. 얼룩 직사각형은 서로 겹치지 않지만 접할 수는 있다. 얼룩 직사각형과 카펫 정사각형은 당연히 도서실 직사각형에 완전히 포함된다. 얼룩 직사각형의 수는 최대 100,000개이다.</p>

<p>첫째 줄에는 도서실 직사각형의 왼쪽 위 꼭지 점과 오른쪽 아래 꼭지 점의 좌표가 주어진다. 둘째 줄에는 카펫 정사각형의 가로 길이가 주어진다. 셋째 줄에는 얼룩의 수가 주어지고, 넷째 줄부터는 얼룩 직사각형들의 왼쪽 위 꼭지 점과 오른쪽 아래 꼭지 점의 좌표가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 여분의 카펫으로 완전히 가릴 수 있는 얼룩의 최대 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','0 10 15 0
6
7
1 2 3 1
3 4 5 2
7 5 9 4
7 8 8 6
9 7 11 6
10 5 11 4
12 4 14 2
','4
','DATA_STRUCTURE'),
                                                                                                                (6376,'BAEKJOON','https://www.acmicpc.net/problem/2605',2605,'줄 세우기','1초','128 MB',4,'<p>점심시간이 되면 반 학생 모두가 한 줄로 줄을 서서 급식을 탄다. 그런데 매일 같이 앞자리에 앉은 학생들이 앞에 줄을 서 먼저 점심을 먹고, 뒷자리에 앉은 학생들은 뒤에 줄을 서 늦게 점심을 먹게 된다. 어떻게 하면 이러한 상황을 바꾸어 볼 수 있을까 고민하던 중 선생님이 한 가지 방법을 내 놓았다. 그 방법은 다음과 같다.</p>

<p>학생들이 한 줄로 줄을 선 후, 첫 번째 학생부터 차례로 번호를 뽑는다. 첫 번째로 줄을 선 학생은 무조건 0번 번호를 받아 제일 앞에 줄을 선다. 두 번째로 줄을 선 학생은 0번 또는 1번 둘 중 하나의 번호를 뽑는다. 0번을 뽑으면 그 자리에 그대로 있고, 1번을 뽑으면 바로 앞의 학생 앞으로 가서 줄을 선다. 세 번째로 줄을 선 학생은 0, 1 또는 2 중 하나의 번호를 뽑는다. 그리고 뽑은 번호만큼 앞자리로 가서 줄을 선다. 마지막에 줄을 선 학생까지 이와 같은 방식으로 뽑은 번호만큼 앞으로 가서 줄을 서게 된다. 각자 뽑은 번호는 자신이 처음에 선 순서보다는 작은 수이다.</p>

<p>예를 들어 5명의 학생이 줄을 서고, 첫 번째로 줄을 선 학생부터 다섯 번째로 줄을 선 학생까지 차례로 0, 1, 1, 3, 2번의 번호를 뽑았다고 하자, 첫 번째 학생부터 다섯 번째 학생까지 1부터 5로 표시하면 학생들이 줄을 선 순서는 다음과 같이 된다.</p>

<ul>
	<li>첫 번째 학생이 번호를 뽑은 후 : 1</li>
	<li>두 번째 학생이 번호를 뽑은 후 : 2 1</li>
	<li>세 번째 학생이 번호를 뽑은 후 : 2 3 1</li>
	<li>네 번째 학생이 번호를 뽑은 후 : 4 2 3 1</li>
	<li>다섯 번째 학생이 번호를 뽑은 후 : 4 2 5 3 1</li>
</ul>

<p>따라서 최종적으로 학생들이 줄을 선 순서는 4, 2, 5, 3, 1이 된다.</p>

<p>줄을 선 학생들이 차례로 뽑은 번호가 주어질 때 학생들이 최종적으로 줄을 선 순서를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 학생의 수가 주어지고 둘째 줄에는 줄을 선 차례대로 학생들이 뽑은 번호가 주어진다. 학생의 수가 100 이하이고, 학생들이 뽑는 번호는 0 또는 자연수이며 학생들이 뽑은 번호 사이에는 빈 칸이 하나씩 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>학생들이 처음에 줄을 선 순서대로 1번부터 번호를 매길 때, 첫째 줄에 학생들이 최종적으로 줄을 선 순서를 그 번호로 출력한다. 학생 번호 사이에는 한 칸의 공백을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
0 1 1 3 2
','4 2 5 3 1
','DATA_STRUCTURE'),
                                                                                                                (6377,'BAEKJOON','https://www.acmicpc.net/problem/2696',2696,'중앙값 구하기','1초','128 MB',14,'<p>어떤 수열을 읽고, 홀수번째 수를 읽을 때 마다, 지금까지 입력받은 값의 중앙값을 출력하는 프로그램을 작성하시오.</p>

<p>예를 들어, 수열이 1, 5, 4, 3, 2 이면, 홀수번째 수는 1번째 수, 3번째 수, 5번째 수이고, 1번째 수를 읽었을 때 중앙값은 1, 3번째 수를 읽었을 때는 4, 5번째 수를 읽었을 때는 3이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스의 첫째 줄에는 수열의 크기 M(1 ≤ M ≤ 9999, M은 홀수)이 주어지고, 그 다음 줄부터 이 수열의 원소가 차례대로 주어진다. 원소는 한 줄에 10개씩 나누어져있고, 32비트 부호있는 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해 첫째 줄에 출력하는 중앙값의 개수를 출력하고, 둘째 줄에는 홀수 번째 수를 읽을 때 마다 구한 중앙값을 차례대로 공백으로 구분하여 출력한다. 이때, 한 줄에 10개씩 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
9
1 2 3 4 5 6 7 8 9
9
9 8 7 6 5 4 3 2 1
23
23 41 13 22 -3 24 -31 -11 -8 -7
3 5 103 211 -311 -45 -67 -73 -81 -99
-33 24 56
','5
1 2 3 4 5
5
9 8 7 6 5
12
23 23 22 22 13 3 5 5 3 -3
-7 -3
','DATA_STRUCTURE'),
                                                                                                                (6381,'BAEKJOON','https://www.acmicpc.net/problem/2716',2716,'원숭이 매달기','1초','128 MB',9,'<p>깊은 아마존 정글에 거대한 나무들에서 갈색 원숭이들이 매우 좋아하는 무화과가 열리고, 이 나무에는 향나무노린재들이 서식하고 있다.</p>

<p>나무 꼭대기에 도달하기 위해서 원숭이들은 매우 조심스럽게 나무에 올라가는 길을 찾아야한다. 거대한 나무는 부서지기 쉬운 덩굴들이 있는데 이 덩굴들은 시소의 원리와 비슷하다. 덩굴의 무게가 불균형 하면 그 덩굴은 끊어지며 그 원숭이들은 땅으로 떨어져버린다. 원숭이들은 서로 협력하여 덩굴의 균형을 유지한다면 그들은 모두 무화과가 열리고 향나무노린재들이 서식하는 나무 꼭대기에 도달할 수 있다는 것을 발견했다.</p>

<p>덩굴은 두개의 덩굴로 나눠질 수 있는데 덩굴이 끊어지지 않기 위해서는 나눠진 두 덩굴은 같은 수의 원숭이들이 매달려 있어야한다. 덩굴의 나눠지는 지점을 "[]"로 정의 내리면 덩굴의 구조를 꺾쇠괄호로 표시할 수 있다. 또한 덩굴의 깊이는 25를 넘지 않는다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/monkey.png" style="width: 360.833px; height: 204.167px;"></p>

<p>원숭이들은 덩굴의 균형을 유지하면서 나무꼭대기에 도달할 수 있는 최소 원숭이 수를 알고 싶다. 나무 꼭대기에 도달하기 위해서 최소 한 마리 원숭이가 필요하다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 N(1 ≤ N ≤ 1000)이 주어진다.</p>

<p>각 테스트 케이스는 한 줄로 이루어져 있고, 덩굴의 구조를 꺾쇠괄호로 표현한 문자열이 주어진다. 문자열의 길이는 0보다 크거나 같고, 150보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 덩굴의 균형을 유지하면서 나무꼭대기에 도달할 수 있는 최소 원숭이 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 입력의 2번째 테스트 케이스는 빈 줄 입니다.</p>

				</div>
				</div>','3
[]

[[][[]]]
','2
1
8
','DATA_STRUCTURE'),
                                                                                                                (6382,'BAEKJOON','https://www.acmicpc.net/problem/2776',2776,'암기왕','2초','256 MB',7,'<p>연종이는 엄청난 기억력을 가지고 있다. 그래서 하루 동안 본 정수들을 모두 기억 할 수 있다. 하지만 이를 믿을 수 없는 동규는 그의 기억력을 시험해 보기로 한다. 동규는 연종을 따라 다니며, 연종이 하루 동안 본 정수들을 모두 ‘수첩1’에 적어 놓았다. 그것을 바탕으로 그가 진짜 암기왕인지 알아보기 위해, 동규는 연종에게 M개의 질문을 던졌다. 질문의 내용은 “X라는 정수를 오늘 본 적이 있는가?” 이다. 연종은 막힘없이 모두 대답을 했고, 동규는 연종이 봤다고 주장하는 수 들을 ‘수첩2’에 적어 두었다. 집에 돌아온 동규는 답이 맞는지 확인하려 하지만, 연종을 따라다니느라 너무 힘들어서 여러분에게 도움을 요청했다. 동규를 도와주기 위해 ‘수첩2’에 적혀있는 순서대로, 각각의 수에 대하여, ‘수첩1’에 있으면 1을, 없으면 0을 출력하는 프로그램을 작성해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트케이스의 개수&nbsp;T가 들어온다. 다음 줄에는 ‘수첩 1’에 적어 놓은 정수의 개수 N(1 ≤ N ≤ 1,000,000)이 입력으로 들어온다. 그 다음 줄에 &nbsp;‘수첩 1’에 적혀 있는 정수들이 N개 들어온다. 그 다음 줄에는 ‘수첩 2’에 적어 놓은 정수의 개수 M(1 ≤ M ≤ 1,000,000) 이 주어지고, 다음 줄에 ‘수첩 2’에 적어 놓은 정수들이 입력으로 M개 들어온다. 모든 정수들의 범위는 int 로 한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>‘수첩2’에 적혀있는 M개의 숫자 순서대로, ‘수첩1’에 있으면 1을, 없으면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
5
4 1 5 2 3
5
1 3 7 9 5
','1
1
0
0
1
','DATA_STRUCTURE'),
                                                                                                                (6383,'BAEKJOON','https://www.acmicpc.net/problem/2788',2788,'스타트업','5초','128 MB',21,'<p>요즘 한국에는 스타트업 열풍이 불고 있다. 상근이는 스타트업에게 사무실을 빌려주는 스타트업을 시작했다. 사무실은 총 N개가 있다. 가장 왼쪽에 있는 사무실은 1번, 가장 오른쪽은 N번이며, 그 사이 사무실은 순서대로 번호가 매겨져 있다.&nbsp;</p>

<p>처음에 사무실은 모두 비어있다. 사무실에 회사가 입주할 때, 회사는 상근이에게 다음과 같은 네 가지 정보를 알려주어야 한다.</p>

<ul>
	<li>T: 입주일 (상근이가 스타트업을 시작한 날이 1일이다)</li>
	<li>K: 사무실 번호</li>
	<li>Z: 하루 수익 (회사가 손해를 보고있다면 음수일 수도 있다)</li>
	<li>S: 입주일 당시에 그 회사가 가지고 있는 금액</li>
</ul>

<p>만약 입주하려고 하는 사무실 K에 이미 회사가 있다면, K에 있던 회사는 짐을 싸서 사무실을&nbsp;비워야 한다. 또, 입주하는 날은 하루종일 이사를 해야 하기 때문에, 일을 하지 않아서 수익을 올리지 않는다.</p>

<p>놀랍게도 이 사무실에 입주한 회사는 매일 매일 Z만큼 수익을 올리며, 이 금액은 늘어나지도, 줄어들지도 않는다.</p>

<p>가끔 상근이는 가장 부유한 회사가 어디인지 알아본다. 항상 연속으로 붙어있는 사무실을 조사하며, 다음과 같이 나타낼 수 있다.</p>

<ul>
	<li>T: 조사하는 날 (상근이가 스타트업을 시작한 날이 1일)</li>
	<li>A와 B: A번 사무실부터 B번까지 조사</li>
</ul>

<p>상근이는 항상 입주한 회사의 모든 업무가 끝난 다음에 조사를 한다. (사무실에서 밤 8시가 넘었는데 일을 할 수 없다) 따라서, 각 회사가 하루에 버는 수익은 항상 입주할 때 보고한 금액이다.</p>

<p>이벤트의 정보가 주어졌을 때, 조사에 대한 답을 구하는 프로그램을 작성하시오. 회사가 입주하는 정보와 상근이가 조사하는 정보를 합쳐서&nbsp;이벤트라고 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 사무실의 개수 N과 이벤트의 개수 M이 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ M ≤ 300,000)</p>

<p>다음 M개 줄에는 이벤트의 정보가 주어진다. 회사의 입주는 "1 T K Z S"와 같이 주어지며, 상근이의 조사는 "2 T A B"로 주어진다.</p>

<p>모든 이벤트는 일어난 순서대로 주어진며, 하루에 일어나는 이벤트는 최대 한 개 이다. 따라서, T가 항상 증가하는 순서로 주어진다. 마지막 이벤트가 일어난 날은 10<sup>6</sup>보다 작으며, Z와 S의 절댓값도 10<sup>6</sup>보다 작다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>상근이의 질문에 대한 답(주어진 구간에 포함 되는 가장 부유한 회사가 가지고 있는 금액)을 한 줄에 하나씩 출력한다. 만약, 그 구간에 있는 회사가 하나도 없다면, "nema"를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 4
1 1 1 2 4
1 2 2 3 2
2 5 1 2
2 7 1 2
','12
17
','DATA_STRUCTURE'),
                                                                                                                (6385,'BAEKJOON','https://www.acmicpc.net/problem/2812',2812,'크게 만들기','1초','128 MB',13,'<p>N자리 숫자가 주어졌을 때, 여기서 숫자 K개를 지워서 얻을 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 주어진다. (1 ≤ K < N ≤ 500,000)</p>

<p>둘째 줄에 N자리 숫자가 주어진다. 이 수는 0으로 시작하지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력으로 주어진 숫자에서 K개를 지웠을 때 얻을 수 있는 가장 큰 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2
1924
','94
','DATA_STRUCTURE'),
                                                                                                                (6384,'BAEKJOON','https://www.acmicpc.net/problem/2820',2820,'자동차 공장','1초','256 MB',18,'<p>상근이는 자동차를 매우 좋아한다. 자동차 공장에 취직한 상근이는 계속된 승진 끝에 드디어 사장이 되었다. 공장에는 총 N명의 직원이 있다. 상근이를 제외한 모든 직원은 한 명의 상사가 있다. (상근이는 모든 사람의 상사이다) 상근이의 번호는 1번이고, 나머지 직원의 번호는 2부터 N이다.</p>

<p>모든 직원은 자신의 모든 부하 직원(직속 부하와 부하의 부하등등을 모두 포함)의 월급을 인상하거나 삭감할 수 있다. 상근이는 권력 남용을 막기 위해 직원의 월급을 모니터링 하려고 한다.</p>

<p>월급의 변화를 모니터링하는 프로그램을 작성하시오.</p>

<p>모든 직원의 월급은 항상&nbsp;양의 정수이고 2<sup>31</sup>-1 이하이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 직원의 수 N과 월급 변화와 조사 쿼리의 수 M이 주어진다. (1 ≤ N, M ≤ 500,000)</p>

<p>다음 N개 줄의 i번째 줄에는 직원 i의 초기 월급과 상사의 번호가 주어진다. (상근이는 상사가 없기 때문에, 초기 월급만 주어진다)</p>

<p>다음 M개 줄에는 월급 변화와 조사 쿼리가 주어진다.</p>

<ol>
	<li>p a x가 주어진 경우 a의 모든 부하의 월급을 x만큼 증가시킨다. (-10,000 ≤ x ≤ 10,000)</li>
	<li>u a가 주어진 경우에는 a의 월급을 출력한다.</li>
</ol>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력으로 u가 주어질 때마다 해당하는 직원의 월급을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 3
5
3 1
p 1 5
u 2
u 1
','8
5
','DATA_STRUCTURE'),
                                                                                                                (6387,'BAEKJOON','https://www.acmicpc.net/problem/2832',2832,'정렬','1초','128 MB',17,'<p>상근이는 다음과 같은 정렬 알고리즘을 만들었다.</p>

<pre>reverse-sort(sequence a)
    while (A is not in nondecreasing order)
        partition a into the minimum number of slopes
        for every slope with length greater than one
            reverse(slope)</pre>

<p>여기서 slope란 감소하는 a의 연속 부분 수열이다. reverse는 그 구간의 순서를 뒤집는다.</p>

<p>1부터 N으로 이루어진 길이가 N인 순열이 주어진다. 처음에 순열의 slope의 길이는 모두 짝수이다. reverse를 몇 번 호출하는지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. (2 ≤ N ≤ 100,000) 둘째 줄에는 정렬해야 하는 순열이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 reverse를 몇 번 호출하는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
2 1
','1
','DATA_STRUCTURE'),
                                                                                                                (6389,'BAEKJOON','https://www.acmicpc.net/problem/2835',2835,'인기도 조사','1초','128 MB',14,'<p>최근에 상근이가 살고 있는 나라에서는 인구 조사가 있었다. 사실 이번 인구 조사의 진짜 이유는 바로 텔레비전 인기도 조사이다.</p>

<p>각 사람이 텔레비전을 시청한 시간은 아래와 같은 형식이다.</p>

<p>HH:MM:SS - HH:NN:SS</p>

<p>앞 시간은 그 사람이 텔레비전을 시청하기 시작한 시간이며, 다음 시간은 시청을 마친 시간이다. 사람들은 그 구간의 가장 처음과 마지막 초에도 텔레비전을 시청한다. 만약, 어떤 사람이 자정이 넘기 전(23:45:30) 에 텔레비전을 시작했다면, 다음날 텔레비전 시청을 종료한다. (01:15:00)</p>

<p>모든 데이터를 수집했고, 이제 이 데이터를 분석하려고 한다.</p>

<p>어떤 초의 인기도는 그 초에 티비를 보고 있던 사람의 수로 나타낼 수 있다. 또, 구간의 인기도는 구간에 포함되는 초의 인기도의 합을 그 구간의 길이로 나눈 값이다.</p>

<p>Q개의 구간이 주어졌을 때, 그 구간의 인기도를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 상근이가 살고 있는 나라의 국민의 수 N이 주어진다. (N ≤ 100,000)</p>

<p>다음 N개 줄에는 각 사람이 티비를 시청한 구간이 문제에서 설명한 대로 주어진다. (0 ≤ HH ≤ 23, 0 ≤ MM ≤ 59, 0 ≤ SS ≤ 59)</p>

<p>다음 줄에는 인기도를 조사하려고 하는 구간의 수 Q가 주어진다. (Q ≤ 100,000)</p>

<p>다음 Q개 줄에는 인기도를 구하려고 하는 구간이 같은 형식으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 Q개의 구간에 대해서 각 구간의 인기도를 출력한다. 정답과의 오차는 최대 10<sup>-6</sup>까지 허용한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
00:00:00 - 00:00:01
00:00:01 - 00:00:03
00:00:00 - 00:00:02
00:00:05 - 00:00:09
00:00:06 - 00:00:06
5
00:00:00 - 00:00:03
00:00:07 - 00:00:09
00:00:06 - 00:00:06
00:00:05 - 00:00:09
00:00:00 - 00:00:09
','2.0000000000
1.0000000000
2.0000000000
1.2000000000
1.4000000000
','DATA_STRUCTURE'),
                                                                                                                (6390,'BAEKJOON','https://www.acmicpc.net/problem/2841',2841,'외계인의 기타 연주','1초','256 MB',10,'<p>상근이의 상상의 친구 외계인은 손가락을 수십억개 가지고 있다. 어느 날 외계인은 기타가 치고 싶었고, 인터넷에서 간단한 멜로디를 검색했다. 이제 이 기타를 치려고 한다.</p>

<p>보통 기타는 1번 줄부터 6번 줄까지 총 6개의 줄이 있고, 각 줄은 P개의 프렛으로 나누어져 있다. 프렛의 번호도 1번부터 P번까지 나누어져 있다.</p>

<p>멜로디는 음의 연속이고, 각 음은 줄에서 해당하는 프렛을 누르고 줄을 튕기면 연주할 수 있다. 예를 들면, 4번 줄의 8번 프렛을 누르고 튕길 수 있다. 만약, 어떤 줄의 프렛을 여러 개 누르고 있다면, 가장 높은 프렛의 음이 발생한다.</p>

<p>예를 들어, 3번 줄의 5번 프렛을 이미 누르고 있다고 하자. 이때, 7번 프렛을 누른 음을 연주하려면, 5번 프렛을 누르는 손을 떼지 않고 다른 손가락으로 7번 프렛을 누르고 줄을 튕기면 된다. 여기서 2번 프렛의 음을 연주하려고 한다면, 5번과 7번을 누르던 손가락을 뗀 다음에 2번 프렛을 누르고 연주해야 한다.</p>

<p>이렇게 손가락으로 프렛을 한 번 누르거나 떼는 것을 손가락을 한 번 움직였다고 한다. 어떤 멜로디가 주어졌을 때, 손가락의 가장 적게 움직이는 회수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 멜로디에 포함되어 있는 음의 수 N과 한 줄에 있는 프렛의 수 P가 주어진다. (1 ≤ N ≤ 500,000, 2 ≤ P ≤ 300,000)</p>

<p>다음 N개 줄에는 멜로디의 한 음을 나타내는 두 정수가 주어진다. 첫 번째 정수는 줄의 번호이고 두 번째 정수는 그 줄에서 눌러야 하는 프렛의 번호이다. 입력으로 주어진 음의 순서대로 기타를 연주해야 한다. 줄의 번호는 N보다 작거나 같은 자연수이고, 프렛의 번호도 P보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 멜로디를 연주하는데 필요한 최소 손가락 움직임을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 15
2 8
2 10
2 12
2 10
2 5
','7
','DATA_STRUCTURE'),
                                                                                                                (6388,'BAEKJOON','https://www.acmicpc.net/problem/2843',2843,'마블','1초','128 MB',18,'<p>민혁이는 매주 금요일마다 지수와 함께 논다. 이번 주 금요일은 지수와 민혁이가 친구가 된지 십 년이 되는 날이다. 따라서, 둘은 엄청난 게임을 하기로 결정했다. 민혁이는 바닥이 흙인 운동장을 예약했고, 지수는 조약돌 한 개를 들고 왔다.</p>

<p>먼저 민혁이는 운동장 바닥에 나뭇가지로 방향 그래프를 그린다. 이 그래프에서 모든 정점은 많아야 한 개의 나가는 간선(outgoing edge)를 가질 수 있다. 그 다음 민혁이는 조약돌을 한 정점 위에 올려 놓는다. 만약, 조약돌이 있는 정점에 나가는 간선이 있다면, 조약돌은 그 간선을 통해서 이동할 수 없을 때까지 계속해서 이동한다. 더 이상 이동할 수 있는 정점이 없다면, 조약돌은 그 자리에서 멈춘다. 조약돌은 그래프를 무한히 이동할 수도 있고, 방문하지 않는 정점이 있을 수도 있다.</p>

<p>민혁이는 지수가 게임의 규칙을 확실하게 이해했는지 알기 위해서 다음과 같은 두 가지 질문을 하려고 한다.</p>

<ul>
	<li>1 X - 조약돌을 정점 X에 놓았을 때, 조약돌이 무한히 움직이지 않는다면 조약돌이 멈추는 정점의 번호는 몇 번인가?</li>
	<li>2 X - 정점 X에서 나가는 간선을 지운다. (항상 나가는 간선이 있는 정점만 주어진다)</li>
</ul>

<p>민혁이의 질문이 주어졌을 때, 지수의 답변을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 그래프의 정점의 개수 N이 주어진다. (1 ≤ N ≤ 300,000)</p>

<p>둘째 줄에는 각 정점의 나가는 간선이 공백으로 구분되어서 주어진다. 정점의 번호는 1부터 시작하며, 나가는 간선이 없는 경우에는 0이 주어진다.</p>

<p>셋째 줄에는 민혁이의 질문의 수 Q가 주어진다. (1 ≤ Q ≤ 300,000)</p>

<p>넷째 줄부터 Q개 줄에는 문제 설명에 나온 질문 형식대로 민혁이의 질문이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1로 시작하는 쿼리가 주어질때 마다, 조약돌이 멈추는 정점의 번호를 한 줄에 하나씩 출력한다. 만약, 어떤 정점에 멈추지 않고 무한히 이동한다면, CIKLUS를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
2 3 1
7
1 1
1 2
2 1
1 2
1 1
2 2
1 2
','CIKLUS
CIKLUS
1
1
2
','DATA_STRUCTURE'),
                                                                                                                (6392,'BAEKJOON','https://www.acmicpc.net/problem/2849',2849,'탭댄스','1초','128 MB',20,'<p>창영이와 현우는 탭댄스 학원을 다니고 있다. 탭댄스는 밑창에 탭(tap)이라는 쇠붙이를 붙인 구두를 신고 리듬감 있게 플로어를 쳐서 경쾌한 소리를 내며 추는 춤이다. 알고보니 창영이와 현우는 춤에 소질이 있었고, 이제 그들만의 안무를 만들려고 한다.</p>

<p>탭댄스의 안무는 L과 R로 이루어진 수열로 묘사할 수 있다. L은 왼쪽 발로, R은 오른쪽 발로 바닥을 탭하는 것이다. 창영이는 같은 발을 두 번 연속해서 사용하지 않을 때, 탭댄스의 진가가 나타난다고 생각한다. 따라서, 창영이는 안무의 점수를 만들었다. 안무의 점수는 L과 R이 두 번 연속해서 나오지 않는 연속된 원소들로 이루어진 가장 긴 부분 수열의 길이이다.</p>

<p>안무를 만드는 것은 매우 어려운 일이다. 현우는 창영이의 춤을 본 뒤, 안무에서 수정할 부분을 알려주었다. 창영이는 매번 수정할 때 마다 안무의 점수를 구하려고 한다. 안무의 수정은 하나의 L을 R로 또는 R을 L로 바꾸는 것이다.</p>

<p>가장 처음에 창영이가 만든 안무에는 L만 포함하고 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 창영이의 안무의 길이 N(1≤ N ≤ 200,000)과 현우가 안무를 수정한 횟수 Q(1≤ Q ≤ 200,000)가 주어진다.</p>

<p>다음 Q개 줄에는 현우가 안무의 몇 번째를 수정했는지가 순서대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 Q개의 정수로 이루어져 있다. 현우가 창영이의 안무를 수정할 때마다 안무의 점수를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 2
2
4
','3
5
','DATA_STRUCTURE'),
                                                                                                                (6393,'BAEKJOON','https://www.acmicpc.net/problem/2867',2867,'수열의 값','1초','128 MB',17,'<p>수열의 값이란 수열에서 가장 큰 원소와 가장 작은 원소의 차이이다.</p>

<p>예를 들어, (3, 1, 7, 2)는 수열의 값이 6이고, (42, 42)는 0이다.</p>

<p>수열이 주어졌을 때, 모든 부분 수열의 값의 합을 출력하는 프로그램을 작성하시오 .</p>

<p>(3, 1, 7, 2)의 부분 수열은 총 10개 (3), (1), (7), (2), (3,1), (1,7), (7,2), (3,1,7), (1,7,2), (3,1,7,2) 가 있고, 각각의 수열의 값을 구한뒤 이를 합하면 31이 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N(2 ≤ N ≤ 300,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수열의 원소가 한 줄에 하나씩 주어진다. 원소는 100,000,000보다 크지 않은 양의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 입력으로 주어진 수열의 부분 수열의 값의 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1
2
3
','4
','DATA_STRUCTURE'),
                                                                                                                (6394,'BAEKJOON','https://www.acmicpc.net/problem/2898',2898,'고대 자물쇠','1초','128 MB',13,'<p>한중혁은 자신의 몬스터 트럭으로 도시의 절반을 날려버린 대가로 유명한 고고학자의 조수로 일하게 되었다. 그의 임무 중 하나는 고대 문서 상자의 열쇠를 만드는 일이다.</p>

<p>고대 문서 상자는 흥미로운 자물쇠가 달린 정교한 매커니즘으로 구성되어있다. 각각의 자물쇠는 너비 W cm, 높이 L cm 이며 상단부, 하단부, 그리고 이 둘 사이의 빈 공간으로 구성되어있다. 상단부와 하단부는 음이아닌 정수의 수열 r1, r2, r3, ..., rL로 나타내진다.</p>

<p>각 자물쇠에 맞는 열쇠는 가장자리 사이의 공간에 완벽하게 맞는 작은 점토 탭으로 되어있다. 아래 그림은 7cm X 8cm 형태의 자물쇠와 이에 맞는 열쇠를 나타낸다. 상단부를 나타내는 수열은 {2, 1, 3, 2, 3, 2, 3}이며 하단부를 나타내는 수열은 {3, 4, 2, 3, 2, 3, 4}이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/8377c495-0c12-4a6b-b104-4a9637683713/-/preview/" style="width: 253px; height: 223px;"></p>

<p>한중혁은 하나의 열쇠가 두 개 이상의 자물쇠를 열 수도 있다는 것을 발견했다. 열쇠를 만드는 작업은 매우 힘들기 때문에 최소한의 열쇠로 모든 자물쇠를 열고자 한다. 한중혁의 작업을 덜어주기 위해, 최소 몇 개의 열쇠를 만들어야 하는지 알려주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에는 자물쇠의 너비 W (1 ≤ W ≤ 10<sup>8</sup>), 자물쇠의 길이 L (1 ≤ L ≤ 1000), 그리고 자물쇠의 개수 N (1 ≤ N ≤ 100)이 주어진다.</p>

<p>다음 2N개의 줄은 자물쇠의 정보를 나타낸다. 각 줄은 W보다 작은 L개의 수로 구성되어 있으며 상단부를 나타내는 수열과 하단부를 나타내는 수열이 주어진다. 모든 자물쇠는 상단부와 하단부 사이에 적어도 1cm의 빈 공간이 존재한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한중혁이 만들어야 할 열쇠의 최소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8 7 2
2 1 3 2 3 2 3
3 4 2 3 2 3 4
3 2 4 3 4 3 4
2 3 1 2 1 2 3
','1
','DATA_STRUCTURE'),
                                                                                                                (6379,'BAEKJOON','https://www.acmicpc.net/problem/2905',2905,'홍준이와 울타리','1초','256 MB',19,'<p>홍준이는 오래된 울타리를 색칠해야한다. 이 울타리는 너비가 1cm이고 높이가 여러 가지인 널빤지 N개로 만들어졌다. 색칠을&nbsp;빨리 하기 위해, 홍준이는 롤러 Super Paint Roller Deluxe를 샀다. 이 롤러의 폭은 X cm이다. 홍준이는 색칠을 할 때, 롤러의 모든 부분이 널빤지를 벗어나지않게&nbsp;해야한다. 그렇지 않으면&nbsp;페인트가 흘러서 주위를 얼룩지게 할 수 있다. 또한, 색칠&nbsp;중에 롤러는 언제나 땅과 평행해야한다. 즉, 홍준이가 롤러를 안전하게 쓰기 위해서는, X개의 연속된 널빤지를 선택해서 맨 밑에서부터 X개의 널빤지 중 가장 높이가 낮은 널빤지 전체를 색칠할 때까지, 한 번에 색칠해야한다. 그 다음&nbsp;다른 X개의 널빤지를 선택해서, 같은 방법으로 칠하는 작업을 반복한다.</p>

<p>이렇게 색칠하면&nbsp;널빤지의 몇 부분이 색칠되지 않으므로, 홍준이는 그 부분을 칫솔로 페인트칠&nbsp;해야한다. 이건 누구나 알다시피 지루한 작업이기 때문에, 홍준이는 여러분에게 Super Paint Roller Deluxe를 이용해서 가장 많은 영역을 색칠할 수 있도록 도움을 요청했다. 이러한 방법이 여러 가지 있다면, 홍준이는&nbsp;최소한의 롤러질 횟수로 색칠하려고한다. 홍준이를 도와, 칫솔로 칠해야&nbsp;할 널빤지의 최소 넓이와 최소 롤러질 횟수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 널빤지의 수 N (1 ≤ N ≤ 1 000 000), Super Paint Roller Deluxe의 너비 X (1 ≤ X ≤&nbsp;100 000, X ≤ N)가 주어진다.</p>

<p>두 번째 줄에 널빤지들의 높이를 의미하는 1 000 000 이하의 자연수 N개가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 홍준이가 칫솔로 칠해야하는&nbsp;널빤지 넓이의 최솟값을&nbsp;출력한다.</p>

<p>두 번째 줄에 이때&nbsp;필요한 최소한의 롤러질 횟수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
5 3 4 4 5
','3
2
','DATA_STRUCTURE'),
                                                                                                                (6341,'BAEKJOON','https://www.acmicpc.net/problem/2906',2906,'폭발 사고','1초','128 MB',19,'<p>준규는 화학과 대학원생이다. 준규의 랩에서는 최근 흥미로운 테입을 발견했다. 이 테입은 N개의 서로 같은 길이의 조각으로 이뤄져 있는데, 두 조각 사이는 쉽게 구부러지지만 정확히 180도로만 구부러진다.</p>

<p>테입의 한 면은 매우 불안정한 휘발성 화학물질로 코팅되어 있다. 만약 이 코팅된 면끼리 닿는다면 엄청난 폭발이 일어날 것이다.</p>

<p>테입의 다른 한 면은 아직 다 코팅이 끝나지 않아서, 테입의 처음 A개 조각과 끝의 B개 조각만 코팅이 되어 있다. 물론 이 면의 코팅도 같은 화학물질로 코팅되어 있기 때문에 서로 닿으면 폭발한다.</p>

<p>준규는 이 테입이 폭발하지 않도록 구부릴 수 있는 방법의 수를 알고싶어 한다. 이 테입은 한 번 이상 구부릴 수 있으며, 두 조각 사이를 구부린 방법이 하나라도 다르면 다른 방법으로 센다.</p>

<p>답이 매우 커질 수 있기 때문에 방법의 수를 10301로 나눈 나머지를 출력한다.</p>

<p>아래 예시는 N=4, A=1, B=1일 때 가능한 방법의 수를 나타낸 것이다. 단, 아래 그림에서는 편의를 위해 90도 구부린 것으로 그려져 있지만 실제 준규는 이 테입을 180도로 구부린다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/52ce6484-e80c-42f5-a5cd-6ec9932b8b1c/-/preview/" style="width: 344.167px; height: 161.667px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에 자연수 N, A, B(A>0, B>0, A+B ≤ N ≤ 1000)가 주어진다. N은 조각의 수, A는 테입의 왼쪽에 코팅된 조각의 수, B는 테잎의 오른쪽에 코팅된 조각의 수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가능한 방법의 수를 10301로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 1 1
','6
','DATA_STRUCTURE'),
                                                                                                                (6413,'BAEKJOON','https://www.acmicpc.net/problem/2910',2910,'빈도 정렬','1초','128 MB',8,'<p>위대한 해커 창영이는 모든 암호를 깨는 방법을 발견했다. 그 방법은 빈도를 조사하는 것이다.</p>

<p>창영이는 말할 수 없는 방법을 이용해서 현우가 강산이에게 보내는 메시지를 획득했다. 이 메시지는 숫자 N개로 이루어진 수열이고, 숫자는 모두 C보다 작거나 같다. 창영이는 이 숫자를 자주 등장하는 빈도순대로 정렬하려고 한다.</p>

<p>만약, 수열의 두 수 X와 Y가 있을 때, X가 Y보다 수열에서 많이 등장하는 경우에는 X가 Y보다 앞에 있어야 한다. 만약, 등장하는 횟수가 같다면, 먼저 나온 것이 앞에 있어야 한다.</p>

<p>이렇게 정렬하는 방법을 빈도 정렬이라고 한다.</p>

<p>수열이 주어졌을 때, 빈도 정렬을 하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째&nbsp;줄에 메시지의 길이 N과 C가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ C&nbsp;≤ 1,000,000,000)</p>

<p>둘째 줄에 메시지 수열이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 입력으로 주어진 수열을 빈도 정렬한 다음 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
2 1 2 1 2
','2 2 2 1 1
','DATA_STRUCTURE'),
                                                                                                                (6416,'BAEKJOON','https://www.acmicpc.net/problem/2912',2912,'백설공주와 난쟁이','1초','256 MB',19,'<p>백설 공주와 난쟁이 N명과 함께 숲 속에 살고 있다. 난쟁이는 매일 광산에 일하러가고, 백설 공주는 그동안 페이스북을 하고 있다.</p>

<p>매일 아침 난쟁이는 한 줄로 휘파람을 불면서 광산으로 출근을 한다. 백설 공주는 그 주변을 돌아다니면서 난쟁이들 사진을 찍는다.</p>

<p>난쟁이가 광산에 들어가면, 백설 공주는 다시 집으로 돌아간다. 집으로 돌아가면서 찍은 사진 중에 페이스북에 올릴 예쁜 사진을 고른다. 각 난쟁이는 모두 모자를 쓰고 있다. 모자의 색상은 총 C가지가 있다. 사진에 찍힌 난쟁이가 쓰고 있는 모자의 색상 중 절반보다 많은 색이 같은 색이라면 예쁜 사진이다. 즉, 사진에 난쟁이가 K명 찍혀있고, K/2보다 많은 난쟁이의 모자 색이 같다면 예쁜 사진이다.</p>

<p>백설공주가 찍은 사진 M개와 각 사진에 찍힌 난쟁이가 주어졌을 때, 예쁜 사진인지 아닌지를 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 난쟁이의 수 N과 모자 색상의 수 C가 주어진다. (3 ≤ N ≤ 300,000, 1 ≤ C ≤ 10,000)</p>

<p>둘째 줄에는 각 난쟁이가 쓰고 있는 모자의 색상이 줄을 서 있는 순서대로 주어진다. 색상은 C이하의 자연수로 나타낸다.</p>

<p>셋째 줄에는 사진의 수 M이 주어진다. (1 ≤ M ≤ 10,000)</p>

<p>다음 M개 줄에는 두 정수 A와 B가 주어진다. (1 ≤ A ≤ B ≤ N) 이 줄은 사진의 정보를 의미하고, A번째 난쟁이부터 B번째 난쟁이까지 사진에 찍혔다는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 총 M 줄이다. 각 사진이 예쁘지 않다면 "no"를 출력하고, 예쁘다면 "yes X"를 출력한다. 예쁜 사진인 경우에 X는 사진에 절반이 넘는 모자의 색상이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 3
1 2 1 2 1 2 3 2 3 3
8
1 2
1 3
1 4
1 5
2 5
2 6
6 9
7 10
','no
yes 1
no
yes 1
no
yes 2
no
yes 3
','DATA_STRUCTURE'),
                                                                                                                (6417,'BAEKJOON','https://www.acmicpc.net/problem/2927',2927,'남극 탐험','5초','128 MB',21,'<p>상근이는 "얼음을 꿈꾸다" 여행사의 사장이다. 이 여행사는 남극 근처의 섬 N개를 구매해 당일치기 여행을 제공하고 있다. 관광객들에게 가장 인기 있는 동물은 황제 펭귄으로 섬에서 쉽게 찾을 수 있다.</p>

<p>여행사는 점점 인기를 얻게 되었고, 이제 보트를 이용하는 것이 효율적이지 않은 상황까지 이르렀다. 상근이는 섬 사이에 다리를 건설해 관광객을 버스로 이동시키려고 한다. 상근이는 컴퓨터 프로그램을 이용해서 다리를 건설하는 과정을 관리하려고 한다.</p>

<p>섬은 1번부터 N번까지 번호가 매겨져 있다. 가장 처음에는 아무 다리도 없으며, 각 섬에 펭귄이 몇 마리 살고있는지는 모두 알고있다. 펭귄의 수는 변할 수 있다. 하지만, 항상 0보다 크거나 같고, 1000보다 작거나 같다.</p>

<p>상근이의 프로그램은 다음과 같은 세 가지 명령을 수행할 수 있어야 한다.</p>

<ul>
	<li>"bridge A B" - 섬 A와 B사이에 다리를 건설하는 명령이다. (A와 B는 다르다) 이전까지 지어진 다리를 이용해서 이동할 수 없는 경우에만 다리를 지어야 한다. 다리를 지어야 하면 "yes", 지을 필요가 없이 이미 이동할 수 있으면 "no"를 출력한다.</li>
	<li>"penguins A X" - 섬 A에 살고있는 펭귄의 수를 다시 세보니 X마리가 되었다는 명령이다. 아무것도 출력할 필요가 없다.</li>
	<li>"excursion A B" - 관광객들이 섬 A에서 시작해 B에서 끝나는 여행 경로를 이용하는 명령이다. A에서 B로 갈 수 있는 경우에는 이동하는 섬에 있는 모든 펭귄의 수를 구해 출력한다. (A와 B 포함) 이동할 수 없는 경우에는 "impossible"를 출력한다.</li>
</ul>

<p>상근이의 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 섬의 수 N (1 ≤ N ≤ 30,000)이 주어진다.</p>

<p>둘째 줄에는 각 섬에 있는 펭귄의 수가 주어진다.</p>

<p>셋째 줄에는 명령의 개수 Q (1 ≤ Q ≤ 300,000)가 주어진다.</p>

<p>다음 Q개 줄에는 문제에서 주어진 명령 중 하나가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>"bridge"나 "excursion" 명령이 주어질 때 마다 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4 2 4 5 6
10
excursion 1 1
excursion 1 2
bridge 1 2
excursion 1 2
bridge 3 4
bridge 3 5
excursion 4 5
bridge 1 3
excursion 2 4
excursion 2 5
','4
impossible
yes
6
yes
yes
15
yes
15
16
','DATA_STRUCTURE'),
                                                                                                                (6425,'BAEKJOON','https://www.acmicpc.net/problem/2934',2934,'LRH 식물','1초','128 MB',17,'<p>상근이는 유전자 조작을 통해 줄기 두 개로 이루어진 식물을 만들었다. 이 식물은 줄기의 x좌표 L, R과 높이 H로 나타낼 수 있다. 아래 그림은 L=2, R=5, H=4인 식물이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/43949532-4476-43a6-9cd9-c81b375a5f91/-/preview/" style="width: 207px; height: 150px;"></p>

<p>상근이는 매일 매일 화단에 식물을 하나씩 심는다. 첫 번째 날에 심은 식물의 높이는 1이고, 그 다음날에 심은 식물은 전날에 심은 식물의 높이보다 1 크다.</p>

<p>새 식물의 줄기가 다른 식물의 수평 선분과 교차하는 경우가 있다. 이러한 경우에 그 위치에는 꽃이 하나 피게 된다. (이미 꽃이 있는 경우에는 꽃이 더 피지 않는다) 점에서 접하는 경우에는 꽃이 피지 않는다.</p>

<p>아래 그림은 예제를 나타낸 것이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/a2791ed1-78da-44e4-9e73-c042261d5b89/-/preview/" style="width: 339.167px; height: 60.8333px;"></p>

<p>모든 식물의 좌표가 주어졌을 때, 매일 매일 피는 꽃의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 식물을 심은 날의 수 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>다음 N개 줄에는 매일 매일 심은 식물의 두 줄기 좌표 L과 R이 주어진다. (1 ≤ L < R ≤ 100,000)&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 N개의 줄에 매일 매일 핀 꽃의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 4
3 7
1 6
2 6
','0
1
1
2
','DATA_STRUCTURE'),
                                                                                                                (6424,'BAEKJOON','https://www.acmicpc.net/problem/2957',2957,'이진 탐색 트리','1초(하단참고)','128 MB',16,'<p>이진 탐색 트리는 모든 노드가 많아야 2개의 자식 노드를 가지고 있는 트리이고, 각 노드에는 수가 하나씩 쓰여있다. 만약 어떤 노드에 쓰여 있는 수가 X라면, 그 노드의 왼쪽 서브트리에는 X보다 작은 수, 오른쪽 서브트리에는 X보다 큰 수만 저장되어 있어야 한다.</p>

<p>1보다 크거나 같고, N보다 작거나 같은 수 N개가 한 번씩 등장하는 수열이 입력으로 주어진다. 이 수열을 이용해서 이진 탐색 트리를 만들려고 한다. 이제 배열의 첫 번째 수를 루트 노드로 놓고, 다른 나머지 수들을 순서대로 삽입하면서 이진 탐색 트리를 만들려고 한다. 즉, 첫 번째 수를 제외한 모든 수에 대해서 insert(X,root)를 실행하는 것과 같다. 그 함수는 다음과 같다.&nbsp;</p>

<p>이진 탐색 트리에 삽입하는 함수는 다음과 같다.</p>

<pre>insert(number X, node N)
    카운터 C값을 1 증가시킨다
    if X가 노드 N에 있는 수보다 작다면
        if N의 왼쪽 자식이 없다면
            X를 포함하는 새 노드를 만든 뒤, N의 왼쪽 자식으로 만든다
        else
            insert(X, N의 왼쪽 자식)
    else (X가 노드 N에 있는 수보다 크다면)
        if N의 오른쪽 자식이 없다면
            X를 포함하는 새 노드를 만든 뒤, N의 오른쪽 자식으로 만들기
        else
            insert(X, N의 오른쪽 자식)</pre>

<p>각 수를 삽입한 후에 C의 값을 출력하는 프로그램을 작성하시오. 카운터 C의 값은 0으로 초기화되어 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 300,000)</p>

<p>다음 N개의 줄에는 수열의 수가 차례대로 주어진다. 수는 구간 [1, N]에 포함된 정수이고, 중복되지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>N개의 줄에 각 수가 트리에 삽입된 후에 카운터 C값을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1
2
3
4
','0
1
3
6
','DATA_STRUCTURE'),
                                                                                                                (6431,'BAEKJOON','https://www.acmicpc.net/problem/2964',2964,'벽과 못','1초','128 MB',21,'<p>상근이의 방의 한쪽 벽에는 못이 N개 박혀 있다. 아침에 일찍 일어나서 이 벽을 바라보며 하루를 어떻게 살 것인가를 생각하던 중에 상근이는 이 벽은 2차원 평면이고, 못은 그 평면 위의 점과 같다는 생각을 했다. 서로 다른 두 못은 같은 x좌표나 y좌표를 갖지 않는다.</p>

<p>마침 바닥에 고무줄이 하나 떨어져 있었다. 상근이는 고무줄 안에 모든 못이 포함되도록 못에 고무줄을 걸어 놓았다. 이 고무줄은 매우 비싼 고무줄이기 때문에 끊어지지 않는다.</p>

<p>상근이는 벽에 있는 못의 개수가 세 개보다 적어질 때까지 아래와 같은 과정을 거쳐 벽에 있는 못을 빼려고 한다.</p>

<ol>
	<li>고무줄이 만드는 다각형의 면적을 적는다.</li>
	<li>가장 왼쪽, 오른쪽, 위, 아래에 있는 못 중 하나를 고른다.</li>
	<li>2번에서 고른 못을 벽에서 제거한다. 그럼 고무줄은 남은 못을 모두 감싸게 된다.</li>
</ol>

<p>상근이가 2번 단계에서 고른 못이 어떤 못인지 주어졌을 때, 1번 단계에서 적는 면적을 모두 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 못의 개수 N이 주어진다. (3 ≤ N ≤ 300,000)</p>

<p>다음 N개 줄에는 못의 좌표가 주어진다. 모든 좌표는 1과 1,000,000,000 사이이며, 서로 다른 두 못이 같은 x좌표나 y좌표를 갖는 경우는 없다.</p>

<p>마지막 줄에는 L, R, U, D로 이루어진 N-2개의 문자열이 주어진다. 이 문자열은 상근이가 2번단계에서 고른 못의 정보이며, 다음과 같은 의미를 갖는다.</p>

<ul>
	<li>L: 가장 왼쪽 못 (가장 작은 x좌표)</li>
	<li>R: 가장 오른쪽 못 (가장 큰 x좌표)</li>
	<li>U: 가장 위쪽 못 (가장 큰 y좌표)</li>
	<li>D: 가장 아래쪽 못 (가장 작은 y좌표)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>상근이가 1번 단계에서 구하는 면적을 순서대로 한 줄에 하나씩 출력한다. 출력은 소수점 첫째 자리까지 출력한다. </p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 4
2 2
4 1
3 5
5 3
LUR
','9.0
6.5
2.5
','DATA_STRUCTURE'),
                                                                                                                (6426,'BAEKJOON','https://www.acmicpc.net/problem/2969',2969,'메뚜기','4초','128 MB',18,'<p>꽃밭에 N*N개의 꽃이 N행 N열로 심어져 있다. 이 꽃밭에는 메뚜기가 한 마리 있는데, 메뚜기는 모든 꽃의 꽃잎의 개수를 알고 있다.</p>

<p>메뚜기는 맨 처음에 R행 C열에 있는 꽃 위에 있고, 다음과 같은 규칙을 지키면서 최대한 많은 꽃을 방문하려고 한다.</p>

<ol>
	<li>메뚜기는 인접한 행 또는 열에 있는 꽃으로 점프할 수 있다. 만약, 인접한 행에 있는 꽃으로 이동할 때는, 적어도 두 열 이상 점프를 해야 한다. 또, 인접한 열에 있는 꽃으로 이동할 때는, 적어도 두 행 이상 점프를 해야 한다. 즉, (r<sub>1</sub>, c<sub>1</sub>)에서 (r<sub>2</sub>, c<sub>2</sub>)로 점프를 할 수 있으려면 다음과 같은 조건을 만족해야 한다.

	<ul>
		<li>|r<sub>1</sub>-r<sub>2</sub>| = 1인 경우 |c<sub>1</sub>-c<sub>2</sub>| > 1 또는</li>
		<li>|c<sub>1</sub>-c<sub>2</sub>| = 1인 경우 |r<sub>1</sub>-r<sub>2</sub>| > 1</li>
	</ul>
	</li>
	<li>점프하려고 하는 칸에 있는 꽃의 꽃잎의 개수는 현재 있는 칸의 꽃잎의 개수보다 많아야 한다.</li>
</ol>

<p>메뚜기가 최대 몇 개의 꽃을 방문할 수 있는지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. (1 ≤ N ≤ 1500)</p>

<p>둘째 줄에 메뚜기가 가장 처음에 있는 위치 R과 C가 주어진다. (1 ≤ R, C ≤ N)</p>

<p>다음 N개 줄에는 꽃잎의 수가 주어진다. 꽃잎의 수는 1,000,000보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최대 몇 개의 꽃을 방문할 수 있는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 1
1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 7
','4
','DATA_STRUCTURE'),
                                                                                                                (6433,'BAEKJOON','https://www.acmicpc.net/problem/2983',2983,'개구리 공주','1초','128 MB',17,'<p>트럭을 타고 이동하던 중에 상근이는 휴식을 취하기 위해서 호수에 잠시 들렸다. 호수에는 개구리가 살고 있고, 개구리는 호수 위에 떠있는 식물 N개를 점프하면서 다닌다. 오래된 전설에 따르면 개구리에게 키스를 하면 개구리는 아름다운 공주로 변한다고 한다. 일단 개구리를 잡아야 전설이 사실인지 아닌지 확인할 수 있다. 개구리를 잡아보자.</p>

<p>호수는 2차원 평면으로 생각할 수 있고, 식물은 그 평면 위의 점으로 나타낼 수 있다. (x, y)위에 있는 개구리는 아래 네 가지 방향 중 한 방향으로 점프할 수 있다.</p>

<ol>
	<li>임의의 양의 정수 P에 대해서, (x+P, y+P)로 점프할 수 있다. 이 방향을 A라고 한다.</li>
	<li>임의의 양의 정수 P에 대해서, (x+P, y-P)로 점프할 수 있다. 이 방향을 B라고 한다.</li>
	<li>임의의 양의 정수 P에 대해서, (x-P, y+P)로 점프할 수 있다. 이 방향을 C라고 한다.</li>
	<li>임의의 양의 정수 P에 대해서, (x-P, y-P)로 점프할 수 있다. 이 방향을 D라고 한다.</li>
</ol>

<p>개구리는 네 방향 중 한 방향을 고른다. 그 다음 그 방향에 있는 가장 가까운 식물로 점프를 한다. 만약, 고른 방향에 식물이 없다면, 개구리는 그 위치에 그대로 있는다. 개구리가 점프를 하고 난 이후에, 원래 있던 식물은 호수로 가라앉게되고 사라진다.</p>

<p>상근이는 식물의 위치와 개구리가 고른 방향을 모두 알고 있다. 상근이는 개구리의 점프가 끝나는 꽃의 좌표를 알아낸 다음, 거기서 개구리를 잡으려고 한다.</p>

<p>개구리의 점프가 끝나는 식물의 위치는 어디일까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 식물의 수 N과 점프의 수 K가 주어진다. (1 ≤ N, K ≤ 100,000)</p>

<p>둘째 줄에는 개구리가 고른 방향 K개가 주어진다. 이 방향은 A,B,C,D로만 이루어져 있다.</p>

<p>셋째 줄부터 N개 줄에는 식물의 좌표가 X, Y가 주어진다. (0 ≤ X, Y ≤ 1,000,000,000) 처음으로 주어지는 식물에 개구리가 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>개구리의 점프가 끝나는 식물의 좌표를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 5
ACDBB
5 6
8 9
4 13
1 10
7 4
10 9
3 7
','7 4
','DATA_STRUCTURE'),
                                                                                                                (6442,'BAEKJOON','https://www.acmicpc.net/problem/3002',3002,'아날로그 다이얼','1초','256 MB',19,'<p>아날로그 다이얼이란 0부터 9까지 각 숫자 중 하나를 항상 표시하고 있는 작은 기계이다. 다이얼에는 화면에 보이는 숫자를 1 증가시킬 수 있는 버튼도 있다. (9를 1 증가시키면 0이 된다)</p>

<p>상근이는 이러한 아날로그 다이얼을 N개 가지고 있고, 모두 책상에 일렬로 올려 놓았다. 왼쪽 기계부터 1번기계이며, 가장 오른쪽 기계는 N번 기계이다. 또, 기계의 앞에 무엇인가를 작성할 수 있도록 종이 두 장을 놓았다.</p>

<p>가장 처음에 상근이는 다이얼에 보이는 숫자를 첫 번째 종이에 적는다. 그 다음 다음과 같은 행동을 M번 반복한다.</p>

<p>1. 두 정수 A와 B를 고른 다음, 첫 번째 종이에 작성한다. (1 ≤ A ≤ B ≤ N)</p>

<p>2. A번째 다이얼부터 B번째 다이얼에 적혀있는 숫자의 합을 구한 다음에 두 번째 종이에 작성한다.</p>

<p>3. A번째부터 B번째 다이얼의 버튼을 한 번씩 누른다.</p>

<p>상근이는 위와 같은 게임(?)을 모두 완료했다. 하지만, 갑자기 벽에서 정인이가 튀어나왔고, 두 번째 종이와 다이얼 N개를 모두 들고 군대로 도망가버렸다.</p>

<p>상근이는 첫 번째 종이만 가지고 있다. 두 번째 종이에 쓰여 있는 수를 모두 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 250,000, 1 ≤ M ≤ 100,000)</p>

<p>둘째 줄에는 가장 처음에 다이얼에 표시된 숫자가 주어진다. 이 숫자는 공백없이 주어진다.</p>

<p>다음 M개 줄에는 상근이가 고른 숫자인 A와 B가 주어진다. (1 ≤ A ≤ B ≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 총 M개 줄이다. 상근이가 구한 다이얼의 합을 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
1234
1 4
1 4
1 4
','10
14
18
','DATA_STRUCTURE'),
                                                                                                                (6437,'BAEKJOON','https://www.acmicpc.net/problem/3006',3006,'터보소트','1초','128 MB',17,'<p>명우가 소트 알고리즘을 하나 발명했다. 이 알고리즘의 이름은 터보소트이다.&nbsp;</p>

<p>터보소트는 1부터 N까지 총 N개의 수가 섞여있을 때만 사용할 수 있으며, 다음과 같이 N단계로 이루어져 있다.</p>

<ul>
	<li>첫 번째 단계에서 숫자 1의 위치를 찾는다. 그 다음 바로 앞의 숫자와 위치를 바꾸어가면서, 1이 제일 앞에 오게 바꾼다.</li>
	<li>두 번째 단계에서는 숫자 N의 위치를 찾는다. 그 다음 바로 뒤의 숫자와 위치를 바꾸어가면서, N이 제일 마지막에 오게 바꾼다.</li>
	<li>세 번째&nbsp;단계는 숫자 2의 위치를 찾은 후에, 바로 앞의 숫자와 위치를 바꾸어가면서, 두 번째 위치에 오게 바꾼다.</li>
	<li>네 번째 단계는&nbsp;숫자 N-1의 위치를 찾은 다음에, 바로 뒤의 숫자와 위치를 바꾸면서, 뒤에서 2번째 위치에 오게 바꾼다.</li>
	<li>다섯 번째 단계도 위와 같은 식으로 하면 되고 이를 N번 반복하는 것이다.</li>
</ul>

<p>정리하면, 홀수번째 단계이면, 아직까지 고르지 않은 숫자 중 제일 작은 수를 고른 다음에, 그것을 인접한 숫자와 위치를 바꾸면서 올바른 위치로 이동시키고, 짝수번째 단계일때는, 제일 큰 수를 고른 다음에 위치를 이동시키는 것이다.</p>

<p>명우는 이때, 각 단계에서 숫자의 위치를 몇 번 바꾸는지 구하려고 한다.</p>

<p>1부터 N까지 총 N개의 수로 이루어진 배열이 주어졌을 때, 터보 소트의 각 단계에서, 숫자의 위치를 몇 번씩 바꾸는지 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이며, 배열의 크기이다.</p>

<p>둘째&nbsp;줄부터 N개의 줄에는 1보다 크거나 같고, N보다 작거나 같은 수가 중복 없이 주어진다. 이 숫자가 차례대로 배열에 포함되어 있는 수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 단계에서 숫자의 위치를 몇 번 바꾸는지 출력한다. 총 N줄을 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
2
1
3
','1
0
0
','DATA_STRUCTURE'),
                                                                                                                (6448,'BAEKJOON','https://www.acmicpc.net/problem/3015',3015,'오아시스 재결합','1초','256 MB',16,'<p>
	오아시스의 재결합 공연에 N명이 한 줄로 서서 기다리고 있다.</p>

<p>
	이 역사적인 순간을 맞이하기 위해 줄에서서 기다리고 있던 백준이는 갑자기 자기가 볼 수 있는 사람의 수가 궁금해 졌다.</p>

<p>
	두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.</p>

<p>
	줄에 서있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>
	첫째 줄에 줄에서 기다리고 있는 사람의 수 N이 주어진다. (1 ≤ N ≤ 500,000)</p>

<p>
	둘째 줄부터 N개의 줄에는 각 사람의 키가 나노미터 단위로 주어진다. 모든 사람의 키는 2<sup>31</sup> 나노미터 보다 작다.</p>

<p>
	사람들이 서 있는 순서대로 입력이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	서로 볼 수 있는 쌍의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
2
4
1
2
2
5
1
','10
','DATA_STRUCTURE'),
                                                                                                                (6449,'BAEKJOON','https://www.acmicpc.net/problem/3018',3018,'캠프파이어','1초','128 MB',8,'<p>이번 여름에 선영이와 친구들은 코딩 연습을 하기 위해 E일간 근처 바닷가로 MT를 갔다.</p>

<p>매일 밤에는 캠프파이어 시간이 있다. 캠프파이어에 참가하는 사람들은 모두 모여서 노래를 부른다. 캠프파이어는 필수 코스가 아니기 때문에, 매일 참가하고 싶은 사람만 참가한다.</p>

<p>MT에 참가한 사람 중 가장 인기있는 사람은 선영이다.&nbsp;</p>

<p>매일 밤, 선영이가 캠프파이어에 참가한다면, 나머지 사람들이 모르는 새로운 노래를 즉석에서 만들어 부른다. 사람들은 모두 그 노래만 캠프파이어가 끝날 때까지 부른다.</p>

<p>선영이가 피곤해서 캠프파이어에 참가하지 않는 날도 있다. 이 날은 사람들이&nbsp;각자 아는 노래를 서로 공유한다.</p>

<p>매일 캠프파이어에 참가하는 사람이 누구인지 주어졌을 때, 모든 노래를 알게되는 사람이 누구인지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 MT에 참가한 사람의 수 N이 주어진다. (1 ≤ N ≤ 100) 사람들은 1부터 N까지 번호가 매겨져 있으며, 선영이의 번호는 1이다.</p>

<p>둘째 줄에는 E가 주어진다. (1 ≤ E ≤ 50)</p>

<p>다음 E개 줄에는 그날 캠프파이어에 참가한 사람의 수 K와 참가한 사람의 번호가 주어진다. (2 ≤ K ≤ N)</p>

<p>선영이는 적어도 한 번 캠프파이어에 참가한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>MT가 끝났을 때, 선영이를 포함해 모든 노래를 아는 사람의 번호를 오름차순으로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3
2 1 2
3 2 3 4
3 4 2 1
','1
2
4
','DATA_STRUCTURE'),
                                                                                                                (6451,'BAEKJOON','https://www.acmicpc.net/problem/3025',3025,'돌 던지기','1초','128 MB',17,'<p>이 모든 사건의 시작은 2주 전이었다. 그 날 상근이는 복도에 누워서 잠을 자고 있었다. 커다란 돌을 들고 그 옆을 지나가던 민혁이는 복도에서 잠을 자는 사람을 처음봐서 신기하게 쳐다보고 있었다. 그 때였다. 들고 있던 돌을 상근이의 왼 발에 떨어뜨렸다. 상근이는 응급실로 실려갔고, 한 달 동안 침대에 누워서 휴식을 취해야 한다는 진단을 받았다. 민혁이는 미안한 마음에 하던 일을 모두 중단하고 상근이를 간호하기로 했다.</p>

<p>상근이는 2주 동안 온라인 저지 문제를 풀었다. 2주 동안 문제를 풀다보니 게임을 하고 싶어졌고, 마침 민혁이를 이용해서 게임을 하기로 했다.</p>

<p>상근이의 게임은 R×C 보드를 세워놓은 상태에서 진행한다. 맨 처음에 각 정사각형 칸은 비어있거나 벽으로 막혀있다. 상근이는 민혁이에게 돌을 떨어놓을 열을 지시하고, 민혁이는 가장 윗 행의 그 열에 돌을 놓는다. 돌을 놓은 이후에는 중력에 의해서 돌이 떨어지게 된다.</p>

<p>돌에 작용하는 중력은 다음과 같다.</p>

<ol>
	<li>돌의 아랫칸이 벽으로 막혀있거나 가장 아랫줄이라면, 돌은 그 자리에 그대로 멈춰 있는다.</li>
	<li>돌의 아랫칸이 비어있다면, 돌은 아랫칸으로 이동한다.</li>
	<li>돌의 아랫칸에 돌이 있다면, 돌은 다음과 같이 미끄러진다.
	<ol>
		<li>만약 돌의 왼쪽 칸과 왼쪽-아래 칸이 비어있다면, 돌은 왼쪽으로 미끄러진다.</li>
		<li>만약 돌이 왼쪽으로 미끄러지지 않았고, 오른쪽 칸과 오른쪽-아래 칸이 비어있다면, 돌은 오른쪽으로 미끄러진다.</li>
		<li>위의 두 경우가&nbsp;아니라면 돌은 그 자리에 멈추고, 다시는 움직이지 않는다.</li>
	</ol>
	</li>
</ol>

<p>민혁이는 돌의 이동이 멈춘 이후에 다른 돌을 던지기 시작한다.</p>

<p>보드의 초기 상태와 민혁이가 돌을 놓은 열의 번호가 순서대로 가 주어졌을 때, 모든 돌을 던진 이후에 보드의 상태를 구하는 프로그램을 작성하시오.</p>

<p>민혁이는 항상 제일 윗 칸이 비어있는 칸에만 돌을 던진다.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 보드의 크기 R과 C가 주어진다. (1 ≤ R ≤ 30,000, 1 ≤ C ≤ 30)</p>

<p>다음 R개 줄에는 C개의 문자가 주어지며, 보드의 초기 상태이다. .는 빈 칸, X는 벽으로 막힌 곳을 나타낸다.</p>

<p>다음 줄에는 돌을 던진&nbsp;횟수 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>다음 N개 줄에는 돌을 던진 열의 위치가 순서대로 주어진다. (가장 왼쪽 열의 번호는 1번)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 R개 줄에 걸쳐서 보드의 게임이 모두 끝난 후의 상태를 출력한다. 돌은 O로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 4
....
....
X...
....
....
4
1
1
1
1
','....
O...
X...
....
OOO.
','DATA_STRUCTURE'),
                                                                                                                (6452,'BAEKJOON','https://www.acmicpc.net/problem/3027',3027,'3차원 직사각형','1초','128 MB',22,'<p>3차원 공간의 XY평면, YZ평면, ZX평면 중 하나에 평행한&nbsp;직사각형이 N개 있다.</p>

<p>적어도 한 점을 공유하는 직사각형 쌍의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 직사각형의 개수 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>다음 줄에는 직사각형의 좌표 6개가 주어진다. 처음 세 숫자는 직사각형의 한 꼭짓점 좌표이고, 다음 세 숫자는 그 반대편 꼭짓점 좌표이다.</p>

<p>모든 좌표는 1보다 크거나 같고, 999보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 적어도 한 점을 공유하는 직사각형 쌍의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 1 1 1 3 3
1 3 3 1 6 6
1 4 4 1 5 5
','2
','DATA_STRUCTURE'),
                                                                                                                (6453,'BAEKJOON','https://www.acmicpc.net/problem/3039',3039,'스터디장 홍준','3초','128 MB',20,'<p>홍준이는 동아리에서 스터디장을 맡고 있다. 이 스터디에 오는 사람들의 주된 목표는 다 같이 모여서 공부를 하는 것이 아닌 모르는 것을 질문하는 것 이다. 홍준이도 이러한 점을 잘 알고 있다.</p>

<p>스터디에 있는 학생들의 능력을 두 개의&nbsp;자연수 A와 B로 표현할 수 있다. A는 학생이 얼마나 잘 이해하고 있는지를 나타내고, B는 이 과목에 대한&nbsp;학생의&nbsp;지식의 깊이&nbsp;정도를 나타낸다. 물론 값이 클 수록 이해를 더 잘하고, 지식의&nbsp;깊이가 깊은 것을 의미한다.</p>

<p>스터디에 있는 학생은 자신 보다 이해를 못하거나, 지식의 깊이가 낮은 학생한테 질문하지 않는다. 하지만, 지식의 깊이가 같고, 자신보다 이해를 잘한 학생한테는 질문한다. 동시에 지식의 깊이 차이가 최소인 학생에게 질문하고 싶어한다. 만약 지식의 깊이 차이가 최소인 사람이 여러 명인 경우, 이해 정도의 차이가 최소인 사람한테 질문하고 싶어한다.</p>

<p>홍준이는 학생들의 이러한 성향을 매우 잘 파악하고 있고, 종종 학생들로부터 누구한테 질문하면 좋겠냐는 질문을 받는다. 홍준이를 도와 학생들의 질문에 대답해주는 프로그램을 작성하시오.</p>

<p>시간이 지남에 따라 동아리에 사람이 더 가입한다. 동아리를 탈퇴하는 사람은 없다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 상황의 수 N이 주어진다. (1 ≤ N ≤ 200 000)</p>

<p>그&nbsp;다음 N개의 줄에 다음과 같은 2가지 종류의 상황이 주어진다.</p>

<ul>
	<li>"D A B", 이해의 정도가 A이고, 지식의 깊이가 B인 학생이 동아리에 가입한다.</li>
	<li>"P i", i번째로 가입한 학생이 누구한테 질문을 해야하는지 물어온다.</li>
</ul>

<p>주어지는 수 A, B는 1이상,&nbsp;2ㆍ10 <sup>9</sup>&nbsp;이하다. 그리고 A, B가 동일한 학생은 존재하지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 줄에&nbsp;"P i"의 상황에 대한 답을 출력해야 한다. 만약 질문할 수 있는 학생이 존재하지 않는 경우 "NE"를 출력한다. 만약 i번째로 가입한 학생이 질문하는 학생이 k번째로 동아리에 가입했다면, 수 k를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
D 3 1
D 2 2
D 1 3
P 1
P 2
P 3
','NE
NE
NE
','DATA_STRUCTURE'),
                                                                                                                (6457,'BAEKJOON','https://www.acmicpc.net/problem/3045',3045,'이중 연결 리스트','1초','128 MB',18,'<p>창영이는 1학년 때 숙제로 했던 이중 연결 리스트 소스를 상근이에게 생일 선물로 보내주었다. 상근이는 드디어 자신이 원하던 기능이 있는 소스를 받게 되어서 매우 기뻤다. 상근이는 하루종일 이 리스트를 가지고 놀려고 한다.</p>

<p>리스트에는 총 N개의 노드가 포함되어 있고, 가장 왼쪽 노드가 1번이며 나머지는 오른쪽으로 갈 수록 1씩 번호가 증가한다. 리스트가 수행할 수 있는 연산은 아래와 같이 2가지이다.</p>

<p>A) 노드 X를 노드 Y의 앞으로 이동</p>

<p>B) 노드 X를 노드 Y의 뒤으로 이동</p>

<p>아래 그림은 노드가 6개인 이중 연결 리스트의 모습이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/5b34905c-567f-483d-860a-b80667f0c7f9/-/preview/" style="width: 360px; height: 38.3333px;"></p>

<p>여기에 "A 1 4" 연산을 수행하면 아래와 같이 된다. (노드 1을 노드 4의 앞으로 이동)</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/7609bf26-d382-4c89-8c03-af85246548bc/-/preview/" style="width: 360px; height: 37.5px;"></p>

<p>그 다음, "B 3 5" 연산을 수행하면 아래 그림과 같은 모습이 된다. (노드 3을 노드 5의 뒤로 이동)</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/35803717-9d37-4a98-9c17-e5538914a134/-/preview/" style="width: 360px; height: 38.3333px;"></p>

<p>리스트를 가지고 다 논 다음에는 처음 상태로 다시 만들어야 한다. 따라서, 상근이는 리스트에 연산을 입력할 때 마다 종이에 적어두었다.</p>

<p>상근이가 입력한 연산이 모두 주어졌을 때, 처음 상태로 만들기 위해 리스트가 수행해야 하는 연산을 구하는 프로그램을 작성하시오. 이때, 연산을 되도록 적게 사용해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 노드의 수 N과 연산의 수 M이 주어진다. (2 ≤ N ≤ 500,000, 0 ≤ M ≤ 100,000)</p>

<p>다음 M개 줄에는 상근이가 입력한 연산이 문제 설명에 나온 형식으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 처음 상태로 만들기 위해서 필요한 연산의 최솟값을 출력한다. 이 값을 K라고 한다.</p>

<p>다음 K개 줄에는 리스트가 수행해야 하는 연산을 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 1
A 2 1
','1
A 1 2
','DATA_STRUCTURE'),
                                                                                                                (6454,'BAEKJOON','https://www.acmicpc.net/problem/3077',3077,'임진왜란','1초','128 MB',8,'<p>현우는 방금 선생님으로부터 역사 시험 결과를 받았다. 현우가 가장 열심히 공부한 문제는 임진왜란의 해전을 일어난 순서대로 적는 문제이다.</p>

<p>올바른 순서는 다음과 같다.</p>

<p>1. 옥포 해전 2. 사천 해전 3. 한산도 대첩&nbsp;4. 명량 해전 5. 노량 해전</p>

<p>현우는 정말 열심히 공부했고, 옥포 해전을 제외한 모든 해전의 날짜를 외웠다. 따라서, 현우는 옥포 해전이 가장 먼저 일어난 해전인지 마지막에 일어난 해전인지 생각해내지 못했고, 다음과 같이 결국 제일 마지막에 적고말았다.</p>

<p>1. 사천 해전 2. 한산도 대첩 3. 명량 해전 4. 노량 해전&nbsp;5. 옥포 해전</p>

<p>현우가 적은 정답은 모든 위치에서 정답과 일치하지 않는다. 따라서 5개 해전 중에 4개 해전의 순서를 올바르게 적었지만, 점수는 5점 만점에 0점이 된다.</p>

<p>현우는 이러한 채점 방식이 큰 문제가 있다고 생각했다.</p>

<p>현우는 선생님께 해전이 일어난 정확한 연도도 중요하지만, 상대적인 관계가 훨씬 더 중요하다고 말했고, 선생님은 현우의 의견을 받아들여 이 문제를 다시 채점하기로 했다.</p>

<p>선생님이 다시 사용한 채점 방법은 두 해전을 골라 순서가 일치하면 점수를 주는 방법이다. 즉, 선생님은 학생의 답 중에 N(N-1)/2개의 쌍을 모두 고른뒤, 올바른 순서로 적혀져 있으면 1점을 주려고 한다. 최종 점수는 획득점수/(N(N-1)/2)가 된다.</p>

<p>문제의 정답과 현우가 작성한 답안이 주어졌을 때, 현우의 점수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 해전의 개수 N이 주어진다. (2 ≤ N ≤ 2500) 다음 줄에는 올바른 정답이 공백으로 구분되어 주어진다. 그 다음 줄에는 현우가 작성한 답안이 공백으로 구분되어 주어진다. 해전의 이름은 3글자~15글자 알파벳 소문자로 이루어져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>현우가 획득한 점수를 a/b로 출력한다. (약분 하면 안 된다)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
okpo sacheon hansan myeongnyang noryang
sacheon hansan myeongnyang noryang okpo
','6/10
','DATA_STRUCTURE'),
                                                                                                                (6455,'BAEKJOON','https://www.acmicpc.net/problem/3078',3078,'좋은 친구','1초','128 MB',12,'<p>상근이는 환갑을 바라보던 나이에 수능 시험을 다시보고 교대에 입학했고, 초등학교 선생님으로 취직했다.</p>

<ul>
	<li>상근: 요즘 애들은 친구를 사귀지 않나봐. 내가 앞에서 보고 있으면, 친구가 있는 학생이 별로 없는 것 같아.</li>
	<li>??: 오빠! 오빠는 말콤의 친구와 성적이라는 책 안 읽어 봤어? 이 책에는 성적과 친구가 무슨 관계가 있는지 나와. 요즘 애들은 친구를 사귀기 전에 먼저 그 친구의 반 등수를 살펴봐. 말콤은 이 연구를 하기 위해서 6년동안 초등학교에서 선생님으로 위장 했었지. 하지만, 6년이라는 시간을 초등학교에서 보냈지만, 그 사람은 결국 결론을 얻지 못했어.</li>
	<li>상근: 근데?</li>
	<li>??: 말콤이 어느 날 자신이 초등학생이 되어 학교를 활보하는 꿈을 꾸었어. 근데 잠을 깨고 나니 내가 꿈을 꾸고 초등학생이 된건지, 아니면 초등학생이 꿈을 꾸고 지금의 내가 되어있는지를 모르겠는거야. 그래서 말콤은 상식적인 사고 방식에 큰 의문을 가졌지. 그 때 말콤은 깨달았던거야. 초등학교 친구는 부질없구나. 그제서야 알게된거야. 모든 학생은 자신과 반 등수의 차이가 K를 넘으면 친구가 아니라는거.</li>
	<li>상근: 아? 근데 K는 어떻게 구해?</li>
	<li>??: K는 문제에서 주어지지. 근데, 더 중요한 사실이 있어. 친구와 좋은 친구의 차이야. 말콤이 친구와 성적을 쓰고 2년 뒤에 낸 책인 좋은 친구라는 책에는 좋은 친구는 이름의 길이가 같아야 된다는 말이 나와.</li>
	<li>상근: 아! 그럼 난 오늘 집에 가서 우리 반에 좋은 친구가 몇 쌍이나 있는지 구해봐야 겠어!</li>
</ul>

<p>상근이네 반의 N명 학생들의 이름이 성적순으로 주어졌을 때, 좋은 친구가 몇 쌍이나 있는지 구하는 프로그램을 작성하시오. 좋은 친구는 등수의 차이가 K보다 작거나 같으면서 이름의 길이가 같은 친구이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 주어진다. (3 ≤ N ≤ 300,000, 1 ≤ K ≤ N) 다음 N개 줄에는 상근이네 반 학생의 이름이 성적순으로 주어진다. 이름은 알파벳 대문자로 이루어져 있고, 2글자 ~ 20글자이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 좋은 친구가 몇 쌍이 있는지&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2
IVA
IVO
ANA
TOM
','5
','DATA_STRUCTURE'),
                                                                                                                (6459,'BAEKJOON','https://www.acmicpc.net/problem/3089',3089,'네잎 클로버를 찾아서','1초','128 MB',13,'<p>숭이는 지구에 놀러온 외계인에게 조정당하고 있다. 외계인은 숭이를 이용해서 네잎 클로버를 찾은 뒤, 숭이를 그 자리에 놔두고 다시 자기들의 행성으로 떠나려고 한다. 숭이가 있는 곳은 2차원 평면으로 나타낼 수 있고, 클로버는 N개의 점으로 나타나 있다.</p>

<p>숭이의 절친한 친구인 희웅이와 태완이는 숭이를 찾아 다시 정신을 차리게 해주려고 한다. 숭이는 맨 처음에 (0, 0)에 있고, 외계인은 그에게 명령을 M번 전송한다. 각 명령은 네 방향 중 하나이며, 숭이는 그 방향으로 가장 가까운 네잎 클로버가 있는 곳까지 걸어간다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/c6bc344b-6f52-4ec5-b588-56fe1813bfc1/-/preview/" style="width: 333px; height: 332px;"></p>

<p>네잎 클로버의 위치와 외계인이 전송한 명령이 주어졌을 때, 모든 명령을 수행한 뒤에 숭이가 있는 곳의 위치를 찾는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 네잎 클로버의 개수 N과 외계인이 전송한 명령의 수 M이 주어진다. (3 ≤ N ≤ 100,000, 1 ≤ M ≤ 100,000)</p>

<p>다음 N개 줄에는 네잎 클로버의 위치 X<sub>i</sub>, Y<sub>i</sub>가 주어진다. (-100,000 < X<sub>i</sub>, Y<sub>i</sub> < 100,000) 한 위치에 두 개 이상의 네잎 클로버가 있는 경우는 없다.</p>

<p>마지막 줄에는 외계인이 숭이에게 내린 명령이 주어진다. 왼쪽 방향은 L, 오른쪽은 R, 위는 U, 아래는 D로 주어진다. 항상 주어지는 방향에는 네잎 클로버가 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>숭이의 마지막 위치를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 4
1 1
1 0
0 1
0 0
RULD
','0 0
','DATA_STRUCTURE'),
                                                                                                                (6456,'BAEKJOON','https://www.acmicpc.net/problem/3090',3090,'차이를 최소로','1초','128 MB',19,'<p>정수 N개로 이루어진 배열 A가 주어진다. 상근이는 수열의 수 하나를 골라서 값을 1 감소시킬 수 있다. 단, 수는 1보다 작아질 수 없다.</p>

<p>상근이는 위의 감소시키는 연산을 최대 T번 하려고 한다. 이때, 인접한 수의 차이의 최댓값을 최소로 하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 T가 주어진다. (2 ≤ N ≤ 100 000, 1 ≤ T ≤ 10<sup>9</sup>)</p>

<p>둘째 줄에는 배열 A에 들어있는 수 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> < 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 인접한 수의 차이의 최댓값을 가장 작게한 배열 A의 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>을 공백으로 구분하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>각각의 테스트 케이스에 대해서, 점수는 (100×(S+1)/(D+1))/(데이터 개수) 점이다. 이때, D는 출력한 수열에서 인접한 수의 차이의 최댓값, S는 정답이다. 즉, 출력한 수열이 정답인 경우 10점을 얻게 된다. 하지만, 출력한 수열이 총 T번 감소시켜서 만들 수 없는 경우에는 그 테스트 케이스에 대해서 0점을 얻게 된다.</p>

<p>예를 들어, 예제 출력 2를 "1 2 3 5 6"으로 하면 10×(2/3)=6.66점을 받게 된다. 정답은 1인데, 출력한 수열에서의 답은 2이기 때문이다.</p>

				</div>
				</div>','5 2
3 2 3 2 2
','2 2 2 2 2
','DATA_STRUCTURE'),
                                                                                                                (6458,'BAEKJOON','https://www.acmicpc.net/problem/3103',3103,'순열의 순서','2초','128 MB',21,'<p>지승이는 대학교에서 수학을 가르치고 있다. 이번학기에는 "이산 수학과 조합론"을 가르치며, 수강생은 총 N명이다. 지난 시간에 강의한 내용은 순열의 순서(Ranks of permutations)이다.</p>

<p>1부터 K까지 이루어진 수열이 있을 때, 각 숫자가 한 번씩만 등장하는 수열을 순열이라고 한다. 순열은 총 K!가지 경우의 수가 있을 수 있다. 수열 (1, 2, 3)은 총 3! = 6가지 방법으로 나타낼 수 있다. 순열은 첫 번째 숫자를 비교하고, 두 번째 숫자를 비교하고, ..., 이와 같은 방식으로 계속해서 비교하는 방식으로 순서를 매길 수 있다.</p>

<ol>
	<li>(1, 2, 3)</li>
	<li>(1, 3, 2)</li>
	<li>(2, 1, 3)</li>
	<li>(2, 3, 1)</li>
	<li>(3, 1, 2)</li>
	<li>(3, 2, 1)</li>
</ol>

<p>한 수열로 만들 수 있는 순열을 모두 순서대로 나열했을 때, 인덱스가 순열의 순서된다. 예를 들어, (3, 1, 2)의 순서는 5가 된다.</p>

<p>지승이는 학생들에게 순열의 순서를 계산하는 숙제를 내주려고 한다. 한 학생에게 순열을 하나 알려주고, 그 학생은 다음 수업 전까지 그 순열의 순서를 구해와야 한다.</p>

<p>지승이는 간단한 알고리즘을 이용해 숙제에 낼 순열을 만들려고 한다.</p>

<p>먼저, K개의 숫자로 이루어진 순열을 하나 아무거나 고른다. 그 다음, 학생마다 A와 B를 골라 A번째 수와 B번째 수의 위치를 바꾼 순열을 새롭게 만든다.</p>

<p>예를 들어, 고른 순열이 (1, 5, 4, 2, 3)이고, 고른 A와 B가 (1, 3), (2, 3), (2, 5)라면, 학생들이 받게되는 순열은 (4, 5, 1, 2, 3), (1, 4, 5, 2, 3), (1, 3, 4, 2, 5)가 된다. 각 순열의 순서는 91, 17, 9이다.</p>

<p>지승이가 고른 순열과 A와 B가 주어졌을 때, 각 순열의 순서를 구하는 프로그램을 작성하시오. 순서가 매우 커질 수 있기 때문에, 1,000,000,007로 나눈 나머지를 출력한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 K와 N이 주어진다. (2 ≤ K ≤ 300,000, 1 ≤ N ≤ 100,000) K는 순열의 길이, N은 학생의&nbsp;수이다.</p>

<p>둘째 줄에는 지승이가 고른 순열이 주어진다. 순열은 1부터 K까지 정수 K개로 이루어져 있으며, 한 숫자는 한 번만 등장한다.</p>

<p>다음 N개 줄에는 A와 B가 주어진다. (1 ≤ A < B ≤ K)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄에 하나씩 순열의 순서를 1,000,000,007로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
1 5 4 2 3
1 3
2 3
2 5
','91
17
9
','DATA_STRUCTURE'),
                                                                                                                (6460,'BAEKJOON','https://www.acmicpc.net/problem/3106',3106,'월급 인상','1초','128 MB',21,'<p>연종이는 성공한 벤쳐회사 "봉씨"의 사장이다. 가장 처음에 연종이는 이 회사의 유일한 직원이었다. 하지만, 점점 사업이 성공하면서 연종이는 직원을 뽑게 되었고, 이제 연종이를 제외하고 N명의 직원이 일하는 회사가 되었다.</p>

<p>봉씨에서는 직원의 이름을 부르지 않는 문화가 있다. 모든 직원은 서로를 숫자로 불러야 한다. 숫자는 자신이 들어온 순서대로 1번부터 N번까지 번호매겨진다. 연종이의 번호는 0이다.</p>

<p>새로운 직원이 고용될 때, 그 직원은 기존 직원의 부하로 배정된다. 그리고, 그 직원의 첫 월급은 연종이가 능력을 테스트해 본 후에 정해준다.&nbsp;</p>

<p>만약, 신입 사원의 월급이 그의 상사보다 많다면, 그 상사의 월급은 신입 사원의 월급 만큼 인상된다. 만약, 월급 인상으로 인해 신입 사원의 상사의 월급이 그의 상사 월급보다 많아진다면, 그 상사의 월급도 신입 사원의 월급 만큼 인상된다. 즉, 상사의 월급과 신입 사원의 월급이 같아지는 것이다.&nbsp;이 작업은 모든 직원이 자신의 상사보다 월급이 작거나 같을 때 까지 반복된다.&nbsp;</p>

<p>신입 사원이 채용된 순서와 첫 월급, 그리고 상사의 번호가 주어졌을 때, 새로운 직원이 뽑힐 때 마다, 월급 인상을 받는 직원의 수를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 직원의 수 N이 주어진다. (1 ≤ N ≤ 300,000)</p>

<p>둘째 줄에는 연종이의 첫 월급이 주어진다.</p>

<p>다음 N개의 줄에는 직원이 고용된 순서대로 I와 B가 주어진다. I는 첫 월급이고, B는 상사의 번호이다.</p>

<p>모든 월급은 1보다 크거나 같고, 10<sup>9</sup>보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 직원이 고용되었을 때, 월급 인상 받는 직원의 수를 한 줄에 하나씩 N개의 숫자를 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
5000
4500 0
6000 0
4000 1
5500 3
7000 4
6300 2
6300 2
','0
1
0
2
4
1
0
','DATA_STRUCTURE'),
                                                                                                                (6462,'BAEKJOON','https://www.acmicpc.net/problem/3108',3108,'로고','1초','128 MB',14,'<p>로고는 주로 교육용에 쓰이는 프로그래밍 언어이다. 로고의 가장 큰 특징은 거북이 로봇인데, 사용자는 이 거북이 로봇을 움직이는 명령을 입력해 화면에 도형을 그릴 수 있다.</p>

<p>거북이는 위치와 각도로 표현할 수 있다. 거북이는 입에 연필을 물고 있는데, 연필을 내리면 움직일 때 화면에 선을 그리고, 올리면 선을 그리지 않고 그냥 지나가기만 한다.</p>

<p>제일 처음에 거북이는 (0,0)에 있고, 거북이가 보고 있는 방향은 y축이 증가하는 방향이다. 또한 연필은 내리고 있다.</p>

<p>사용자는 다음과 같은 다섯가지 명령으로 거북이를 조정할 수 있다.</p>

<ol>
	<li>FD x: 거북이를 x만큼 앞으로 전진</li>
	<li>LT a: 거북이를 반시계 방향으로 a도 만큼 회전</li>
	<li>RT a: 거북이를 시계 방향으로 a도 만큼 회전</li>
	<li>PU: 연필을 올린다</li>
	<li>PD: 연필을 내린다.</li>
</ol>

<p>축에 평행한 직사각형 N개가 주어졌을 때, 이 직사각형을 그리는데 필요한 PU 명령의 최솟값을 구하는 프로그램을 작성하시오.</p>

<p>거북이는 같은 선을 여러 번 그릴 수 있지만, 문제에 주어진 직사각형 N개를 제외한 어떤 것도 그릴 수 없다. 거북이의 크기는 아주 작아서 좌표 평면의 한 점이라고 생각하면 된다. 직사각형의 변은 축에 평행하다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 직사각형의 개수 N이 주어진다. (1 ≤ N ≤ 1000)</p>

<p>다음 N개의 줄에는 직사각형의 좌표 x1, y1, x2, y2가 주어진다. (?500 ≤ x1 < x2 ≤ 500), (?500 ≤ y1 < y2 ≤ 500) (x1, y1)는 직사각형의 한 꼭짓점 좌표이고, (x2, y2)는 그 점의 대각선 방향의 반대 꼭짓점의 좌표이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>N개의 직사각형을 그리는 필요한 PU명령의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
0 0 10 10
','0
','DATA_STRUCTURE'),
                                                                                                                (6463,'BAEKJOON','https://www.acmicpc.net/problem/3115',3115,'꽃','1초','128 MB',20,'<p>꽃의 수분에 있어서 가장 중요한 역할을 하는 동물은 벌이다. 벌은 매우 정교한 과정을 통해 어떤 꽃을 수분해야 할지 결정한다.</p>

<p>화단 위에 꽃이 N개 있다. 화단의 변은 축에 평행하며, 양 끝 꼭짓점의 좌표는 (0,0), (M,M)이다. 꽃은 화단 위의 점으로 나타낸다.</p>

<p>벌 떼는 베이스 캠프로 사용할 꽃을 하나 정한 다음, 거기에서 모두 모인다. 그 다음, 벌 네마리가 각각 위, 아래, 왼쪽, 오른쪽으로 이동한다. 벌은 다른 꽃을 만나거나 화단의 경계에 도착할때까지 이동한다. 벌이 모두 멈춘 다음에 벌 네마리가 멈춘 좌표를 모두 통과하는 축에 평행한 직사각형을 만들고, 그 직사각형 내부에 있는 꽃을 모두 수분한다. 경계의 위에 있는 꽃은 수분하지 않는다.</p>

<p>꽃의 좌표가 모두 주어졌을 때, 각각의 꽃을 베이스 캠프로 사용한 경우에 수분하는 꽃의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 화단의 크기 M이 주어진다. (2 ≤ M ≤ 1,000,000)</p>

<p>둘째 줄에는 꽃의 개수 N이 주어진다. (1 ≤ N ≤ 300,000)</p>

<p>다음 N개 줄에는 꽃의 좌표 x와 y가 주어진다. (0 < x, y < M)</p>

<p>두 꽃이 같은 좌표를 가지는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 꽃에 대해서, 그 꽃을 베이스 캠프로 사용한 경우에 수분하는 꽃의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
4
1 2
2 2
2 1
1 1
','1
1
1
1
','DATA_STRUCTURE'),
                                                                                                                (6469,'BAEKJOON','https://www.acmicpc.net/problem/3119',3119,'울타리','1초','128 MB',20,'<p>상근이는 집 옆에 나무 울타리를 만들고 있다. 나무 울타리는 직사각형 나무판을 땅에 꽂아서 만든다.</p>

<p>울타리를 만들다보니 점점 흥이 났고, 상근이는 울타리 계획을 까먹고 마구 나무판을 꽂았다. 울타리를 완성한 후 뿌듯해하면서 울타리를 본 상근이는 대혼란에 빠졌다. 나무판을 겹쳐서 꽂기도 했고, 심지어 울타리 중간에 구멍도 있었기 때문이었다.</p>

<p style="text-align:center"><img alt="" src="https://upload.acmicpc.net/7a9ffd56-ae1b-4d96-819b-30f5f69e592f/-/preview/" style="height: 102.5px; width: 338.333px;"></p>

<p style="text-align:center">예제를 그림으로 나타낸 것이다. 굵은 선이 스카이라인이다.</p>

<p>아직 상근이는 울타리를 보고 충격에 빠진 상태이다. 이미 완성된 울타리가 마음에 들었기 때문에, 똑같은 모양의 울타리를 더 적은 수의 나무판을 이용해서 만들려고 한다.</p>

<p>똑같은 모양의 울타리란 스카이라인이 같은 울타리를 말한다.</p>

<p>어떤 나무판자를 남겨야 똑같은 모양의 울타리가 되는지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 상근이가 나무 울타리를 만드는데 사용한 나무판의 개수 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>다음 N개 줄에는 각 나무판의 정보 X, W, H가 주어진다. X는 상근이의 집에서부터&nbsp;떨어진 거리, W와 H는 나무판의 너비와 높이이다. 모든 수는 10<sup>9</sup>를 넘지 않는다.</p>

<p>나무판은 입력으로 주어진 순서대로 1번부터 N번이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 남아있는 나무판의 개수 B를 출력한다. 이때, B를 최소로 해야한다.</p>

<p>둘째 줄에는 어떤 나무판이 남아있는지 공백으로 구분해 출력한다. 정답이 여러 가지인 경우에는 아무거나 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
10 11 30
19 1 20
15 9 10
7 7 20
3 12 40
','3
1 3 5
','DATA_STRUCTURE'),
                                                                                                                (6466,'BAEKJOON','https://www.acmicpc.net/problem/3121',3121,'빨간점, 파란점','1초','128 MB',23,'<p>면 옛날에 좌표평면위에 빨간점과 파란점이 살고 있었다. 빨간점과 파란점은 몇 년동안 화목하게 지내고 있었다. 그런데... 파란점이 빨간점을 공격하기 시작했다. 빨간점은 파란점으로부터 자신들을 지키기 위해 두 평행선을 긋기로 결정했다. 두 선 사이에는 파란점이 있으면 안되며, 그 안에 있는 빨간점은 보호받을 수 있다. 선은 점을 지날 수 없다.</p>

<p>빨간점은 모든 빨간점이 보호받을 수 없음을 알게되었다. 보호받을 수 있는 빨간점 개수의 최댓값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 점의 개수 N이 주어진다. (1 ≤ N ≤ 1000)</p>

<p>다음 N개 줄에는 각 점의 좌표와 색상이 주어진다. 좌표는 절댓값이 10<sup>9</sup>보다 작은 정수쌍이고 색상은 R또는 B이다.</p>

<p>세 점이 일직선상에 있는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>두 평행선으로 보호받을 수 있는 빨간점 개수의 최댓값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
0 0 R
0 1 B
1 1 R
1 0 B
','2
','DATA_STRUCTURE'),
                                                                                                                (6471,'BAEKJOON','https://www.acmicpc.net/problem/3133',3133,'코끼리','3초','128 MB',20,'<p>N개의 식물이 표면에 떠 있는 호수에 코끼리 한 마리가 살고 있다. 이 호수는 각각의 식물들이 정수 좌표에 있는 좌표평면으로 나타낼 수 있다.</p>

<p>매일 아침마다 이 코끼리는 식물들 위를 신나게 뛰어다니며 아침 운동을 한다. 왜 그런지는 모르겠지만 이 코끼리는 항상 현재 식물보다 x, y좌표가 둘 다 큰 식물로만 뛸 수 있다. 다시 말해서, (x<sub>1</sub>, y<sub>1</sub>)에 있는 식물로부터 x<sub>2</sub> > x<sub>1</sub>이고 y<sub>2</sub> > y<sub>1</sub>일때만 코끼리는 (x<sub>2</sub>, y<sub>2</sub>)로 뛸 수 있다. 이 코끼리는 호수 위의 아무 식물에서나 운동을 시작할 수 있다.</p>

<p>모든 식물의 좌표가 주어졌을때, 코끼리가 최대로 뛸 수 있는 식물의 개수를 계산하시오. 그리고 그렇게 뛸 수 있는 방법의 수를 계산하시오. 이때 이 방법의 수가 너무 클 수 있기 때문에 1 000 000 007로 나눈 나머지를 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 식물의 수 N(1 ≤ N ≤ 300 000)이 들어온다.</p>

<p>이후 N개의 줄에는 각각의 식물의 좌표 x<sub>i</sub>, y<sub>i</sub>(0 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 1 000 000 000)가 들어온다. (단, 두 식물이 같은 좌표에 있는 경우는 없다.)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에는 코끼리가 최대로 뛸 수 있는 식물의 개수를 출력하시오.</p>

<p>두 번째 줄에는 그렇게 뛸 수 있는 방법의 수를 1 000 000 007로 나눈 값을 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 1
4 2
2 3
3 4
','3
1
','DATA_STRUCTURE'),
                                                                                                                (6480,'BAEKJOON','https://www.acmicpc.net/problem/3136',3136,'평면도','1초','128 MB',17,'<p>상근이는 자기가 살 집을 설계하려고 한다.</p>

<p>먼저, 정수 좌표마다 점이 찍혀 있는 매우 큰 종이가 필요하다. 그 다음, 이 종이의 원점에 연필을 올린다. 이제 연필을 빠르게 N번 움직여 평면도를 그린다. 연필은 절대로 종이에서 떼지 않는다. 또, 상근이는 연필을 현재 있는 점과 인접한 8개 점 중 하나로만 이동할 수 있다. (가로, 세로, 대각선) 가능한 이동은 아래 그림과 같으며, 숫자로 나타낼 수 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/0890f805-9491-4781-964f-8e013864bae7/-/preview/" style="width: 209px; height: 216px;"></p>

<p>상근이가 그린 평면도가 주어진다. 이때, 방의 수를 구하는 프로그램을 작성하시오. 방은 평면도 상에서 빈 공간이며, 연필 선으로 모든 면이 둘러 쌓여 있어야 한다. 방은 다른 방으로 둘러 쌓여질 수도 있다. 상근이는 이미 그었던 선을 또 그릴 수도 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 연필을 움직인 횟수 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 연필을 움직인 순서가 주어진다. 이 순서는 길이가 N인 숫자이며 0부터 7까지로 이루어져 있다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 평면도의 방의 개수를 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
27250
','3
','DATA_STRUCTURE'),
                                                                                                                (6475,'BAEKJOON','https://www.acmicpc.net/problem/3156',3156,'노래','1초','128 MB',11,'<p>연말에, 한 유명한 라디오 스테이션이 그 해에 걸쳐 청자들의 투표로 인해 랭크된 노래 목록을 출판한다.</p>

<p>스테이션은 그 목록을 잠시동안 안전하게 지키고, 청자들을 위한 추론 경합을 개최한다. 그들은 몇몇 노래의 배치에 대한 특정한 힌트를 발표한다. 그리고 청자들이 가능한 많은 노래의 정확한 위치를 추론하도록 한다.</p>

<p>예를 들어, 다음 두 진술을 고려해보자:</p>

<ul>
	<li>노래 "Ti Da Bu Di Bu Da"는 top3노래중 하나이다.</li>
	<li>노래 "Treba mi ne?to ja?e od sna"와 노래 "Ja se konja bojim"은 top2노래에 속한다.</li>
</ul>

<p>위 진술들은&nbsp;어느것도 정확히 나타내지 않지만, 노래 "Ti Da Bu Di Bu Da"가 리스트의 세 번째 위치에 온다는 것은 추론할 수 있다.</p>

<p>진술들이 주어졌을때,&nbsp; 리스트에서 정확한 위치를 추론할 수 있는 모든 노래를 출력하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에는 진술의 수가 정수 N으로 주어진다. (1 ≤ N ≤ 500 )</p>

<p>다음의 각 N줄에는 "A od B song1 song2 ... songA" 형태의 진술이 주어진다. 이는 "song1", "song2", ... "songA"가 리스트의 top B에 속한다는 의미이다. (1 ≤ A ≤ B ≤ 100)</p>

<p>각각의 노래 이름은 하나의 문자열이고, 최대 20개의 영문 알파벳 소문자로 구성된다. 진술에서 나타나는 다른 노래의 전체 수는 최대 500개이다.</p>

<p>Note: 진술들은 서로 모순되지 않으며, 정확한 위치를 추론할 수 있는 노래가 적어도 한개는 존재한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>리스트에서 그들의 위치가 추론될 수 있는 모든 노래들을 출력하라. 결과는 각 줄에 하나씩 "position song"의 형태로 position에 대한 오름차순으로 출력되어야한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
1 od 3 tidabu
2 od 2 trebami jasekonja
','3 tidabu
','DATA_STRUCTURE'),
                                                                                                                (6479,'BAEKJOON','https://www.acmicpc.net/problem/3176',3176,'도로 네트워크','1초','256 MB',17,'<p>N개의 도시와 그 도시를 연결하는 N-1개의 도로로 이루어진 도로 네트워크가 있다.&nbsp;</p>

<p>모든 도시의 쌍에는 그 도시를 연결하는 유일한 경로가 있고, 각 도로의 길이는 입력으로 주어진다.</p>

<p>총 K개의 도시 쌍이 주어진다. 이때, 두 도시를 연결하는 경로 상에서 가장 짧은 도로의 길이와 가장 긴 도로의 길이를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. (2 ≤ N ≤ 100,000)</p>

<p>다음 N-1개 줄에는 도로를 나타내는 세 정수 A, B, C가 주어진다. A와 B사이에 길이가 C인 도로가 있다는 뜻이다. 도로의 길이는 1,000,000보다 작거나 같은 양의 정수이다.</p>

<p>다음 줄에는 K가 주어진다. (1 ≤ K ≤ 100,000)</p>

<p>다음 K개 줄에는 서로 다른 두 자연수 D와 E가 주어진다. D와 E를 연결하는 경로에서 가장 짧은 도로의 길이와 가장 긴 도로의 길이를 구해서 출력하면 된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 K개 줄에&nbsp;D와 E를 연결하는 경로에서 가장 짧은 도로의 길이와 가장 긴 도로의 길이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
2 3 100
4 3 200
1 5 150
1 3 50
3
2 4
3 5
1 2
','100 200
50 150
50 100
','DATA_STRUCTURE'),
                                                                                                                (6476,'BAEKJOON','https://www.acmicpc.net/problem/3190',3190,'뱀','1초','128 MB',12,'<p> Dummy 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.</p>

<p>게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.</p>

<p>뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.</p>

<ul>
	<li>먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.</li>
	<li>만약 벽이나 자기자신의 몸과 부딪히면 게임이 끝난다.</li>
	<li>만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.</li>
	<li>만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.</li>
</ul>

<p>사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)</p>

<p>다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.</p>

<p>다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)</p>

<p>다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데,  정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 L) 또는 오른쪽(C가 D)로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 게임이 몇 초에 끝나는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
3
3 4
2 5
5 3
3
3 D
15 L
17 D
','9
','DATA_STRUCTURE'),
                                                                                                                (6461,'BAEKJOON','https://www.acmicpc.net/problem/3197',3197,'백조의 호수','1초','256 MB',16,'<p>두 마리의 백조가 호수에서 살고 있었다. 그렇지만 두 마리는 호수를 덮고 있는 빙판으로 만나지 못한다.</p>

<p>호수는 행이 R개, 열이 C개인 직사각형 모양이다. 어떤 칸은 얼음으로 덮여있다.</p>

<p>호수는 차례로 녹는데, 매일 물 공간과 접촉한 모든 빙판 공간은 녹는다. 두 개의 공간이 접촉하려면 가로나 세로로 닿아 있는 것만 (대각선은 고려하지 않는다) 생각한다.</p>

<p>아래에는 세 가지 예가 있다.</p>

<pre>...XXXXXX..XX.XXX ....XXXX.......XX .....XX..........
....XXXXXXXXX.XXX .....XXXX..X..... ......X..........
...XXXXXXXXXXXX.. ....XXX..XXXX.... .....X.....X.....
..XXXXX..XXXXXX.. ...XXX....XXXX... ....X......XX....
.XXXXXX..XXXXXX.. ..XXXX....XXXX... ...XX......XX....
XXXXXXX...XXXX... ..XXXX.....XX.... ....X............
..XXXXX...XXX.... ....XX.....X..... .................
....XXXXX.XXX.... .....XX....X..... .................
      처음               첫째 날             둘째 날
</pre>

<p>백조는 오직 물 공간에서 세로나 가로로만(대각선은 제외한다) 움직일 수 있다.</p>

<p>며칠이 지나야 백조들이 만날 수 있는 지 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫째 줄에는 R과 C가 주어진다. 단, 1 ≤ R, C ≤ 1500.</p>

<p>다음 R개의 줄에는 각각 길이 C의 문자열이 하나씩 주어진다. .은 물 공간, X는 빙판 공간, L은 백조가 있는 공간으로 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 문제에서 주어진 걸리는 날을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 2
.L
..
XX
XX
XX
XX
XX
XX
..
.L
','3
','DATA_STRUCTURE'),
                                                                                                                (6486,'BAEKJOON','https://www.acmicpc.net/problem/3319',3319,'전령들','1초','128 MB',23,'<p>옛날 옛날에, 아름다운 몰다비아의 지역에 1부터 N까지 고유한 번호가 붙여진 N개의 중세 도시가 있었다. 번호 1이 붙여진 도시는 수도이다. 도시들은 N-1개의 양방향 도로로 연결되어 있으며, 각 도로는 킬로미터 단위의 길이를 가지고 있다.</p>

<p>도시를 두 번 거치지 않고 도시의 쌍을 순회하는 방법은 유일하다. (즉 도로의 그래프가 트리 형태이다)</p>

<p>도시가 공격당했을 때, 최대한 빠른 시간 내에 이 사실을 수도에 보고해야 한다. 각 도시에 살고 있는 전령들이 이 메시지를 전달한다. 각각의 전령에는 여정을 시작하기 위해 필요한 시간과 일정 속력(킬로미터 당 분 단위)이 있다.</p>

<p>도시에서 출발한 메시지는 수도까지 유일한 가장 짧은 경로를 통해서 전달된다. 처음에는 공격당한 도시의 전령이 메시지를 전달한다. 그 전령이 순회하는 다른 도시에서 전령은 두 가지 선택을 할 수 있다. 수도 방향의 다음 도시로 이동하거나, 그 도시의 전령에게 메시지를 남길 수 있다. 새로운 전령은 위와 같은 방식을 따른다. 종합해보면, 메시지는 수도까지 전달되는 동안 여러 전령을 거칠 수 있다.</p>

<p>이때, 각 도시에서 수도까지 메시지를 전하는데 걸리는 최소 시간을 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄엔, 몰다비아의 도시의 개수 N이 주어진다.</p>

<p>다음 줄부터 N-1개의 줄에 공백으로 구분된 세 개의 정수 U, V, D가 주어진다. 이는 도시 U와 도시 V 사이에 D 킬로미터의 도로가 있음을 의미한다.</p>

<p>그 아래에, 한 줄에 하나씩 N-1개의 정수 쌍이 주어진다. i번째 쌍인 S<sub>i</sub>, V<sub>i</sub>는 (i+1)번째 도시의 전령을 표현하는 수이다. S<sub>i</sub>는 여정을 준비하는데 걸리는 시간, V<sub>i</sub>는 1km를 가는데 걸리는 시간(분)이다. 수도에는 전령이 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력에는 N-1개의 정수로 이루어진 하나의 줄을 출력해야 한다. i번째 수는 (i+1)번째 도시에서 수도로 메시지를 보내는데 필요한 최소 시간(분)을 나타낸다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 20
2 3 12
2 4 1
4 5 3
26 9
1 10
500 2
2 30
','206 321 542 328
','DATA_STRUCTURE'),
                                                                                                                (6489,'BAEKJOON','https://www.acmicpc.net/problem/3323',3323,'삼각형','1초','128 MB',23,'<p>
	양의 정수를 좌표로 갖는 점 K개와, 한 점은 원점, 다른 두 점은 음이 아닌 정수를 좌표로 갖는점으로 이루어진 M개의 삼각형이 주어진다.</p>

<p>
	이때, 각각의 삼각형의 내부에 주어진 K개의 점 중 적어도 하나는 있는지 없는지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>
	첫째 줄에 K와 M이 주어진다. 둘째 줄부터 K개의 줄에는 각 점의 x좌표와 y좌표가 공백으로 구분되어 주어진다. 다음 M개의 줄에는 삼각형의 원점이 아닌 꼭짓점의 좌표가 (x1, y1), (x2, y2)가 순서대로 공백으로 구분되어져서 주어진다.</p>

<p>
	1 ≤ K, M ≤ 100,000</p>
<p>
	1 ≤ K개 점의 좌표 ≤ 10<sup>9</sup></p>
<p>
	0 ≤ 삼각형 꼭짓점 좌표 ≤ 10<sup>9</sup></p>
<p>
	삼각형의 넓이는 0이 아니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	M개의 줄을 출력한다. i번줄에는 i번째 입력으로 주어진 삼각형의 내부에 점이 적어도 1개 있으면 Y를, 아니면 N을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>
	<img alt="" src=https://www.acmicpc.net/upload/images/triangleandpoint.png" style="width: 304px; height: 207px;"></p>

				</div>
				</div>','4 3
1 2
1 3
5 1
5 3
1 4 3 3
2 2 4 1
4 4 6 3
','Y
N
Y
','DATA_STRUCTURE'),
                                                                                                                (6491,'BAEKJOON','https://www.acmicpc.net/problem/3346',3346,'꿍 기지국','1초','128 MB',18,'<p>누구나 다 아는 꿍텔레콤은 새로 건설된 고속도로에 꿍전파를 널리 퍼뜨리기 위해 여러 기지국들을 세우려고 했다. 하지만 언제나 어설픈 꿍은 발전소가 없다는 것을 뒤늦게 알아차렸다. 기지국마다 발전소를 만들 수는 없으므로 단 하나의 발전소만을 만들어 기지국들에 전력을 공급해야 한다. 이때 발전소는 고속도로상에 지을 예정이며 고속도로상의 임의의 지점에서 가장 가까운 기지국까지의 거리를 d라고 했을 때 d의 값이 최대가 되는 곳에 지으려고 한다.</p>

<p>하지만 꿍은 언제나 어설프다. 이번에도 여러분의 도움이 필요하다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄은 두 개의 정수 $N$ ($1 ≤ N ≤ 10^6$) and $L$ ($1 ≤ L ≤ 10^9$)가 주어지며 $N$은 기지국의 개수, $L$은 고속도로의 길이를 나타낸다.</p>

<p>다음 $N$줄은 $x_i$, $y_i$ ($-10^9 ≤ x_i, y_i ≤10^9$) 으로 이루어지는데 각각 기지국의 $x$, $y$좌표를 나타내며 모든 점들은 중복되지 않는다. 좌표들은 $x$좌표값을 기준으로 오름차순으로 주어지며 같은 $x$좌표값에 대해서는 $y$좌표값을 기준으로 오름차순으로 주어진다.</p>

<p>고속도로는 $(0,0)$ 부터 $(L,0)$까지의 일직선 도로다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가능한 d의 최댓값을 출력한다. 절대오차는 $10^{-3}$까지 허용한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 10
0 0
11 1
','5.545455
','DATA_STRUCTURE'),
                                                                                                                (6494,'BAEKJOON','https://www.acmicpc.net/problem/3351',3351,'삼각 분할','3초','128 MB',20,'<p>계산기하 분야에서 삼각분할은, 다음과 같은 조건을 만족하는 삼각형의 집합을 뜻한다.</p>

<ul>
	<li>삼각형의 각 꼭짓점은 다각형에 있는 꼭짓점 중 하나이다.</li>
	<li>삼각형끼리는 겹쳐서 안되며, 삼각형들의 합집합은 다각형과 동일하다.</li>
</ul>

<p>볼록 다각형이라 함은. 다각형 내부의 내각이 모두 180도 미만인, 변이 3개 이상인 도형을 뜻한다.</p>

<p>볼록 다각형이 주어졌을 때, 우리는 이 볼록 다각형을 두개의 볼록 다각형으로 분할하는 직선을 다각형의 절단선이라고 정의한다.</p>

<p>삼각분할된 볼록다각형이 주어지며, 각각의 삼각분할된 삼각형들은 내부가 주어진 색상 C<sub>i</sub>로 칠해져 있다. 다각형 내부의 임의의 색상이 같은 점 쌍이, 다른 조각으로 분할되는 일이 없도록 최대한 많은 절단선을 그었을 때, 몇개의 절단선을 그을 수 있는가?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 다각형의 정점 수 n이 주어진다. (3 ≤&nbsp;n ≤ 100,000)</p>

<p>이후 n-2개의 줄에 분할된 삼각형의 정보가 네 정수 a b c d 형태로 주어진다. 이는 주어진 삼각형이 다각형의 정점 a, b, c를 세&nbsp;꼭짓점으로 하며, 내부가 d라는 색상으로 칠해져 있음을 뜻한다. (1 ≤ a, b, c, d ≤ n)</p>

<p>입력으로 주어진 다각형은 문제에서 주어진 조건을 만족한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>다각형을 분할하는 최대의 절단선의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 2
4 5 1 1
3 1 4 2
','1
','DATA_STRUCTURE'),
                                                                                                                (6493,'BAEKJOON','https://www.acmicpc.net/problem/3362',3362,'수수께끼','1초','128 MB',15,'<p>엘레오노라의 할머니 서차(Sercha)는 손녀, 손자들에게 수학&nbsp;수수께끼를 내는 것을 좋아하십니다. 저번 가족여행에서는 이 문제를 내주셨습니다 :</p>

<p>"만약 어떤 가게에 K개의 상품을 팔고 있고 가격은 1에서 K라고 한다면, 내가 N개의 동전을 갖고 있고 그 동전은 A<sub>1</sub>,A<sub>2</sub>,<strong><sup>. .&nbsp;.</sup></strong>,A<sub>N</sub>이라고 한다. 나는 너무 늙어서 딱 그 가격에 최소 개수를 가져가고 싶어. 동전을 A<sub>1</sub>부터 차례대로 가져갈때, 동전을 몇&nbsp;개 가져가면&nbsp;최소 개수로 1부터 K까지의 가격을 지불할 수 있을까?"</p>

<p>엘레오노라는 몇 초 지나지 않고 대답했고, 생각했습다.</p>

<p>"이런 기본적인 알고리즘은 이제 쉽죠!"</p>

<p>엘레오노라를 도와줄 프로그램을 작성해 봅시다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 테스트 케이스 수인 T가 주어집니다. 각 케이스의&nbsp;첫째 줄에는 N(N≤100,000)과 K(K≤1,000,000)가 입력되고 둘째 줄에는&nbsp;N개의 정수 동전&nbsp;가치A<sub>i</sub>(A<sub>i</sub>≤100,000)가 주어집니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 서차 할머니께서&nbsp;가져가셔야&nbsp;하는 동전 개수를 출력하고 만약 N개를 다 가져가셔도 할 수 없으시다면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
7 10
1 2 3 4 5 6 7
3 3
2 4 1
3 6
3 1 4
','4
3
-1
','DATA_STRUCTURE'),
                                                                                                                (6495,'BAEKJOON','https://www.acmicpc.net/problem/3366',3366,'수열 줄이기','1초','128 MB',15,'<p>
	수열 a<sub>1</sub>, ..., a<sub>n</sub>이 주어졌을 때, reduce(i)는 a<sub>i</sub>와 a<sub>i+1</sub>를 max(a<sub>i</sub>, a<sub>i+1</sub>)로 바꾸는 연산이다. 이 연산을 사용하면 수열의 길이는 1만큼 작아지게 된다.</p>

<p>
	reduce연산의 비용은 max(a<sub>i</sub>, a<sub>i+1</sub>)과 같다. 연산을 n-1번 사용하면, 수열의 길이는 1이 된다.</p>

<p>
	reduce연산을 n-1번 사용해서, 수열의 길이를 1로 만들 때, 연산의 비용의 합의 최솟값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>
	첫째 줄에 수열의 길이 n(1 ≤ n ≤ 1,000,000)이 주어진다. 다음 n개의 줄에는 수열의 원소 a<sub>i</sub>가 순서대로 주어진다. (0 ≤ a<sub>i</sub> ≤ 1,000,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	첫째 줄에 수열의 길이를 1로 만드는데 드는 비용의 합의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1
2
3
','5
','DATA_STRUCTURE'),
                                                                                                                (6502,'BAEKJOON','https://www.acmicpc.net/problem/3392',3392,'화성 지도','1초','128 MB',19,'<p>
	2051년, 야심차게 발사한 화성탐사선 성화가 탐사한 곳의 화성 지도를 N개 보냈다.</p>

<p>
	화성탐사선의 성공에 의기양양해진 BaSA(Baekjoon Space Agency)는 야심찬 계획을 발표했다.</p>

<p>
	화성 전체 지도를 만들겠습니다!</p>

<p>
	전체 지도를 만들기 전에, 지금까지 화성탐사선이 보낸 지도를 모두 합쳤다. 이때, 이 지도의 크기는 몇일까?</p>

<p>
	탐사선이 보낸 지도는 항상 직사각형 모양이며, 겹칠 수도 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>
	첫째 줄에 화성탐사선 성화가 보낸 지도의 수 N(1 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 각 지도의 정보가 주어진다. 지도의 정보는 네 정수 x1, y1, x2, y2 (0 ≤ x1 < x2 ≤ 30,000, 0 ≤ y1 < y2 ≤ 30,000)으로 이루어져 있다. (x1, y1)와 (x2, y2)은 직사각형의 왼쪽 아래 좌표와 오른쪽 위 좌표이다. 모든 지도는 직사각형이고, 변은 항상 x축과 y축에 평행하다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	첫째 줄에 지금까지 탐사선이 보낸 지도를 모두 합쳤을 때, 그 면적을 출력한다. (직사각형을 모두 합쳤을 때 면적)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>
	<img alt="" src=https://www.acmicpc.net/upload/images/mar0.gif" style="width: 188px; height: 250px;"></p>

				</div>
				</div>','2
10 10 20 20
15 15 25 30
','225
','DATA_STRUCTURE'),
                                                                                                                (6504,'BAEKJOON','https://www.acmicpc.net/problem/3421',3421,'이상한 규정','5초','128 MB',24,'<p>암호기법 덕분에 우리는 의도된 수신자 이외에 누구도 메세지를 읽을 수 없도록 암호화 할 수 있다. 하지만, 암호화된 메세지들은 실제로 수신자에게 도달하지 않을 경우 쓸모가 없다. 오늘날, 컴퓨터 네트워크는 이러한 메세지들을 전송하는 가장 일반적인 방법이다. 이 문제에서는 네트워크 공급자들이 해결해야 하는 문제에 대해 공부한다. 메세지는 암호화되어있기 때문에, 네트워크 보안에 대해 더이상 신경쓰지 않아도 됨을 기억해라.</p>

<p>컴퓨터(서버)를 연결하는 네트워크 케이블들은 다른 회사에 속해 있다. 새로 만들어진 독점 금지법은 모든 회사가 각 서버에서 케이블을 2개보다 많이 소유하지 못하게 한다. 또한, 자원 낭비를 피하기 위해 각 회사가 불필요한 케이블을 소유하면 안 된다는 내용도 있다. (즉, 어떠한 케이블을 제거하면 이전에 연결되어있던 두 개의 서버는 연결이 끊어진다.) &nbsp;회사들은 케이블을 계속 사고 팔기 때문에, 이러한 규정을 시행하는 것은 매우 어렵다. 당신의 임무는 이러한 규정의 시행을 도와주는 프로그램을 작성하는 것이다!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 몇 가지 예시를 포함한다. 각 예시의 첫 번째 줄에는 공백으로 구분된 네 개의 정수 N, M, C, T가 주어진다. N은 서버의 개수(1<=N<=8000), M은 케이블의 개수(0<=M<=100 000), C는 회사의 개수(1<=C<=100), T는 케이블 판매 거래수(0<=T<=100 000)를 나타낸다.</p>

<p>다음의 M행은 케이블에 대한 내용이다. 각 줄에는 공백으로 구분된 세개의 정수 S<sub>j1</sub>, S<sub>j2</sub>, K<sub>j</sub>가 주어진다. S<sub>j1</sub>과 S<sub>j2</sub>는 해당 케이블로 연결된 서버의 번호이고(1<=S<sub>j1</sub><S<sub>j2</sub><=n), K<sub>j</sub>는 처음 케이블을 소유하고 있는 회사의 번호이다. 각 서버 쌍에는 최대 하나의 케이블만 연결된다. 초기 상태는 규정을 만족한다. 즉, 각 회사는 각 서버에 최대 2개의 케이블을 소유하고 있으며, 한 회사가 소유한 케이블 시스템에는 사이클이 없다.</p>

<p>마지막으로 다음의 T행에는 정수 S<sub>i1</sub>, S<sub>i2</sub>, K<sub>i</sub>가 주어진다. 하나의 거래에 대해 K<sub>i</sub> (1<=K<sub>i</sub><=C) 회사가 서버 S<sub>i1</sub>와 S<sub>i2</sub> 사이의 케이블을 구매하려는 것을 나타낸다.</p>

<p>마지막 예시의 다음에는 4개의 0이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 예시에 대해, 거래의 결과를 나타내는 T개의 행을 출력하라. 가능한 출력결과는 다음과 같다.</p>

<ul>
	<li>"No such cable." : 서버 쌍이 케이블로 연결되지 않을 때</li>
	<li>"Already owned." : 이미 회사 K<sub>i</sub>가 케이블을 가지고 있을 때</li>
	<li>"Forbidden: monopoly." : 회사 K<sub>i</sub>가 이미 서버 S<sub>i1</sub>이나 S<sub>i2</sub>에서 2개의 케이블을 가지고 있을 때</li>
	<li>"Forbidden: redundant." : 회사 K<sub>i</sub>가 서버 S<sub>i1</sub>과 S<sub>i2</sub>에 대해 각각 최대 1개의 케이블을 가지고 있으나 소유권을 부여할 경우 K<sub>i</sub>가 가진 케이블이 사이클을 형성할 때</li>
	<li>"Sold." : 위의 제한 사항 중 하나도 적용되지 않을 때. 이 경우 서버 S<sub>i1</sub>과 S<sub>i2</sub>에 대한 케이블의 소유권은 이후 거래를 위해 K<sub>i</sub>에게 옮겨간다.</li>
</ul>

<div>각 인스턴스 뒤에는 한 개의 빈 줄을 출력해라.</div>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5 3 5
1 2 1
2 3 1
3 4 2
1 4 2
1 3 3
1 2 3
1 2 3
1 4 3
2 3 3
2 4 3
2 1 1 1
1 2 1
1 2 1
0 0 0 0
','Sold.
Already owned.
Forbidden: monopoly.
Forbidden: redundant.
No such cable.

Already owned.
','DATA_STRUCTURE'),
                                                                                                                (6505,'BAEKJOON','https://www.acmicpc.net/problem/3425',3425,'고스택','1초','128 MB',12,'<p>고창영은 스택을 조금 변형해서 고스택을 만들었다.</p>

<p>고스택은 숫자만을 저장할 수 있고, 다음과 같은 10가지 연산을 수행할 수 있다.</p>

<p>편의상 스택의 가장 위에 저장된 수를 첫 번째 수라고 하고, 그 다음은 차례대로 두 번째 수, 세 번째 수라고 한다.</p>

<ul>
	<li><strong>NUM X</strong>: X를 스택의 가장 위에 저장한다. (0 ≤ X ≤ 10<sup>9</sup>)</li>
	<li><strong>POP</strong>: 스택 가장 위의 숫자를 제거한다.</li>
	<li><strong>INV</strong>: 첫 번째 수의 부호를 바꾼다. (42 -> -42)</li>
	<li><strong>DUP</strong>: 첫 번째 숫자를 하나 더 스택의 가장 위에 저장한다.</li>
	<li><strong>SWP</strong>: 첫 번째 숫자와 두 번째 숫자의 위치를 서로 바꾼다.</li>
	<li><strong>ADD</strong>: 첫 번째 숫자와 두 번째 숫자를 더한다.</li>
	<li><strong>SUB</strong>: 첫 번째 숫자와 두 번째 숫자를 뺀다. (두 번째 - 첫 번째)</li>
	<li><strong>MUL</strong>: 첫 번째 숫자와 두 번째 숫자를 곱한다.</li>
	<li><strong>DIV</strong>: 첫 번째 숫자로 두 번째 숫자를 나눈 몫을 저장한다. 두 번째 숫자가 피제수, 첫 번째 숫자가 제수이다.</li>
	<li><strong>MOD</strong>: 첫 번째 숫자로 두 번째 숫자를 나눈 나머지를 저장한다. 두 번째 숫자가 피제수, 첫 번째 숫자가 제수이다.</li>
</ul>

<p><img alt="" src=https://www.acmicpc.net/upload/images/stmc.png" style="height: 69.1667px; width: 356.667px;"></p>

<p>이항 연산자의 경우에 첫 번째 숫자가 오른쪽에 있는 수이고, 두 번째 숫자가 왼쪽에 있는 수이다. 또, 연산을 수행하기 전에 두 숫자를 모두 스택에서 제거한 뒤, 결과를 다시 스택에 저장하는 것이다.</p>

<p>숫자가 부족해서 연산을 수행할 수 없을 때, 0으로 나눴을 때 (DIV, MOD), 연산 결과의 절댓값이 10<sup>9</sup>를 넘어갈 때는 모두 프로그램 에러이다.</p>

<p>음수 나눗셈에 대한 모호함을 피하기 위해 다음과 같이 계산한다. 나눗셈의 피연산자에 음수가 있을 때는, 그 수를 절댓값을 씌운 뒤 계산한다. 그리고 나서 몫과 나머지의 부호는 다음과 같이 결정한다. 피연산자중 음수가 한 개일때는 몫의 부호가 음수이다. 이 경우를 제외하면 몫의 부호는 항상 양수이다. 나머지의 부호는 피제수의 부호와 같다. 따라서, 13 div -4 = -3, -13 mod 4 = -1, -13 mod -4 = -1이다.</p>

<p>프로그램 에러가 발생했을 경우에는, 현재 프로그램의 수행을 멈추고, 그 다음 어떤 명령도 수행하지 않는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 기계 여러 대의 설명으로 이루어져 있다. 각 기계의 설명은 프로그램과 입력영역으로 나누어져 있다.</p>

<p>프로그램은 명령어로 이루어져 있고, 명령어는 한 줄에 하나씩 있다. 각 명령은 문제 설명에 나와있는 대문자 알파벳 3글자이고, 다른 글자는 주어지지 않는다. NUM의 경우에는 명령어 다음에 숫자가 주어지며, 이 숫자는 0보다 크거나 같고, 10<sup>9</sup>보다 작거나 같은 정수이다. NUM과 숫자는 공백으로 구분되어져 있다. 각 프로그램은 END가 나오면 끝난다.</p>

<p>입력영역은 첫째 줄에 프로그램 수행 횟수 N이 있다. (0 ≤ N ≤ 10,000) 다음 N개의 줄에는 한 줄에 하나씩 입력값 V<sub>i</sub>가 있다. (0 ≤ V<sub>i</sub> ≤ 10<sup>9</sup>) 각 입력값에 대해서 프로그램을 한 번씩 수행해야 하고, 이 수행은 모두 독립적이다. 매번 프로그램을 수행할 때, 스택에 들어있는 값은 입력값 V<sub>i</sub> 하나이다.</p>

<p>각각의 기계 설명은 빈 줄로 구분되어져 있다. QUIT이 나오면 다음 기계 설명이 없다는 뜻이다. 명령어가 100,000개를 넘어가는 경우와 스택이 수행될 때, 1,000개 이상의 숫자를 저장하는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 입력값에 대해서, 해당하는 프로그램을 수행한 뒤, 출력값을 출력하면 된다. 출력값이란 스택에 저장되어 있는 숫자이다.</p>

<p>만약, 프로그램 에러가 발생하거나, 모든 수행이 종료됐을 때 스택에 저장되어 있는 숫자가 1개가 아니라면, "ERROR"를 출력한다.</p>

<p>각 기계에 대한 출력값을 모두 출력한 뒤에는 빈 줄을 하나 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','DUP
MUL
NUM 2
ADD
END
3
1
10
50

NUM 1
NUM 1
ADD
END
2
42
43

NUM 600000000
ADD
END
3
0
600000000
1

QUIT
','3
102
2502

ERROR
ERROR

600000000
ERROR
600000001
','DATA_STRUCTURE'),
                                                                                                                (6500,'BAEKJOON','https://www.acmicpc.net/problem/3429',3429,'방어선','3초','128 MB',17,'<p>온 나라가 고통받았던 전쟁이 끝났습니다. 전쟁을 교훈삼아, Ardenia의 수도의 방어선을 탄탄하게 할 때가 되었습니다. 방어선 중 가장 핵심적인 부분은 수도에서 북쪽 숲으로 뻗어나가는 메이지 타워입니다. 메이지 타워에서 Ardenia를 지키는 마법사들은 Ardenia의 왕인 당신에게 방어에 대한 한 가지 조언을 하였습니다. 적군에게 에너지 볼트를 쓰는 것에 관한 긴 설명을 하긴 했지만, 결국 당신이 이해하기로는 도시의 방어의 질은 높이가 증가하는 순서대로의 연속된 타워들 중 가장 길이가 긴 것에 의해 결정된다는 것입니다.</p>

<p>새로운 타워를 짓는 것은 불가능한 것으로 보이고, 일단은 몇 개의 타워를 없애서 도시의 방어의 질을 높이려고 합니다. (타워를 없애지 않아도 됩니다.) 타워를 없애는 일이 복잡하기 때문에, 마법사들이 한 가지 조건을 걸었습니다: 없애는 타워들은 연속해야 합니다.</p>

<p>예를 들어, 타워들의 높이가&nbsp;5, 3, 4, <u>9, 2, 8</u>, 6, 7, 1 이었다고 합시다. 밑줄 친 (연속한) 타워들을 없애면, 높이가 5, <strong>3, 4, 6, 7</strong>, 1인 타워들이 남고, 여기서 가장 긴 연속한 증가하는 부분은 굵게 표시한 3, 4, 6, 7이 됩니다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있습니다.</p>

<p>첫째 줄에는 테스트 케이스의 개수 Z ≤ 25 가 주어집니다.</p>

<p>이후 두 줄씩 입력이 주어지는데, 첫째 줄은 타워의 수를 나타내는 양의 정수 n ≤ 2 · 10<sup>5</sup> 이 주어집니다. 둘째 줄에는 10<sup>9</sup> 이하인 양의 정수 n개가 공백으로 구분되어 주어집니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 테스트 케이스에 대해, 몇 개의 연속한 타워를 없애서 만들 수 있는 가장 긴 연속한 증가하는 타워들의 길이를 출력하세요.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
9
5 3 4 9 2 8 6 7 1
7
1 2 3 10 4 5 6
','4
6
','DATA_STRUCTURE'),
                                                                                                                (6503,'BAEKJOON','https://www.acmicpc.net/problem/3430',3430,'용이 산다','3초','128 MB',15,'<p>옛날 아주 먼 옛날, 한 마을에 용이 살고 있었습니다. 그 마을에는 호수가 여러개 있었는데, 그 호수들은 모두 물이 들어 있었습니다. 이 마을에는 가끔 비가 내립니다. 신기하게도 비는 한 호수 위에서만 내린다고 합니다. 비가 내렸을 때 그 호수가 비어있다면 그 호수는 다시 물로 꽉 차지만, 만약 호수에 물이 있는데 다시 비가 내릴경우 호수가 넘쳐 흘러서 엄청난 재앙을 불러 일으킬 수 있었습니다. 용은 비가 오지 않는 날에는 하루에 한개의 호수에 있는 물을 전부 먹어 치울 수 있었지만, 비가 오는 날에는 물을 마시지 못했습니다. 용은 신비한 능력을 가지고 있어서 언제 어디서 비가 올지를 정확히 알아낼 수 있었기 때문에, 비가 오기 전 그 호수의 물을 전부 먹어치울 수 있었고 마을사람들은 행복하게 살았답니다.</p>

<p>그런데 어느 여름날, 장맛비가 찾아왔습니다. 용은 언제 어디서 호수의 물을 먹을지를 계산하려고 했지만, 엄청난 양의 비에 당황한 나머지 실패하고 말았답니다. 여러분이 용을 도와서 재앙으로부터 마을을 지켜주세요!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 테스트 케이스의 수 Z가 주어진다.</p>

<p>각 테스트 케이스의 첫 번째 줄에는 두 개의 자연수 n,m이 주어진다. n은 호수의 개수이고, m은 호수에 비가 내리는 날의 수이다. (n ≤ 10<sup>6</sup>, m ≤ 10<sup>6</sup>)</p>

<p>각 테스트 케이스의 두 번째 줄에는 m개의 정수 t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>,...,t<sub>m</sub> 이 주어진다. (0 ≤ t<sub>i</sub> ≤ n) 만약 t<sub>i</sub>가 자연수라면 i번째 날에는 t<sub>i</sub>번 호수에서 비가 내림을 의미한다. t<sub>i</sub>가 0이라면 i번째 날에는 비가 오지 않음을 의미하고, 이 날은 용이 호수로부터 물을 마실 수 있다. 용은 비가 오는 날에는 물을 마시지 않는다는 사실을 기억하라.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 만약 재앙을 막을 수 있다면 YES를, 막을 수 없다면 NO를 출력한다.</p>

<p>만약 YES인 경우에는 두 번째 줄에 ℓ개의 자연수 또는 0을 출력한다. (이때 ℓ은 일기예보에서 주어진 0의 개수, 즉 비가 오지 않는 날의 수이다.) 각 자연수는 용이 물을 마셔야 할 호수의 번호를 나타내며, 만약 0일 경우는 아무 호수에서도 물을 마시지 않음을 의미한다. (아무리 용이라도 빈 호수에서는 물을 마실 수 없기 때문이다.)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2 4
0 0 1 1
2 4
0 1 0 2
2 3
0 1 2
2 4
0 0 0 1
','NO
YES
1 2
NO
YES
0 1 0
','DATA_STRUCTURE'),
                                                                                                                (6509,'BAEKJOON','https://www.acmicpc.net/problem/3499',3499,'미토콘드리아 이브','1초','128 MB',14,'<p>미토콘드리아 DNA는 생물의 세포 내에 있는 미토콘드리아의 DNA 분자이다.</p>

<p>이 DNA는 모계로부터 유전된다. 즉,&nbsp;전 인류의 공통 모계 조상인 "미토콘드리아 이브"가 존재한다. 모계 조상은 가계도의 여성 부분을 타고 거슬러 올라가면 나오는 조상이다. 예를 들어, 어머니나 할머니가 자식의 모계 조상이 된다.</p>

<p>인류의 미토콘드리아 이브는 약 20만년 전 동아프리카에 살았던 것으로 추정된다.</p>

<p>이 문제에서는 이형 접합인 진핵 생물&nbsp;단일종으로 이루어진 한 집단에 대해 다룬다. 연구자들은 이 집단의 개체 수 성장을 시간을 두고 완벽하게 기록했고, 그 중 몇 개체들의 미토콘드리아 DNA를 서열화했다. 관찰한 집단의 미토콘드리아 DNA는 모계로부터 유전될 때 돌연변이 없이 유전되었다고 가정한다.</p>

<p>현재 살아있는 모든 개체가 같은 미토콘드리아 DNA를 가졌는지 확인하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에&nbsp;관찰을 시작한 시기에 살아있던 개체의 수인 정수 n (1 ≤ n ≤ 100,000)이 주어진다. 이 개체들의 ID는 1부터 n까지&nbsp;정수이다.</p>

<p>다음 n 줄에는 각 줄마다 하나의 문자가 주어진다. i 번째 줄의 문자는 ID가 i인 개체의 성별을 의미하는데, M은 수컷, F는 암컷을 의미한다.</p>

<p>다음 줄에는 관측 기간 동안의 출생과 사망한 횟수의 합인 정수 m (0 ≤ m ≤ 100,000)이 주어진다.</p>

<p>다음 m 줄에는 출생과 사망에 대한 정보가 시간순으로 주어진다.</p>

<p>출생은 세 단어로 주어지는데, 순서대로 아빠의 ID, 엄마의 ID, 성별을 나타낸다.&nbsp;(위와 마찬가지로 M은 수컷, F는 암컷이다)&nbsp;새끼의 ID는 그때까지 ID로 쓰이지 않은 가장 작은 양의 정수이다.</p>

<p>사망은 음수 하나로 주어지는데, 죽은 개체의 ID에 마이너스 부호를 붙인 것이다.</p>

<p>그 다음&nbsp;줄에는 서열화된 미토콘드리아 DNA의 수인 정수 k(0 ≤ k ≤ n + m)가 주어진다.</p>

<p>다음 k 줄에서,&nbsp;각 줄에서 공백으로 구별되는 두 정수가 주어지는데, 전자는 미토콘드리아 DNA가 분석된 개체의 ID이고, 후자는 그 개체의 미토콘드리아 DNA의 고유 식별 번호이다. 두 미토콘드리아 DNA의 고유 식별 번호가 같을 때는 두 DNA가 같을 경우 밖에 없다. 미토콘드리아 DNA의 고유 식별 번호는 1부터 10<sup>9</sup>까지의 정수이다.</p>

<p>입력의 모든 주어진 데이터는 모순이 없고, 한 개체의 미토콘드리아 DNA는 최대 한 번만 분석된다. 관찰이 끝났을 때 최소 하나의 개체는 살아 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 하나의 단어이다.</p>

<ul>
	<li>YES - 실험이 끝났을 때 생존한 개체가 모두 같은 미토콘드리아 DNA를 가지는 경우.</li>
	<li>NO -&nbsp;실험이 끝났을 때 생존한 어떤 개체들이 서로 다른 미토콘드리아 DNA를 가지는 경우.</li>
	<li>POSSIBLY - YES와 NO를 확정할 수 없는 경우.</li>
</ul>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
M
F
M
F
12
3 4 F
1 2 M
1 2 M
3 4 F
-3
-2
-4
-1
6 5 M
7 5 F
-7
-6
0
','YES
','DATA_STRUCTURE'),
                                                                                                                (6515,'BAEKJOON','https://www.acmicpc.net/problem/3650',3650,'암호 해독','1초','128 MB',16,'<p>상근이와 선영이는 메시지를 자주 주고 받는다. 하지만, 그들은 다른 사람이 자신이 작성한 메시지를 읽는 것을 매우 싫어한다. 정인이는 이 두 사람이 서로 보내는 메시지에 큰 관심을 가지고 있고, 메시지를 가로채고 있다. 하지만, 상근이와 선영이는 메시지를 암호화 하기 때문에 정인이는 메시지를 읽을 수 없다. 정인이가 가로채는 메시지는 암호화된 메시지(암호문)이다.</p>

<p>최근에 정인이는 우연히 메시지 원본(평문)을 얻었다. 정인이는 다른 메시지도 해독하기 위해서 암호키를 찾기로 했다.</p>

<p>상근이와 선영이는 메시지를 k개의 글자씩 블록으로 나눈 다음에 각 블록에 들어있는 글자의 순서를 바꾸는 것이다. 순서를 바꾸는 방법은 총 k!가지가 있으며, 이 중 한 순열을 골라서 모든 블록에 동일하게 적용한다. 이때 사용한 순열을 암호키라고 한다. 아래 그림은 secret을 암호키 (514362)를 이용해서 암호화한 것이고, 블록의 크기는 6이다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/keysecret.png" style="height:133px; width:246px"></p>

<p>정인이는 블록의 크기도 알고 있다. 또, 평문과 암호문의 길이는 같고, 길이는 항상 k로 나누어 떨어진다. 또, 모든 블록은 같은 암호키를 이용해서 암호화 한다.</p>

<p>평문 M과 암호문 C, 그리고 블록의 크기 k가 주어졌을 때, M을 C로 암호화하는 암호키의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 세 줄로 이루어져 있고, 블록의 크기 k, 평문 M, 암호문 C가 한 줄에 하나씩 주어진다. k는 1보다 큰 양의 정수이고, M과 C는 알파벳 소문자로만 이루어져 있으며, 길이는 최대 100이다. M과 C의 길이는 같고, M의 길이는 k의 배수이다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 가능한 암호키의 개수를 출력한다. 암호키의 수는 2<sup>63</sup>-1을 넘지 않는다. 만약, M에서 C를 만들 수 없다면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
treewood
ertedowo
6
secret
etrcse
1
impossibru
youdontsay
','1
2
0
','DATA_STRUCTURE'),
                                                                                                                (6514,'BAEKJOON','https://www.acmicpc.net/problem/3653',3653,'영화 수집','1초','256 MB',17,'<p>상근이는 영화 DVD 수집가이다. 상근이는 그의 DVD 콜렉션을 쌓아 보관한다.</p>

<p>보고 싶은 영화가 있을 때는, DVD의 위치를 찾은 다음 쌓아놓은 콜렉션이 무너지지 않게 조심스럽게 DVD를 뺀다. 영화를 다 본 이후에는 가장 위에 놓는다.</p>

<p>상근이는 DVD가 매우 많기 때문에, 영화의 위치를 찾는데 시간이 너무 오래 걸린다. 각 DVD의 위치는, 찾으려는 DVD의 위에 있는 영화의 개수만 알면 쉽게 구할 수 있다. 각 영화는 DVD 표지에 붙어있는 숫자로 쉽게 구별할 수 있다.</p>

<p>각 영화의 위치를 기록하는 프로그램을 작성하시오. 상근이가 영화를 한 편 볼 때마다 그 DVD의 위에 몇 개의 DVD가 있었는지를 구해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스의 개수는 100개를 넘지 않는다.</p>

<p>각 테스트 케이스의 첫째 줄에는 상근이가 가지고 있는 영화의 수 n과 보려고 하는 영화의 수 m이 주어진다. (1 ≤ n, m ≤ 100,000) 둘째 줄에는 보려고 하는 영화의 번호가 순서대로 주어진다.</p>

<p>영화의 번호는 1부터 n까지 이며, 가장 처음에 영화가 쌓여진 순서는 1부터 증가하는 순서이다. 가장 위에 있는 영화의 번호는 1이다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서 한 줄에 m개의 정수를 출력해야 한다. i번째 출력하는 수는 i번째로 영화를 볼 때 그 영화의 위에 있었던 DVD의 개수이다. 상근이는 매번 영화를 볼 때마다 본 영화 DVD를 가장 위에 놓는다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
3 3
3 1 1
5 3
4 4 5
','2 1 0
3 0 4
','DATA_STRUCTURE'),
                                                                                                                (6517,'BAEKJOON','https://www.acmicpc.net/problem/3662',3662,'보석 분배','1초','128 MB',20,'<p>민혁이와 민규는 보석으로 가득찬 박스를 가지고 있고, 이제 이 보석을 나누려고 한다. 하지만, 각 보석의 가치가 다르기 때문에 공정하게 보석을 나누는 것은 매우 어려운 일이다.</p>

<p>보석을 나누기 위해서, 턴을 번갈아가면서 보석을 하나씩 가져간다. 보석이 남아있지 않을 때 까지 턴을 번갈아가며, 누가 먼저 시작할지는 동전을 던져서 결정한다.</p>

<p>민혁이와 민규는 서로 다른 전략을 가지고 보석을 고르려고 한다. 민혁이는 남아있는 보석 중에서 민혁이에게 가장 가치있는 보석을 고른다. 만약, 그러한 보석이 여러 가지라면, 민규에게 가장 가치가 없는 보석을 고른다.</p>

<p>민규는 최종 가치의 합이 최대가 되게 보석을 고른다. 만약, 그러한 보석이 여러 가지라면, 민혁이의 최종 가치가 최대한 크게 되는 보석을 고른다.</p>

<p>누가 턴을 먼저 시작할지와, 각 사람이 느끼는 보석의 가치가 주어졌을 때, 두 사람이 가져가는 보석의 가치를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T (T ≤ 100)가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.</p>

<ul>
	<li>보석의 개수 n (1 ≤ n ≤ 1000)</li>
	<li>먼저 턴을 시작하는 사람의 이름 (민혁이인 경우에는 "Petra", 민규인 경우에는 "Jan")</li>
	<li>n개의 줄에 걸쳐서 민혁이가 느끼는 가치 p<sub>i</sub>, 민규가 느끼는 가치 j<sub>i</sub> (0 ≤ p<sub>i</sub>, j<sub>i</sub>&nbsp;≤ 1 000)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서 두 사람이 최종적으로 가져가는 보석 가치를&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
4
Petra
100 80
70 80
50 80
30 50
4
Petra
10 1
1 10
6 6
4 4
7
Jan
4 1
3 1
2 1
1 1
1 2
1 3
1 4
','170 130
14 16
9 10
','DATA_STRUCTURE'),
                                                                                                                (6521,'BAEKJOON','https://www.acmicpc.net/problem/3685',3685,'김강山','3초','128 MB',22,'<p>김강산은 서울 신촌에 있는 인공 산이다. 김강산은 사람들이 벽돌을 쌓아서 만들었으며, 등산을 연습하기 위해 만들었다. 사람들은 암벽 등반을 연습하기 위해 김강산에 방문하지만, 김강산은 초심자용이 아니다. 김강산의 관리인 상근이는 사람들이 조금 등반하기 쉽게 산을 조금 고치려고 한다.</p>

<p>김강산은 벽돌이 무더기 n개가 연속되는 형태로 나타낼 수 있고, 각 벽돌 무더기는 벽돌이 h<sub>i</sub>개 쌓여있는 것이다. 인접한 무더기 사이의 높이 차이는 h<sub>i+1</sub> - h<sub>i</sub> (1 ≤ i ≤ n-1) 이다. 상근이는 모든 높이 차이를 d보다 작거나 같게 만들려고 한다.</p>

<p>상근이는 벽돌 무더기에 벽돌을 더 놓거나 뺄 수 있다. 이때, 첫 번째 무더기와 마지막 무더기의 벽돌의 개수는 변경할 수 없다. 벽돌을 놓거나 빼는 일은 매우 힘든 일이다. 따라서, 상근이는 이러한 벽돌의 수를 최소로 하려고 한다.</p>

<p>김강산의 정보가 주어졌을 때, 인접한 높이 차이를 d이하로 만들기 위해 놓거나 빼야하는 벽돌 개수의 최솟값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 최대 100개의 테스트 케이스로 이루어져 있다.</p>

<p>각 테스트 케이스의 첫째 줄에는 n과 d가 주어진다. (2 ≤ n ≤ 100, 0 ≤ d ≤ 10<sup>9</sup>) 둘째 줄에는 h<sub>i</sub>가 주어진다. (0 ≤ h<sub>i</sub> ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 인접한 높이 차이를 d 이하로 만들기 위해 쌓거나 빼야하는 돌의 개수의 최솟값을 출력한다. 만약, d이하로 만들 수 없다면 impossible을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
10 2
4 5 10 6 6 9 4 7 9 8
3 1
6 4 0
4 2
3 0 6 3
','6
impossible
4
','DATA_STRUCTURE'),
                                                                                                                (6520,'BAEKJOON','https://www.acmicpc.net/problem/3691',3691,'컴퓨터 조립','1초','128 MB',13,'<p>상근이는 술을 먹던 도중 프로그래밍을 못하는 이유를 갑자기 깨달았다. 그 이유는 바로 상근이의 컴퓨터 성능이 좋지 않았기 때문이다. 상근이는 컴퓨터를 사기로 결심했다.</p>

<p>상근이는 컴퓨터를 조립해서 만들 것이다. 따라서, 각 부품을 모두 따로 구매해서 직접 조립해야 한다. 각각의 부품은 하나씩 구매하면 된다.</p>

<p>컴퓨터의 성능은 가장 안 좋은 부품의 성능과 같다. 따라서, 상근이는 예산을 초과하지 않으면서 가장 안 좋은 부품의 성능을 최대로 하려고 한다.</p>

<p>각 부품의 이름과 종류, 성능이 주어진다. 이때, 상근이의 예산으로 구매할 수 있는 가장 성능이 좋은 컴퓨터를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스는 100개를 넘지 않는다.</p>

<p>각 테스트 케이스의 첫째 줄에는 부품의 개수 n과 상근이의 예산 b가 주어진다. (1 ≤ n ≤ 1,000, 1 ≤ b ≤ 1,000,000,000)</p>

<p>다음 n개 줄에는 부품의 정보가 "type name price quality"와 같은 형식으로 주어진다. type은 부품의 종류, name은 그 부품의 이름, price는 가격 (0 ≤ price ≤ 1,000,000), quality는 성능 (0 ≤ quality ≤ 1,000,000,000)이다.</p>

<p>부품의 이름은 겹치지 않고, 성능은 숫자가 높을수록 좋은 것이다. 문자열에는 글자와 숫자, 그리고 밑 줄만을 포함하며, 최대 길이는 20글자이다.</p>

<p>항상 주어진 예산으로 컴퓨터를 조립할 수 있는 경우만 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 상근이의 예산으로 구매할 수 있는 가장 좋은 컴퓨터의 성능을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
18 800
processor 3500_MHz 66 5
processor 4200_MHz 103 7
processor 5000_MHz 156 9
processor 6000_MHz 219 12
memory 1_GB 35 3
memory 2_GB 88 6
memory 4_GB 170 12
mainbord all_onboard 52 10
harddisk 250_GB 54 10
harddisk 500_FB 99 12
casing midi 36 10
monitor 17_inch 157 5
monitor 19_inch 175 7
monitor 20_inch 210 9
monitor 22_inch 293 12
mouse cordless_optical 18 12
mouse microsoft 30 9
keyboard office 4 10
','9
','DATA_STRUCTURE'),
                                                                                                                (6523,'BAEKJOON','https://www.acmicpc.net/problem/3698',3698,'애매함','1초','128 MB',16,'<p>단어의 첫 글자와 마지막 글자를 제외한 나머지 글자의 순서를 섞어도 그 단어는 쉽게 읽을 수 있다. 예를 들어, 문장 "tihs snetncee mkaes prfecet sesne"는 많은 사람들이 쉽게 읽을&nbsp;수 있다.</p>

<p>문장의 공백을 모두 제거해도 그 문장은 쉽게 읽을 수 있다. 예를 들면 "thissentencemakesperfectsense" 이다.</p>

<p>하지만, 글자의 순서를 섞고, 공백을 제거하면 문장은 쉽게 읽을 수 없다. "tihssnetnceemkaesprfecetsesne"와 같은 문장은 쉽게 읽을 수 없다.</p>

<p>글자의 순서를 섞고, 단어 사이의 공백을 제거한 문장이 주어진다. 또, 올바른 단어의 목록이 주어진다. 이때, 원래 문장을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스의 개수는 최대 100개이다.</p>

<p>각 테스트 케이스의 첫째 줄에는 글자의 순서를 뒤섞고, 공백을 제거한 문장이 주어진다. 이 문장은 알파벳 소문자로만 이루어져 있으며, 길이는 최대 1000글자이다.</p>

<p>둘째 줄에는 올바른 단어의 개수 n (1 ≤ n ≤ 10,000)이 주어진다. 다음 n개 줄에는 올바른 단어가 주어진다. 모든 단어는 중복되지 않으며, 알파벳 소문자로만 이루어져 있다. 또, 길이는 최대 100글자이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다, 원래 문장을 유일하게 만들 수 있으면 그 문장을 출력한다. 문장을 만들 수 있는 방법이 여러 가지인 경우에는 "ambiguous"를, 불가능한 경우에는 "impossible"을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
tihssnetnceemkaesprfecetsesne
5
makes
perfect
sense
sentence
this
hitehre
2
there
hello
hitehre
3
hi
there
three
','this sentence makes perfect sense
impossible
ambiguous
','DATA_STRUCTURE'),
                                                                                                                (6526,'BAEKJOON','https://www.acmicpc.net/problem/3770',3770,'대한민국','1초','128 MB',16,'<p>대한민국은 동아시아에 위치한 한반도에 위치하고 있다. 3면이 바다인 한국의 서쪽으로 서해, 동쪽으로 동해, 남쪽으로 남해에 의해 둘러싸여 있다.</p>

<p>대한민국의 동해안에는 도시가 N개 있고, 서해안에는 도시가 M개 있다. (M ≤ 1000, N ≤ 1000) 각 도시는 북쪽부터 남쪽까지 번호가 1번부터 매겨져 있다. 새로 취임한 대통령은 서해안과 동해안을 연결하는 K개의 고속도로를 만들려고 한다. 각 고속도로는 동해안에 있는 도시와 서해안에 있는 도시를 연결하는 일직선 도로이다. (원래 일직선인 도로는 운전사를 지루하게 하고 피로감을 느끼게 하여 사고의 원인이 되므로, 일부러 고저를 만들거나 커브를 만들어서 그러한 일이 일어나지 않도록 설계되어 있다)</p>

<p>고속도로가 서로 교차하는 곳에는 휴게소를 지으려고 한다. 한 점에서 교차하는 고속도로는 최대 2개이다. 고속도로가 주어졌을 때, 고속도로가 교차하는 곳의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 N, M, K가 주어진다. K는 고속도로의 수이다. 둘째 줄부터 K개의 줄에는 고속도로의 정보가 주어진다. 고속도로의 정보는 숫자 2개로 이루어져 있다. 첫 번째 숫자는 동해안에 있는 도시의 번호이고, 두 번째 숫자는 서해안에 있는 도시의 번호이다.</p>

<p>고속도로의 개수는 40만개보다 작거나 같으며, 문제의 정답이 2<sup>63</sup>-1보다 작거나 같은 경우만 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 교차점의 수를 케이스 번호와 함께 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
3 4 4
1 4
2 3
3 2
3 1
','Test case 1: 5
','DATA_STRUCTURE'),
                                                                                                                (6527,'BAEKJOON','https://www.acmicpc.net/problem/3780',3780,'네트워크 연결','1초','128 MB',16,'<p>종빈이는 아주 큰 그룹의 총수다. 이 그룹은 1부터 N번까지의 번호로 구분할 수 있는 N개의 기업을 운영하고 있다. 현재 각 기업은 서로 독립적인 자체 컴퓨팅 및 통신센터를 가지고 있다.</p>

<p>어느 날 종빈이는 계열사의 CTO인 서현이에게 서비스 개선을 위해 각 기업의 서버를 네트워크로 연결하여 단일 통신센터에서 관리 가능한 클러스터 형태로 구성할 것을 제안했다. 종빈이의 제안을 들은 서현이는 다음과 같은 병합 과정을 고안해냈다.</p>

<ol>
	<li>클러스터 A를 제공하는 기존에 존재하는 센터 I를 고른다.</li>
	<li>클러스터 B를 제공하는 기업 J를 고른다. B는 A가 아닌 임의의 클러스터이며, J는 센터가 아닐 수 있다.</li>
	<li>I와 J를 통신 라인으로 연결한다. 이때 기업 I와 J를 잇는 라인의 길이는 |I ? J|(mod 1000)이다.</li>
	<li>위 방식을 통해 클러스터 A와 B는 새로운 클러스터로 합쳐지며, 이 클러스터는 B의 센터에 의해 제공된다.</li>
</ol>

<p>이러한 병합 과정을 거치던 중에, 각 기업에서 현재 센터까지 연결되는 라인의 길이가 총 얼마나 되는지에 관한 문의가 들어왔다. 서현이를 위해 병합하는 과정과 그 과정에서 통신센터와 각 기업을 잇는 라인의 길이를 구하는 프로그램을 작성해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트케이스로 주어진다. 입력의 첫 번째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스에는 기업의 수를 나타내는 N(4&nbsp;≤ N ≤ 20,000)이 주어진다. 다음은 몇 개의 줄에 걸쳐 아래 두 가지 종류의 명령어가 들어온다.</p>

<ul>
	<li>E I ? 기업 I와 현재 I의 센터까지의 거리를 출력한다.&nbsp;</li>
	<li>I I J ? 센터 I를 기업 J에 연결한다.</li>
</ul>

<p>각 테스트케이스의 끝에는 단어 O가 주어진다.&nbsp;<span style="font-family:Arial,&quot;Helvetica Neue&quot;,Helvetica,Tahoma,sans-serif">각 테스트케이스에서 명령어의 총 개수는 200,000개를 넘지 않으며, 그중 I 명령어의 개수는 N개보다 작다.</span></p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>E 명령어가 들어올 때마다 한 줄에 해당 거리를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
4
E 3
I 3 1
E 3
I 1 2
E 3
I 2 4
E 3
O
','0
2
3
5
','DATA_STRUCTURE'),
                                                                                                                (6528,'BAEKJOON','https://www.acmicpc.net/problem/3830',3830,'교수님은 기다리지 않는다','2초','256 MB',18,'<p>
	상근이는 매일 아침 실험실로 출근해서 샘플의 무게를 재는 일을 하고 있다. 상근이는 두 샘플을 고른 뒤, 저울을 이용해서 무게의 차이를 잰다.</p>

<p>
	교수님의 마음에 들기 위해서 매일 아침부터 무게를 재고 있지만, 가끔 교수님이 실험실에 들어와서 상근이에게 어떤 두 샘플의 무게의 차이를 물어보기도 한다. 이때, 상근이는 지금까지 잰 결과를 바탕으로 대답을 할 수도 있고, 못 할 수도 있다.</p>

<p>
	상근이는 결과를 출근한 첫 날부터 공책에 적어 두었다. 하지만, 엄청난 양의 무게가 적혀있기 때문에, 교수님의 질문에 재빨리 대답할 수가 없었다. 이런 상근이를 위해서 프로그램을 만들려고 한다.</p>

<p>
	상근이가 실험실에서 한 일이 순서대로 주어진다. 어떤 두 샘플의 무게의 차이를 구할 수 있는지 없는지를 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">


<p>
	입력은 여러 개의 테스트 케이스로 이루어져 있다.</p>

<p>
	각 테스트 케이스의 첫째 줄에는 샘플의 종류의 개수 N (2 ≤ N ≤ 100,000)과 상근이가 실험실에서 한 일의 수 M (1 ≤ M ≤ 100,000)이 주어진다. 샘플은 1번부터 N번까지 번호가 매겨져 있다. 다음 M개 줄에는 상근이가 실험실에서 한 일이 주어진다.</p>

<p>
	상근이가 무게를 쟀다면, ! a b w와 같은 형식으로 주어진다. 이 뜻은 b가 a보다 w그램 무겁다는 뜻이다. (a ≠ b) w는 1,000,000을 넘지 않는 음이 아닌 정수이다. 모든 측정은 정확하고, 일관성을 유지한다.</p>

<p>
	교수님의 질문은 ? a b와 같은 형식으로 주어진다. 이 뜻은 b가 a보다 얼마나 무거운지를 출력하라는 뜻이다.</p>

<p>
	마지막 줄에는 0이 두 개 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	교수님의 질문 (? a b)이 입력으로 들어올 때 마다, 지금까지 측정한 결과를 바탕으로 a와 b의 무게 차이를 계산할 수 있다면, b가 a보다 얼마나 무거운지를 출력한다. 무게의 차이의 절댓값이 1,000,000을 넘지 않는다. 만약, 측정한 결과를 바탕으로 무게의 차이를 계산할 수 없다면, "UNKNOWN"을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 2
! 1 2 1
? 1 2
2 2
! 1 2 1
? 2 1
4 7
! 1 2 100
? 2 3
! 2 3 100
? 2 3
? 1 3
! 4 3 150
? 4 1
0 0
','1
-1
UNKNOWN
100
200
-50
','DATA_STRUCTURE'),
                                                                                                                (6532,'BAEKJOON','https://www.acmicpc.net/problem/3837',3837,'사이버 도넛 범죄 수사','5초','128 MB',19,'<p>서기 2042년. 인터넷은 가상 현실을 만들 정도로 발전했고 사이버 범죄는 매일 일어난다. 그래서 2041년 SWERC 대회 우승자는 사이버 범죄가 일어날 때마다 도넛을 떨어뜨리는 요원을 개발해냈다. 모든 도넛은 고유 번호가 있고, 마드리드 경찰국은 범죄 정보와 그 범죄의 도넛 고유번호가 담긴 커다란 DB를 가지고 있다.</p>

<p>오늘은 너의 날이다. 너의 임무는 DB에 담긴 기록을 읽어 새로운 범죄 현장의 도넛과 유사한 도넛을 찾아내는 새로운 요원을 개발하는 것이다.</p>

<p>가상 범죄학 전문가들은 도넛 간의 유사성 판별의 기준을 제시했다. 그것은 도넛의 구멍의 반지름의 차와 도넛 전체의 반지름의 차의 합이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>모든 테스트 케이스는 첫 번째 줄에 DB 속의 도넛의 개수인 n이 주어진다.&nbsp;(1 ≤ n ≤ 100, 000)</p>

<p>그 뒤의 n개의 줄 중에서 i번째 줄은 i번째 도넛의 구멍의 반지름과 도넛 전체의 반지름을 나타내는 두 개의 정수 l과 w가 주어진다.&nbsp;(1 ≤ l, w ≤ 10<sup>9</sup>)</p>

<p>그리고 나서는 당신이 DB에서 찾는 도넛의 개수를 나타내는 q가 주어진다.&nbsp;(1 ≤ q ≤ 50, 000)</p>

<p>그 뒤의 q개의 줄 중에서 i번째 줄은 i번째 도넛의 차원을 나타낸다.</p>

<p>다른 테스트 케이스는 빈 줄로 구분되며 입력의 종료 전에 -1이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>매 테스트 케이스의 출력물은 정수로 이루어진 q개의 줄이어야 한다. i번째 줄에는 새로 발견된 i번째 도넛과 가장 가까운 DB의 도넛 간의 유사도를 출력하라.</p>

<p>서로 다른 테스트 케이스에 대한 답안은 빈 줄로 구분되어야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
2 3
3 4
2
1 1
3 4

2
1 1
9 9
4
4 5
6 5
2 5
3 4

-1
','3
0

7
7
5
5
','DATA_STRUCTURE'),
                                                                                                                (6537,'BAEKJOON','https://www.acmicpc.net/problem/3935',3935,'바람의 신','1초','128 MB',17,'<p>용태는 바람의 신이다.</p>

<p>용태는 구름을 움직여서 날씨를 조정할 수 있다. 구름의 밑에 있는 지역에는 항상 비가 내리며, 그 이외의 지역은 항상 맑다.</p>

<p>용태는 마음씨가 매우 좋기 때문에, 모든 마을에 비를 골고루 내리게 하려고 한다. 또, 축제나 시장이 열리는 날은 맑게 만들어 주려고 한다.&nbsp;</p>

<p>용태가 맡은 나라는 창영제국이라는 매우 작은 나라이다. 이 나라는 4×4 크기의 정사각형으로 이루어져 있으며, 다음과 같이 번호가 매겨져 있다. 한 마을은 1×1 정사각형 하나를 차지한다.</p>

<table class="table table-bordered" style="width:16%">
	<tbody>
		<tr>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>4</td>
		</tr>
		<tr>
			<td>5</td>
			<td>6</td>
			<td>7</td>
			<td>8</td>
		</tr>
		<tr>
			<td>9</td>
			<td>10</td>
			<td>11</td>
			<td>12</td>
		</tr>
		<tr>
			<td>13</td>
			<td>14</td>
			<td>15</td>
			<td>16</td>
		</tr>
	</tbody>
</table>

<p>구름의 크기는 2×2이며, 나라의 경계를 넘어갈 수 없다. 용태는 축제와 시장이 각 마을 별로 언제 열리는지를 알고 있다. 이 날은 그 마을에 비가 오면 안 된다.</p>

<p>첫 날에 구름은 이 나라의 중심부에 있다. (6-7-10-11)</p>

<p>그 다음 날 부터 하루가 시작하는 순간에 구름을 움직일 수 있다. 구름은 동서남북 중 한 방향으로 한 칸 또는 두 칸 움직일 수 있다. 구름을 전날과 같은 자리에 놔두는 것은 가능하다. 하지만, 대각선으로 움직이거나 서로 다른 방향으로 두 칸 움직이는 것은 불가능하다.</p>

<p>어떤 마을을 비가 오지 않은 채로 일주일을 내버려 두면 안 된다. 최대 6일까지 비가 오지 않은채로 있을 수 있지만, 적어도 7일이 되는 날에는 비가 와야 한다. 또, 문제가 시작하기 바로 전 날에는 모든 마을에 비가 왔고, N일 이후의 일은 전혀 관여할 필요가 없다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있으며, 마지막 줄에는 0이 하나 주어진다.</p>

<p>테스트 케이스의 첫째 줄에는 마지막 날 N이 주어진다. 다음 N개 줄에는 각 마을의 축제와 시장 계획이 주어진다. 한 줄에는 16개의 숫자가 주어지며, 1번마을부터 16번마까지 차례대로 주어진다. 1이면 축제나 시장이 열리는 것이고, 0이면 없는 것이다.</p>

<p>N은 365를 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다, 문제의 조건을 만족시키면서 비를 내리게 할 수 잇으면 1을, 없으면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1
0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1
0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0
0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0
7
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0
0 0 0 1 0 0 0 0 0 0 1 0 1 0 0 0
0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
0 0 1 1 0 0 0 0 0 1 0 0 0 0 0 0
1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0
0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0
1 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0
0
','0
1
0
1
','DATA_STRUCTURE'),
                                                                                                                (6539,'BAEKJOON','https://www.acmicpc.net/problem/3954',3954,'Brainf**k 인터프리터','7초','128 MB',15,'<p>Brainf**k 프로그램이 주어졌을 때, 이 프로그램이 끝나는지, 무한 루프에 빠지는지 알아내는 프로그램을 작성하시오.</p>

<p>무한 루프란, 특정 시점부터 탈출하지 않고 무한히 반복 실행되는 루프를 말한다.</p>

<p>Brainf**k 인터프리터는 정수를 담는 하나의 배열(unsigned 8-bit 정수)과, 그 배열의 칸 하나를 가리키는 포인터로 이루어져 있다. Brainf**k 프로그램은 다음과 같이 8개의 명령어로 이루어져 있다.</p>

<table class="table table-bordered" style="width:100%">
	<tbody>
		<tr>
			<th style="width:20%"><code>-</code></th>
			<td style="width:80%">포인터가 가리키는 수를 1 감소시킨다. (modulo 2<sup>8</sup>)</td>
		</tr>
		<tr>
			<th><code>+</code></th>
			<td>포인터가 가리키는 수를 1 증가시킨다. (modulo 2<sup>8</sup>)</td>
		</tr>
		<tr>
			<th><code><</code></th>
			<td>포인터를 왼쪽으로 한 칸 움직인다.</td>
		</tr>
		<tr>
			<th><code>></code></th>
			<td>포인터를 오른쪽으로 한 칸 움직인다.</td>
		</tr>
		<tr>
			<th><code>[</code></th>
			<td>만약 포인터가 가리키는 수가 0이라면,&nbsp;<code data-stringify-type="code">[</code>&nbsp;와 짝을 이루는&nbsp;<code data-stringify-type="code">]</code>&nbsp;의 다음 명령으로 점프한다.</td>
		</tr>
		<tr>
			<th><code>]</code></th>
			<td>만약 포인터가 가리키는 수가 0이 아니라면,&nbsp;<code data-stringify-type="code">]</code>&nbsp;와 짝을 이루는&nbsp;<code data-stringify-type="code">[</code>&nbsp;의 다음 명령으로 점프한다.</td>
		</tr>
		<tr>
			<th>.</th>
			<td>포인터가 가리키는 수를 출력한다.</td>
		</tr>
		<tr>
			<th>,</th>
			<td>문자 하나를 읽고 포인터가 가리키는 곳에 저장한다. 입력의 마지막(EOF)인 경우에는 255를 저장한다.</td>
		</tr>
	</tbody>
</table>

<p>인터프리터는 Brainf**k 프로그램의 첫 번째 명령부터 수행하고, 더이상 수행할 명령이 없다면, 프로그램을 종료한다. 각 명령을 수행하고 나면, 다음 명령을 수행한다.&nbsp;물론 <code>[</code>이나 <code>]</code>인 경우에는 다음 명령으로 이동하는 것이 아니라 점프를 한다.</p>

<p>데이터 배열의 크기는 문제에서 주어지는 값을 사용해야 한다. 또, 데이터 배열의 값이 underflow나 overflow를 일으켰을 때는 일반적인 방법을 따르면 된다. 프로그램을 수행하기 전에, 데이터 배열의 값은 0으로 초기화되어 있고, 포인터가 가리키는 칸은 0번 칸이다.</p>

<p>포인터를 왼쪽이나 오른쪽으로 움직일 때, 데이터 배열의 범위를 넘어간다면, 반대쪽으로 넘어가게 된다. 즉, 포인터가 0을 가리킬 때, 1을 감소시킨다면, 배열의 크기 - 1번째를 가리키게 된다.</p>

<p><code>[</code>와 <code>]</code>는 루프를 의미하며, 중첩될 수 있다. 입력으로 주어진 프로그램은 잘 짜여 있음이 보장된다. 즉 프로그램을 왼쪽에서 오른쪽으로 훑으면서 <code>[</code>의 개수에서 <code>]</code>의 개수를 빼면 항상 0보다 크거나 같고, 맨 끝까지 훑으면 그 값은 0이 된다.</p>

<p>이 문제는 Brainf**k 프로그램이 무한 루프에 빠지는지 안 빠지는지를 검사하기만 하면 된다. 따라서, 출력은 무시한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 t (0 < t ≤ 20)가 주어진다. 각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 s<sub>m</sub>, s<sub>c</sub>, s<sub>i</sub>가 주어진다. s<sub>m</sub>은 메모리(배열)의 크기이고, s<sub>c</sub>는 프로그램 코드의 크기, s<sub>i</sub>는 입력의 크기이다. (0 < s<sub>m</sub> ≤ 100,000, 0 < s<sub>c</sub>, s<sub>i</sub> < 4096)</p>

<p>둘째 줄에는 Brainf**k 프로그램이 주어진다. 프로그램은 s<sub>c</sub>개의 문자로 이루어져 있다.</p>

<p>셋째 줄에는 프로그램의 입력이 주어진다. (공백이 아니면서 출력할 수 있는 문자만 주어진다)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 프로그램이 종료된다면 "Terminates"를, 무한 루프에 빠지게 된다면 "Loops"를 출력한다. 무한 루프에 빠졌을 때는, 프로그램의 어느 부분이 무한 루프인지를 출력한다. (<code>[</code>와 <code>]</code>의 위치) 프로그램이 명령어를 50,000,000번 이상 수행한 경우, 프로그램은 항상 종료되었거나 무한 루프에 빠져있다. 무한 루프일 경우, 해당 루프는 적어도 한 번 실행이 완료된 상태이며, 한 번의 무한 루프에서 실행되는 명령어의 개수는 50,000,000개 이하이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
10 4 3
+-.,
qwe
1000 5 1
+[+-]
a
100 74 4
+++++[->++<]>[-<+++++++>]<[->+>+>+>+<<<<]>+++>--->++++++++++>---<<<.>.>.>.
xxyz
9999 52 14
+++++[>+++++++++<-],+[-[>--.++>+<<-]>+.->[<.>-]<<,+]
this_is_a_test
','Terminates
Loops 1 4
Terminates
Terminates
','DATA_STRUCTURE'),
                                                                                                                (6543,'BAEKJOON','https://www.acmicpc.net/problem/3986',3986,'좋은 단어','1초','256 MB',7,'<p>이번 계절학기에 심리학 개론을 수강 중인 평석이는 오늘 자정까지 보고서를 제출해야 한다. 보고서 작성이 너무 지루했던 평석이는 노트북에 엎드려서 꾸벅꾸벅 졸다가 제출 마감 1시간 전에 깨고 말았다. 안타깝게도 자는 동안 키보드가 잘못 눌려서 보고서의 모든 글자가 A와 B로 바뀌어 버렸다! 그래서 평석이는 보고서 작성을 때려치우고 보고서에서 좋은 단어나 세보기로 마음 먹었다.</p>

<p>평석이는 단어 위로 아치형 곡선을 그어 같은 글자끼리(A는 A끼리, B는 B끼리) 쌍을 짓기로 하였다. 만약 선끼리 교차하지 않으면서 각 글자를 정확히 한 개의 다른 위치에 있는 같은 글자와 짝 지을수 있다면, 그 단어는 좋은 단어이다. 평석이가 좋은 단어 개수를 세는 것을 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 단어의 수 N이 주어진다. (1 ≤ N ≤ 100)</p>

<p>다음 N개 줄에는 A와 B로만 이루어진 단어가 한 줄에 하나씩 주어진다. 단어의 길이는 2와 100,000사이이며, 모든 단어 길이의 합은 1,000,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 좋은 단어의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
ABAB
AABB
ABBA
','2
','DATA_STRUCTURE'),
                                                                                                                (6548,'BAEKJOON','https://www.acmicpc.net/problem/3988',3988,'수 고르기','1초','256 MB',17,'<p>수열이 주어졌을 때, M을 수열의 모든 두 원소의 차이 중 가장 큰 값이라고 한다. m은 그 차이 중 가장 작은 값이라고 한다.</p>

<p>크기가 N인 수열 V가 주어진다. 여기서 K개 수를 적절히 제거해서 M+m을 가능한 작게 만드는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N(3 ≤ N ≤ 1,000,000)과 K(1 ≤ K ≤ N-2)가 주어진다.</p>

<p>둘째 줄에 V의 원소가 공백으로 구분되어 주어진다. (-5,000,000 ≤ V<sub>i</sub> ≤ 5,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가장 작은 M+m을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
-3 -2 3 8 6
','7
','DATA_STRUCTURE'),
                                                                                                                (6553,'BAEKJOON','https://www.acmicpc.net/problem/4002',4002,'닌자배치','1초','256 MB',20,'<p>한 닌자 조직에서는 한 고객에게 닌자들을 배치하고, 닌자들이 그 고객을 위해 한 일에 대해 보상을 해주고 있다.&nbsp;</p>

<p>이 닌자 조직에서는 마스터라고 불리는 닌자 한 명이 있고, 마스터 닌자를 제외한 모든 닌자는 오직 한 명의 보스를 모시고 있다. 닌자들의 비밀을 유지하고, 리더십을 보장하기 위해 오직 보스만이 자신의 부하들에게 명령을 지시한다. 보스 이외의 다른 사람이 명령을 전달하는 것은 철저히 금지되어 있다. 당신은 조직 내 한 그룹의 닌자를 모아 고객 한 명에게 배치하려고 한다. 당신은 배치된 닌자들에게 월급을 준다. 각 닌자들은 자신이 받는 월급이 고정되어 있다. 닌자들에게 주는 월급의 총 액수는 주어진 예산 범위 안이어야만 한다. 더욱이, 명령을 전달하기 위해서는 당신은 한 명의 닌자를 매니저로 정하고, 그 매니저가 배치된 모든 닌자에게 명령을 전달하도록 한다. 명령이 지시가 되면, 배치가 안 된 닌자라도 그 명령이 전달될 수 있다.. 매니저는 배치에 동원될 수도 있고, 동원이 안될 수도 있다. 만약, 배치가 안되면, 월급은 없다.</p>

<p>당신은 주어진 예산안에서 고객의 만족도를 극대화하려고 한다. 고객의 만족도는 배치된 닌자의 총 수와 매니저의 리더십 레벨의 곱으로 계산이 된다. 각각의 닌자의 리더십 레벨은 고정이 되어 있다.</p>

<p>각 닌자 i (1 ≤ i ≤ N) 에 대해 보스 B<sub>i</sub>, 월급 C<sub>i</sub>, 그리고 리더십 레벨 L<sub>i</sub>가 주어지고, 그리고 월급으로 줄 수 있는 예산 M이 주어졌을 때, 매니저와 배치된 닌자가 주어진 조건을 만족하도록 선택이 되었을 때, 고객 만족도의 최댓값을 출력하는 프로그램을 작성하시오.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에 두 개의 자연수 N, M이 공백을 두고 주어진다. 여기서 N 닌자의 수이고, M은 총 예산이다.</p>

<p>그 다음의 N줄에 각 닌자의 보스, 월급, 그리고 리더십 레벨이 나온다. (i+1)-번째 줄에 세 개의 자연수 B<sub>i</sub>, C<sub>i</sub>, L<sub>i</sub>가 하나의 공백을 사이에 두고 주어진다. 여기서 B<sub>i</sub>는 닌자 i의 보스이고, C<sub>i</sub>는 닌자 i의 월급을, 그리고 L<sub>i</sub>는 닌자 i의 리더십 레벨을 표시한다. 만일 B<sub>i</sub> = 0이면, 닌자 i는 마스터이다. B<sub>i</sub> < i가 항상 만족되어야 하므로, 각 닌자에 대해 자신의 보스 번호는 항상 그 닌자의 번호보다 작다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>고객의 만족도가 최대가 되는 값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>만일 닌자 1을 매니저로 선택하고, 닌자 3과 4를 배치하면, 월급의 총 액수는 4이고 이 액수는 예산 4를 초과하지 않는다. 배치된 닌자의 수가 2명이므로, 매니저의 리더십 레벨은 3이고, 고객의 만족도는 6이 된다. 이 값은 최대 값이다.</p>

				</div>
				</div>','5 4
0 3 3
1 3 5
2 2 2
1 2 4
2 3 1
','6
','DATA_STRUCTURE'),
                                                                                                                (6563,'BAEKJOON','https://www.acmicpc.net/problem/4004',4004,'쿠나이','3초','256 MB',25,'<p>쿠나이(수리검)은 칼과 비슷하게 생긴 닌자들이 사용하는 정교한 무기이다. 닌자들은 이 칼을 적에게 던져서 적을 공격한다.</p>

<p>H개의 행(row)과 W개의 열(column)의 정사각형으로 이루어진 격자에 N명의 닌자가 있다. 모든 닌자는 정사각형의 중앙에 있으며, 하나의 정사각형에는 단 한 명의 닌자만 있을 수 있다. 각 닌자는 쿠나이를 가지고 있으며 네 방향(위, 아래, 좌 우) 중 한쪽 방향을 바라보고 있다. 초기(시간 0)에, 모든 닌자들은 자신들의 쿠나이를 그가 바라보고 있는 방향으로 던진다.</p>

<p>모든 쿠나이는 직선방향으로 1의 속도로 나아간다. 동시에 하나보다 많은 쿠나이가 같은 장소에 도달하면, 쿠나이들은 서로 충돌하여 사라진다. 쿠나이의 크기는 너무 작아서 무시할 수 있다. 또한, 닌자들은 매우 빨리 움직이기 때문에 쿠나이에 맞지 않는다. 쿠나이는 다른 쿠나이와 부딪히지 않는 한 속도가 줄어들지 않고 계속 같은 방향으로 움직인다.</p>

<p>다음의 그림에서, 화살표는 쿠나이를 나타낸다. 화살표의 방향이 쿠나이가 움직이는 방향이다. 다음의 그림에서 굵게 표시한 쿠나이는 충돌하는 것들이다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/k1.png" style="height: 123.333px; width: 374.167px;"></p>

<p>반면에, 다음의 각 그림에서는, 굵게 표시한 화살표는 다른 굵은 화살표와 충돌하지 않는다. 두 번째와 세 번째&nbsp;그림에서 얇은 화살표는 다른 굵은 화살표와 충돌한다. 충돌한 화살표는 사라지기 때문에, 이 그림들에서는 굵은 화살표가 다른 굵은 화살표와 충돌하지 않는다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/k2.png" style="width: 375.833px; height: 102.5px;"></p>

<p>W*H 격자에서 충분한 시간이 지난 후 쿠나이가 지나간 정사각형의 수를 계산하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 격자의 크기를 나타내는 두 정수 W와 H가 하나의 빈칸을 사이에 두고 주어진다. (1 ≤ W ≤ 1 000 000 000, 1 ≤ H ≤ 1 000 000 000)</p>

<p>두 번째 줄에는 닌자의 수를 나타내는 하나의 정수 N이 주어진다. (1 ≤ N ≤ 100 000)</p>

<p>그 다음 N개의 줄 중에서 i-번째 줄은 왼쪽으로부터 X<sub>i</sub>-번째 열(column)과 위로부터 Y<sub>i</sub>-번째 행(row)에 있는 닌자 i의 위치를 나타내는 세 정수 X<sub>i</sub>,Y<sub>i</sub>,D<sub>i</sub>가 주어진다. 같은 위치에는 두 명의 닌자가 있을 수 없다. 닌자 i의 방향은 D<sub>i</sub>의 값으로 나타낸다. (1 ≤ X<sub>i</sub> ≤ W, 1 ≤ Y<sub>i</sub> ≤ H)</p>

<ul>
	<li>D<sub>i</sub> = 0이면, 닌자 i는 오른쪽을 향하여 보고 있다.</li>
	<li>D<sub>i</sub> = 1이면, 닌자 i는 위쪽을 향하여 보고 있다.</li>
	<li>D<sub>i</sub> = 2이면, 닌자 i는 왼쪽을 향하여 보고 있다.</li>
	<li>D<sub>i</sub> = 3이면, 닌자 i는 아래쪽을 향하여 보고 있다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>W*H 격자에서 충분한 시간이 지난 후 쿠나이가 지나간 정사각형의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>이 예제에서, 초기의 (시간 0) 격자는 다음과 같이 나타난다.&nbsp;</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/e1.png" style="height:149px; width:188px"></p>

<p>닌자 i가 던진 쿠나이를 쿠나이 i라 하자. 시간 0.5에서는 쿠나이 2와 쿠나이 3이 충돌하여 사라질 것이다. 다음의 그림은 시간 1에서의 격자를 보여준다. 회색으로 표시된 정사각형은 쿠나이가 이미 지나간 정사각형을 나타낸다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/e2.png" style="height:157px; width:196px"></p>

<p>시간 2에서는 쿠나이 1과 쿠나이 5가 서로 충돌하여 사라질 것이다. 시간 2인 경우의 격자는 다음의 그림과 같다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/e3.png" style="height:152px; width:188px"></p>

<p>시간 2 이후에는 더 이상 쿠나이가 충돌하지 않는다. 충분한 시간이 지난 후의 격자는 다음과 같다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/e4.png" style="height:163px; width:196px"></p>

<p>마지막으로, 격자에서 쿠나이가 지나각 정사각형의 수는 11이다. 그러므로, 11을 출력해야 한다.</p>

				</div>
				</div>','5 4
5
3 3 2
3 2 0
4 2 2
5 4 1
1 1 3
','11
','DATA_STRUCTURE'),
                                                                                                                (6555,'BAEKJOON','https://www.acmicpc.net/problem/4012',4012,'컨벤션 센터','2초','64 MB',22,'<p>
	시루세리 정부는 새로운 컨벤션 센터를 건설하였다. 여러 단체들이 회의를 개최하기 위해 이곳을 사용하기를 원한다. 한 단체가 컨벤션 센터를 사용하고 있는 경우, 그 단체가 사용하는 동안에는 다른 단체들이 컨벤션 센터를 사용할 수 없다. 컨벤션 센터의 책임자는 가능하면 가장 많은 단체들이 컨벤션 센터를 이용할 수 있도록 단체들을 선정하기를 원한다. 물론, 이러한 선정 방법에는 여러 가지가 있을 수 있다.&nbsp;</p>

<p>
	예를 들어 다음의 네 단체의 경우를 고려해보자. 네 단체는 다음의 표에 나타난 기간 동안 컨벤션 센터를 사용하고 싶어 한다</p>

<p>
	<img alt="" src=https://www.acmicpc.net/upload/images/conv.png" style="width: 388px; height: 163px;"></p>

<p>
	이 예에서는 최대 두 단체가 컨벤션 센터를 이용할 수 있다. 그 후보로는 (단체1, 단체3) 혹은 (단체2, 단체3) 혹은 (단체1, 단체4)이다. 단, 컨벤션 센터를 이용할 때에는 한 단체의 끝나는 날짜와또 다른 한 단체의 시작 날짜가 겹칠 수 없음을 주의하라. 그러므로 단체1과 단체2는 날짜 9가 서로 겹치므로 컨벤션 센터를 사용하기 위해 동시에 선정될 수 없다.&nbsp;</p>

<p>
	컨벤션 센터의 책임자는 위의 예와 같이 단체 선정방법이 여러 가지가 존재할 때 다음과 같은 규칙으로 컨벤션 센터를 사용할 단체를 선정한다. 각 단체들은 컨벤션 센터 사용을 신청한 순서대로 번호가 매겨지고, 선정 후보가 되는 단체는 단체 번호의 오름차순으로 주어진다. 이러한 후보 집합들 중에 사전편집상의 순서(lexicographical order)로 가장 처음 나타나는 집합이 선정된다.</p>

<p>
	위의 예에서는 세 후보 집합 {(1,3), (2,3), (1,4)}에 대해서 사전편집상의 순서가 (1,3) < (1,4) < (2,3) 이므로 가장 처음 나타나는 후보 (1,3), 즉 단체1과 단체3이 컨벤션 센터 사용가능 단체로 선정되게 된다.&nbsp;</p>

<p>
	여러분이 할 일은 이 책임자를 도와서 어떤 단체가 컨벤션 센터를 사용할 지를 정하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>
	입력의 첫 번째 줄에는 컨벤션 센터를 사용하기 원하는 단체의 수 N(N≤200,000)이 정수로 주어진다. 두 번째 줄부터 시작해서 N개의 줄에는 단체의 번호 순서대로 각 줄마다 두 개의 정수가 주어지는데 이는 컨벤션 센터를 사용하기 원하는 각 단체의 시작 날짜와 끝 날짜를 의미한다.&nbsp;</p>
<p>
	각 단체가 요구하는 회의 시작 날짜는 항상 1보다 크거나 같고, 회의 끝 날짜는 10<sup>9</sup>을 초과하지 않는다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	출력의 첫 번째 줄에는 컨벤션 센터를 사용할 수 있는 최대 단체의 수 M을 출력한다. 두 번째 줄에는 사전편집상의 순서로 가장 처음 나타나는 M개의 단체의 번호를 오름차순으로 출력한다</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>
	사전편집상의 순서(lexicographical order)에서 리스트 l<sub>1</sub>이 리스트 l<sub>2</sub>보다 작다는 것은 l<sub>1</sub>이 l<sub>2</sub>의 접두어(prefix)이거나 l<sub>1</sub>과 l<sub>2</sub>가 서로 다른 첫 번째 위치 j에서 l<sub>1</sub>[j] < l<sub>2</sub>[j]의 관계가 성립함을 의미한다.</p>

				</div>
				</div>','4
4 9
9 11
13 19
10 17
','2
1 3
','DATA_STRUCTURE'),
                                                                                                                (6564,'BAEKJOON','https://www.acmicpc.net/problem/4014',4014,'도로','1초','128 MB',19,'<p>뉴 아시아 왕국에는 M개의 도로로 연결된 N개의 마을이 있다. 어떤 도로들은 자갈로, 그리고 다른 도로들은 콘크리트로 포장이 되어있다. 무료도로를 유지하기 위해서는 많은 경비가 필요하기 때문에 이 왕국에서 모든 도로를 무료화 하는 것은 불가능하여 보인다. 따라서 새로운 도로유지 방안이 필요하다.&nbsp;</p>

<p>왕은 무료도로의 수를 가능한 한 최소화하되, 어떤 마을에서 다른 마을로 갈 때 반드시 오직 하나의 무료도로로 이루어진 경로가 있도록 결정하였다. 또한 콘크리트 도로가 현대 교통에 적합하지만, 왕은 자갈길을 걷는 것이 매우 흥미 있다고 생각하였다. 결과적으로 왕은 정확히 K개의 자갈도로를 무료도로로 유지하기로 결정하였다.</p>

<p>예를 들어 뉴 아시아 왕국의 마을과 도로는 그림 1a와 같다. 만일 왕이 2개의 자갈도로를 무료로 하고자 하면, 왕국은 그림 1b와 같이 (1, 2), (2, 3), (3, 4), (3, 5)를 무료로 하여야 한다. 이 계획은 왕의 요구사항을 만족하는데 그 이유는 (1) 모든 두 마을이 무료도로를 통하여 연결되어 있으며, (2) 가능한 가장 적은 수의 무료도로를 가지고 있고, (3) 정확히 두 개의 무료 자갈도로를 포함한다: (2, 3)과 (3, 4)&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/70ed732a-9d35-490b-a67f-473711cc742a/-/preview/" style="width: 356.667px; height: 154.167px;"></p>

<p>그림1: (a) 뉴 아시아 왕국의 마을과 도로 예. 실선은 콘크리트 도로를 점선은 자갈도로를 뜻함. (b) 정확히 두 개의 무료 자갈도로를 포함하는 도로유지방안. 무료도로만 표시되었음.</p>

<p>뉴 아시아왕국의 도로와 왕이 원하는 무료자갈도로의 수가 주어졌을 때, 왕의 요구사항을 만족하는 도로유지방안이 있다면 그 방안을 출력하는 프로그램을 작성하는 것이다</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 세 개의 정수가 하나의 빈칸을 사이에 두고 주어진다.&nbsp;</p>

<ul>
	<li>N, 마을의 개수 (1≤ N ≤20,000),</li>
	<li>M, 도로의 개수 (1≤ M ≤100,000), 그리고</li>
	<li>K, 왕이 무료로 유지하기를 원하는 자갈도로의 개수 (0≤ K ≤ N-1)</li>
</ul>

<p>다음 M 줄에는 1에서부터 M까지의 도로가 기술된다. (i+1)번째 줄은 도로 i를 뜻한다. 여기에는 세 개의 정수가 하나의 빈칸을 사이에 두고 주어진다:&nbsp;</p>

<ul>
	<li>u<sub>i</sub>와 v<sub>i</sub>, 도로 i에 의해 연결되는 두 마을. 마을은 1부터 N으로 표시되며,&nbsp;</li>
	<li>c<sub>i</sub>는 도로 i의 종류; c<sub>i</sub> = 0은 자갈 도로, c<sub>i</sub> = 1은 콘크리트 도로를 뜻한다.</li>
</ul>

<p>인접한 두 마을을 연결하는 도로는 하나뿐이다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>만일 왕의 요구사항을 만족하는 도로유지방안이 없다면, 여러분의 프로그램은 no solution을 첫 번째 줄에 출력하여야 한다.</p>

<p>그렇지 않은 경우, 여러분의 프로그램은 유효한 도로유지방안의 무료도로들을 한 줄에 하나씩 열거하여 출력하여야 한다. 도로는 입력 시 주어진 형태로 출력이 되어야 하나, 도로의 순서는 어떤 순서라도 무방하다. 만일 유효한 도로유지방안이 여러 개가 있는 경우, 그 중 하나만 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 7 2
1 3 0
4 5 1
3 2 0
5 3 1
4 3 0
1 2 1
4 2 1
','3 2 0
4 3 0
1 2 1
5 3 1
','DATA_STRUCTURE'),
                                                                                                                (6541,'BAEKJOON','https://www.acmicpc.net/problem/4160',4160,'이혼','30초','128 MB',16,'<p><img alt="" src=https://www.acmicpc.net/upload/images/divorce.jpg" style="float:right; height:269px; width:269px">잭과 질은 이혼을 하게 되었고, 두 사람은 재산을 공평하게 나누려고 한다. 두 사람은 집을 N채 가지고 있고, 각 집의 가치는 1,000,000달러 보다 크거나 같고, 40,000,000보다 작거나 같다. 잭은 일부 집을 가져가고, 질도 일부 집을 가져간다. 남은 집은 판다.</p>

<p>잭이 가져가는 집의 가치의 합은 질의 합과 같아야 한다. 공평하게 나누는 경우가 여러 가지라면, 각 사람이 가진 집의 가치의 합을 가장 크게 하려고 한다.</p>

<p>집 N채의 가치가 주어졌을 때, 팔아야 하는 집의 가치를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 테스트 케이스 여러 개로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 집의 수 N이 주어진다. 집의 수는 24개를 넘지 않는다. 다음 N개 줄에는 집의 가치가 주어진다.</p>

<p>입력의 마지막 줄에는 0이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다, 집을 공평하게 나누기 위해 팔아야 하는 집의 가치를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>문제의 예제는 잭과 질이 가지고 있는 집 5채의 가치가 6,000,000, 30,000,000, 3,000,000, 11,000,000, 3,000,000인 경우이다. 잭이 6,000,000 달러 집, 질이 3,000,000 달러 집 두 개를 가져가면 두 사람은 공평하게 집을 나눌 수 있다. 남는 집 (11,000,000 달러, 30,000,000 달러) 의 합은 41,000,000 달러이다.</p>

				</div>
				</div>','5
6000000
30000000
3000000
11000000
3000000
0
','41000000
','DATA_STRUCTURE'),
                                                                                                                (6545,'BAEKJOON','https://www.acmicpc.net/problem/4195',4195,'친구 네트워크','3초','256 MB',14,'<p>민혁이는 소셜 네트워크&nbsp;사이트에서 친구를 만드는 것을 좋아하는 친구이다. 우표를 모으는 취미가 있듯이, 민혁이는 소셜 네트워크&nbsp;사이트에서 친구를 모으는 것이 취미이다.</p>

<p>어떤 사이트의 친구 관계가 생긴 순서대로 주어졌을 때, 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하시오.</p>

<p>친구 네트워크란 친구 관계만으로 이동할 수 있는 사이를 말한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스의 첫째 줄에는 친구 관계의 수 F가 주어지며, 이 값은 100,000을 넘지 않는다. 다음 F개의 줄에는 친구 관계가 생긴 순서대로 주어진다. 친구 관계는 두 사용자의 아이디로 이루어져 있으며, 알파벳 대문자 또는 소문자로만 이루어진 길이 20 이하의 문자열이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>친구 관계가 생길 때마다, 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
3
Fred Barney
Barney Betty
Betty Wilma
3
Fred Barney
Betty Wilma
Barney Betty
','2
3
4
2
2
4
','DATA_STRUCTURE'),
                                                                                                                (6549,'BAEKJOON','https://www.acmicpc.net/problem/4211',4211,'금고 회사','5초','256 MB',24,'<p>주식회사 금고는 매우 안전한 금고를 만드는 회사이다. 금고사의 최신 금고는 빛을 이용한다. 직사각형 그리드에 거울을 적절히 넣고, 레이저를 발사해 감지기에 레이저가 감지되는지를 확인한다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/mirro.png" style="height: 102.5px; width: 347.5px;"></p>

<p>레이저는 그리드의 가장 윗 행의 왼쪽에서 발사된다. 레이저가 거울을 만난 경우에 레이저는 반사된다. 모든 거울은 45도 대각선 방향 (\ 또는 /)이다. 레이저가 가장 아랫 행의 오른쪽으로 빠져 나올 때(왼쪽 그림), 금고가 열린다. 그 외의 경우에는 알람이 울린다.</p>

<p>모든 금고에는 거울이 한 개씩 빠져있다. (오른쪽 그림) 사용자는 거울 한 개를 비어있는 칸에 넣는다. 올바른 사용자는 거울의 정확한 위치와 모양 (4행 3열, /)을 알고 있기 때문에, 금고를 안전하게 열 수 있다.</p>

<p>금고의 정보가 주어졌을 때, 금고가 안전한지 아닌지 구하는 프로그램을 작성하시오. 안전한 금고는 거울을 넣지 않았을 때 열리면 안되며, 금고를 열 수 있는 거울의 위치와 모양이 적어도 한 개는 존재한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있고 각 테스트 케이스는 금고 하나를 나타낸다.</p>

<p>테스트 케이스의 첫째 줄에는 네정수 r, c, m, n이 주어진다. (1 ≤ r,c ≤ 1,000,000, 0 ≤ m,n ≤ 200,000) 금고는 r행 c열로 이루어져 있다.</p>

<p>다음 m개 줄에는 두 정수 r<sub>i</sub>와 c<sub>i</sub> (1 ≤ r<sub>i</sub> ≤ r, 1 ≤ c<sub>i</sub> ≤ c)가 주어지며, r<sub>i</sub>행 c<sub>i</sub> 열에 /모양의 거울이 있다는 뜻이다.</p>

<p>다음 n개 줄에도 \모양&nbsp;거울의 정보가 주어지며, /모양 정보와 같은 방식으로 주어진다.</p>

<p>모든 m+n개의 위치는 서로 다르다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다, 테스트 케이스 번호를 출력하고 다음을 출력한다.</p>

<ul>
	<li><code>0</code> 거울을 삽입하지 않고 금고를 열 수 있을때</li>
	<li><code>k r c</code> 거울을 넣지 않으면 금고가 열리지 않고, 금고를 열 수 있는 위치의 수가 k개, 그 중 가장 사전순으로 앞서는 위치가 (r, c)인 경우 (한 위치에 /와 \ 모양의 거울을 넣을 수 있는 경우에 위치 1개로 센다)</li>
	<li><code>impossible</code> 거울을 넣어도 금고를 열 수 없는 경우</li>
</ul>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 6 1 4
2 3
1 2
2 5
4 2
5 5
100 100 0 2
1 77
100 77
100 100 0 0
','Case 1: 2 4 3
Case 2: 0
Case 3: impossible
','DATA_STRUCTURE'),
                                                                                                                (6575,'BAEKJOON','https://www.acmicpc.net/problem/4373',4373,'수집합','1초','128 MB',15,'<p>정수 집합 S가 주어졌을 때, a + b + c = d를 만족하는 가장 큰 d를 구하는 프로그램을 작성하시오. 이때, a, b, c, d는 S의 원소이며, 서로 다른 수이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 집합 S의 크기 n(1 ≤ n ≤ 1000)이 주어진다. 다음 줄부터 n개의 줄에는 집합 S의 원소(-536870912&nbsp;~ +536870911)가 하나씩 주어진다. 집합의 원소는 중복되지 않는다. 입력의 마지막 줄에는 0이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 가장 큰 d를 출력한다. d가 없는 경우에는 "no solution"을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
2
3
5
7
12
5
2
16
64
256
1024
0
','12
no solution
','DATA_STRUCTURE'),
                                                                                                                (6585,'BAEKJOON','https://www.acmicpc.net/problem/4442',4442,'빌보의 생일','3초','256 MB',16,'<p>
	프로도와 샘은 다가오는 빌보의 111번째 생일 파티를 계획하려고 한다. 그들은 중간계의 모든 호빗을 생일 파티에 초대했고, 단 한 명의 예외도 없이 모두 참석하기로 했다. 호빗은 한 줄로 되어있는 매우 긴 식탁에 앉을것이다. 그러나, 프로도와 샘은 서로 대화를 하지 않으면서 파티를 계획했기 때문에, 각자 독자적으로 좌석표를 작성했다.</p>

<p>
	결국 프로도와 샘은 새로운 좌석표를 만들기로 했다. 이때, 새로운 좌석표와 두 좌석표에서 다른 순서로 앉은 쌍의 수를 최소로 하려고 한다. 이 값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>
	입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 호빗의 수를 나타내는 정수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 2개의 줄은 각각 프로도의 좌석표와 샘의 좌석표이다. 각 좌석표는 한 줄로 이루어져 있고, N개의 서로 다른 알파벳 문자열로 이루어져 있다. 두 좌석표에 등장하는 호빗의 이름은 모두 같다. 입력의 마지막 줄에는 0이 있다. 이름은 최대 6글자이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	각 테스트 케이스에 대해서, 최종 좌석표와 프로도와 샘의 좌석표에서 서로 다른 순서로 앉은 쌍의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
Frodo Sam Bilbo
Sam Frodo Bilbo
5
A B C D E
B A D E C
0
','1
3
','DATA_STRUCTURE'),
                                                                                                                (6583,'BAEKJOON','https://www.acmicpc.net/problem/4792',4792,'레드 블루 스패닝 트리','3초','256 MB',18,'<p>무방향, 무가중치, 연결 그래프가 주어진다. 그래프의 각 간선은 빨간색 또는 파란색으로 색칠되어져 있다. 이 그래프의 스패닝 트리 중 파란색 간선이 정확히 k개인 것이 있는지 없는지 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다.</p>

<p>각 테스트 케이스의 첫 줄에는 세 정수 n, m, k가 주어진다. n은 그래프의 정점의 개수 (2 ≤ n ≤ 1,000)이고, m은 간선의 개수, k는 문제에 설명되어 있는 파란색 간선의 개수 (0 ≤ k < n) 이다.</p>

<p>다음 m개 줄에는 간선의 정보가 주어지며, 각 정보는 세 정수 c, f, t로 이루어져 있다. c는 간선의 색상을 나타내며, 빨간색인 경우에는 R, 파란색인 경우에는 B이다. f와 t는 정수로 간선이 연결하는 두 정점을 나타낸다. (1 ≤ f, t ≤ n, f ≠ t) 두 정점을 연결하는 간선은 최대 한 개이다.</p>

<p>입력의 마지막 줄에는 0이 세 개 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 파란색 간선이 정확하게 k개인 스패닝 트리를 만들 수 있으면 1, 없으면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3 2
B 1 2
B 2 3
R 3 1
2 1 1
R 1 2
0 0 0
','1
0
','DATA_STRUCTURE'),
                                                                                                                (6587,'BAEKJOON','https://www.acmicpc.net/problem/4803',4803,'트리','1초','256 MB',12,'<p>그래프는 정점과 간선으로 이루어져 있다. 두 정점 사이에 경로가 있다면, 두 정점은 연결되어 있다고 한다. 연결 요소는 모든 정점이 서로 연결되어 있는 정점의 부분집합이다. 그래프는 하나 또는 그 이상의 연결 요소로 이루어져 있다.</p>

<p>트리는 사이클이 없는 연결 요소이다. 트리에는 여러 성질이 있다. 예를 들어, 트리는 정점이 n개, 간선이 n-1개 있다. 또, 임의의 두 정점에 대해서 경로가 유일하다.</p>

<p>그래프가 주어졌을 때, 트리의 개수를 세는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 n ≤ 500과 m ≤ n(n-1)/2을 만족하는 정점의 개수 n과 간선의 개수 m이 주어진다. 다음 m개의 줄에는 간선을 나타내는 두 개의 정수가 주어진다. 같은 간선은 여러 번 주어지지 않는다. 정점은 1번부터 n번까지 번호가 매겨져 있다. 입력의 마지막 줄에는 0이 두 개 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력으로 주어진 그래프에 트리가 없다면 "No trees."를, 한 개라면 "There is one tree."를, T개(T > 1)라면&nbsp;"A forest of T trees."를 테스트 케이스 번호와 함께 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 3
1 2
2 3
3 4
6 5
1 2
2 3
3 4
4 5
5 6
6 6
1 2
2 3
1 3
4 5
5 6
6 4
0 0
','Case 1: A forest of 3 trees.
Case 2: There is one tree.
Case 3: No trees.
','DATA_STRUCTURE'),
                                                                                                                (6610,'BAEKJOON','https://www.acmicpc.net/problem/4881',4881,'자리수의 제곱','1초','128 MB',7,'<p>양의 정수를 하나 고른 뒤, 각 자리수의 제곱의 합을 구한다. 이것을 계속 반복하면, 흥미로운 특징을 가지는 무한 수열을 얻을 수 있다.</p>

<p>가장 처음에 5로 시작했을 때, 다음과 같은 수열을 얻을 수 있다.</p>

<p>5, 25, 29, 85, 89, 145, 42, 20, 4, 16, 37, 58, ...</p>

<p>여기서 가장 흥미로운 특징은 58다음에 나타난다. 5<sup>2</sup> + 8<sup>2</sup> = 89로 이 숫자는 이미 수열에 나왔단 수이다. 즉, 58 다음부터 수열은 다음과 같은 구간이 반복해서 나온다. 89, 145, 42, 20, 4, 16, 37, 58</p>

<p>위의 사이클은 다른 숫자로 시작해도 나타나는 사이클이다. (3, 18, 36, 64, 등등등)</p>

<p>어떤 숫자는 1로 반복되는 사이클이 나타나기도 한다. 예를 들어 19로 시작했을 때를 살펴보자.</p>

<p>19, 82, 68, 100, 1, ...</p>

<p>두 숫자가 주어졌을 때, 같은 수가 나올 때 까지 필요한 수열의 길이의 합의 최솟값을 구하는 프로그램을 작성하시오.</p>

<p>예를 들어, 61과 29로 시작하면, (61, 37, 58, <strong>89</strong>)와 (29, 85, <strong>89</strong>)에서 같은 수를 만들 수 있다. 19와 100으로 시작하는 경우에는 (19, 82, 68, <strong>100</strong>), (<strong>100</strong>)으로 같은 수를 만들 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력을 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, A와 B가 주어진다. (0 < A, B < 10<sup>9</sup>)</p>

<p>마지막 줄에는 0이 두 개 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, A와 B를 출력하고, 두 수열의 길이의 합의 최솟값을 출력한다. 만약, 두 수열에서 같은 수가 나타나지 않는다면, 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>89, 145, 42, 20, 4, 16, 37, 58 사이클</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/cycle1.png" style="height:384px; width:389px"></p>

<p>1 사이클</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/cycle2.png" style="height:305px; width:288px"></p>

				</div>
				</div>','89 89
19 100
61 19
0 0
','89 89 2
19 100 5
61 19 0
','DATA_STRUCTURE'),
                                                                                                                (6600,'BAEKJOON','https://www.acmicpc.net/problem/4882',4882,'정규형','1초','128 MB',13,'<p><img alt="" src=https://www.acmicpc.net/upload/images/andortree.png" style="float:right; height:172px; width:164px">모든 불리언 식은 Disjunctive Normal Form(DNF)나 Conjunctive Normal Form(CNF)로 나타낼 수 있다. DNF는 하나 또는 그 이상의 CNF식을 OR로 연결한 식이고, CNF는 DNF식을 AND로 연결한 식이다.</p>

<p>AND/OR 트리는 DNF나 CNF 불리언 식을 트리와 같은 형태로 표현한 것이다. DNF나 CNF는 서로를 부분식으로 포함하기 때문에, 서브 트리의 레벨만 알면 그 서브&nbsp;트리가 AND트리인지 OR트리인지를 알 수 있다.</p>

<p>오른쪽 그림은 (A∨(B∧C))∧(D∨E)를 트리로 나타낸 것이다. 레벨 1(가장 위)과 3은 AND트리이다.</p>

<p>AND/OR 트리가 주어졌을 때, 식을 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 32,000글자를 넘지 않는다.</p>

<pre>(E<sub>1</sub> E<sub>2</sub> ... E<sub>n</sub>)</pre>

<p>항상 n > 0을 만족하고, E<sub>i</sub>가 T인 경우에는 true, F인 경우에는 false이다. 부분식도 이와 같은 형식으로 주어진다.</p>

<p>가장 낮은 레벨에 있는 트리는 AND 트리이다. 입력의 마지막 줄에는 ()가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 다음을 출력한다.</p>

<pre>k. E</pre>

<p>k는 테스트 케이스의 번호이고, E는 입력으로 주어진 식의 값 true 또는 false이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','((F(TF))(TF))
(TFT)
((TFT)T)
()
','1. false
2. false
3. true
','DATA_STRUCTURE'),
                                                                                                                (6614,'BAEKJOON','https://www.acmicpc.net/problem/4933',4933,'뉴턴의 사과','1초','128 MB',14,'<p>
	두 바이너리 트리 A와 B는 다음과 같은 두 조건을 만족할 때 동등하다고 한다.</p>

<p>
	1. 두 트리가 비어있다. 또는,</p>
<p>
	2. 두 트리의 루트가 같다. 또:</p>
<p>(a) A의 왼쪽 서브 트리가 B의 왼쪽 서브 트리와 동등하고, A의 오른쪽 서브 트리가 B의 오른쪽 서브 트리와 동등하다. 또는,</p>
<p>(b) A의 왼쪽 서브 트리가 B의 오른쪽 서브 트리와 동등하고, A의 오른쪽 서브 트리가 B의 왼쪽 서브 트리와 동등하다.</p>

<p>
	예를 들어, 아래 왼쪽 3개 트리는 서로 동등하다. 하지만, 가장 오른쪽 트리와는 동등하지 않다.</p>

<p>
	<img alt="" src=https://www.acmicpc.net/upload/images/tree(1).png" style="width: 389.167px; height: 128.333px;"></p>

<p>
	두 바이너리 트리가 주어졌을 때, 동등한지 아닌지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">

<p>
	첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 두 줄로 이루어져 있다. 각 줄은 비교해야 하는 트리의 정보이다.</p>

<p>
	각 트리의 정보는 포스트오더로 주어진다. 서브트리가 없는 경우에는 nil로 주어진다. 트리의 모든 데이터는 알파벳 대문자이다. 각 줄의 마지막은 end가 있다. 예를 들어, 문제 설명의 가장 왼쪽 그림을 포스트오더로 나타내면 다음과 같다.</p>

<p>
	nil nil nil G F nil nil C nil nil E nil D B A end</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	각 테스트 케이스에 대해서, 두 트리가 동등하면 true를, 아니면 false를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
nil nil nil G F nil nil C nil nil E nil D B A end
nil nil C nil nil E nil D B nil nil G nil F A end
nil nil nil E D nil nil C B nil nil nil G F A end
nil nil nil E C nil nil D B nil nil nil G F A end
','true
false
','DATA_STRUCTURE'),
                                                                                                                (6633,'BAEKJOON','https://www.acmicpc.net/problem/5012',5012,'불만 정렬','1초','256 MB',17,'<p>정렬 알고리즘의 상한(upper bound)은 n<sup>2</sup>이다. 이 사실은 쉽게 증명할 수 있다. 올바른 순서가 아닌 임의의 두 원소(a<sub>i</sub> > a<sub>j</sub>, i < j)를 선택하고, 그 위치를 서로 바꿔준다. 이렇게 올바른 순서가 아닌 것을 도치(inversion)라고 하며, 도치의 개수는 최대 n(n-1)/2개이다.&nbsp;</p>

<p>현주는 사회에 대한 불만이 많은 아이이다. 그는 항상 정렬을 할 때, 두 원소를 선택하는 것에도 큰 불만을 가지고 있다. 현주는 a<sub>i</sub> > a<sub>j</sub> > a<sub>k</sub>와 i < j < k를 만족하는 세 원소를 선택한 뒤, a<sub>k</sub>, a<sub>j</sub>, a<sub>i</sub>로 순서를 바꾸려고 한다.</p>

<p>현주는 자신이 만든 정렬 알고리즘을 불만 정렬 알고리즘이라고 이름을 붙였다. 이제 이 알고리즘의 상한을 구하려고 한다. 현주가 선택할 수 있는 세 원소의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 길이가 주어진다. (1 ≤ n ≤ 10<sup>5</sup>)</p>

<p>다음 줄에는 수열의 원소가 공백으로 구분되어 주어진다. 각 원소는 1보다 크거나 같고, n보다 작거나 같은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 도치된 세 원소 (a<sub>i</sub>&nbsp;> a<sub>j</sub>&nbsp;> a<sub>k</sub>와 i < j < k를 만족하는 세 원소)의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3 3 2 1
','2
','DATA_STRUCTURE'),
                                                                                                                (6634,'BAEKJOON','https://www.acmicpc.net/problem/5021',5021,'왕위 계승','1초','128 MB',12,'<p>유토피아의 왕이 사망했다. 왕은 자손을 남기지 않고 사망했기 때문에, 왕위를 계승할 사람을 지목하지 않았다. 왕실 귀족은 왕위를 주장하기 시작했다. 유토피아의 법에는 왕의 계승자가 없는 경우에, 나라를 세운 사람과 혈통이 가까운 사람이 유토피아를 통치한다는 조항이 있다.</p>

<p>나라를 세운 사람과 혈통이 가장 가까운 사람은 그의 자손이 아닌 사람과 피가 덜 섞인 사람이다. 모든 사람은 아버지의 혈통과 어머니의 혈통을 반 씩 받게 된다. 나라를 세운 사람의 자식은 1/2 왕족이며, 그 아들이 왕족이 아닌 사람과 결혼한 경우에는 아들의 자식은 1/4 왕족이 된다.</p>

<p>가장 나라를 세운 사람과 혈통이 가까운 사람을 찾는 프로그램을 작성하시오.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 M이 주어진다. (2 ≤ N, M ≤ 50)</p>

<p>둘째 줄에 유토피아를 세운 사람의 이름이 주어진다.</p>

<p>다음 N개 줄에는 가족 정보가 주어진다. 정보는 이름 세 개로 이루어져 있고, 공백으로 구분되어져 있다. 첫 번째 이름은 자식의 이름이고, 뒤의 두 이름은 부모의 이름이다.</p>

<p>다음 M개 줄에는 왕위를 계승받기를 주장하는 사람의 이름이 한 줄에 하나씩 주어진다.</p>

<p>모든 이름은 1~10글자이며, 알파벳 소문자로만 이루어져 있다. 나라를 세운 사람이 왕위를 계승하는 경우나, 누군가의 자식인 경우는 없다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 유토피아를 세운 사람과 가장 혈통이 가까운 사람의 이름을 출력한다. 항상 답이 유일한 경우만 입력으로 주어진다.</p>

<p>문제에 주어지는 가족 관계는 성별, 나이를 고려하지 않고 만들었기 때문에, 실제로는 말이 안되는 경우가 나올 수도 있다. 하지만, 모든 자식의 부모는 유일하며, 다시 자식이 부모의 부모가 되는 경우도 없다. 또, 한 사람이 여러 명의 자식이 될 수 도 없다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9 2
edwardi
charlesi edwardi diana
philip charlesi mistress
wilhelm mary philip
matthew wilhelm helen
edwardii charlesi laura
alice laura charlesi
helen alice bernard
henrii edwardii roxane
charlesii elizabeth henrii
charlesii
matthew
','matthew
','DATA_STRUCTURE'),
                                                                                                                (6643,'BAEKJOON','https://www.acmicpc.net/problem/5107',5107,'마니또','1초','128 MB',10,'<p>N명의 사람들이 있다. 이들은 각자 다른 한 명의 이름이 적힌 쪽지를 받아서, 그 사람에게 몰래 선행을 베푼다. 이때 자기 자신의 이름을 받을 수는 없으며, 선행을 받은 사람은 누가 자신을 도와줬는지도 알 수 없다.</p>

<p>그런데 이런 마니또 활동을 하던 중 할 짓이 지지리도 없던 세종이는 여기서 "마니또 체인"이라는 개념을 발견했다! 세종이가 동우에게 선행을 베풀고, 동우가 재혁이에게 선행을 베풀고, 재혁이가 호용이에게 선행을 베풀고... 이렇게 하다 보면 언젠가 누군가는 처음 선행을 베푼 세종이에게 선행을 베풀게 되리라는 것이다. 이렇게 선행을 베푸는 연결 고리가 반드시 생긴다! 이 고리는 그냥 2명일 수도 있고, 아예 N명 모두가 포함될 수도 있다.</p>

<p>우리가 할 일은 N명의 사람들 사이에서 이러한 연결 고리가 몇 개나 발생하는지를 알아내는 것이다. 문제는 여러 개로 이루어져 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>각 테스트 케이스의 첫 번째 줄에는 사람의 명수 N이 주어진다(3 <= N <=20). 만약 N = 0이면 입력의 끝을 의미하며 더 이상의 입력은 없다.</p>

<p>각 테스트 케이스의 두 번째 줄부터 N개의 줄에 거쳐 두 사람의 이름이 주어진다. 각&nbsp;줄에 누가 누구에게 선행을 베푸는지가 주어진다. 첫 번째 이름과 두 번째 이름은 각각 해당 케이스&nbsp;전체에 걸쳐 중복되지 않으며, 한 줄에 같은 이름이 두 번 등장하지 않는다. 이름의 길이는 10자를 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다, 한 줄에&nbsp;해당 케이스의 번호(1부터 시작)와 연결 고리의 개수를 공백을 두고 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
Andrew Sally
Chen Andrew
Ahmed Tess
Sally Chen
Tess Ahmed
0
','1 2
','DATA_STRUCTURE'),
                                                                                                                (6650,'BAEKJOON','https://www.acmicpc.net/problem/5215',5215,'로테이트','1초','128 MB',21,'<p>상근이와 정인이는 로테이트라는 새로운 게임을 창안했다. 먼저, 정인이는 길이가 N인 수열을 생각한다. 그 다음, 각 섹션에 K개의 수가 들어있도록 수열을 섹션으로 나눈다. (K는 N을 나눌 수 있는 수) 첫 번째 섹션에는 수열의 첫 K개 수가 포함되고, 두 번째 섹션에는 그 다음 K개 수가 포함된다. 나머지 섹션에도 이런식으로 수가 포함된다.</p>

<p>상근이와 정인이는 아래와 같은 두 가지 연산을 수열에 행할 수 있다.</p>

<ol>
	<li>각 섹션을 왼쪽 또는 오른쪽으로 X만큼 회전(rotate)시킨다.</li>
	<li>수열 전체를 왼쪽 또는 오른쪽으로 X만큼 회전시킨다.</li>
</ol>

<p>2번 연산은 수열 전체에 행하는 연산이기 때문에, 각 섹션에 들어있는 수를 바꿀 수도 있다. 정인이느 자기가 생각한 수열에 위의 연산을 수행한 다음에 상근이에게 최종 수열을 보여준다. 최종 수열과 정인이가 행한 연산이 순서대로 주어졌을 때, 처음 수열을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 길이 N, 섹션의 크기 K, 정인이가 행한 연산의 수 Q가 주어진다. (1 ≤ N, K, Q ≤ 100,000)</p>

<p>다음 Q개 줄에는 정인이가 수열에 행한 연산이 순서대로 주어진다. 각 줄의 처음에는 어떤 연산인지를 나타내는 A (1 ≤ A ≤ 2)가 주어지며, 그 다음 수는 얼만큼 돌렸는지를 나타내는 X (-100,000 ≤ X ≤ 100,000)이다. 음수는 왼쪽 방향, 양수는 오른쪽 방향 회전이다.</p>

<p>마지막 줄에는 모든 연산을 수행하고 난 뒤의 최종 수열이 공백으로 구분되어서 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 처음 정인이가 생각한 수열을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2 2
2 2
1 1
3 2 1 0
','0 1 2 3
','DATA_STRUCTURE'),
                                                                                                                (6618,'BAEKJOON','https://www.acmicpc.net/problem/5397',5397,'키로거','1초','256 MB',9,'<p>창영이는 강산이의 비밀번호를 훔치기 위해서 강산이가&nbsp;사용하는 컴퓨터에 키로거를 설치했다. 며칠을 기다린 끝에 창영이는 강산이가 비밀번호 창에 입력하는 글자를 얻어냈다.</p>

<p>키로거는 사용자가 키보드를 누른 명령을 모두 기록한다. 따라서, 강산이가 비밀번호를 입력할 때, 화살표나 백스페이스를 입력해도&nbsp;정확한 비밀번호를 알아낼 수 있다.&nbsp;</p>

<p>강산이가 비밀번호 창에서 입력한 키가 주어졌을 때, 강산이의 비밀번호를 알아내는 프로그램을 작성하시오.&nbsp;강산이는 키보드로 입력한 키는 알파벳 대문자, 소문자, 숫자, 백스페이스, 화살표이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한줄로 이루어져 있고, 강산이가 입력한 순서대로 길이가 L인 문자열이 주어진다. (1 ≤ L ≤ 1,000,000) 강산이가 백스페이스를 입력했다면, -가 주어진다. 이때 커서의 바로 앞에 글자가 존재한다면, 그 글자를 지운다. 화살표의 입력은 <와 >로 주어진다. 이때는 커서의 위치를 움직일 수 있다면, 왼쪽 또는 오른쪽으로 1만큼 움직인다. 나머지 문자는 비밀번호의 일부이다. 물론, 나중에 백스페이스를 통해서 지울 수는 있다. 만약 커서의 위치가 줄의 마지막이 아니라면, 커서 및 커서 오른쪽에 있는 모든 문자는 오른쪽으로 한 칸 이동한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 강산이의 비밀번호를 출력한다. 비밀번호의 길이는 항상 0보다 크다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
<<BP<A>>Cd-
ThIsIsS3Cr3t
','BAPC
ThIsIsS3Cr3t
','DATA_STRUCTURE'),
                                                                                                                (6623,'BAEKJOON','https://www.acmicpc.net/problem/5419',5419,'북서풍','1초','256 MB',17,'<p>강한 북서풍이 불고 있다. 이 뜻은 동쪽과 남쪽 사이의 모든 방향으로 항해할 수 있다는 뜻이다. 북쪽이나 서쪽으로 항해하는 것은 불가능하다.</p>

<p>작은 섬이 여러 개 있는 바다가 있다. 섬은 좌표 평면의 한 점으로 나타낼 수 있다. y 좌표가 증가하는 방향은 북쪽, x좌표가 증가하는 방향은 동쪽이다. 북서풍을 타고 항해할 수 있는 섬의 쌍의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수가 주어진다.</p>

<p>각 테스트 케이스의 첫째 줄에는 섬의 수 n (1 ≤ n ≤ 75000)이 주어진다. 다음 n개 줄에는 각 섬의 좌표 x<sub>i</sub>, y<sub>i</sub>가 주어진다. 두 섬의 좌표가 같은 경우는 없다. (-10<sup>9</sup> ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 북서풍을 타고 항해할 수 있는 섬의 쌍의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
4
-10 -10
-10 10
10 -10
10 10
3
1 3
2 2
3 1
','5
3
','DATA_STRUCTURE'),
                                                                                                                (6626,'BAEKJOON','https://www.acmicpc.net/problem/5460',5460,'양궁','1초','128 MB',28,'<p>재현이는 얼마 전 토너먼트 형태의 양궁 대회를 열었다. 1번부터 N번까지 번호가 매겨진 N개의 표적이 일직선상에 순서대로 (가장 좌측에 1번부터 시작하여 오른쪽에 N번으로 끝난다.) 나열되어 있으며, 2×N 명의 궁수들이 있다.</p>

<p>토너먼트는 다음과 같이 진행된다 - 한 표적에는 항상 2명의 궁수들이 할당되어 있으며, 두 궁수는 한 표적을 두고 경쟁하며 승자와 패자를 가른다. 승자와 패자가 결정된 후에는, 2 ~ N 표적에서 승리한 궁수들이 왼쪽 표적으로 이동하며 (1 ~ N-1 표적으로), 2 ~ N 표적에서 패배한 궁수들은 그 자리에 머무른다. 이때 1번 표적에서 승리한 궁수는 그 자리에 머무르며, 1번 표적에서 패배한 궁수는 N번째 표적으로 이동한다. 이 토너먼트는 R번 진행되며, R ≥ 2×N임이 보장된다.</p>

<p>경험있는 양궁 해설가 승원이는 자신을 포함에서 이번에 출전하는 양궁 선수의 실력 등급을 모두 알고 있다. 각 선수의 실력 등급은 1 ~ 2×N 까지의 수로 표시되며, 등급이 낮은 선수일수록 뛰어난 선수이다. 승원이의 이 데이터는 정말 정확해서, 항상 실력이 높은 선수가 실력이 낮은 선수를 이긴다는 사실을 보장할 수 있다. 승원이는 양궁 해설에 타고난 재능을 가지고 있지만 이상하게 양궁 자체에는 별 관심이 없어서, 이번 대회에서 이기는 것보다는 오늘 밤 있는 코드포스 라운드를 놓치지 않는 것에 더 관심이 있다. 출구는 맨 왼쪽에 있기 때문에, 승원이는 R번의 라운드가 끝나고 나서 가장 왼쪽 타겟에 서 있기를 원한다.</p>

<p>다행이도, 승원이를 제외한 2×N-1명의 궁수가 연습을 위해 일찍 대회장에 나와있었다. 승원이는 적절한 위치에 끼어들어가서 양궁 경기를 시작하려 한다. 과연 승원이는 어떠한 위치에 끼어들어가야지 가장 일찍 집에 들어갈 수 있을까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로부터 다음의 데이터를 읽어야 한다 :</p>

<ul>
	<li>첫 번째 줄에 N과 R이 주어진다.</li>
	<li>두 번째 줄에는 승원이의 실력 등급이 주어진다.</li>
	<li>세 번째 줄 이후 2×N-1개의 줄에 각 선수의 실력 등급이 주어진다. 현재 선수들은 주어지는 순서대로 왼쪽에서 오른쪽으로 서 있다. 즉 세 번째 줄에 적혀있는 선수가 가장 왼쪽에 있으며, 2×N+1번째 줄에 적혀있는 선수가 가장 오른쪽에 있다. 실력 등급은 2×N 보다 작거나 같은 서로 다른 자연수이다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>승원이가 집에 일찍 들어가기 위해 끼어들어가야 할 위치를 출력한다. 이때 위치는, 승원이가 처음 경쟁할 때 삼을 표적의 번호를 뜻한다. 만약에 최적의 위치가 여러 곳이라면, 그 중 가장 번호가 높은 위치를 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>승원이의 실력 등급은 7이다. 1번 표적에서 시작할 경우 승원이는 4번 표적으로 간 후 끝까지 해당 표적에 머무른다. 2번 표적이나 4번 표적에서 시작할 경우 승원이는 끝까지 해당 표적에 머무른다. 3번 표적에서 시작할 경우 승원이는 실력 등급이 8인 궁수를 이기고 2번 표적에 끝까지 머무른다.</p>

				</div>
				</div>','4 8
7
4
2
6
5
8
1
3
','3

','DATA_STRUCTURE'),
                                                                                                                (6628,'BAEKJOON','https://www.acmicpc.net/problem/5461',5461,'고용','1초','128 MB',18,'<p>재현이는 초고층 건물인 "제2사과타워"를 짓기 위해 노동자들을 고용하고 있다. 1번부터 N번까지 총 N명의 노동자들이 지원했는데, i (1 ≤ i ≤&nbsp;N)번째 노동자는 최저임금 S<sub>i</sub>를 가지고 있어 Si보다 크거나 같은 만큼의 임금을 받아야 하며, 또한 Q<sub>i</sub>라는 건설 자격증 레벨을 가지고 있다.</p>

<p>최근 정부에서는 건설 자격증을 활성화하기 위해서, 노동자들의 임금을 항상 자격증 레벨에 비례하기 지급하게 하는 규정을 만들었다. 만약 A라는 노동자의 자격증 레벨이 Q<sub>a</sub>이고, B라는 노동자의 자격증 레벨이 Q<sub>b</sub>라면, A의 임금은 Q<sub>a</sub> * k, B의 임금은 Q<sub>b</sub> * k가 되어야 한다. 노동자들에게 지급하는 임금은 정수가 아닌 실수 범위여도 무방하다.</p>

<p>재현이는 수중에 W달러를 가지고 있으며, 사실 재현이는 자격증에 대해서는 별로 관심이 없고 그저 건물을 빨리 짓고 싶기 때문에, 자격증 레벨과 상관없이 현재 자금 내에서 가장 많은 노동자들을 고용하고 싶어 한다. 만약 고용할 수 있는 노동자의 수가 같다면, 노동자들에게 최소 비용을 지급하는 고용 방안을 원하며, 노동자의 수와 비용이 같다면 어떤 방법이든지 상관 없다. 재현이를 도와, 고용할 수 있는 노동자의 최대 수와 그 때 고용해야 할 노동자를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로부터 다음의 데이터를 읽어야 한다:</p>

<ul>
	<li>첫째 줄에는 N과 W가 주어진다.</li>
	<li>이후 N개 줄에 각 노동자의 정보가 주어진다. 이후 주어지는 정보의 i번째 줄에는 i번째 노동자의 최저임금 S<sub>i</sub>, 자격증 레벨 Q<sub>i</sub>가 주어진다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력에 최대로 고용할 수 있는 노동자의 수 H를 출력하며, 이후 H개의 줄에 고용하고 싶어하는 노동자들의 번호를 출력한다. 노동자들의 번호는 제각기 달라야 하며 순서는 어떤 순서여도 상관없다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 100
5 1000
10 100
8 10
20 1
','2
2
3
','DATA_STRUCTURE'),
                                                                                                                (6629,'BAEKJOON','https://www.acmicpc.net/problem/5464',5464,'주차장','1초','128 MB',9,'<p>시내 주차장은 1부터 N까지 번호가 매겨진 N개의 주차 공간을 가지고 있다. 이 주차장은 매일 아침 모든 주차 공간이 비어 있는 상태에서 영업을 시작하며, 하룻동안 다음과 같은 방식으로 운영된다. 차가 주차장에 도착하면, 주차장 관리인이 비어있는 주차 공간이 있는지를 검사한다. 만일 비어있는 공간이 없으면, 차량을 빈 공간이 생길 때까지 입구에서 기다리게 한다. 만일 빈 주차 공간이 하나만 있거나 또는 빈 주차 공간이 없다가 한 대의 차량이 주차장을 떠나면 곧바로 그 장소에 주차를 하게 한다. 만일 빈 주차 공간이 여러 곳이 있으면, 그 중 번호가 가장 작은 주차 공간에 주차하도록 한다. 만일 주차장에 여러 대의 차량이 도착하면, 일단 도착한 순서대로 입구의 대기장소에서 줄을 서서 기다려야 한다. 대기장소는 큐(queue)와 같이, 먼저 대기한 차량부터 주차한다.</p>

<p>주차료는 주차한 시간이 아닌 차량의 무게에 비례하는 방식으로 책정된다. 주차료는 차랑의 무게에다 주차 공간마다 따로 책정된 단위 무게당 요금을 곱한 가격이다.</p>

<p>주차장 관리원은 오늘 M대의 차량이 주차장을 이용할 것이라는 것을 알고 있다. 또한, 차량들이 들어오고 나가는 순서도 알고 있다.</p>

<p>주차 공간별 요금과 차량들의 무게와 출입 순서가 주어질 때, 오늘 하룻동안 주차장이 벌어들일 총 수입을 계산하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>반드시 표준 입력으로부터 다음의 데이터를 읽어야 한다.</p>

<ul>
	<li>첫 번째 줄에는 정수 N과 M이 빈칸을 사이에 두고 주어진다.</li>
	<li>그 다음 N개의 줄에는 주차 공간들의 단위 무게당 요금을 나타내는 정수들이 주어진다. 그 중 s번째 줄에는 주차 공간 s의 단위 무게당 요금 Rs가 들어있다.</li>
	<li>그 다음 M개의 줄에는 차량들의 무게를 나타내는 정수들이 주어진다. 차량들은 1 부터 M 까지 번호로 구분되고, 이 번호는 출입 순서와는 상관없다. 이 M개의 줄 중 k번째 줄에는 차량 k의 무게를 나타내는 정수 Wk가 들어있다.</li>
	<li>그 다음 2*M 개의 줄에는 차량들의 주차장 출입 순서를 나타내는 정수들이 한 줄에 하나씩 주어진다. 양의 정수 i는 차량 i가 주차장에 들어오는 것을 의미하고, 음의 정수 -i는 차량 i가 주차장에서 나가는 것을 의미한다. 주차장에 들어오지 않은 차량이 주차장에서 나가는 경우는 없다. 1 번부터 M 번까지 모든 차량은 정확하게 한 번씩 주차장에 들어오고, 한 번씩 주차장에서 나간다. 또한 입구에서 대기 중인 차량이 주차를 하지 못하고 나가는 경우는 없다.</li>
</ul>

<ul>
	<li>1 ≤ N ≤ 100 주차 공간의 수</li>
	<li>1 ≤ M ≤ 2,000 차량의 수</li>
	<li>1 ≤ Rs ≤ 100 주차 공간 s의 단위 무게당 요금</li>
	<li>1 ≤ Wk ≤ 10,000 차량 k의 무게</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 반드시 표준 출력으로 하여야 하며, 하나의 줄에 한 개의 정수를 출력한다. 이 정수는 오늘 하룻동안 주차장이 벌어들인 총 수입이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<ul>
	<li>차량 3이 주차 공간 1에 주차한다. 주차료는 300 * 2 = 600 이다.</li>
	<li>차량 2가 주차 공간 2에 주차한다. 주차료는 100 * 3 = 300 이다.</li>
	<li>차량 1이 차랑 3이 떠난 주차공간 1에 주차한다. 주차료는 200 * 2 = 400 이다.</li>
	<li>차량 4가 마지막 남은 주차 공간 3에 주차한다. 주차료는 800 * 5 = 4,000 이다.</li>
</ul>

				</div>
				</div>','3 4
2
3
5
200
100
300
800
3
2
-3
1
4
-4
-2
-1
','5300
','DATA_STRUCTURE'),
                                                                                                                (6636,'BAEKJOON','https://www.acmicpc.net/problem/5466',5466,'상인','1초','128 MB',22,'<p>어떤 상인이 육지에서 최적 여행 스케줄을 구하는 것이 매우 어려웠기 때문에, 직선으로 흐르는 다뉴브강을 따라 이동하면서 물건을 팔기로 했다. 이 상인은 다뉴브 강을 따라 임의의 위치로부터 다른 임의의 위치로 순식간에 갈 수 있는 매우 빠른 보트를 가지고 있다. 그러나 이 보트는 연료 소비량이 매우 많다. 이 보트로 강이 시작되는 방향으로 거슬러 올라갈 때는 미터당 U 달러가 소비되고 강을 아래로 내려갈 때는 미터당 D 달러가 소비된다.</p>

<p>이 상인이 강을 따라 방문하고자 하는 시장이 N개 있으며 각 시장은 단 하루만 열린다. 각 시장 X에 대하여, 보트를 구입한 날을 기준으로 하여 이 시장이 열리는 날짜를 나타내는 Tx, 또한 강이 시작하는 곳으로부터 이 시장까지의 거리(미터) Lx, 이 시장을 방문하면 얻는 이익(달러) Mx를 알고 있다. 강이 시작하는 곳부터 상인이 사는 집까지의 거리는 S이다. 상인은 자기 집에서 출발하여 시장들을 방문한 다음 다시 자기 집으로 돌아와서 여행을 끝낸다.</p>

<p>시장을 방문하는 여행을 통해서 상인이 이익을 최대로 얻기 위해서, 어느 시장들을 선택하여 어떠한 순서대로 방문해야 할지를 결정하는 것을 도와주고자 한다. (선택하는 시장들이 전혀 없을 수도 있다.) 상인이 얻는 전체 이익은 시장들을 방문하여 얻는 이익의 합에서 강을 따라 오르내리는 데 드는 연료 비용을 뺀 것이다.</p>

<p>시장 A와 시장 B를 모두 방문할 경우, 이들 두 시장을 방문하는 순서는 시장이 열리는 날짜 순서대로임에 유의하라. 예를 들어 시장 A가 시장 B보다 먼저 열리면, 시장 B를 먼저 방문한 다음에 시장 A를 방문할 수는 없다. 그러나 두 시장이 같은 날에 열리면, 임의의 순서로 이들 두 시장을 방문할 수 있다. 하루에 방문할 수 있는 시장의 개수에는 제한이 없다. 두 배의 이익을 얻기 위해 같은 시장을 두 번 방문할 수는 없지만, 이미 방문한 시장을 이익을 얻지 않고 거쳐서 지나갈 수는 있다.</p>

<p>보트의 미터당 연료 비용, 상인이 사는 집의 위치, 각 시장이 열리는 날짜, 위치, 시장을 방문할 때 얻는 이익이 주어질 때 여행을 끝마친 후 얻을 수 있는 최대 이익을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로부터 다음의 데이터를 읽어야 한다 :</p>

<ul>
	<li>첫 번째 줄에 정수들 N, U, D 와 S가 빈칸 하나를 사이에 두고 차례대로 주어진다.</li>
	<li>다음의 N 개의 줄에는 특별한 순서 없이 N개의 시장들에 대한 정보가 주어진다. 이들 N개의 줄 중 k번째 줄은 k번째 시장을 나타내며 이 줄에 세 개의 정수가 빈칸 하나를 사이에 두고 차례대로 주어진다 : 시장이 열리는 날 Tk, 시장의 위치 Lk, 시장을 방문할 때 얻는 이득 Mk.</li>
</ul>

<p>유의 사항 : 입력으로 주어지는 위치들은 모두 다르다. 즉, 같은 장소에서 두 시장이 열리지 않으며 상인이 사는 장소에서는 시장이 열리지 않는다.</p>

<ul>
	<li>1 ≤ N ≤ 500,000 시장의 개수</li>
	<li>1 ≤ D ≤ U ≤ 10 보트를 타고 강을 거슬러 올라갈 때 드는 미터당 비용 (U), 강을 따라 내려갈 때 드는 미터당 비용(D)</li>
	<li>1 ≤ S ≤ 500,001 상인이 살고 있는 집의 위치</li>
	<li>1 ≤ Tk ≤ 500,000 시장 k가 열리는 날</li>
	<li>1 ≤ Lk ≤ 500,001 시장 k의 위치</li>
	<li>1 ≤ Mk ≤ 4,000 시장 k를 방문할 때 얻는 이익</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 여행을 끝낸 뒤 얻을 수 있는 최대 이득에 해당하는 하나의 정수를 한 줄에 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>
	최적인 스케줄은 시장 1과 시장 3 (위치 80과 위치 75에 있는 시장들) 을 방문하는 것이다. 방문하는 순서와 이때 얻는 이익 및 비용은 다음과 같다:
</p>
<ul>
	<li>상인은 100 달러의 비용으로 강을 20미터 거슬러 위로 올라간다. 지금까지 이득 : -100</li>
	<li>시장 1을 방문하여 100달러 이익을 얻는다. 지금까지 이득 : 0</li>
	<li>25 달러의 비용으로 강을 5미터 거슬러 위로 올라간다. 지금까지 이득 : -25</li>
	<li>시장 3을 방문하여 150달러 이익을 얻는다. 지금까지 이득 : 125</li>
	<li>75 달러의 비용으로 강을 따라 25미터 아래로 내려가서 집에 돌아간다. 마지막 이득 : 50</li>
</ul>

				</div>
				</div>','4 5 3 100
2 80 100
20 125 130
10 75 150
5 120 110
','50
','DATA_STRUCTURE'),
                                                                                                                (6642,'BAEKJOON','https://www.acmicpc.net/problem/5476',5476,'장난감 동물','2초','128 MB',21,'<p>상근이와 선영이는 장난감 동물을 가지고 재미있게 놀려고 한다. 먼저, 아래 세 가지 게임판 중 하나를 선택한다. 각 게임판은 여러 개의 칸(그림에는 동그라미)으로 이루어져 있고, 각 게임판은 일차원, 이차원, 삼차원 모양이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/28de2c25-ff44-40eb-a9f6-455f475fcd7c/-/preview/" style="width: 356.667px; height: 77.5px;"></p>

<p>상근이는 N개의 작은 장난감 동물을 칸에 넣는다.</p>

<p>두 칸의 거리는 장난감 동물이 한 칸에서 출발해서 다른 칸으로 도착하는데 필요한 이동의 횟수이다. 장난감 동물은 자신이 있는 칸과 인접한 칸 중 하나로 이동할 수 있다. (각 칸과 인접한 칸은 그림에서 선분으로 이어져 있다)</p>

<p>두 장난감 동물이 서로의 소리를 들으려면 두 칸의 거리가 D보다 작거나 같아야 한다. 게임판의 종류와 각 장난감 동물의 위치, 그리고 D가 주어졌을 때,&nbsp;서로의 소리를 들을 수 있는 장난감 동물의 쌍의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 네 정수 B, N, D, M이 주어진다.</p>

<p>B는 게임판의 종류이다. (1 ≤ B ≤ 3) 문제 설명의 왼쪽 그림이 1번 게임판, 중간 그림이 2번, 오른쪽 그림이 3번 게임판이다.</p>

<p>N은 장난감 동물의 수이다. (1 ≤ N ≤ 100,000)</p>

<p>D는 두 장난감 동물이 서로의 소리를 들을 수 있는 가장 먼 거리이다. (1 ≤ D ≤ 100,000,000)</p>

<p>M은 게임판의 크기이다. (입력으로 들어올 수 있는 가장 큰 좌표값) B가 1인 경우 M은 최대 75,000,000이고, 2인 경우에는 75,000, 3인 경우에는 75이다.</p>

<p>다음 N개의 줄에는 각 장난감 동물의 좌표가 주어진다. 모든 좌표는 1보다 크거나 같고, M보다 작거나 같은 자연수이다.</p>

<p>같은 칸에 장난감 동물 여러 개가 들어가 있을 수도 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 서로의 소리를 들을 수 있는 장난감 동물의 쌍의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>1-2 (거리 2)&nbsp;<br>
1-4 (거리 4)&nbsp;<br>
1-5 (거리 3)&nbsp;<br>
2-3 (거리 3)&nbsp;<br>
2-4 (거리 4)&nbsp;<br>
3-4 (거리 3)&nbsp;<br>
3-5 (거리 4)&nbsp;<br>
4-5 (거리 3)&nbsp;</p>

				</div>
				</div>','2 5 4 10
5 2
7 2
8 4
6 5
4 4
','8
','DATA_STRUCTURE'),
                                                                                                                (6653,'BAEKJOON','https://www.acmicpc.net/problem/5480',5480,'전함','6초','256 MB',19,'<p>홍준이는 대한민국의 자랑스러운 해군이다. 오늘은 전함을 타고 적과 싸우는 상황을 가정한 실전 연습을 하려고 한다.&nbsp;</p>

<p>전장은 n × n 크기의 그리드로 나타낼 수 있다. 가장 왼쪽 아래 점의 좌표는 (1,1)이고, 가장 오른쪽 위 점의 좌표는 (n,n)이다. 적의 함대는 전함 k개로 이루어져 있다. 각 전함 i는 길이가 0보다 크고 양 끝점이 (x<sub>i</sub>,y<sub>i</sub>), (x<sub>i</sub>,y<sub>i</sub>)인 선분으로 나타낼 수 있다. 또, 전함의 무게는 w<sub>i</sub>이다. 홍준이는 전함을 부수기 위해 레이저 대포를 총 l번 발사한다. 대포는 수직이나 수평 방향으로 발사할 수 있다.</p>

<p>대포를 수직으로 발사한다면, 레이저는 (a,1)과 (a,n)을 연결하는 선분으로 나타낼 수 있고, 이 선분과 만나는 전함을 모두 파괴한다. (끝점도 포함) 대포를 수평으로 발사하면, 레이저는 (1,a)와 (n,a)를 연결하는 선분으로 나타낼 수 있고, 이 선분과 만나는 전함도 모두 파괴한다.</p>

<p>홍준이는 매번 레이저 캐논을 발사할 때마다, 파괴한&nbsp;전함중 가장 무거운 전함을 대통령에게 보고해야 한다.</p>

<p>아래 그림에는 5 × 5 크기의 그리드에 전함이 다섯 개 있다. 각 전함의 무게는 선분 옆에 쓰여 있다. 첫 번째 레이저를 (4,1)과 (4,5)를 연결하는 선분으로 수직&nbsp;발사하면, 전함 두 개를 파괴할 수 있다. 파괴한&nbsp;전함의 무게는 4와 5인데, 가장 무거운 전함은 5이므로 5를 보고한다. 그 다음, 레이저를 (1,4)와 (5,4)를 연결하는 선분으로 수평&nbsp;발사하면, 두 전함을 파괴할 수 있다. 파괴한&nbsp;전함의 무게는 1과 2이고, 무거운 전함은 2이므로 2를 보고한다. 두 번째 레이저를 발사했을 때, 무게가 4인 전함은 첫 번째 레이저에 의해서 파괴되었기 때문에 파괴되지 않는다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/battlefield.png" style="height:199px; width:234px"></p>

<p>모든 전함의 위치와 홍준이가 발사한 레이저의 정보가 주어진다. 레이저를 발사할 때마다, 파괴한&nbsp;전함중 가장 무거운 전함의 무게를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 그리드의 크기 n, 전함의 수 k, 대포를 발사한 횟수 l이 주어진다. 1 ≤ n ≤ 1,000,000,000, 1 ≤ k,l ≤ 100,000. 다음 k개 줄에는 다섯 정수 x, y, x, y, w가 주어진다. 이 숫자는 전함의 양 끝점 (x,y), (x,y) (1 ≤ x,y,x,y ≤ n)와 무게 w를 나타낸다. (1 ≤ w ≤ 1,000,000) 다음 l개 줄에는 두 정수 a와 b가 주어진다. (1 ≤ a ≤ n, b = 0 또는 1) b가 0인 경우에는 대포를 (1,a)와 (n,a)를 연결하는 선분으로 수평 발사한 것이고, 1인 경우에는 (a,1)와 (a,n)을 연결하는 선분으로 수직 발사한 것이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 l줄을 출력한다. 매번 레이저를 발사할 때마다, 파괴한 전함 중 가장 무거운 전함의 무게를 출력한다. 만약, 파괴된 전함이 없는 경우에는 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
5 5 2
1 2 2 5 1
1 4 2 1 2
3 5 5 4 4
3 1 3 2 3
3 3 5 3 5
4 1
4 0
5 2 2
3 1 1 3 2
4 5 1 1 3
4 1
4 0
','5
2
3
0
','DATA_STRUCTURE'),
                                                                                                                (6651,'BAEKJOON','https://www.acmicpc.net/problem/5531',5531,'버블 정렬','1초','128 MB',24,'<p>버블 정렬은 다음과 같은 의사 코드를 가지는 가장 간단한 정렬 방법 중 하나이다.</p>

<pre>void bubble_sort(int *a, int n) {
    int i, j;
    for (i = 0; i < n - 1; ++i) {
        for (j = 0; j < n - 1; ++j) {
            if (a[j] > a[j + 1]) {
                /* 순서가 틀린 쌍이라면, 두 쌍을 교환한다. */
                /* 이때 두 쌍의 교환 횟수는 1 증가한다. */
                int x = a[j];
                a[j] = a[j + 1];
                a[j + 1] = x;
            }
        }
    }
}
</pre>

<p>길이 n인 배열 A에 대해서 A*를 정의하고자 한다. A*는 배열 A의 i번째 원소와 j번째 원소를 한번만 바꿔놓은 배열이다. (1 ≤ i < j ≤ n).</p>

<p>모든 배열 A* 중, 교환 횟수가 최소인 배열 A*의 교환 횟수를 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정수 N이 주어지며, 이후 N개의 줄에 배열 A가 A<sub>1</sub>, ..., A<sub>N</sub> 순서로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>배열 A* 중 교환 횟수가 최소인 배열의 교환 횟수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
10
3
6
8
1
','0
','DATA_STRUCTURE'),
                                                                                                                (6660,'BAEKJOON','https://www.acmicpc.net/problem/5568',5568,'카드 놓기','1초','256 MB',7,'<p>상근이는 카드 n(4 ≤ n ≤ 10)장을 바닥에 나란히 놓고 놀고있다. 각 카드에는 1이상 99이하의 정수가 적혀져 있다. 상근이는 이 카드 중에서 k(2 ≤ k ≤ 4)장을 선택하고, 가로로 나란히 정수를 만들기로 했다. 상근이가 만들 수 있는 정수는 모두 몇 가지일까?</p>

<p>예를 들어, 카드가 5장 있고, 카드에 쓰여 있는 수가 1, 2, 3, 13, 21라고 하자. 여기서 3장을 선택해서 정수를 만들려고 한다. 2, 1, 13을 순서대로 나열하면 정수 2113을 만들 수 있다. 또, 21, 1, 3을 순서대로 나열하면 2113을 만들 수 있다. 이렇게 한 정수를 만드는 조합이 여러 가지 일 수 있다.</p>

<p>n장의 카드에 적힌 숫자가 주어졌을 때, 그 중에서 k개를 선택해서 만들 수 있는 정수의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n이, 둘째 줄에 k가 주어진다. 셋째 줄부터 n개 줄에는 카드에 적혀있는 수가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 상근이가 만들 수 있는 정수의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 1의 경우 상근이는 11, 12, 21, 112, 121, 122, 212를 만들 수 있다.</p>

				</div>
				</div>','4
2
1
2
12
1
','7
','DATA_STRUCTURE'),
                                                                                                                (6666,'BAEKJOON','https://www.acmicpc.net/problem/5588',5588,'별자리 찾기','1초','128 MB',11,'<p>상근이는 밤하늘 사진에서 별자리를 찾고 있다. 사진에는 꼭 찾고 싶은 별자리와 같은 형태, 방향, 크기의 도형이 한 개가 포함되어 있다. 하지만, 상근이가 가지고 있는 사진 속에는 별자리를 구성하는 별 이외에 다른 별도 찍혀 있다.</p>

<p>왼쪽 그림은 상근이가 찾고자하는 별자리이다. 오른쪽 그림은 상근이가 가지고 있는 별자리 사진이고, 상근이가 찾은 별자리의 별은 동그라미가 쳐져 있다. 주어진 별자리의 별 좌표를 x방향으로 2, y방향으로 -3만큼 평행 이동하면 사진 속 위치가 된다.</p>

<p style="text-align: center;"><img alt="" src=https://www.acmicpc.net/upload/images/star1.png" style="width: 270px; height: 270px;"><img alt="" src=https://www.acmicpc.net/upload/images/star2.png" style="width: 270px; height: 270px;"></p>

<p>꼭 찾고 싶은 별자리의 모양과, 사진에 찍힌 별의 위치가 주어졌을 때, 별자리 좌표를 사진 속 좌표로 변환하기 위해 변환해야 하는 양을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 찾고 싶은 별자리를 구성하는 별의 개수 m이 주어진다. 다음 m개 줄에는 별자리를 구성하는 별의 x좌표와 y좌표가 주어진다. 다음 줄에는 사진의 별의 개수 n이 주어진다. 다음 n개 줄에는 사진에 있는 별의 x좌표와 y좌표가 주어진다. (1 ≤ m ≤ 200, 1 ≤ n ≤ 1000) 별의 x 좌표와 y좌표는 0 이상, 1000000 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 찾고 싶은 별자리 좌표를 얼마나 평행 이동하면 사진 속의 좌표가 되는지를 출력한다. 첫 번째 정수는 x 방향으로 평행 이동하는 양이고, 두 번째 정수는 y 방향으로 평행 이동하는 양이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
8 5
6 4
4 3
7 10
0 10
10
10 5
2 7
9 7
8 10
10 2
1 2
8 1
6 7
6 0
0 9
','2 -3
','DATA_STRUCTURE'),
                                                                                                                (6667,'BAEKJOON','https://www.acmicpc.net/problem/5676',5676,'음주 코딩','1초','256 MB',15,'<p>오늘은 ACM-ICPC 대회 전 날이다. 상근이는 긴장을 풀기 위해서 팀원들과 근처 술집으로 갔다.</p>

<p>상근이와 친구들은 다음 날 있을 대회를 연습하기 위해서 작은 게임을 하기로 했다.</p>

<p>먼저, 선영이는 상근이에게 총 N개의 정수로 이루어진 수열 X<sub>1</sub>, X<sub>2</sub>, ... X<sub>N</sub>을 적어준다. 게임은 총 K번 라운드로 이루어져있고, 매 라운드마다 선영이는 상근이에게 명령을 하나씩 내린다. 명령은 아래와 같이 두 가지가 있다.</p>

<ul>
	<li>변경: 이 명령은 친구가 수열의 한 값을 바꾸고 싶을 때 사용한다.</li>
	<li>곱셈: 선영이는 상근이에게 i와 j를 말한다. 상근이는 X<sub>i</sub> × X<sub>i+1</sub> × ... × X<sub>j-1</sub> × X<sub>j</sub> 의 값이 양수인지, 음수인지, 0인지를 대답한다.</li>
</ul>

<p>곱셈 명령에서 상근이가 대답을 잘못했을 때의 벌칙은 소주 한 잔이다. 상근이는 갑자기 대회가 걱정되기 시작했다. 또, 상근이는 발머의 피크 이론을 증명하고 싶지 않다.</p>

<p>다행히 선영이는 상근이에게 노트북 사용을 허락했다. 상근이는 자신의 수학 실력보다 코딩 실력을 더 믿는다.</p>

<p>상근이를 돕는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다.</p>

<p>각 테스트 케이스의 첫째 줄에는 수열의 크기 N과 게임의 라운드 수 K가 주어진다. (1 ≤ N, K ≤ 10<sup>5</sup>)</p>

<p>둘째 줄에는 총 N개의 숫자 X<sub>i</sub>가 주어진다. (-100 ≤ X<sub>i</sub> ≤ 100)</p>

<p>다음 K개 줄에는 선영이가 내린 명령이 주어진다. 명령은 C 또는 P로 시작한다.</p>

<p>C로 시작하는 명령은 변경 명령이고, 그 다음에 i와 V가 주어진다. X<sub>i</sub>를 V로 변경하는 명령이다. (1 ≤ i ≤ N, -100 ≤ V ≤ 100)</p>

<p>P로 시작하는 명령은 곱셈 명령이고, 그 다음에 i와 j가 주어진다. (1 ≤ i ≤ j ≤ N)</p>

<p>각 테스트 케이스에 곱셈 명령은 항상 한 번 이상있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 곱셈 명령의 결과를 한 줄에 모두 출력하면 된다. 출력하는 i번째 문자는 i번째 곱셈 명령의 결과이다. 양수인 경우에는 +, 음수인 경우에는 -, 영인 경우에는 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>발머의 피크 이론(Ballmers Peak Theory)은 프로그래머의 혈중 알콜 농도가 0.129% 와 0.138% 사이일 때 초인적인 코딩 실력을 발휘한다는 이론이다.</p>

				</div>
				</div>','4 6
-2 6 0 -1
C 1 10
P 1 4
C 3 7
P 2 2
C 4 -5
P 1 4
5 9
1 5 -2 4 3
P 1 2
P 1 5
C 4 -5
P 1 5
P 4 5
C 3 0
P 1 5
C 4 -5
C 4 -5
','0+-
+-+-0
','DATA_STRUCTURE'),
                                                                                                                (6671,'BAEKJOON','https://www.acmicpc.net/problem/5699',5699,'문자열 농장','5초','128 MB',21,'<p>상근이와 선영이는 조금 독특한 농장을 운영하고 있다. 보통 농장에서는 동물이나 야채를 기르지만, 그들은 문자열을 기른다.</p>

<p>문자열은 연속되는 문자를 나타낸다. 문자열을 자라면서 왼쪽이나 오른쪽에 문자가 추가된다. 문자가 없어지는 경우는 없고, 중간에 문자가 추가되는 경우도 없다.</p>

<p>상근이와 선영이는 문자열의 성장 과정을 사진으로 찍었다. 하지만, 사진에 따로 적어놓은 것이 없기 때문에, 어떤 사진이 어떤 문자열의 사진인지를 까먹었다. 그들은 사진을 벽에 그들이 자란 순서대로 전시해놓으려고 한다. 자 이제 사진의 순서를 찾는 프로그램을 작성해보자.</p>

<p>각 사진은 문자열로 나타낼 수 있다. 사진의 순서는 반드시 다음과 같은 규칙을 지켜야 한다. s<sub>i</sub>가 s<sub>i+1</sub>의 바로 앞에 오려면, s<sub>i+1</sub>은 s<sub>i</sub>가 자란 형태이어야 한다. 즉, s<sub>i</sub>가 s<sub>i+1</sub>의 연속된 부분 문자열이어야 한다. 상근이와 선영이는 같은 사진을 여러 번 찍지 않는다. 따라서, 사진의 순서에 포함되는 사진은 모두 다르다.</p>

<p>상근이와 선영이가 찍은 사진이 입력으로 주어진다. 이때, 가장 긴 사진의 순서를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 사진의 개수 N이 주어진다. (1 ≤ N ≤ 10<sup>4</sup>) 다음 N개 줄에는 사진에 찍혀있는 문자열이 주어진다. 문자열은 알파벳 소문자로만 이루어져 있고, 길이는 1000을 넘지 않는다.</p>

<p>각 테스트 케이스 마다 입력으로 주어지는 문자열의 길이의 합은 10<sup>6</sup>을 넘지 않는다.</p>

<p>입력의 마지막 줄에는 0이 하나 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 가장 긴 사진의 순서의 길이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
plant
ant
cant
decant
deca
an
2
supercalifragilisticexpialidocious
rag
0
','4
2
','DATA_STRUCTURE'),
                                                                                                                (6672,'BAEKJOON','https://www.acmicpc.net/problem/5729',5729,'수축하는 다각형','1초','128 MB',14,'<p>다각형의 모든 꼭짓점이 한 원의 위에 있을 때, 그 다각형은 내접한다고 한다. 원에 내접하는 다각형이 주어진다. 이때, 이 다각형이 정다각형이 되기 위해서 지워야 하는 꼭짓점의 개수를 구하는 프로그램을 작성하시오. 정다각형이란, 모든 각의 크기가 같고, 변의 길이가 같은 다각형을 말한다.</p>

<p>다각형에서 꼭짓점 v를 제거하려면, 먼저, 그 꼭짓점과 연결된 꼭짓점 w1과 w2를 찾아야 한다. 그 다음, w1과 w2를 이어, 새로운 변을 만들면 된다.</p>

<p>아래 그림 (a)는 꼭짓점의 수가 10개인 원에 내접하는 다각형이고, (b)는 (a)에서&nbsp;꼭짓점 다섯 개를 제거해, 정오각형을 만든 그림이다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/poly(1).png" style="height:186px; width:386px"></p>

<p>다각형의 변의 개수는 적어도 세 개이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 내접 다각형의 꼭짓점의 수 N이 주어진다. (3 ≤ N ≤ 10<sup>4</sup>) 둘째 줄에는 N개의 정수 X<sub>i</sub>가 주어진다. (1 ≤ X<sub>i</sub> ≤ 10<sup>3</sup>) X<sub>i</sub>는 내접 다각형의 각 꼭짓점 사이의 호의 길이이다. 즉, i번 꼭짓점과 (i+1) mod N번 꼭짓점 사이의 호의 길이이고, 시계 방향으로 주어진다. 호는 현과 다르다.&nbsp;</p>

<p>입력의 마지막 줄에는 0이 하나 주어진다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 정다각형으로 만들기 위해 제거해야 하는 꼭짓점의 최소 개수를 출력한다. 만약, 정다각형을 만들 수 없다면, -1을 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1000 1000 1000
6
1 2 3 1 2 3
3
1 1 2
10
10 40 20 30 30 10 10 50 24 26
0
','0
2
-1
5
','DATA_STRUCTURE'),
                                                                                                                (6675,'BAEKJOON','https://www.acmicpc.net/problem/5811',5811,'낙하산 고리들','3초','128 MB',24,'<p>레오나르도 다 빈치의 코덱스 아틀란티쿠스 에는 최초로 설계한 꽤 정교한 낙하산이 설명되어 있는데, 이 다 빈치의 낙하산은 피라미드 모양의 나무 구조를 통해 열리는 우산모양의 리넨 옷감으로 설계되어있다.</p>

<p>스카이다이버 아드리안 니콜라스는 500년 이상 오래된 다 빈치의 디자인을 시험해보았다. 이를 위해, 사람의 몸을 다 빈치의 낙하산에 묶기 위한 최신식 초경량 구조를 사용하였다. 우리는 리넨 옷감에도 걸 수 있는 고리 구조를 사용하고자 한다. 각각의 고리는 유연하고 강한 소재로 만들어졌다. 모든 고리들은 열고 닫을 수 있으므로, 다른 고리들과 쉽게 연결될 수 있다. 체인은 고리 구조의 특별한 형태를 말한다. 아래에 있는 그림처럼, 각각의 고리들이 (최대 두 개의) 인접한 고리들과 차례대로 연결되어 있고, 시작과 끝이 있는 고리 구조는 체인이 된다. (시작과 끝에 있는 고리들은 각각 최대 하나의 다른 고리들과 연결된다.) 특히, 고리 하나도 마찬가지로 체인이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/9a414353-1ccb-479f-9704-f3b882bfa009/-/preview/" style="width: 84px; height: 82px;"></p>

<p>하나의 고리가 세 개 이상의 다른 고리들과 연결된 고리 구조의 형태도 당연히 가능하다. 이러한 고리 구조에서, 어떤 하나의 고리를 열어서 없앤 후에 남은 다른 고리들이 모두 체인의 형태를 만들 때 (혹은 고리가 하나도 남지 않았을 때), 그 고리를 중요한 고리라고 한다. 다시 말해, 중요한 고리를 제거하면, 체인만 남게 된다.</p>

<p>다음의 그림과 같이, 0번부터 6번까지 번호가 매겨진 7개의 고리를 생각해보자. 이 고리 구조에는 2개의 중요한 고리가 있다. 그 중 하나는 2번인데, 이 고리를 없애면 남은 고리들이 [1], [0, 5, 3, 4], 그리고 [6]의 체인이 된다. 다른 하나는 3번인데, 이 고리를 없애면 남은 고리들이 [1, 2, 0, 5], [4], 그리고 [6]의 체인이 된다. 만약 그 이외의 다른 고리들을 없애면, 체인이 아닌 것이 남아있게 된다. 예를 들어, 5번 고리를 없애면 [6]은 체인이 되지만, 0번, 1번, 2번, 3번, 그리고 4번 고리로 만들어진 고리 구조는 체인이 아니다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/b2731a11-b0a9-4105-bde8-7eb94af206a6/-/preview/" style="width: 261px; height: 175px;"></p>

<p>여러분이 할 일은 입력으로 주어지는 고리 구조에서, 중요한 고리의 개수를 세는 프로그램을 작성하는 것이다.</p>

<p>처음에는, 서로 연결되지 않은 고리들의 개수가 주어진다. 다음에는, 고리 구조가 만들어 진다. 입력 중에 언제든지, 여러분은 현재 고리 구조에서 중요한 고리의 개수를 답해야 된다. 이를 위해 여러분은 3개의 함수를 구현해야한다.</p>

<ul>
	<li>Init(N) - 처음에, 오직 한번 실행된다. 인자 N의 의미는 0부터 N - 1까지 번호가 붙은 N개의 고리들이 있다는 것을 의미한다.</li>
	<li>Link(A, B) - A번 고리와 B번 고리를 서로 연결함을 의미한다. A와 B는 다르고, A번 고리와 B번 고리는 현재 연결되어 있지 않다는 것을 보장한다. 이를 제외하고, A번 고리와 B번 고리 사이에는 다른 제약조건이 없다. (특히, 물리적인 조건과는 관계가 없다.) 또한, Link(A, B)와 Link(B, A)는 서로 같은 의미이다.</li>
	<li>CountCritical() ? 현재의 고리 구조의 형태에서, 중요한 고리의 개수를 계산하여 반환한다.</li>
</ul>

<p>N = 7 개의 고리가 주어질 때를 생각해보자. 다음의 표는 가능한 호출 순서에 대해서, 각 호출에서 얻은 결과를 보여준다.</p>

<table class="table table-bordered" style="width:20%;">
	<thead>
		<tr>
			<th style="width:10%;">함수 호출</th>
			<th style="width:10%;">반환값</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Init(7)</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>CountCritical()</td>
			<td>7</td>
		</tr>
		<tr>
			<td>Link(1,2)</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>CountCritical()</td>
			<td>7</td>
		</tr>
		<tr>
			<td>Link(0,5)</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>CountCritical()</td>
			<td>7</td>
		</tr>
		<tr>
			<td>Link(2,0)</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>CountCritical()</td>
			<td>7</td>
		</tr>
		<tr>
			<td>Link(3,2)</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>CountCritical()</td>
			<td>4</td>
		</tr>
		<tr>
			<td>Link(3,5)</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>CountCritical()</td>
			<td>3</td>
		</tr>
		<tr>
			<td>Link(4,3)</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>CountCritical()</td>
			<td>2</td>
		</tr>
	</tbody>
</table>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 함수를 호출한 횟수 L이 주어진다. 둘째 줄부터 L개 줄에는 함수를 호출한 순서가 주어진다. -1이 주어지는 경우는 CountCritical을 호출한 경우이며, 숫자 두 개 A와 B가 주어지는 경우는 Link(A,B)를 호출한 경우이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>CountCritical을 호출할 때 마다 결과를 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 13
-1
1 2
-1
0 5
-1
2 0
-1
3 2
-1
3 5
-1
4 3
-1
','7
7
7
7
4
3
2
','DATA_STRUCTURE'),
                                                                                                                (6674,'BAEKJOON','https://www.acmicpc.net/problem/5812',5812,'크래이피쉬 글쓰는 기계','2초','512 MB',19,'<p>활자 인쇄기를 발명한 독일 대장장이인 요하네스 구텐베르크는 레오나르도가 열렬히 존경하는 사람이었다. 레오나르도는 크래이피쉬 글쓰는 기계 ? il gambero scrivano ?로 불리는 매우 단순한 타자 기계를 설계하여 구텐베르크에게 존경을 표시하였다. 이것은 단순한 현대의 타자기와 매우 비슷하며, 단지 두 개의 명령어만 받아들인다: 하나는 그 다음 문자를 타자하는 것이고, 다른 하나는 가장 최근의 명령어들을 취소(undo)하는 것이다. 이 타자 기계의 주목할만한 특징은 취소 기능이며, 이는 매우 강력한 기능이다: 취소 명령은 자기자신, 즉 취소 명령어에 대해서도 적용될 수 있다.</p>

<p>여러분이 할 일은 크래이피쉬 글쓰기 기계와 같이 동작하는 소프트웨어를 구현하는 것이다: 빈 텍스트에서 시작하고, 사용자가 입력한 명령어의 순서들을 받아들이고, 다음과 같이 텍스트의 현재 상황의 특정 위치에 대한 질의를 수행한다.</p>

<ul>
	<li>Init() ? 실행 초기에 인자가 없이 한번만 호출된다. 이 함수는 자료 구조를 초기화 하는데 사용될 수 있다. 이것은 결코 취소될 필요가 없을 것이다.</li>
	<li>TypeLetter(L) ? a, …, z으로부터 선택된 하나의 소문자 L을 텍스트의 끝에 추가한다.</li>
	<li>UndoCommands(U) ? 양의 정수 U에 대해, 가장 최근의 U 개의 명령어를 취소한다.</li>
	<li>GetLetter(P) ? 음이 아닌 인덱스 P에 대해, 현재 텍스트에서 위치 P의 문자를 되돌려준다. 텍스트에서 첫 번째 문자의 인덱스는 0 이다. (이 질의는 명령어가 아니어서 취소 명령어에서는 무시된다.)</li>
</ul>

<p>Init()를 호출한 후에, 그 외의 루틴들은 임의의 순서로 0번 이상 호출 될 수 있다. U는 이전에 들어온 명령어들의 수를 초과하지 않음이 보장되며, P는 현재의 텍스트의 길이보다 작을 것이다 (현재 텍스트에서의 문자의 수).</p>

<p>UndoCommands(U)에서는 이전의 U개의 명령어를 역순으로 취소한다: 만약 취소될 명령어가 TypeLetter(L)라면, 이것은 현재 텍스트의 끝에서부터 L을 삭제한다: 만약 취소될 명령어가 어떤 값 X에 대해 UndoCommands(X) 라면 이것은 이전의 X개의 명령어를 원래의 순서대로 다시 실행한다.</p>

<p>하나의 가능한 호출순서에 대해서 각 호출후의 텍스트의 상태를 보인다.</p>

<table class="table table-bordered table-center-50">
	<thead>
		<tr>
			<th>Call</th>
			<th>Returns</th>
			<th>Current text</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Init()</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>TypeLetter(a)</td>
			<td>&nbsp;</td>
			<td>a</td>
		</tr>
		<tr>
			<td>TypeLetter(b)</td>
			<td>&nbsp;</td>
			<td>ab</td>
		</tr>
		<tr>
			<td>GetLetter(1)</td>
			<td>b</td>
			<td>ab</td>
		</tr>
		<tr>
			<td>TypeLetter(d)</td>
			<td>&nbsp;</td>
			<td>abd</td>
		</tr>
		<tr>
			<td>UndoCommands(2)</td>
			<td>&nbsp;</td>
			<td>a</td>
		</tr>
		<tr>
			<td>UndoCommands(1)</td>
			<td>&nbsp;</td>
			<td>abd</td>
		</tr>
		<tr>
			<td>GetLetter(2)</td>
			<td>d</td>
			<td>abd</td>
		</tr>
		<tr>
			<td>TypeLetter(e)</td>
			<td>&nbsp;</td>
			<td>abde</td>
		</tr>
		<tr>
			<td>UndoCommands(1)</td>
			<td>&nbsp;</td>
			<td>abd</td>
		</tr>
		<tr>
			<td>UndoCommands(5)</td>
			<td>&nbsp;</td>
			<td>ab</td>
		</tr>
		<tr>
			<td>TypeLetter(c)</td>
			<td>&nbsp;</td>
			<td>abc</td>
		</tr>
		<tr>
			<td>GetLetter(2)</td>
			<td>c</td>
			<td>abc</td>
		</tr>
		<tr>
			<td>UndoCommands(2)</td>
			<td>&nbsp;</td>
			<td>abd</td>
		</tr>
		<tr>
			<td>GetLetter(2)</td>
			<td>d</td>
			<td>abd</td>
		</tr>
	</tbody>
</table>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 명령어와 질의의 수 L이 주어진다. 다음 줄부터 L개 줄에는 명령어와 질의가 주어진다.</p>

<p>첫 번째 문자가 T인 경우에는 TypeLetter 명령이다. T a와 같이 주어진 경우에는 TypeLetter(a)를 호출하면 된다. U인 경우에는 UndoCommands, P는 GetLetter를 의미하며, 공백으로 구분되어 주어지는 숫자를 인자로 호출하면 된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>GetLetter에 의해 리턴된 문자를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','14
T a
T b
P 1
T d
U 2
U 1
P 2
T e
U 1
U 5
T c
P 2
U 2
P 2
','b
d
c
d
','DATA_STRUCTURE'),
                                                                                                                (6658,'BAEKJOON','https://www.acmicpc.net/problem/5814',5814,'마상시합 토너먼트','1초','256 MB',22,'<p>1491년 베아트리체의 결혼식을 위해서 밀란의 스포르자 공작은 다빈치에게 3일간의 마상시합(말을 타고 창 실력을 겨루는 게임)을 포함한 결혼 축제를 기획하도록 부탁하였다. 하지만 가장 인기있는 기사가 도착이 늦기에...</p>

<p>마상시합 토너먼트에 참가하는 N 명의 기사는 처음에 한 줄로 서 있고, 줄에 선 순서대로 기사들은 0 부터 N - 1 까지 번호가 붙어 있다. 마상시합의 한 라운드는 두 위치 S와 E를 (0 ≤ S < E ≤ N - 1) 부름으로써 시작된다. 그러면 번호가 S 이상 E 이하인 모든 기사들이 이번 라운드에서 경쟁하여 1명의 승자가 정해지게 된다. 승자는 다시 원래의 줄로 돌아가고, 패자들은 경기에서 빠지게 된다. 기사들이 0번 쪽으로 순서를 유지하면서 이동하여 원래 줄의 빈 자리들을 채운다. 결과적으로 남은 기사들의 번호는 0 부터 N - (E - S) - 1 까지가 된다. 다음 라운드도 같은 방식으로 계속되어 마지막 한 명의 기사가 남을 때 까지 계속된다.</p>

<p>다빈치는 기사들의 실력이 모두 다르다는 것을 알고 있으며, 실력은 0 부터 N - 1 까지의 정수로 표현된다 (값이 클 수록 더 좋은 실력을 의미한다). 또한, 다빈치는 모든 C개의 라운드에서 불려질 번호 범위도 정확히 알고 있고, 각 라운드에서 가장 좋은 실력 값을 가진 기사가 반드시 이긴다고 확신한다.</p>

<p>N 명의 기사들 중 N - 1 명은 이미 도착하여 줄을 서 있지만, 가장 인기있는 기사만이 아직 도착하지 않았다. 아직 도착하지 않은 기사의 실력 값은 R이다. 다빈치는 그 기사의 인기를 이용해 축제의 즐거움을 더할 목적으로, 그 기사가 승리하는 라운드의 수가 가장 많아지도록 그 기사의 위치를 정하고 싶어한다. 그 기사가 참여하지 않는 라운드는 무관하며 단지 그 기사가 참여해서 이기는 라운드의 수 만이 중요하다는 점에 주의하라.</p>

<p>기사의 총 수 N = 5인 경우에, N - 1 명의 기사들은 이미 줄을 서 있고 각각의 실력 값은 줄에 있는 순서 대로 [1, 0, 2, 4]라고 하자. 늦게 온 기사의 실력 값은 R = 3임을 알수 있다. 토너먼트는 C = 3 라운드로 구성되며 각 라운드에서 불려지는 (S, E) 값들은 순서대로 다음과 같다고 하자: (1, 3), (0, 1), (0, 1).</p>

<p>다빈치가 늦게 온 기사를 첫 번째 위치에 배치하게 되면 전체 기사들의 실력 값은 [3, 1, 0, 2, 4]가 된다. 첫 번째 라운드는 위치 1, 2, 3에 있는 실력 값이 각각 1, 0 , 2인 기사들이 경쟁하고 실력 값 2인 기사가 승자가 된다. 이 라운드 후에 남은 기사들이 있는 줄의 실력 값은 순서대로 [3, 2, 4]와 같이 될 것이다. 다음 라운드는 실력 값 3인 기사와 실력 값 2인 기사가 (위치 번호로는 0과 1) 경쟁하고 실력 값 3인 기사가 승리하여, 남은 줄의 실력 값은 [3, 4]가 된다. 마지막 라운드의 승자는 실력 값 4인 기사일 것이다. 결과적으로, 늦게 온 기사는 단 하나의 라운드(두 번째 라운드)에서만 승리하였다.</p>

<p>반면에, 다빈치가 늦게 온 기사를 실력 값 1인 기사와 0인 기사 사이에 배치하였다면, 최초의 줄의 실력 값들은 다음과 같을 것이다: [1, 3, 0, 2, 4]. 이 경우, 첫 라운드에 참여하는 기사들의 실력 값은 3, 0, 2와 같으며, 실력 값 3인 기사가 승리한다. 이제 남은 줄의 실력 값들은 [1, 3, 4]이며 그 다음 라운드에서 실력 값 1, 3인 기사들이 경쟁하여 역시 실력 값 3인 기사가 승리한다. 직후의 남은 줄의 실력 값들은 [3, 4]이며, 마지막 라운드에서는 실력 값 4인 기사가 승리한다. 따라서, 이 경우 늦게 온 기사는 2개의 라운드에서 승리하며, 늦게온 기사가 3회 이상 승리하는 것은 불가능하므로 이 방법이 가장 좋은 경우이다.</p>

<p>다빈치가 바라는 바에 따라, 늦게 온 기사가 승리하는 라운드의 수가 최대가 되는 위치를 찾아내는 프로그램을 작성하라. 구체적으로, GetBestPosition(N, C, R, K, S, E) 함수를 작성하여야 한다.</p>

<p>N은 기사들의 총 수이다 (1 ≤ N ≤ 100,000)</p>

<p>C는 진행되는 라운드의 수이다 (1 ≤ C ≤ N - 1).</p>

<p>R은 늦게 온 기사의 실력 값이다. 늦게 온 기사를 포함한 모든 기사들의 실력 값은 0 이상 N - 1 이하의 정수이며 모두 다르다. R의 값은 다른 입력 값들로 부터 계산이 가능하지만, 명시적으로 주어진다.</p>

<p>K는 N - 1 개의 정수의 배열이며, 이미 줄에 서 있는 N - 1 명의 기사들의 실력 값을 줄에 서 있는 순서와 같은 순서로 저장하고 있다.</p>

<p>S와 E는 크기 C인 배열들이다. 0 이상 C - 1 이하의 i 에 대해서 S[i]과 E[i]의 값은 (i + 1) 번째 라운드에 참여하는 기사들의 줄에서의 위치가 S[i] 부터 E[i] 까지 임을 의미한다. 모든 i에 대해서 S[i] < E[i] 임은 보장된다.</p>

<p>이 함수를 호출할 때 인자들의 값의 정확함이 보장된다. 즉, E[i]의 값은 (i + 1) 번째 라운드가 시작할 때 줄에 있는 기사들의 수 보다 작음이 보장되며, 모든 C개의 라운드가 끝난 다음에는 단 한 명의 기사만이 남아 있음이 보장된다.</p>

<p>GetBestPosition(N, C, R, K, S, E) 함수는 늦게 온 기사를 배치할 수 있는 최적의 위치 P를 리턴하여야 한다 (0 ≤ P ≤ N - 1). 만약 최적의 위치가 여러 개일 경우는 가장 작은 값을 리턴하여야 한다. (늦게 온 기사의 위치는 그 기사가 배치된 이후의 줄에서의 위치를 말하며, 가장 앞의 위치를 0으로 시작하여 표현한 것이다. 다르게 표현하면, P는 늦게온 기사를 최적 위치에 배치한 후, 그 기사 앞에 있는 기사들의 수이다. 특정한 경우들을 보면, P = 0이라는 것은 늦게 온 기사가 가장 앞에 위치한다는 뜻이며, P = N - 1 이라는 것은 늦게 온 기사가 줄의 가장 뒤에 위치한다는 뜻이다.)</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N, C, R이 주어진다. 둘째 줄부터 N번째 줄까지 K[i]의 값이 한 줄에 하나씩 주어지며, N+1번째 줄부터 N+C번째 줄까지 S[i]와 E[i]의 값이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>GetBestPosition(N, C, R, K, S, E)를 호출한 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3 3
1
0
2
4
1 3
0 1
0 1
','1
','DATA_STRUCTURE'),
                                                                                                                (6624,'BAEKJOON','https://www.acmicpc.net/problem/5817',5817,'고통받는 난쟁이들','1초','512 MB',17,'<p>옛날 옛적, 일곱 언덕과 일곱 바다를 건너 작은 마을이 있었어요. 백설공주는 놀고 먹고 자다가 일어나서 문명 5, 리그 오브 레전드, 풋볼 매니저를 하다가 다시 자는 난쟁이들 N명과 살고 있었어요. 계속되는 이런 생활에 진저리가 난 백설공주는 난쟁이들에게 고통을 주기로 결심했고, 체육 수업을 빙자한 얼차려를 주기로 했답니다!</p>

<p>수업이 시작할 때, 난쟁이들은 키가 큰 순서로 한 줄로 서 있어야 돼요. 신기하게도 난쟁이들 중 키가 같은 사람은 한 명도 없었고, 정확하게 1, 2, ... , Ncm의 키를 가지고 있었어요. 하지만, 난쟁이들의 머리는 계속되는 트롤링으로 인해 피폐해져 있었고, 자기들끼리 키를 비교해 한 줄로 설만큼의 지능조차 없었답니다. 그래서 백설공주는 다음 명령을 통해 난쟁이들을 조종하기로 했어요.</p>

<ul>
	<li>1 X Y -- X번째 위치와 Y번째 위치에 있는 난쟁이 둘이 위치를 바꾸도록 합니다.또 백설공주는 다음 명령으로 난쟁이들이 줄 서있는 순서를 살펴봅니다.</li>
</ul>

<p>또 백설공주는 다음 명령으로 난쟁이들이 제대로 서 있는지를 확인해요.</p>

<ul>
	<li>2 A B -- A, A+1, ..., Bcm의 키를 가진 난쟁이들이 모두 이웃해 서 있는지 확인합니다(꼭 A, A+1, ..., B 순서일 필요는 없습니다).</li>
</ul>

<p>멍청한 난쟁이들이 백설공주가 시키는대로 잘 따르게 도와줘&nbsp;더 이상 백설공주가 화나지 않게 해주세요!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에 난쟁이들의 인원수&nbsp;N과 백설공주가 명령하는 횟수&nbsp;M이 주어집니다.(2 ≤ N ≤ 200 000, 2 ≤ M ≤ 200 000).</p>

<p>다음 줄에는 난쟁이들이 처음에 서 있는 순서를 나타내는&nbsp;N개의 자연수가 주어집니다(자연수의 범위는 1부터 N까지이며, 한 숫자는 한번만 주어집니다).</p>

<p>다음 M개의 줄에는 백설공주의 명령이 주어지는데,&nbsp;</p>

<p>"1 X Y" (1 ≤ X, Y ≤N, X ≠ Y) 또는</p>

<p>“2 A B” (1 ≤ A ≤ B ≤ N) 꼴로 주어지고 그 의미는 위에서 설명한 바와 같습니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력엔 2번째 형태의 백설공주의 명령에 대한 대답을&nbsp;"YES"나 "NO"로&nbsp;한 줄에 한번씩&nbsp;출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
2 4 1 3 5
2 2 5
1 3 1
2 2 5
','NO
YES
','DATA_STRUCTURE'),
                                                                                                                (6690,'BAEKJOON','https://www.acmicpc.net/problem/5875',5875,'오타','1초','128 MB',14,'<p>올바른 괄호쌍을 좋아하는 키파는 최근에 노트북을 샀다.&nbsp;그런데&nbsp;키보드의 크기가 너무 작았기 때문에, 키파는 혹시&nbsp;여는 괄호와 닫는 괄호를 서로 잘못 입력하지&nbsp;않았는지 걱정되었다.&nbsp;키파를 도와 올바른&nbsp;괄호쌍이 되도록&nbsp;고쳐 주자.</p>

<p>키파는 괄호를 입력할 때 매우 조심했기 때문에 최대 한 번 오타를 내었다. 올바른 괄호쌍은 다음과 같이 정의된다:</p>

<ul>
	<li>()는 올바른 괄호쌍이다.</li>
	<li>A가 올바른 괄호쌍이라면 (A) 또한 올바른 괄호쌍이다.</li>
	<li>A와 B가 올바른 괄호쌍이라면 AB 또한 올바른 괄호쌍이다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 키파가 입력한 괄호열이 주어진다. 길이는 1 이상 100,000 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 하나의 문자만 고쳐서&nbsp;올바른 괄호쌍이 될 수 있는 경우의 수를&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>키파가 입력한 다음 문자열을 자세히 보자:</p>

<pre>12345678
()(())))</pre>

<p>2번째 문자 )를 (로 고침으로써 올바른 문자열을 만들 수 있다:</p>

<pre>12345678
(((())))</pre>

<p>비슷하게, 5번째 문자, 6번째 문자, 혹은 7번째 문자를 고침으로써 올바른 문자열을 만들 수 있다.</p>

				</div>
				</div>','()(())))
','4
','DATA_STRUCTURE'),
                                                                                                                (6693,'BAEKJOON','https://www.acmicpc.net/problem/5896',5896,'효율적으로 소 사기','1초','128 MB',18,'<p>농부 존은 새 소들이 필요하다! 그래서 농부 존은 소 시장에 가서 새 소들을 사려고 한다.</p>

<p>농부 존은 돈이 많이 없기 때문에 소들을 최대한&nbsp;효율적으로 사야 한다.&nbsp;그래서 농부 존은 M원과 K개의 소 쿠폰을 가지고 소 시장에 나온 N마리의 소들을 최대한 많이 사려고 한다.</p>

<p>소 쿠폰은 소 한 마리당 한 번만 쓸 수 있고, 쓰고 나면 사라진다.&nbsp;i번째 소는 P<sub>i</sub>원이고, 쿠폰을 썼을 때는 C<sub>i</sub>원이 될 때, 농부 존이 최대로 살 수 있는 소의 마릿수를 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 소 시장에 나온 소들의 마릿수 N(1 ≤ N ≤ 50,000), 농부 존이 가지고 있는 쿠폰의 개수 K(1 ≤&nbsp;K ≤ N), 농부 존이 가지고 있는 돈 M(1 ≤ M ≤ 10<sup>14</sup>)이 주어진다.</p>

<p>다음 줄부터 P<sub>i</sub> (1 ≤&nbsp;P<sub>i</sub> ≤ 10<sup>9</sup>), C<sub>i</sub> (1 ≤ C<sub>i</sub> ≤ P<sub>i</sub>)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>농부 존이 최대로 살 수 있는 소 마릿수를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>농부 존은 1개의 쿠폰과 7원을 가지고&nbsp;소 시장에 갔다.</p>

<p>3번째 소에 쿠폰 하나를 쓰고 1,2,3번 소를 산다. (1 + 2 + 3 = 6원)</p>

				</div>
				</div>','4 1 7
3 2
2 2
8 1
4 3
','3
','DATA_STRUCTURE'),
                                                                                                                (6697,'BAEKJOON','https://www.acmicpc.net/problem/5905',5905,'악당 로봇','1초','128 MB',20,'<p>슈퍼히어로 박승원은 결국 지구를 침략한 악당 로봇들을 해킹하는 데 성공했다. 로봇은 N개의 취약점을 가지고 있는데, (1 ≤&nbsp;N ≤ 20) i번째 취약점은 A, B, C 로만 구성된 15자 이하의 문자열 S<sub>i</sub> 로 표현된다. 박승원 역시 로봇들을 A, B, C 버튼을 누르면서 공격할 수 있으며, 로봇의 취약점과 일치하도록 버튼을 누르면 공격에 성공하게 된다.</p>

<p>예를 들어 로봇의 취약점이 "ABA", "CB", "ABACB"라 하자. 박승원이 만약에 "ABACB"를 누르게 되면, 1 ~ 3번째 문자가 "ABA", 4 ~ 5번째 문자가 "CB", 전체가 "ABACB"와 매칭되어서 3번의 공격을 성공한 것과 같다. 이 예제에서 볼수 있다시피 여러개의 취약점을 한꺼번에 공격할 수 있으며, 또한 한 취약점을 여러 번 사용할 수도 있다.</p>

<p>우리의 슈퍼히어로 박승원에게는 시간이 없기 때문에 정확히 K번밖에 버튼을 누를 수 없다. (1 ≤&nbsp;K ≤ 1000) 우리 모두 박승원을 도와 그가 공격할 수 있는 최대 횟수를 출력해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 N과 K가&nbsp;주어지며, 이후 N개의 줄에 취약점 S<sub>i</sub>가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>박승원이 공격할 수 있는 최대 횟수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>ABACBCB 를 눌러 공격하면 ABA와 한번, ABACB와 한번, CB와 두번 매칭되어 총 4번 공격에 성공한다.</p>

				</div>
				</div>','3 7
ABA
CB
ABACB
','4
','DATA_STRUCTURE'),
                                                                                                                (6695,'BAEKJOON','https://www.acmicpc.net/problem/5916',5916,'농장 관리','1초','128 MB',20,'<p>N개의 농장과 농장을 양방향으로 연결하는 N-1개의 도로가 있다. 임의의 두 농장 사이에는 하나의 경로만 존재한다. 농장은 1번부터 N번까지 번호가 매겨져 있다.</p>

<p>농장을 관리하는 재현이는 도로에 나무를 심기로 결정했다. 나무를 심는 과정은 쿼리로 이루어져 있으며, 쿼리는 총 2가지가 존재한다.</p>

<ul>
	<li>P u v: u번 농장과 v번 농장 사이의 경로에 존재하는 모든 도로에 나무를 하나씩 심는다.</li>
	<li>Q u v: u번 농장과 v번 농장 사이의 도로에 존재하는 나무의 개수를 출력한다.</li>
</ul>

<p>초기에 나무는 한 그루도 심겨져 있지 않다. 쿼리를 수행해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 농장의 수 N과 쿼리의 수 M(1 ≤ N, M ≤ 100,000)이 주어진다.</p>

<p>둘째 줄부터 N-1개의 줄에는 도로가 연결하는 농장의 번호가 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. 쿼리는 한 개의 문자 w와 두 개의 정수 u, v로 이루어져 있고, 문제에서 설명한 형식이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>쿼리 Q가 주어질 때 마다, 나무의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 6
1 4
2 4
3 4
P 2 3
P 1 3
Q 3 4
P 1 4
Q 2 4
Q 1 4
','2
1
2
','DATA_STRUCTURE'),
                                                                                                                (6710,'BAEKJOON','https://www.acmicpc.net/problem/6051',6051,'시간 여행','1초','128 MB',14,'<p>모범생 현수는 코딩하는 시간을&nbsp;늘리기 위해&nbsp;타임 머신을 구매 했다.&nbsp;현수는 정상적으로 문제를 코딩하거나 (타임 머신을 사용하지 않고), 과거의 임의의 지점으로 시간여행 할 수 있다.&nbsp; 미래로 시간 여행 할 수 없으며, 과거로 가면 새로운 미래가 진행된다.</p>

<p>현수는 자유롭게 문제를&nbsp;풀거나 과거로 돌아가면서 자신이 푼 문제 목록을 기록한다. 과거로 돌아가면 과거 이전까지 풀었던 문제 목록만 남는다.</p>

<p>현수는&nbsp; 기록 되어 있는 문제 목록 중 가장 최근에 푼 문제 번호를 알고 싶다. (가장 최근에 푼 문제가 없다면 -1을 출력)</p>

<p>매 쿼리마다 문제 목록에&nbsp;기록되어 있는 가장 최근에 푼 문제를 출력하는 프로그램을 작성하시오.</p>

<p>현수는 개인의 타임라인 관점에서&nbsp;연속적인 업데이트를 나타내는 &nbsp;N (1 <= N <= 80,000) 개의 쿼리 Q<sub>i</sub>(1...N) 를 제공한다.</p>

<p>각 쿼리는 한 줄의 입력이다. 각 줄은 하나의 문자 c ( a, s, t 중 하나)로 시작한다. c가 a또는 t 이면 c 다음에 공백과 정수 K가 주어진다.&nbsp;(1 <= K <= 1,000,000)</p>

<p>c가 a 이면 현수는 문제 번호가 K인 문제를 풀고 문제 목록에 기록 한다.</p>

<p>c가 s 이면 현수는 가장 최근에 작성한 문제 목록을 삭제한다.</p>

<p>c가 t이면, 현수는 K 번째&nbsp;쿼리 직전까지 시간을 거슬러 올라 간다. 즉, 현수는 K-1번째 쿼리와 K번째 쿼리 사이로 시간 여행한다. (입력을 위해 예제 입력 참조). K 쿼리&nbsp; 바로 전에 있던 푼 문제 목록으로 되돌아 간다.</p>

<p>이해를 돕기 위해 아래에&nbsp;푼 문제 목록과 12개의&nbsp;쿼리,&nbsp;각 쿼리에 대한&nbsp;출력결과가 주어진다.&nbsp;&nbsp;</p>

<pre>Q#   쿼리     문제목록      출력         참조
 1   a 5  -> [5]         => 5        5번 문제를 목록에 기록
 2   a 3  -> [5,3]       => 3        3번 문제를  목록에 기록
 3   a 7  -> [5,3,7]     => 7        7번 문제를 목록에 기록
 4   s    -> [5,3]       => 3        가장 최근 기록한 7를 목록에서 삭제
 5   t 2  -> [5]         => 5        2번째 쿼리 직전으로 되돌아감
 6   a 2  -> [5,2]       => 2        2번 문제를 목록에 기록
 7   t 4  -> [5,3,7]     => 7        4번째 쿼리 직전으로 되돌아감
 8   a 4  -> [5,3,7,4]   => 4        4번 문제를 목록에 기록
 9   s    -> [5,3,7]     => 7        가장 최근 기록한 4를 목록에서 삭제
10   t 7  -> [5,2]       => 2        7번째 쿼리 직전으로 되돌아감
11   s    -> [5]         => 5        가장 최근 기록한 2를 목록에서 삭제
12   s    -> []          => -1       가장 최근 기록한 5를 목록에서 삭제</pre>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄 : 하나의 정수 N</p>

<p>두 번째 줄 부터 N+1번째 줄까지: 쿼리 Q<sub>i</sub>&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1부터 N번째 줄 : Q<sub>i</sub> 처리 후 목록에 기록 되어 있는 가장 최근에 푼 문제를 출력하시오 (가장 최근에 푼 문제가 없으면 -1).</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12
a 5
a 3
a 7
s
t 2
a 2
t 4
a 4
s
t 7
s
s
','5
3
7
3
5
2
7
4
7
2
5
-1
','DATA_STRUCTURE'),
                                                                                                                (6721,'BAEKJOON','https://www.acmicpc.net/problem/6181',6181,'플러드 필 (Flood Fill)','2초','128 MB',21,'<p>재현이는 얼마 전, 그래프 탐색에 대해서 배웠다. 강의를 맡은 지학이는 그래프 탐색을 통해서 풀 수 있는 대표적인 문제인 Flood Fill에 대해서 알려주었다.</p>

<ul>
	<li>N * N 격자에 M개의 점이 있을 때, 상하좌우에 붙어있는 인접한 셀을 연결되어 있다고 하자, 연결되어 있는 점들의 집합을 “섬” 이라고 부르면, 섬의 개수와, 가장 큰 섬의 크기는 얼마인가?</li>
</ul>

<p>이 문제를 푸는 법은 여러 방법이 있지만, 재현이는 깊이 우선 탐색으로 문제를 풀었다. 재현이는 점들을 정점이라 생각하고, 연결되어 있는 점들 사이에 간선을 이으면, 그래프의 컴포넌트의 개수와, 가장 큰 컴포넌트의 크기를 묻는 문제로 변환됨을 알아냈다. 재현이는 이를 깊이 우선 탐색으로 구한 후 지학이에게 자랑하였다.</p>

<p>지학이는 재현이가 이 문제를 푼 것을 본 후 감탄하여, 문제를 조금 더 어렵게 해서 주었다.</p>

<ul>
	<li>N은 무조건 1,000,000,000이다. 고로 격자의 크기는 1,000,000,000 * 1,000,000,000 크기이다.</li>
	<li>(x1, y1) 점과 (x2, y2) 점의 “택시 거리” 는 |x2 - x1| + |y2 - y1| 으로 정의된다. 이 정의대로라면 상하좌우에 인접한 셀은 택시 거리가 1 이하인 셀의 쌍이었다는 것을 알 수 있다. 지학이는 “붙어있다” 의 정의를 바꿨다</li>
	<li>택시 거리가 1 이하가 아니라, 택시 거리가 D 이하이면 붙어 있는 것이다.</li>
</ul>

<p>이 문제는 갓 그래프 탐색을 배운 재현이에게 너무 어려운 문제였고, 재현이는 여러분들에게 도움을 요청했다. 재현이를 도와주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 M과 D가 주어진다. (1 <= M <= 100,000, 1 <= D <= 1,000,000,000)</p>

<p>이후 M개의 줄에 점의 좌표 Xi, Yi가 주어진다. (1 <= Xi, Yi <= 1,000,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>지학이가 어렵게 바꾼 문제의 정의대로, 섬의 개수와 가장 큰 섬의 크기를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>(1,1) - (3,3) - (2,2) 셀은 연결되었으며, (10, 10) 셀은 혼자이다. 섬의 개수는 2개이고, 가장 큰 섬은 크기가 3이다.</p>

				</div>
				</div>','4 2
1 1
3 3
2 2
10 10
','2 3
','DATA_STRUCTURE'),
                                                                                                                (6726,'BAEKJOON','https://www.acmicpc.net/problem/6198',6198,'옥상 정원 꾸미기','1초','128 MB',11,'<p><img alt="sook-001(1).jpg" src="https://upload.acmicpc.net/ca458f07-d3b3-436f-a996-49080935149a/-/preview/" style="width: 343.333px; height: 214.167px;"></p>

<p>도시에는 N개의 빌딩이 있다.</p>

<p>빌딩 관리인들은 매우 성실 하기 때문에, 다른 빌딩의 옥상 정원을 벤치마킹 하고 싶어한다.</p>

<p>i번째 빌딩의 키가 h<sub>i</sub>이고, 모든 빌딩은 일렬로 서 있고 오른쪽으로만 볼 수 있다.</p>

<p>i번째 빌딩 관리인이 볼 수 있는 다른 빌딩의 옥상 정원은 i+1, i+2, .... , N이다.</p>

<p>그런데 자신이 위치한 빌딩보다 높거나 같은 빌딩이 있으면 그 다음에 있는 모든 빌딩의 옥상은 보지 못한다.</p>

<p>예) N=6, H = {10, 3, 7, 4, 12, 2}인 경우</p>

<pre>             =
 =           =
 =     -     =
 =     =     =        -> 관리인이 보는 방향
 =  -  =  =  =
 =  =  =  =  =  =
10  3  7  4  12 2     -> 빌딩의 높이
[1][2][3][4][5][6]    -> 빌딩의 번호</pre>

<ul>
	<li>1번 관리인은 2, 3, 4번 빌딩의 옥상을 확인할 수 있다.</li>
	<li>2번 관리인은 다른 빌딩의 옥상을 확인할 수 없다.</li>
	<li>3번 관리인은 4번 빌딩의 옥상을 확인할 수 있다.</li>
	<li>4번 관리인은 다른 빌딩의 옥상을 확인할 수 없다.</li>
	<li>5번 관리인은 6번 빌딩의 옥상을 확인할 수 있다.</li>
	<li>6번 관리인은 마지막이므로 다른 빌딩의 옥상을 확인할 수 없다.</li>
</ul>

<p>따라서, 관리인들이 옥상정원을 확인할 수 있는 총 수는 3 + 0 + 1 + 0 + 1 + 0 = 5이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<ul>
	<li>첫 번째 줄에 빌딩의&nbsp;개수 N이 입력된다.(1 ≤ N ≤ 80,000)</li>
	<li>두 번째 줄 부터 N+1번째 줄까지 각 빌딩의 높이가 h<sub>i</sub> 입력된다. (1 ≤ h<sub>i</sub> ≤ 1,000,000,000)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<ul>
	<li>각 관리인들이 벤치마킹이 가능한 빌딩의 수의 합을 출력한다.</li>
</ul>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
10
3
7
4
12
2
','5
','DATA_STRUCTURE'),
                                                                                                                (6738,'BAEKJOON','https://www.acmicpc.net/problem/6416',6416,'트리인가?','1초','128 MB',0,'<p>트리는 굉장히 잘 알려진 자료 구조이다. 트리를 만족하는 자료 구조는 비어 있거나(노드의 개수가 0개), 노드의 개수가 1개 이상이고 방향 간선이 존재하며 다음과 같은 조건을 만족해야 한다. 이때, 노드 u에서 노드 v로 가는 간선이 존재하면 간선을 u에 대해서는 나가는 간선, v에 대해서는 들어오는 간선이라고 하자.</p>

<ol>
	<li>들어오는 간선이 하나도 없는 단 하나의 노드가 존재한다. 이를 루트(root) 노드라고 부른다.</li>
	<li>루트 노드를 제외한 모든 노드는 반드시 단 하나의 들어오는 간선이 존재한다.</li>
	<li>루트에서 다른 노드로 가는 경로는 반드시 가능하며, 유일하다. 이는 루트를 제외한 모든 노드에 성립해야 한다.</li>
</ol>

<p>아래의 그림을 보자. 원은 노드, 화살표는 간선을 의미하며, 화살표의 방향이&nbsp;노드&nbsp;u에서 노드 v로 향하는 경우 이는 이 간선이 u에서 나가는 간선이며 v로 들어오는 간선이다. 3개의 그림 중&nbsp;앞의 2개는 트리지만 뒤의 1개는 트리가 아니다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images2/tree1.gif"><img alt="" src=https://www.acmicpc.net/upload/images2/tree2.gif" style="background-color:initial; font-size:medium; height:210px; width:204px"><img alt="" src=https://www.acmicpc.net/upload/images2/tree3.gif" style="background-color:initial; font-size:medium; height:194px; width:164px"></p>

<p>당신은 간선의 정보들을 받아서 해당 케이스가 트리인지를 판별해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있으며, 입력의 끝에는 두 개의 음의 정수가 주어진다.</p>

<p>각 테스트 케이스는 여러 개의 정수쌍으로 이루어져 있으며, 테스트 케이스의 끝에는 두 개의 0이 주어진다.</p>

<p>각 정수쌍 u, v에 대해서 이는 노드 u에서 노드 v로 가는 간선이 존재함을 의미한다. u와 v는 0보다 크다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 테스트 케이스의 번호가 k일 때(k는 1부터 시작하며, 1씩 증가한다)&nbsp;트리일 경우&nbsp;"Case k is a tree."를, 트리가 아닐 경우 "Case k is not a tree."를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 8  5 3  5 2  6 4
5 6  0 0

8 1  7 3  6 2  8 9  7 5
7 4  7 8  7 6  0 0

3 8  6 8  6 4
5 3  5 6  5 2  0 0
-1 -1
','Case 1 is a tree.
Case 2 is a tree.
Case 3 is not a tree.
','DATA_STRUCTURE'),
                                                                                                                (6736,'BAEKJOON','https://www.acmicpc.net/problem/6505',6505,'문자열 디코딩','1초','128 MB',14,'<p>상근이는 문자열을 인코딩하는 흥미로운 아이디어를 가지고 있다. 다음은 인코딩이 동작하는 방법에 대한 설명이다.</p>

<p>인코딩하려고 하는 문자열의 각 문자를 x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>이라고 하자.</p>

<ol>
	<li>자연수 m과 집합 {1, 2, ..., n}에서 서로 다른 n개의 수 p<sub>1</sub>, p<sub>2</sub>, ... p<sub>n</sub>를 고른다. (p는 1부터 n까지 숫자의 순열이 된다)</li>
	<li>3번을 m번 반복한다.</li>
	<li>모든 1 ≤ i ≤ n 에 대해서, y<sub>i</sub>를 x<sub>pi</sub>로 정한다. 그 다음 x<sub>i</sub>와 y<sub>i</sub>를 바꾼다.</li>
</ol>

<p>문자열 "hello"를 인코딩하려고 할 때를 생각해보자. m = 3를 고르고, 순열 p는 2, 3, 1, 5, 4를 고른다면, hello" -> "elhol" -> "lhelo" -> "helol"와 같이 인코딩 된다.</p>

<p>인코딩 된 문자열과 인코딩하는데 사용한 m과 p1, ..., pn이 주어졌을 때, 인코딩 하기 전 문자열을 구하는 프로그램을 작성하시오. (디코딩)</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 n과 m이 주어진다. (1 ≤ n ≤ 80, 1 ≤ m ≤ 10<sup>9</sup>) 다음 줄에는 인코딩하는데 사용한 n개의 서로 다른 숫자 p<sub>1</sub>, ..., p<sub>n</sub>이 주어진다. (1 ≤ p<sub>i</sub> ≤ n) 셋째 줄에는 인코딩된 문자열이 주어진다. 입력의 마지막 줄에는 0이 두 개 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서 디코딩한 문자열을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
2 3 1 5 4
helol
16 804289384
13 10 2 7 8 1 16 12 15 6 5 14 3 4 11 9
scssoet tcaede n
8 12
5 3 4 2 1 8 6 7
encoded?
0 0
','hello
second test case
encoded?
','DATA_STRUCTURE'),
                                                                                                                (6741,'BAEKJOON','https://www.acmicpc.net/problem/6523',6523,'요세푸스 한 번 더!','2초','128 MB',14,'<p>프로 드링커 상근이는 술을 마실때, 요세푸스 문제와 같은 순서로 술을 마신다. 요세푸스 문제를 천 번 넘게 푼 상근이는 머리 속으로 가장 마지막에 술을 마시는 사람의 위치를 계산할 수 있다. 따라서, 같이 술을 마시는 친구들은 상근이를 이기기 위해서 술을 마시는 새로운 순서를 제시했다.</p>

<p>먼저, 원탁에 모두 앉는다. 총 N명이 원탁에 앉았다면, 각 사람의 번호는 0번부터 N-1번이 된다.</p>

<p>요세푸스 문제와 다르게 다음 사람을 고르기 위해서 두 숫자 a와 b를 이용한다. 현재 선택된 사람의 번호가 x라면, 다음 사람의 번호는 ax<sup>2</sup>+b mod N이 된다.</p>

<p>가장 처음 시작하는 사람의 번호는 0번이다. 다음 사람의 번호는 위의 식을 이용해서 고른다.</p>

<p>각 사람은 한 번의 기회를 더 받을 수 있다. 즉, 한 번 걸리면 술을 마시는 것이 아니고, 두 번 걸렸을 때, 술을 마시는 것이다.</p>

<p>만약, 어떤 사람이 세 번 걸렸다면, 그 즉시 모두 자리를 박차고 일어나 집으로 간다.</p>

<p>N과 a, b가 주어졌을 때, 술을 마시지 않고 집으로 가는 사람의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 세 숫자 N, a, b가 공백으로 구분되어져 있다. (2 ≤ N ≤ 10<sup>9</sup>, 0 ≤ a, b < N) 또, 첫 사람이 술을 마시기 위해 필요한 단계의 수는 10<sup>6</sup>보다 작다. 입력의 마지막 줄에는 0이 하나 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 술을 마시지 않고 집으로 가는 사람의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>요세푸스 문제는&nbsp;<a href="http://www.acmicpc.net/problem/1158">1158번</a>을&nbsp;참고하면 된다.</p>

				</div>
				</div>','2 1 1
5 1 1
10 3 7
101 9 2
698253463 1 181945480
1000000000 999999999 999999999
0
','0
2
4
96
698177783
999999994
','DATA_STRUCTURE'),
                                                                                                                (6743,'BAEKJOON','https://www.acmicpc.net/problem/6549',6549,'히스토그램에서 가장 큰 직사각형','1초','256 MB',16,'<p>히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형이다. 각 직사각형은 같은 너비를 가지고 있지만, 높이는 서로 다를 수도 있다. 예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.</p>

<p style="text-align: center;"><img alt="" src=https://www.acmicpc.net/upload/images/histogram.png" style="height: 110.833px; width: 351.667px;"></p>

<p>히스토그램에서 가장 넓이가 큰 직사각형을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 테스트 케이스 여러 개로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 직사각형의 수 n이 가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 그 다음 n개의 정수 h<sub>1</sub>, ..., h<sub>n</sub> (0 ≤ h<sub>i</sub> ≤ 1,000,000,000)가 주어진다. 이 숫자들은 히스토그램에 있는 직사각형의 높이이며, 왼쪽부터 오른쪽까지 순서대로 주어진다. 모든 직사각형의 너비는 1이고, 입력의 마지막 줄에는 0이 하나 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 2 1 4 5 1 3 3
4 1000 1000 1000 1000
0
','8
4000
','DATA_STRUCTURE'),
                                                                                                                (6791,'BAEKJOON','https://www.acmicpc.net/problem/7469',7469,'K번째 수','1초','256 MB',19,'<p>현정이는 자료 구조 프로젝트를 하고 있다. 다른 학생들은 프로젝트 주제로 스택, 큐와 같은 기본 자료 구조를 구현하는 주제를 선택했다. 하지만, 현정이는 새로운 자료 구조를 만들었다.</p>

<p>현정이가 만든 자료구조는 배열을 응용하는 것이다. 배열 a[1...n]에는 서로 다른 수가 n개 저장되어 있다. 현정이는 여기에 Q(i,j,k)라는 함수를 구현해 모두를 놀라게 할 것이다.</p>

<blockquote>
<p>Q(i,j,k):&nbsp;배열 a[i...j]를 정렬했을 때, k번째 수를 리턴하는 함수</p>
</blockquote>

<p>예를 들어, a = (1,5,2,6,3,7,4)인 경우 Q(2,5,3)의 답을 구하는 과정을 살펴보자. a[2...5]는 (5,2,6,3)이고, 이 배열을 정렬하면 (2,3,5,6)이 된다. 정렬한 배열에서 3번째 수는 5이다. 따라서 Q(2,5,3)의 리턴값은 5이다.</p>

<p>배열 a가 주어지고, Q함수를 호출한 횟수가 주어졌을 때, 각 함수의 리턴값을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 배열의 크기 n과 함수 Q를 호출한 횟수 m이 주어진다. (1 ≤ n ≤ 100,000, 1 ≤ m ≤ 5,000)</p>

<p>둘째 줄에는 배열에 포함된 정수가 순서대로 주어진다. 각 정수는 절댓값이 10<sup>9</sup>를 넘지 않는 정수이다.</p>

<p>다음 m개 줄에는 Q(i,j,k)를 호출할 때 사용한 인자 i,j,k가 주어진다. (1 ≤ i ≤ j ≤ n, 1 ≤ k ≤ j-i+1)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q함수를 호출할 때마다 그 함수의 리턴값을 한 줄에 하나씩 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 3
1 5 2 6 3 7 4
2 5 3
4 4 1
1 7 3
','5
6
3
','DATA_STRUCTURE'),
                                                                                                                (6794,'BAEKJOON','https://www.acmicpc.net/problem/7511',7511,'소셜 네트워킹 어플리케이션','1초','128 MB',11,'<p>어렸을때부터 컴퓨터 프로그래밍에 엄청난 소질을 보인 상근이는 항상 소셜 네트워킹 웹사이트를 만들고 싶어 했다. 상근이는 페이스북을 벤치마킹하기 위해 지난 3년간 열심히 사용을 했고, 이제 페이스북의 단점을 보완한 새 소셜 네트워킹 웹 2.0 어플리케이션을 만들려고 한다.</p>

<p>사람들은 소셜 네트워킹 어플리케이션에 가입을 한 다음, 현실에서 아는 사람을 친구로 추가하기 시작한다. 이러한 친구 관계 정보를 이용해 친구 관계 그래프를 그릴 수 있다.</p>

<p>소셜 네트워킹 어플리케이션에서 가장 중요한 기능은 한 사람이 다른 사람의 페이지를 방문했을 때, 친구 관계 그래프에서 두 사람 사이의 경로를 보여주는 기능이다. 경로가 없는 경우에는 보여주지 않는다.</p>

<p>상근이의 서비스는 매우 유명해졌고, 위의 기능은 사람들이 점점 많아질수록 경로를 구하는 시간이 매우 느려지게 되었다. 그 이유는 두 사람 사이의 경로가 없는 경우에 경로를 찾기 위해 너무 오랜시간 그래프를 탐색하기 때문이었다. 따라서, 상근이는 두 사람 사이의 경로가 존재하는지 안 하는지를 미리 구해보려고 한다.</p>

<p>유저의 수와 각 유저의 친구 관계가 입력으로 주어진다. 이때, 주어지는 두 사람이 친구 관계 그래프상에서 경로가 존재하는지 안 하는지를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다.</p>

<p>각 테스트 케이스의 첫째 줄에는 유저의 수 1 ≤ n ≤ 10<sup>6</sup>이 주어진다. 둘째 줄에는 친구 관계의 수 1 ≤ k ≤ 10<sup>5</sup>가 주어진다. 다음 k개 줄에는 두 정수 0 ≤ a, b < n이 주어진다. 두 수는 친구 관계를 나타내며, 유저 a와 b가 친구라는 소리이다. 다음 줄에는 미리 구할 쌍의 수 1 ≤ m ≤ 10<sup>5</sup>가 주어진다. 다음 m개 줄에는 구해야하는 쌍을 나타내는 u, v가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 "Scenario i:"를 출력한다. i는 테스트 케이스 번호이며, 1부터 시작한다. 그 다음, 각각의 쌍마다 두 사람을 연결하는 경로가 있으면 1, 없으면 0을 출력한다.</p>

<p>각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
3
1
0 1
2
0 1
1 2
5
3
0 1
1 2
3 4
2
0 2
1 3
','Scenario 1:
1
0

Scenario 2:
1
0
','DATA_STRUCTURE'),
                                                                                                                (6806,'BAEKJOON','https://www.acmicpc.net/problem/7574',7574,'개구리','1초','128 MB',19,'<p>연꽃잎들이 떠있는 풍경으로 유명한 연못이 있다. 이 연못에 살고 있는 개구리는 연꽃잎과 연꽃잎 사이를 점프해서 움직이기를 좋아한다.</p>

<p>연못은 x,y 좌표로 표현되는 평면 상에서 x ≥ 0, y ≥ 0인 구역 R로 나타낸다. 연못에 떠 있는 연꽃잎은 구역 R안에서 한 변의 길이가 r 인 정사각형으로 나타낸다 (그림 1). 모든 연꽃잎의 크기는 동일하고 서로 겹치지 않는다고 가정한다. 임의의 두 연꽃잎들의 테두리가 맞닿아 있는 경우는 없다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/de0f9c45-e8ab-4c75-bc63-bfe82cf77a43/-/preview/" style="width: 243px; height: 157px;"></p>

<p style="text-align: center;">그림 1</p>

<p>좌표 (0,0)을 포함하는 연꽃잎 S는 항상 존재하고 개구리는 처음에 이 연꽃잎 위에 놓여있다.&nbsp;</p>

<p>개구리는 한 번의 점프로 최대 거리 d만큼 이동할 수 있다. 다만, 동, 서, 남, 북 방향으로만 점프할 수 있다. 따라서 개구리가 그림 2, 3의 연꽃잎 A에서 점프한다면 도달할 수 있는 영역은 그림 2, 3의 어두운 구역과 같다. 개구리가 연꽃잎 A 에서 다른 연꽃잎 B로 점프하기 위해서는 그림 2 에서와 같이 이 구역 안에 B의 일부분이 놓여 있어야 한다. 그림 3과 같이 이 구역에 B의 테두리가 닿아 있는 경우도 점프할 수 있다고 가정한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/c1c43c70-4e23-442c-a556-3b927ac5db86/-/preview/" style="width: 203px; height: 130px;"></p>

<p style="text-align: center;">그림 2</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/5e391a51-6f2c-4576-a86e-33a59b53d3af/-/preview/" style="width: 202px; height: 170px;"></p>

<p style="text-align: center;">그림 3</p>

<p>개구리가 처음 시작 연꽃잎 S에 놓여 있을 때, 연꽃잎 위에서 이동하거나 연꽃잎에서 연꽃잎으로 점프해서 어떤 연꽃잎 위의 좌표 (a,b)인 위치로 이동 할 수 있다. 문제는 (0,0)으로부터 이동 가능한 가장 먼 좌표 (a,b)를 찾는 것이다. 여기서, 좌표 (a,b)의 (0,0)으로부터의 거리는 a+b로 계산된다.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 개의 정수 N, r이 주어진다. 단, 그 범위는 1 ≤ N ≤ 100,000, 1 ≤ r ≤ 10,000 이다. 여기서, N은 연꽃잎들의 수를 나타내고 r은 연꽃잎의 한 변의 길이를 나타낸다. 다음 N개의 줄 각각에는 하나의 연꽃잎의 왼쪽 아래 꼭지 점의 좌표 (x,y)를 나타내는 두 정수 x와 y가 공백을 사이에 두고 주어진다. 단, 0 ≤ x,y ≤ 10,000,000 이다. 다음 줄에는 개구리가 한 번의 점프로 연꽃잎 사이를 이동할 수 있는 최대 거리 d가 주어 진다. 단, 1 ≤ d ≤ 1,000,000 이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 한 줄로 이루어져 있다. 개구리가 (0,0)으로부터 이동 가능한 가장 먼 좌표까지의 거리를 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
0 0
1 4
5 5
6 1
10 4
1
','20
','DATA_STRUCTURE'),
                                                                                                                (6798,'BAEKJOON','https://www.acmicpc.net/problem/7578',7578,'공장','1초','256 MB',16,'<p>어떤 공장에는 2N개의 기계가 2열에 걸쳐 N개씩 배치되어 있다. 이 2개의 열을 각각 A열과 B 열이라고 부른다. A열에 있는 N개의 기계는 각각이 B열에 있는 N개의 기계와 하나씩 짝을 이루어 케이블로 연결되어 있다. 즉, A열의 임의의 기계는 B열의 유일한 기계와 케이블로 연결되어 있고, B열의 임의의 기계는 A열의 유일한 기계와 케이블로 연결되어 있다</p>

<p>또한, 각 기계에는 식별번호가 붙어있으며, 짝이 맺어진 기계끼리는 같은 식별번호가 붙어있다. 즉, 각 열에 있는 N개의 기계끼리는 서로 다른 식별번호를 가지고 있으며, 반대쪽 열에 있는 같은 식별번호를 가진 기계와 케이블로 이어져 있다.</p>

<p>공장 작업의 효율성을 위해 기계들은 짝을 맺은 순서대로 배치되지 않으며, 필요에 따라 각 열의 기계들의 순서를 바꾼 바람에 케이블은 마구 엉켜있는 상태이다. 이렇게 엉켜버린 케이블은 잦은 고장의 원인이 되기 때문에, 기계의 위치를 바꾸지 않은 상태에서 케이블을 두 기계를 잇는 직선의 형태로 만들기로 했다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/e78a497b-7a88-4dfb-bdc7-4e26759187a6/-/preview/" style="width: 264px; height: 103px;"></p>

<p>예를 들어, 위의 그림과 같이 N = 5이고, A열에 위치한 기계의 식별번호가 순서대로 132, 392, 311, 351, 231이고 B열에 위치한 기계의 식별번호가 순서대로 392, 351, 132, 311, 231이라면 케이블들의 교차 횟수 혹은 서로 교차하는 케이블 쌍의 개수는 3이 된다.</p>

<p>정수 N과 A열에 위치한 기계, B열에 위치한 기계의 식별번호가 각각 순서대로 주어질 때에 서로 교차하는 케이블 쌍의 개수를 정확하게 세어 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 세 줄로 이루어져 있다. 첫 줄에는 정수 N이 주어지며, 두 번째 줄에는 A열에 위치한 N개 기계의 서로 다른 식별번호가 순서대로 공백문자로 구분되어 주어진다. 세 번째 줄에는 B열에 위치한 N개의 기계의 식별번호가 순서대로 공백문자로 구분되어 주어진다.</p>

<p>단, 1 ≤ N ≤ 500,000이며, 기계의 식별번호는 모두 0 이상 1,000,000 이하의 정수로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>여러분은 읽어 들인 2N개의 기계의 배치로부터 서로 교차하는 케이블 쌍의 개수를 정수 형태로 한 줄에 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
132 392 311 351 231
392 351 132 311 231
','3
','DATA_STRUCTURE'),
                                                                                                                (6799,'BAEKJOON','https://www.acmicpc.net/problem/7626',7626,'직사각형','3초','128 MB',20,'<p>축에 평행한 직사각형 N개가 평면 위에 있다. 이 직사각형들이 차지하는 전체 면적을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 양의 정수 N이 주어진다. (1 ≤ N ≤ 200,000) 다음 N개 줄에는 공백으로 나누어진 네 값 "x<sub>1</sub>, x<sub>2</sub>, y<sub>1</sub>, y<sub>2</sub>"가 주어진다. 이 값은 직사각형 [x<sub>1</sub>,x<sub>2</sub>] × [y<sub>1</sub>,y<sub>2</sub>]를 나타낸다. 모든 좌표는 0보다 크거나 같고, 10<sup>9</sup>보다 작거나 같으며, 각각의 직사각형은 x<sub>1</sub> < x<sub>2</sub>, y<sub>1</sub> < y<sub>2</sub>를 만족한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 주어진 직사각형 N개가 차지하는 전체 면적을 출력한다. 한 구역이 여러 개의 직사각형으로 덮어져 있는 경우에도 한 번으로 센다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
0 3 1 2
1 2 0 3
','5
','DATA_STRUCTURE'),
                                                                                                                (6801,'BAEKJOON','https://www.acmicpc.net/problem/7627',7627,'스패닝 트리','1초','128 MB',21,'<p>가중치가 있고, 연결되어있는 멀티 그래프 (connected weighted multigraph)가 주어졌을 때, 최소 스패닝 트리의 수를 구하는 프로그램을 작성하시오.</p>

<p>멀티 그래프는 루프(자기 자신으로 향하는 간선)이 있을 수 있고, 두 정점 사이에 간선이 여러 개 있을 수도 있다.</p>

<p>입력으로 주어지는 그래프에서 가중치가 같은 간선은 최대 4번 등장한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 수 N과 간선의 수 M이 주어진다. (1 ≤ N ≤ 5×10<sup>4</sup>, 1 ≤ M ≤ 10<sup>5</sup>) 정점은 1번부터 N번까지 번호가 매겨져 있다. 다음 M개 줄에는 세 정수 a, b, w가 주어지며, 공백으로 구분되어져 있다. (1 ≤ a, b ≤ N, 1 ≤ w ≤ 2<sup>30</sup>) 이 뜻은 a와 b를 연결하는 간선의 가중치가 w라는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소 스패닝 트리의 개수를 1000003로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5
1 2 6
1 2 6
2 3 6
3 1 6
3 3 8
','5
','DATA_STRUCTURE'),
                                                                                                                (6804,'BAEKJOON','https://www.acmicpc.net/problem/7662',7662,'이중 우선순위 큐','6초','256 MB',12,'<p>이중 우선순위 큐(dual priority queue)는 전형적인 우선순위 큐처럼 데이터를 삽입, 삭제할 수 있는 자료 구조이다. 전형적인 큐와의 차이점은 데이터를 삭제할 때 연산(operation) 명령에 따라 우선순위가 가장 높은 데이터 또는 가장 낮은 데이터 중 하나를 삭제하는 점이다. 이중 우선순위 큐를 위해선 두 가지 연산이 사용되는데, 하나는 데이터를 삽입하는 연산이고 다른 하나는 데이터를 삭제하는 연산이다. 데이터를 삭제하는 연산은 또 두 가지로 구분되는데 하나는 우선순위가 가장 높은 것을 삭제하기 위한 것이고 다른 하나는 우선순위가 가장 낮은 것을 삭제하기 위한 것이다. </p>

<p>정수만 저장하는 이중 우선순위 큐 Q가 있다고 가정하자. Q에 저장된 각 정수의 값 자체를 우선순위라고 간주하자. </p>

<p>Q에 적용될 일련의 연산이 주어질 때 이를 처리한 후 최종적으로 Q에 저장된 데이터 중 최댓값과 최솟값을 출력하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력 데이터는 표준입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 Q에 적용할 연산의 개수를 나타내는 정수 k (k ≤ 1,000,000)가 주어진다. 이어지는 k 줄 각각엔 연산을 나타내는 문자(‘D’ 또는 ‘I’)와 정수 n이 주어진다. ‘I n’은 정수 n을 Q에 삽입하는 연산을 의미한다. 동일한 정수가 삽입될 수 있음을 참고하기 바란다. ‘D 1’는 Q에서 최댓값을 삭제하는 연산을 의미하며, ‘D -1’는 Q 에서 최솟값을 삭제하는 연산을 의미한다. 최댓값(최솟값)을 삭제하는 연산에서 최댓값(최솟값)이 둘 이상인 경우, 하나만 삭제됨을 유념하기 바란다.</p>

<p>만약 Q가 비어있는데 적용할 연산이 ‘D’라면 이 연산은 무시해도 좋다. Q에 저장될 모든 정수는 -2<sup>31</sup> 이상 2<sup>31</sup> 미만인 정수이다. </p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 표준출력을 사용한다. 각 테스트 데이터에 대해, 모든 연산을 처리한 후 Q에 남아 있는 값 중 최댓값과 최솟값을 출력하라. 두 값은 한 줄에 출력하되 하나의 공백으로 구분하라. 만약 Q가 비어있다면 ‘EMPTY’를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
7
I 16
I -5643
D -1
D 1
D 1
I 123
D -1
9
I -45
I 653
D 1
I -642
I 45
I 97
D 1
D -1
I 333
','EMPTY
333 -45
','DATA_STRUCTURE'),
                                                                                                                (6808,'BAEKJOON','https://www.acmicpc.net/problem/7785',7785,'회사에 있는 사람','1초','256 MB',6,'<p>상근이는 세계적인 소프트웨어 회사 기글에서 일한다. 이 회사의 가장 큰 특징은 자유로운 출퇴근 시간이다. 따라서, 직원들은 반드시&nbsp;9시부터 6시까지 회사에 있지 않아도 된다.</p>

<p>각 직원은 자기가 원할 때 출근할 수 있고, 아무때나 퇴근할 수 있다.</p>

<p>상근이는 모든 사람의 출입카드 시스템의 로그를 가지고 있다. 이 로그는 어떤 사람이 회사에 들어왔는지, 나갔는지가 기록되어져 있다. 로그가 주어졌을 때, 현재 회사에 있는 모든 사람을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 로그에 기록된 출입 기록의 수 n이 주어진다. (2 ≤ n ≤ 10<sup>6</sup>) 다음 n개의 줄에는 출입 기록이 순서대로 주어지며, 각 사람의 이름이 주어지고 "enter"나 "leave"가 주어진다. "enter"인 경우는 출근, "leave"인 경우는 퇴근이다.</p>

<p>회사에는 동명이인이 없으며, 대소문자가 다른 경우에는 다른 이름이다.&nbsp;사람들의 이름은 알파벳 대소문자로 구성된 5글자 이하의 문자열이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>현재 회사에 있는 사람의 이름을 사전 순의 역순으로 한 줄에 한 명씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
Baha enter
Askar enter
Baha leave
Artem enter
','Askar
Artem
','DATA_STRUCTURE'),
                                                                                                                (6813,'BAEKJOON','https://www.acmicpc.net/problem/7888',7888,'두 교수','3초','128 MB',22,'<p>알고스팟 대학교에는 서로를 정말 싫어하는 교수 두 명이 있다. 이 대학교에서는 교수의 이름을 숫자로 부른다. 서로 싫어하는 두 교수의 번호는 1과 2이다.</p>

<p>알고스팟 대학교에는 총 n명의 교수가 있고, 수업은 매일 매일 같은 시간에 진행된다.&nbsp;각 교수가 맡은 수업은 하나이다. 모든 수업의 시작 시간과 종료 시간은 정해져있다. 또,&nbsp;수업을 조금 더 늦게 끝내거나, 일찍 시작하는 것은 불가능하다. 학교에서 정한 수업 이외의 수업은 할 수 없다.</p>

<p>아직 학교는 수업의 강의실을 정해놓지 않았다. 시간이 겹치는 수업은 같은 강의실에 배정할 수 없다. 하지만, 끝 시간과 시작 시간이 같은 두 수업은 같은 강의실에 배정할 수 있다. 모든 수업에 강의실을 배정할 때, 필요한 강의실의 최소 개수를 구하는 프로그램을 작성하시오. 1번 교수와 2번 교수는 서로를 매우 싫어하기 때문에, 같은 강의실에서 수업을 진행하지 않는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 t가 주어진다. (t ≤ 250) 각 테스트 케이스의 첫째 줄에는 교수의 수 n (2 ≤ n ≤ 10<sup>5</sup>)이 주어진다. 다음 n개 줄에는 i번 교수가 맡은 수업의 시작 시간 start<sub>i</sub>와 끝 시간 end<sub>i</sub>가 주어진다. (0 ≤ start<sub>i</sub> < end<sub>i</sub> ≤ 10<sup>9</sup>) 입력의 크기는 50MB를 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 수업에 강의실을 배정하는데 필요한 강의실의 최소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2
0 10
10 20
3
0 10
10 20
10 20
5
4 14
3 13
2 12
1 11
0 10
4
0 10
10 20
20 30
30 40
','2
2
5
2
','DATA_STRUCTURE'),
                                                                                                                (6839,'BAEKJOON','https://www.acmicpc.net/problem/8217',8217,'유성','5초','256 MB',22,'<p>최근 백준 우주 연합(BIU)은 어떤 은하계 근처에서 새로운 행성 하나를 발견했다. 그 행성은 유성우가 많이 내려 사람이 살기엔 적절치 못한 곳이었으나, 유성우에 관한 연구 대상으로는 아주 좋은 곳으로 밝혀졌다.</p>

<p>BIU 회원국은 이미 그 행성 가까이에 우주정거장을 세웠다. 이 우주 정거장의 목적은 유성우의 운석 샘플을 채취하는 것이다. BIU 연합 최고 지도 사령관인 백준은 행성 궤도를 M개의 구역으로 나누고 1부터 M까지 순서대로 번호를 부여했다. (<em><u>행성 궤도는 원 궤도이므로 1번 구역과 M번 구역은 서로 인접해 있다.</u></em>) 각 구역은 N개의 BIU회원국들이 서로 적당히 나누어&nbsp;가졌다.</p>

<p>각 BIU 회원국들은 모으고자 하는 운석 샘플의 목표치를 정했다. 당신의 임무는 유성우 예보를 바탕으로 각 나라들이 언제 샘플 채취를 완료할 수 있는지 말해주는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째&nbsp;줄에 두 정수 N, M (1 ≤ N, M&nbsp;≤ 300,000)이 주어진다. N은 BIU연합의&nbsp;<strong>회원국</strong> 개수고, M은 행성 궤도의 <strong>구역</strong> 개수이다.</p>

<p>둘째 줄에는 M개의 정수&nbsp;o<sub>i</sub>&nbsp;(1 ≤ o<sub>i</sub>&nbsp;≤ N)가 주어진다. o<sub>i</sub>는 i번째 구역을 소유하고 있는<strong> BIU연합의&nbsp;회원국 번호</strong>를&nbsp;나타낸다.</p>

<p>세&nbsp;번째 줄에는 N개의 정수&nbsp;p<sub>j</sub>&nbsp;(1 ≤ p<sub>j</sub>&nbsp;≤ 10<sup>9</sup>)가 주어진다. p<sub>j</sub>는 j번째 BIU회원국이&nbsp;<strong>목표치로 정한&nbsp;운석 샘플 수량</strong>을&nbsp;나타낸다.</p>

<p>네&nbsp;번째 줄에는 정수 Q (1 ≤ Q ≤ 300,000)가 주어진다. Q는 <strong>유성우 예보의 수</strong>를 나타낸다.</p>

<p>다음 Q개의 줄에는 예측된 유성우의 개수가 날짜 순서로 표시된다. 각 u번째&nbsp;줄은&nbsp;세 가지 정수 l<sub>u</sub>, r<sub>u</sub>, a<sub>u</sub>로 구성되는데, l<sub>u&nbsp;</sub>≤&nbsp;r<sub>u</sub>인 경우 구역&nbsp;l<sub>u</sub>,l<sub>u</sub>+1,…,r<sub>u</sub>에 a<sub>u</sub>개의 운석이 내리고, l<sub>u</sub>>r<sub>u</sub>인 경우 구역&nbsp;l<sub>u</sub>,l<sub>u</sub>+1,…,m,1,…,r<sub>u</sub>에 각 구역당 a<sub>u</sub>개의 운석이 내린다는 뜻이다. (정수&nbsp;a<sub>u</sub>의 범위는&nbsp;1 ≤ a<sub>u</sub>&nbsp;≤ 10<sup>9&nbsp;</sup>이고, 여기서 u는&nbsp;유성우 예보&nbsp;시작&nbsp;후 u번째 날을 의미한다.)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>회원국별로 샘플조사를 끝마칠 수 있는 최소 일&nbsp;수 w<sub>j</sub>를 회원국&nbsp;번호 순서대로 한&nbsp;줄에 하나씩&nbsp;출력한다. 끝마치는 날에는 최소한 p<sub>j</sub>개의 운석 샘플을 가지고 있어야 하며, 유성우 예보 기간 안에 운석 샘플을 다 채우지 못 할 경우 NIE(폴란드어로 NO를 의미)를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5
1 3 2 1 3
10 5 7
3
4 2 4
1 3 1
3 5 2
','3
NIE
1
','DATA_STRUCTURE'),
                                                                                                                (6862,'BAEKJOON','https://www.acmicpc.net/problem/8330',8330,'순열','1초','128 MB',18,'<p>양의 정수로 이루어진 수열 a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>이 주어진다. 여기서, 1번부터 n번까지 숫자의 순서를 바꾸려고 한다. 이때, i번째 숫자는 a<sub>i</sub>보다 크면 안 된다. 즉, 모든 1 ≤ i ≤ n에 대해서 p<sub>i</sub> ≤ a<sub>i</sub>을 만족하는 1부터 n까지 이루어진 순열 p를 찾아야 한다.</p>

<p>수열이 주어졌을 때, 그리고 그 수열을 수정했을 때, 각각 순열을 만들 수 있는지 없는지를 판별하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 n (1 ≤ n ≤ 200,000)이 주어진다. 둘째 줄에는 a<sub>i</sub>가 주어진다. 셋째 줄에는 수열을 수정한 횟수 m (0 ≤ m ≤ 500,000)이 주어진다. 다음 m개 줄에는 수열을 어떻게 수정했는지 한 줄에 하나씩 주어지며, 두 정수 j<sub>i</sub>와 w<sub>i</sub>로 이루어져 있다. (1 ≤ j<sub>i</sub>, w<sub>i</sub> ≤ n) j<sub>i</sub>번째 원소를 w<sub>i</sub>로 수정했다는 이미이다. 수정은 누적해서 이루어진다. 즉, i번째 수정은 (i-1)번 수정된 수열에서 이루어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 총 m+1줄이다. 각 줄마다 순열을 만들 수 있으면 TAK을, 만들 수 없으면 NIE를 출력해야 한다.</p>

<p>첫째 줄에는 입력으로 주어진 수열을 이용해 문제의 조건에 맞는 순열을 만들 수 있는지를, 다음 m개 줄에는 각각의 수정이 이루어진 후에 순열을 만들 수 있는지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>입력으로 주어진 수열을 이용해서 순열 2, 4, 3, 1, 5를 만들 수 있다. 첫 번째 수정 이후에 수열은 3, 4, 3, 2, 4가 되고, 이 수열로 만들 수 있는 순열은 없다. 두 번째 수정 이후에 수열은 5, 4, 3, 2, 4가 되고, 이를 이용해 만들 수 있는 순열은 5, 1, 3, 2, 4이다.</p>

				</div>
				</div>','5
3 4 3 2 5
2
5 4
1 5
','TAK
NIE
TAK
','DATA_STRUCTURE'),
                                                                                                                (6902,'BAEKJOON','https://www.acmicpc.net/problem/8874',8874,'웜뱃','20초','256 MB',26,'<p>브리즈번 시는 돌연변이로 거대해진 웜뱃(호주에 사는 너구리 비슷한 동물)에 장악당했다. 당신의 임무는 사람들을 구조하는 것이다.</p>

<p>브리즈번 시의 도로는 커다란 격자 모양으로 되어 있다. 동서 방향으로 놓인 수평 도로는 R 개가 있고, 북쪽에서 남쪽 방향으로 차례로 번호가 0, …, (R - 1) 로 매겨져 있다. 또한, 남북 방향으로 놓인 수직 도로는 C 개가 있고, 서쪽에서 동쪽 방향으로 차례로 번호가 0, …, (C - 1) 로 매겨져 있다. 다음 그림은 이렇게 번호가 매겨진 도로의 예이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/5ae350c0-e044-4f33-8abf-94d74ce8babd/-/preview/" style="width: 279px; height: 295px;"></p>

<p>웜뱃은 북쪽에서부터 쳐들어오고 있고, 사람들은 남쪽으로 도망친다. 사람들은 가로 방향으로는 어느 쪽이든 움직일 수 있지만, 세로 방향으로는 안전한 방향인 남쪽으로만 움직일 수 있다.</p>

<p>수평 도로 P 와 수직 도로 Q 의 교차로는 (P, Q) 로 표현한다. 두 교차로 사이 세그먼트에는 웜뱃들이 있을 수 있고, 몇 마리의 웜뱃이 있는지는 시간이 흐르면서 변할 수 있다. 여러분의 임무는 북쪽(수평 도로 0 번)의 주어진 교차로에 도착한 사람을 남쪽(수평 도로 R - 1 번)의 주어진 교차로로 가는 길을 알려주는 것인데, 이 경로를 지날 때 가능한 한 적은 수의 웜뱃을 만나야 한다.</p>

<p>먼저, 격자의 크기와 각 도로 세그먼트에 웜뱃이 몇 마리가 있는지가 주어진다. 다음에는 E 개의 이벤트가 차례로 주어지는데, 각 이벤트는 아래 두 가지 중 하나의 형태이다.</p>

<ul>
	<li><code>change</code>: 어떤 도로 세그먼트에 있는 웜뱃의 마릿수가 바뀐다.</li>
	<li><code>escape</code>: 사람 한 명이 수평 도로 0 번의 주어진 교차로로 도착하고, 이 사람을 가장 적은 수의 웜뱃을 만나면서 수평 도로 R - 1 의 주어진 교차로로 보내는 경로를 구해야 한다.</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/2175df74-bd04-4c81-a1a5-82732584297a/-/preview/" style="width: 279px; height: 206px;"></p>

<p>위 그림은 수평 도로가 R = 3 개, 수직 도로가 C = 4 개, 그리고 각 도로 세그먼트에 웜뱃이 몇 마리가 있는지 주어진 지도의 처음 상황이다. 다음 순서대로 이벤트가 발생한다고 하자.</p>

<ul>
	<li>한 사람이 교차로 A = (0, 2) 에 도착해서 교차로 B = (2, 1) 로 도망치고 싶어한다. 이때 만나는 웜뱃 마릿수의 최솟값은 2 인데, 점선을 따라가면 이를 확인할 수 있다.</li>
	<li>또 한 사람이 교차로 X = (0, 3) 에 도착해서 교차로 Y = (2, 3) 로 도망치고 싶어한다. 이때 만나는 웜뱃 마릿수의 최솟값은 7 인데, 또 점선을 따라가면 이를 확인할 수 있다.</li>
	<li><code>change</code> 이벤트가 두 번 발생한다. 수직 도로 0 의 가장 위 세그먼트에 있는 웜뱃의 수가 5 마리로 바뀌고, 수평 도로 1 의 가운데 세그먼트에 있는 웜뱃의 수가 6 마리로 바뀐다. 아래 그림의 동그라미를 친 숫자를 확인해보자.</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/6188923b-c6b6-425a-8df0-637db4979c29/-/preview/" style="width: 279px; height: 206px;"></p>

<p>세 번째 사람이 교차로 A = (0, 2) 에 도착해서 교차로 B = (2, 1) 로 도망치고 싶어한다. 이번에는 만나게 되는 웜뱃의 최소 숫자가 5 마리이고, 다시 점선을 따라가면 이를 확인할 수 있다.</p>

<p>도로의 모양과 각 도로 위의 웜뱃의 수가 주어진다. 그 다음 이벤트가 발생한 순서대로 주어졌을 때, 이를 처리하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수평 도로의 수 R과 수직 도로의 수 C가 주어진다. &nbsp;(2 ≤ R ≤ 5,000, 1 ≤ C ≤ 200)</p>

<p>둘째 줄부터 R+1번째 줄에는 H[i][j]가 주어진다. 각 줄에 주어지는 숫자는 총 C-1개이며, H[i][0]부터 H[i][C-2]까지다. H[i][j]는 교차로 (i,j)와 (i,j+1) 사이의 수평 도로 세그먼트 상의 웜뱃의 마릿수를 나타낸다.</p>

<p>R+2번째 줄부터 2R번째 줄에는 V[i][j]가 주어진다. 각 줄에 주어니는 숫자는 총 C개이며, V[i][0]부터 V[i][C-1]까지다. V[i][j]는 교차로 (i,j)와 (i+1,j) 사이의 수직 도로 세그먼트 상의 웜뱃의 마릿수를 나타낸다.</p>

<p>다음 줄에는 발생하는 이벤트의 수 E가 주어진다.</p>

<p>다음 E개 줄에는 이벤트가 발생하는 순서대로 한 줄마다 이벤트가 하나씩 주어진다.</p>

<p>교차로 (P,Q)와 (P,Q+1)사이의 수평 도로 세그먼트 위의 웜뱃의 마릿수를 바꾸는 이벤트는 "1 P Q W" 형식으로 주어진다. (0 ≤ P ≤ R-1, 0 ≤ Q ≤ C-2, 0 ≤ W ≤ 1,000)</p>

<p>교차로 (P,Q)와 (P+1,Q)사이의 수직 도로 세그먼트 위의 웜뱃의 마릿수를 바꾸는 이벤트는 "2 P Q W" 형식으로 주어진다. (0 ≤ P ≤ R-2, 0 ≤ Q ≤ C-1, 0 ≤ W ≤ 1,000)</p>

<p>교차로 (0,V1)에서 (R-1,V2)로 지나갈 때 만나는 웜뱃 마릿수의 최솟값을 구하는 이벤트는 "3 V1 V2" 형식으로 주어진다. (0 ≤ V1 ≤ C-1, 0 ≤ V2 ≤ C-1)</p>

<p>1번과 2번 이벤트는 합쳐서 최대 500번 발생하며, 3번은 최대 200,000번 발생한다. 한 세그먼트에 있는 웜뱃의 마릿수는 항상 1,000 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 이벤트가 발생할 때 마다, 교차로 (0, V1)에서 (R-1, V2)로 지나갈 때 만나는 웜뱃 마릿수의 최솟값을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
0 2 5
7 1 1
0 4 0
0 0 0 2
0 3 4 7
5
3 2 1
3 3 3
2 0 0 5
1 1 1 6
3 2 1
','2
7
5
','DATA_STRUCTURE'),
                                                                                                                (6901,'BAEKJOON','https://www.acmicpc.net/problem/8875',8875,'장난감 정리 로봇','5초','64 MB',20,'<p>마리타의 남동생은 모든 장난감을 거실 바닥에 어질러놓았다! 다행히도 마리타는 장난감을 정리하는 특별한 로봇들을 개발하였다. 마리타는 어떤 로봇이 어떤 장난감을 집어야 하는지 결정하도록 당신에게 도움을 청했다.</p>

<p>장난감은 총 T 개가 있으며, 각각은 정수 무게 W[i] 와 정수 크기 S[i] 를 가진다. 로봇들은 연약한 로봇과 작은 로봇 두 가지 종류가 있다.</p>

<p>연약한 로봇은 총 A 개가 있다. 각 연약한 로봇에는 무게 제한 X[i] 가 있어서, X[i] 미만의 무게를 가진 장난감만을 운반할 수 있다. 장난감의 크기는 상관없다.</p>

<p>작은 로봇은 총 B 개가 있다. 각 작은 로봇에는 크기 제한 Y[i] 가 있어서, Y[i] 미만의 크기를 가진 장난감만을 운반할 수 있다. 장난감의 무게는 상관없다.</p>

<p>마리타의 로봇들 각각은 하나의 장난감을 정리하는 데 1분이 걸린다. 여러 로봇들이 서로 다른 장난감들을 동시에 정리할 수 있다.</p>

<p>당신의 임무는 마리타의 로봇들이 모든 장난감들을 정리할 수 있는지 결정하고, 만약 가능하다면, 모든 장난감을 정리하는데 걸리는 가장 짧은 시간을 찾는 것이다.</p>

<p>첫 번째 예시로, 무게 제한 X = [6, 2, 9] 를 가진 A = 3 개의 연약한 로봇과 크기 제한 Y = [4, 7] 을 가진 B = 2 개의 작은 로봇이 있고, T = 10 개의 장난감이 아래와 같이 있다고 하자:</p>

<table class="table table-bordered" style="width:45%">
	<thead>
		<tr>
			<th style="width:15%">장난감 번호</th>
			<th style="width:3%">0</th>
			<th style="width:3%">1</th>
			<th style="width:3%">2</th>
			<th style="width:3%">3</th>
			<th style="width:3%">4</th>
			<th style="width:3%">5</th>
			<th style="width:3%">6</th>
			<th style="width:3%">7</th>
			<th style="width:3%">8</th>
			<th style="width:3%">9</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>무게</th>
			<td>4</td>
			<td>8</td>
			<td>2</td>
			<td>7</td>
			<td>1</td>
			<td>5</td>
			<td>3</td>
			<td>8</td>
			<td>7</td>
			<td>10</td>
		</tr>
		<tr>
			<th>크기</th>
			<td>6</td>
			<td>5</td>
			<td>3</td>
			<td>9</td>
			<td>8</td>
			<td>1</td>
			<td>3</td>
			<td>7</td>
			<td>6</td>
			<td>5</td>
		</tr>
	</tbody>
</table>

<p>모든 장난감들을 정리하는 데 걸리는 가장 짧은 시간은 3분이다:</p>

<table class="table table-bordered" style="width:85%">
	<thead>
		<tr>
			<th style="width:10%">&nbsp;</th>
			<th style="width:15%">연약한 로봇 0</th>
			<th style="width:15%">연약한 로봇 1</th>
			<th style="width:15%">연약한 로봇 2</th>
			<th style="width:15%">작은 로봇 0</th>
			<th style="width:15%">작은 로봇 1</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>1분째</th>
			<td>장난감 0</td>
			<td>장난감 4</td>
			<td>장난감 1</td>
			<td>장난감 6</td>
			<td>장난감 2</td>
		</tr>
		<tr>
			<th>2분째</th>
			<td>장난감 5</td>
			<td>&nbsp;</td>
			<td>장난감 3</td>
			<td>&nbsp;</td>
			<td>장난감 8</td>
		</tr>
		<tr>
			<th>3분째</th>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>장난감 7</td>
			<td>&nbsp;</td>
			<td>장난감 9</td>
		</tr>
	</tbody>
</table>

<p>두 번째 예시로, 무게 제한 X = [2, 5] 를 가진 A = 2 개의 연약한 로봇과 크기 제한 Y = [2] 를 가진 B = 1 개의 작은 로봇이 있고, T = 3 개의 장난감이 아래와 같이 있다고 하자</p>

<table class="table table-bordered" style="width:24%">
	<thead>
		<tr>
			<th style="width:15%">장난감 번호</th>
			<th style="width:3%">0</th>
			<th style="width:3%">1</th>
			<th style="width:3%">2</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>무게</th>
			<td>3</td>
			<td>5</td>
			<td>2</td>
		</tr>
		<tr>
			<th>크기</th>
			<td>1</td>
			<td>3</td>
			<td>2</td>
		</tr>
	</tbody>
</table>

<p>어떤 로봇도 무게 5, 크기 3짜리의 장난감을 정리할 수 없기 때문에, 모든 장난감들을 치우는 것은 불가능하다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 연약한 로봇의 개수 A, 작은 로봇의 개수 B, 장난감의 개수 T가 주어진다.</p>

<p>둘째 줄에는 각 연약한 로봇의 무게 제한을 나타내는 길이가 A인 배열이 주어진다.</p>

<p>셋째 줄에는 각 작은 로봇의 크기 제한을 나타나는 길이가 B인 배열이 주어진다.</p>

<p>다음 T개 줄에는 각 장난감의 무게 W[i]와 크기 S[i]가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 장난감을 정리하는데 걸리는 가장 짧은 시간(분)을 출력한다. 만약 정리하는 것이 불가능하다면, -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 2 10
6 2 9
4 7
4 6
8 5
2 3
7 9
1 8
5 1
3 3
8 7
7 6
10 5
','3
','DATA_STRUCTURE'),
                                                                                                                (6903,'BAEKJOON','https://www.acmicpc.net/problem/8876',8876,'바자와 샤자','13초','230 MB',22,'<p>두 사람 바자(Bazza)와 샤자(Shazza)가 다음 게임을 하고 있다. 게임판은 셀로 이루어진 그리드로 되어 있고, R 개의 행이 차례로 번호가 0, …, R - 1 로 매겨져 있고 C 개의 열이 차례로 번호가 0, …, C - 1 로 매겨져 있다. (P, Q) 는 행 P , 열 Q 에 있는 셀을 나타낸다. 각 셀에는 음이 아닌 정수가 쓰여 있고, 게임이 시작될 때 모든 셀의 값은 0이다.</p>

<p>이 게임은 다음과 같이 진행된다. 게임 진행 중에, 바자는 다음 두 가지 중 하나를 할 수 있다.</p>

<ul>
	<li>셀 (P, Q) 의 값을 업데이트한다. 즉, 이 셀에 쓰여진 정수를 바꾼다.</li>
	<li>샤자에게 주어진 직사각형 모양의 셀들 안의 모든 정수들의 (직사각형의 마주보는 양 모퉁이 (P, Q) , (U, V) 를 포함) 최대공약수(GCD)를 계산하도록 요청한다.</li>
</ul>

<p>바자는 최대 N<sub>U</sub> + N<sub>Q</sub> 번 위와 같은 일을 (셀의 값을 N<sub>U</sub> 번 업데이트하고 N<sub>Q</sub> 번 질의을 함) 한 다음에는 지루해서 크리켓을 하러 간다.</p>

<p>당신의 임무는 정답을 구하는 것이다.</p>

<p>R = 2 이고 C = 3 이라고 하고, 바자가 다음과 같이 업데이트를 한다고 하자.</p>

<ul>
	<li>셀 (0, 0) 을 20으로 업데이트</li>
	<li>셀 (0, 2) 를 15로 업데이트</li>
	<li>셀 (1, 1) 을 12로 업데이트</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/31472158-f1aa-4904-8a79-28348667c2dc/-/preview/" style="width: 115px; height: 80px;"></p>

<p>이 결과는 위 그림과 같다. 그리고 바자는 다음 직사각형에 대해 최대공약수가 무엇인지 질의한다.</p>

<ul>
	<li>양 모퉁이 (0, 0) , (0, 2) : 이 직사각형 안의 세 정수는 20, 0, 15이고 최대공약수는 5이다.</li>
	<li>양 모퉁이 (0, 0) , (1, 1) : 이 직사각형 안의 네 정수는 20, 0, 0, 12이고 최대공약수는 4이다.</li>
</ul>

<p>바자가 다음과 같이 업데이트를 했다고 하자</p>

<ul>
	<li>셀 (0, 1) 을 6으로 업데이트</li>
	<li>셀 (1, 1) 을 14로 업데이트</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/aacc6656-4c4b-4ec3-a2a0-bc2e9ccbad3f/-/preview/" style="width: 115px; height: 80px;"></p>

<p>새로운 그리드는 위 그림과 같다. 그리고, 바자는 다음 직사각형에 대해서 다시 최대공약수 GCD 를 질의한다.</p>

<ul>
	<li>양 모퉁이 (0, 0) , (0, 2) : 이 직사각형 안의 세 정수는 이제 20, 6, 15이고 최대공약수는 1이다.</li>
	<li>양 모퉁이 (0, 0) , (1, 1) : 이 직사각형 안의 네 정수는 20, 6, 0, 14이고 최대공약수는 2이다.</li>
</ul>

<p>여기까지 바자가 한 업데이트는 N<sub>U</sub> = 5 회, 질의는 N<sub>Q</sub> = 4 회이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 행의 개수 R, 열의 개수 C, 일의 개수 N이 주어진다. (1 ≤ R, C ≤ 10<sup>9</sup>)</p>

<p>다음 N개 줄에는 일이 발생하는 순서대로 한 줄마다 일 하나씩 주어진다. (N<sub>U</sub> ≤ 22,000, N<sub>Q</sub> ≤ 250,000)</p>

<p>바자가 어떤 셀의 숫자를 바꾸는 일은 1 P Q K로 주어진다. (0 ≤ P ≤ R-1, 0 ≤ Q ≤ C-1, 0 ≤ K ≤ 10<sup>18</sup>)</p>

<p>어떤 직사각형 내의 최대공약수를 구하는 일은 2 P Q U V로 주어진다. (0 ≤ P ≤ U ≤ R-1, 0 ≤ Q ≤ V ≤ C-1) (P, Q)와 (U, V)를 모퉁이로 하는 직사각형 내에 포함된 모든 숫자들의 최대공약수를 계산하여야 한다. 이 직사각형의 범위는 테두리를 포함한다. 즉, (P, Q) 와 (U, V) 가 포함되어 있어야 한다.</p>

<p>직사각형 범위 내에 모든 숫자가 0인 경우에는, 최대공약수는 0이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>직사각형 내의 모든 숫자들의 최대공약수를 일이 주어질 때 마다, 최대공약수를 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 3 9
1 0 0 20
1 0 2 15
1 1 1 12
2 0 0 0 2
2 0 0 1 1
1 0 1 6
1 1 1 14
2 0 0 0 2
2 0 0 1 1
','5
4
1
2
','DATA_STRUCTURE'),
                                                                                                                (6909,'BAEKJOON','https://www.acmicpc.net/problem/8889',8889,'등고선 지도','3초','128 MB',19,'<p>한려해상국립공원은 한반도의 남쪽에 있으며, 120km에 걸친 독특한 해양 생태계를 가지고 있다. 공원은 360개 이상의 섬으로 이루어져 있으며, 섬의 크기도 모두 제각각 다르다. 69개의 무인도와 30개의 유인도로 이루어진 아름다운 수로는 바다의 보석과 같다는 찬사를 받는다.</p>

<p>공원 관리자 김상근은 등고선을 이용해 공원 내의 모든 섬의 고도를 조사하려고 한다. 등고선은 해발 고도가 같은 지점을 연결한 곡선이며, 볼록한 닫힌 곡선이다. (그림 1)</p>

<p>한려해상국립공원의 섬을 나타내는 등고선은 서로 겹치지 않으며, 타원과 같은 단순 볼록 곡선이며 닫혀있다.&nbsp;</p>

<p>컴퓨터는 등고선 지도를 디지털 등고선 지도로 변형해서 사용한다. 디지털 등고선 지도의 등고선은 볼록 직교 다각형 (그림 2) 이다. 직교 다각형이란 모든 변이 수직 또는 수평인 다각형이다. 직교 다각형 P가 볼록이 되려면, P의 모든 내부와 수직선 또는 수평선과의 교점이 비어있거나 선분이어야 한다.</p>

<p>가장 바깥에 있는 등고선은 레벨 1이다. 등고선 c를 둘러싼 등고선의 레벨이 k인 경우에 c의 레벨은 k+1이다. 그림 2에의 지도에서 가장 높은 등고선의 레벨은 5이다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/cantour2.png" style="height: 158.333px; width: 372.5px;"></p>

<p>등고선 n개로 이루어진 디지털 등고선 지도가 주어진다. 이때, 가장 높은 등고선의 레벨을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 등고선의 개수 m(1 ≤ m ≤ 20,000)이 주어진다. 다음 m개 줄에는 각 등고선의 정보를 나타내는 2k+1개의 정수 k, x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, ..., x<sub>k</sub>, y<sub>k</sub> (4 ≤ k ≤ 100, 1 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 10<sup>9</sup>) 가 주어진다. k는 볼록 직교 다각형 Q의 꼭짓점의 개수를 나타내며, (x<sub>i</sub>, y<sub>i</sub>)는 Q의 꼭짓점을 나타낸다. 꼭짓점은 반시계방향으로 주어진다. 두 볼록 직교 다각형이 겹치는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 가장 높은 등고선의 레벨을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p><img alt="" src=https://www.acmicpc.net/upload/images/cantour3.png" style="height:227px; width:593px"></p>

				</div>
				</div>','2
5
4 5 3 14 3 14 12 5 12
4 6 4 13 4 13 11 6 11
4 7 5 12 5 12 10 7 10
4 8 6 11 6 11 9 8 9
4 9 7 10 7 10 8 9 8
4
4 10 7 11 7 11 8 10 8
6 3 7 5 7 5 9 6 9 6 12 3 12
6 8 5 9 5 9 6 12 6 12 9 8 9
10 9 2 9 3 14 3 14 11 7 11 7 8 6 8 6 4 4 4 4 2
','5
3
','DATA_STRUCTURE'),
                                                                                                                (6907,'BAEKJOON','https://www.acmicpc.net/problem/8925',8925,'GC-비율','2초','128 MB',20,'<p>DNA 수열은 A, C, G, T로 이루어져 있다. DNA 수열의 GC-비율은 C와 G의 개수를 수열의 길이로 나눈 값이다. GC-비율이 높은 구간은 유전자의 시작 구간이 될 확률이 높다. 따라서, GC-비율은 매우 중요하다.</p>

<p>매우 긴 DNA 수열에서 수열의 모든 부분 수열 중에서 GC-비율이 가장 큰 부분 수열을 찾는 연구가 활발히 진행중이다. GC-비율이 높은 짧은 부분 수열은 의미없는 경우가 많기 때문에, 길이의 하한(lower bound)을 정해두고 부분 수열을 찾는다.</p>

<p>DNA 수열에서 모든 A와 T를 0으로, C와 G를 1로 바꿔서 길이가 같은 이진수열을 만들 수 있다. 이렇게 만든 이진수열의 평균값은 DNA 수열의 GC-비율과 같아진다.</p>

<table class="table table-bordered" style="width:100%">
	<thead>
		<tr>
			<th>인덱스</th>
			<th>1</th>
			<th>2</th>
			<th>3</th>
			<th>4</th>
			<th>5</th>
			<th>6</th>
			<th>7</th>
			<th>8</th>
			<th>9</th>
			<th>10</th>
			<th>11</th>
			<th>12</th>
			<th>13</th>
			<th>14</th>
			<th>15</th>
			<th>16</th>
			<th>17</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>수열</th>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
		</tr>
	</tbody>
</table>

<p>이진수열이 위와 같이 주어을 때, 길이의 하한이 7이라면 평균이 최대인 부분 수열은 [7,14]가 되고, 평균은 6/8이다. 하한이 5인 경우, 평균이 최대인 부분 수열은 [7,11]이 되고, 평균은 4/5가 된다.</p>

<p>이진수열과 길이의 하한 L이 주어졌을 때, 길이가 적어도 L인 모든 부분 수열 중에서 평균이 최대인 부분 수열을 찾는 프로그램을 작성하시오. 같은 평균을 가지는 부분 수열이 여러 개인 경우, 길이가 짧은 것을 찾으면 된다. 길이가 짧은 것이 여러 개인 경우에는, 시작 위치가 앞서는 것을 찾는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 이진수열의 길이 n(1 ≤ n ≤ 100,000)과 길이의 하한 L(1 ≤ L ≤ 1,000)이 주어진다. 다음 줄에는 길이가 n인 이진수열이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스 마다 부분 수열의 시작 위치와 끝 위치를 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
17 5
00101011011011010
20 4
11100111100111110000
','7 11
6 9
','DATA_STRUCTURE'),
                                                                                                                (6919,'BAEKJOON','https://www.acmicpc.net/problem/8985',8985,'수족관 2','1초','128 MB',19,'<p>아래 그림 1은 수족관을 앞에서 본 모양이다. 이 수족관에는 물이 가득 차 있다. 만약 수족관 밑바닥(수평선분)에 구멍을 하나 뚫으면, 구멍을 통해 수족관 안의 물이 빠지게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/4c0f1045-5150-455d-8a8e-f9f2c9fe9557/-/preview/" style="width: 264px; height: 210px;"></p>

<p style="text-align: center;">그림 1. 수족관과 구멍.</p>

<p>그림 1에서 보는 것처럼, X-축은 왼쪽에서 오른쪽으로 증가하고, Y-축은 위쪽에서 아래쪽으로 증가한다. 바닥을 나타내는 수평선분에 구멍이 있다면, 그 수평선분의 y-좌표와 같거나 작은 위치에 있으면서, 중력에 따라 구멍으로 흘러 들어갈 수 있는 위치에 있는 물은 모두 그 구멍을 통해 외부로 배출된다. 따라서 그림 1의 수족관의 물은 바닥의 구멍을 통해 남김없이 모두 빠진다.&nbsp;</p>

<p>수족관에 담긴 물의 양은 물이 차지하는 면적과 일치하는 양이다. 물의 양의 단위는 L(리터)이다. 따라서 그림 1에서 수족관에 물을 가득 채우면 물의 양은 물이 차지하는 면적과 동일한 40L이다.</p>

<p>하나의 구멍을 통해 1초당 1L의 물이 빠져나간다고 하자. 그러면, 그림 1의 경우에는 40초만에 물이 모두 빠진다.</p>

<p>그림 2처럼 수족관의 바닥이 복잡할 수도 있다.</p>

<p>수족관 바닥은 수평선분과 수직선분이 번갈아 나타나는 형태이다. 또한 아래 그림 2처럼 수족관 위에서 수직방향으로 수족관 바닥을 보았을 때, 수족관의 바닥이 모두 보이는 (즉, 모든 수평선분이 보이는) 형태이다.</p>

<p>수족관에는 하나 이상의 구멍이 존재하는데, 구멍은 수평선분에만 존재하며, 수평선분의 한 가운데에만 위치한다. 그리고 하나의 수평선분에는 최대 하나의 구멍만 존재할 수 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/55d1b6ae-0068-4d23-aee7-051fe344e6a4/-/preview/" style="width: 264px; height: 201px;"></p>

<p style="text-align: center;">그림 2. 수족관의 처음 상태. 물의 양은 26L이고 구멍은 2개.</p>

<p>그림 2에는 2개의 수평선분에 총 2개의 구멍(1번 구멍과 2번 구멍)이 뚫려 있다. 처음 물의 양은 26L이다. 2개의 구멍을 통해, 0초부터 물을 빼기 시작하면 몇 초 후부터 더 이상 물이 빠지지 않게 될까?</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/f9f32a40-9eba-4841-bab3-00831dfe1c44/-/preview/" style="width: 257px; height: 182px;"></p>

<p style="text-align: center;">그림 3. 물이 빠진 중간 상태.</p>

<p>우선, 1번 구멍이 놓인 수평선분의 위쪽 부분에 있는 물 16L가 1번 구멍과 2번 구멍을 통해 동시에 빠져 나가게 된다. 16L가 두 개의 구멍을 통해 배출되므로, 8초 후에는 그림 3과 같은 상태가 된다.&nbsp;</p>

<p>이후에는 3L의 물이 2번 구멍을 통해 3초 동안 배출된다. 결국, 8초+3초 = 11초 동안 물이 배출되고, 그 이후에는 더 이상 배출되지 않는다. 11초 후에 남은 물의 양은 7L이며, 최종 상태는 그림 4와 같다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/e0e15021-56ab-4923-af94-5f7e0799d77b/-/preview/" style="width: 270px; height: 189px;"></p>

<p style="text-align: center;">그림 4. 최종 상태.</p>

<p>물이 가득 찬 수족관 바닥의 모양과 구멍이 뚫려 있는 수평선분들이 입력으로 주어지면, 물이 빠지는 데 걸리는 시간(초)과 남은 물의 양을 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄은 수족관의 경계를 구성하는 꼭짓점의 개수 N (4 ≤ N ≤ 300,000)이 주어진다. N은 짝수이다. 수족관의 경계는 항상 꼭짓점 (0, 0)부터 시작한다. 그리고 마지막 꼭짓점은 (A, 0)의 형태로 끝난다. 즉, 시작 꼭짓점과 마지막 꼭짓점의 y-좌표는 항상 0이다. 모든 꼭짓점의 좌표 값은 0 이상 500,000 이하의 정수이다. 수족관의 경계를 이루는 변은 꼭짓점 (0, 0)부터 시작하는 데, 수직선분으로 시작하여 수평선분과 수직선분이 번갈아가며 반복되다 수직선분으로 끝난다. 따라서 수직선분이 수평선분보다 항상 하나 더 많다. 두 번째 줄부터 N개의 줄에는 수족관 경계에 있는 N개의 꼭짓점의 x-좌표와 y-좌표 값이 빈칸을 사이에 두고 각 줄에 하나씩, 첫 꼭짓점 (0, 0)부터 시계반대방향을 따라 차례로 주어진다. 다음 줄에는 수족관의 수평선분에 위치한 구멍의 개수 K (1 ≤ K ≤ N/2)가 자연수로 주어진다. 다음 K개의 줄에는 각 구멍이 존재하는 수평선분의 양 끝 꼭짓점의 x-좌표와 y-좌표 값이 빈 칸을 사이에 두고 차례로 주어진다. 즉, 어떤 구멍이 위치한 수평선분의 정보가 a b c b로 주어졌다면, 구멍이 위치한 수평선분은 꼭짓점 (a, b)와 꼭짓점 (c, b)를 연결한 선분이라는 의미이다. 항상 a < c이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 두 줄이다. 첫 줄에는 구멍을 통해 물이 빠져나가는 데 걸리는 시간(초)을 소수점 이하 셋째자리에서 반올림 하여 둘째자리까지만 출력한다. 둘째 줄에는 남은 물의 양을 0 이상의 정수로 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>중간 계산 결과 값이 32비트 정수형 범위를 벗어날 수 있으니 필요하면 64비트 정수형을 이용할 것을 권장한다. 실수형은 double형을 사용할 것을 권장한다.</p>

				</div>
				</div>','4
0 0
0 5
8 5
8 0
1
0 5 8 5
','40.00
0
','DATA_STRUCTURE'),
                                                                                                                (6920,'BAEKJOON','https://www.acmicpc.net/problem/8987',8987,'수족관 3','1초','128 MB',22,'<p>아래 그림 1은 수족관을 앞에서 본 모양이다. 이 수족관에는 물이 가득 차 있다. 만약 수족관 밑바닥(수평선분)에 구멍을 하나 뚫으면, 구멍을 통해 수족관 안의 물이 빠지게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/4c0f1045-5150-455d-8a8e-f9f2c9fe9557/-/preview/" style="width: 264px; height: 210px;"></p>

<p style="text-align: center;">그림 1. 수족관과 구멍.</p>

<p>그림 1에서 보는 것처럼, X-축은 왼쪽에서 오른쪽으로 증가하고, Y-축은 위쪽에서 아래쪽으로 증가한다. 바닥을 나타내는 수평선분에 구멍이 있다면, 그 수평선분의 y-좌표와 같거나 작은 위치에 있으면서, 중력에 따라 구멍으로 흘러 들어갈 수 있는 위치에 있는 물은 모두 그 구멍을 통해 외부로 배출된다. 따라서 그림 1의 수족관의 물은 남김없이 모두 빠진다.</p>

<p>수족관에 담긴 물의 양은 물이 차지하는 면적과 일치하는 양이다. 물의 양의 단위는 L(리터)이다. 따라서 그림 1에서 수족관에 물을 가득 채우면 물의 양은 물이 차지하는 면적과 동일한 40L이다.</p>

<p>그림 2처럼 수족관의 바닥이 복잡할 수도 있다.&nbsp;</p>

<p>수족관 바닥은 수평선분과 수직선분이 번갈아 나타나는 형태이다. 또한 그림 2처럼 수족관 위에서 수직방향으로 수족관 바닥을 보았을 때, 수족관의 바닥이 모두 보이는 (즉, 모든 수평선분이 보이는) 형태이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/55d1b6ae-0068-4d23-aee7-051fe344e6a4/-/preview/" style="width: 264px; height: 201px;"></p>

<p style="text-align: center;">그림 2. 수족관의 처음 상태. 물의 양은 26L이고 구멍은 2개.</p>

<p>구멍은 항상 수평선분에만 존재하며, 수평선분의 한 가운데에 위치한다. 그리고 하나의 수평선분에는 최대 하나의 구멍만 존재할 수 있다.&nbsp;</p>

<p>이제 2개의 구멍을 수평선분 2개에 배치해 보자. 이때, 배출되는 물의 양이 최대가 되도록 배치해야 한다. 만약, 그림 3처럼 2개의 구멍을 배치하면, 원래 물의 양인 26L 중에서 19L만 빠져나가고 7L는 남게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/e0e15021-56ab-4923-af94-5f7e0799d77b/-/preview/" style="width: 270px; height: 189px;"></p>

<p style="text-align: center;">그림 3. 19L가 빠져나가고 7L만 남음.</p>

<p>그러나 그림 4처럼 2개의 구멍을 배치하면, 1L만 남고 25L가 빠져나간다. 결국, 구멍을 2개 배치하는 경우에는 최대 25L의 물을 뺄 수 있는 구멍의 배치가 존재하게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/6b94b4cd-f176-4297-a212-ed3281891def/-/preview/" style="width: 262px; height: 183px;"></p>

<p style="text-align: center;">그림 4. 25L가 빠져나가고 1L만 남음.</p>

<p>최대한 많은 양의 물이 배출되도록 K개의 구멍을 배치한다고 할 때, 배출되는 최대 물의 양을 출력하는 프로그램을 작성하시오.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄은 수족관의 경계에 있는 꼭짓점의 개수 N(4 ≤ N ≤ 300,000)이 주어진다. N은 짝수이다. 수족관의 경계는 항상 꼭짓점 (0, 0)부터 시작한다. 그리고 마지막 꼭짓점은 (A, 0)의 형태로 끝난다. 즉, 시작 꼭짓점과 마지막 꼭짓점의 Y-좌표는 항상 0이다. 모든 꼭짓점의 좌표 값은 0 이상 1,000,000,000 이하의 정수이다. 수족관의 경계를 이루는 변은 꼭짓점 (0, 0)부터 시작하는 데, 수직선분으로 시작하여 수평선분과 수직선분이 번갈아가며 반복되다 수직선분으로 끝난다. 따라서 수직선분이 수평선분보다 항상 하나 더 많다. 두 번째 줄부터 N개의 줄에는 수족관 경계에 있는 N개의 꼭짓점의 x-좌표와 y-좌표 값이 빈칸을 사이에 두고 각 줄에 하나씩, 첫 꼭짓점 (0, 0)부터 시계반대방향을 따라 차례로 주어진다. 다음 줄에는 뚫어야 할 구멍의 개수 K (1 ≤ K ≤ N/2)가 자연수로 주어진다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 단 한 줄이다. 최대한 많은 양의 물을 배출하도록 K개의 구멍을 배치한다고 할 때, 배출되는 최대 물의 양을 0 이상의 정수로 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>중간 계산 결과 또는 출력 값이 32비트 정수형 범위를 벗어날 수 있으니 64비트 정수형을 이용할 것을 권장한다.</p>

				</div>
				</div>','4
0 0
0 5
8 5
8 0
1
','40
','DATA_STRUCTURE'),
                                                                                                                (6918,'BAEKJOON','https://www.acmicpc.net/problem/9015',9015,'정사각형','10초','256 MB',15,'<p>평면 위에 N개의 점이 주어졌을 때, 가장 큰 정사각형의 넓이를 구하여라.</p>

<p style="text-align: center;"><img alt="" src=https://www.acmicpc.net/upload/images2/square.png" style="font-size:medium; height:195px; text-align:center; width:192px"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트케이스의 개수 T가 주어진다.</p>

<p>각 테스트케이스의 첫째 줄에는 점의 개수 N(4 ≤ n ≤ 3,000)이 주어지고,&nbsp;이어서 N개의 줄에는 점의 x좌표와 y좌표가 주어진다.&nbsp;모든 좌표는&nbsp;-10000 이상&nbsp;+10000이하의 정수이다. 같은 위치의 점이 여러 번 주어지는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 가장 큰 정사각형의 넓이를 한 줄에 하나씩 출력한다. 단, 정사각형이 없는 경우 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
10
5 2
10 2
7 4
2 5
8 5
5 7
6 7
10 7
8 9
3 10
','26
','DATA_STRUCTURE'),
                                                                                                                (6914,'BAEKJOON','https://www.acmicpc.net/problem/9034',9034,'순위','3초','128 MB',18,'<p>프로 게이머 협회는 등록된 N 명의 선수들에 대한 순위를 유지한다. 선수들의 순위는 게임을 치를 때마다 얻는 점수에 의해 결정된다. 점수를 누적한 값은 랭킹 포인트가 되고, 랭킹 포인트가 높을수록 순위도 높다. 가장 높은 랭킹 포인트를 가진 선수(들)은 순위가 1 이다. 나머지 선수의 순위는 자신보다 한 단계 높은 랭킹 포인트를 가진 선수(들)의 순위에다 해당 선수들의 수를 더한 값이다. 선수들을 1 부터 N 까지의 번호로 구분하자. 예를 들어, N=5 명의 현재 랭킹 포인트가 1 번 선수부터 차례대로 (10, 15, 20, 8, 12) 라고 하면, 선수들의 순위는 차례대로 (4, 2, 1, 5, 3) 이다. 이제 어떤 대회를 통해 일부 선수들이 다음과 같은 점수를 얻었다고 하자. 각 쌍은 (선수 번호, 획득한 점수)이다.</p>

<p style="text-align: center;">(1, 25), (2, 20), (5, 10)</p>

<p>대회가 종료된 후, 선수들의 기존 랭킹 포인트에 새로 획득한 점수가 더해진 랭킹 포인트는 각각 (35, 35, 20, 8, 22)가 된다. 따라서 선수들의 순위는 이제 (1, 1, 4, 5, 3) 이다.</p>

<p>협회에서는 선수들의 게임 결과를 수시로 발표한다. 발표된 결과를 바탕으로 선수들의 순위 정보를 구하여 어떤 시점에 주어진 선수의 현재 순위를 출력하는 질의를 처리할 수 있는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 표준입력(standard input)을 통해 받아들인다. 입력의 첫 줄에는 테스트 케이스의 개수 T (1 ≤ T ≤ 20)가 주어진다. 각 테스트케이스의 첫 줄에는 선수들의 수를 나타내는 정수 N (1 ≤ N ≤ 100,000)이 주어진다. 선수들은 1 부터 N 까지의 번호로 구분된다. 둘째 줄에는 선수들의 게임 결과와 질의의 총 개수를 나타내는 정수 M (1 ≤ M ≤ 200,000)이 주어진다. 셋째 줄부터 M 개의 줄에는 선수의 게임 결과(획득한 점수) 또는 질의가 각 줄에 하나씩 주어진다. 각 줄의 내용은 "R j k" 또는 "Q j"이다. "R j k"는 선수 j 가 획득한 점수가 k 임을 나타내고, "Q j"는 선수 j 의 순위를 묻는 질의이다. 여기서 k 는 1 이상의 정수이다. 질의에 대한 답은 질의가 나온 시점까지 획득한 점수들을 누적한 랭킹 포인트에 의한 순위를 말한다. 각 테스트 케이스의 초기 랭킹 포인트는 모두 0 이라고 가정하고, 입력을 통해서 누적된 최종 랭킹 포인트는 어떤 선수도 1,000,000,000 을 넘지 않는다고 가정하라.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 표준출력(standard output)을 통하여 출력한다. 각 테스트케이스의 각 질의에 대해 순서대로 한 줄에 하나씩 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
3
5
R 2 11
Q 3
R 3 16
R 1 15
Q 1
5
13
R 1 10
R 2 15
Q 3
R 3 20
Q 1
R 4 8
R 5 12
R 1 25
Q 1
R 2 20
R 5 10
Q 3
Q 5
','2
2
3
3
1
4
3
','DATA_STRUCTURE'),
                                                                                                                (6910,'BAEKJOON','https://www.acmicpc.net/problem/9208',9208,'링월드','2초','128 MB',23,'<p>링월드는 반지모양으로 이루어진 나라이다. 이 나라에는 도시가 m개 있고, 편의상 0, 1, 2, ... m-1로 번호가 매겨져 있다. 이 도시는 반지모양을 이루고 있으며, 0, 1, 2, m-1, 그리고 다시 0 순서이다.</p>

<p>연속된 도시의 구간 n개가 주어진다. 각 구간은 도시 x에서 시작하며, x, x+1, x+2, ..., y 까지 도시를 포함한다. m = 5인 경우에 [3, 4, 0], [1], [2,3,4], [3,4,0,1,2]는 모두 올바른 도시 구간이다.</p>

<p>각 구간에서 도시를 하나씩 고르려고 한다. 한 도시가 두 구간에서 선택될 수 없다. 즉, 한 구간에서 도시 i를 골랐으면, 다른 구간에서는 도시 i를 고를 수 없다. 각 구간에서 도시를 하나씩 고르는 것이 가능한지 불가능한지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 1 ≤ T ≤ 20가 주어진다.</p>

<p>각 테스트 케이스의 첫째 줄에는 도시의 수 1 ≤ m ≤ 10<sup>9</sup> 과 구간의 수 1 ≤ n ≤ 10<sup>5</sup>이 주어진다.</p>

<p>다음 n개 줄에는 구간의 시작 도시 x<sub>i</sub>와 끝 도시 y<sub>i</sub>가 주어지며, 구간 [x<sub>i</sub>, x<sub>i</sub> + 1 mod m, ..., y<sub>i</sub>]를 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 각 구간별로 서로 다른 도시를 선택하는 것이 가능하면 YES, 불가능하면 NO를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3 3
0 1
1 2
2 0
200000 3
100000 100000
100001 100001
100000 100001
6 6
0 1
1 2
2 3
3 4
4 5
5 0
6 6
0 0
1 2
2 3
4 4
4 5
5 0
','YES
NO
YES
NO
','DATA_STRUCTURE'),
                                                                                                                (6912,'BAEKJOON','https://www.acmicpc.net/problem/9238',9238,'당근 볶기','1초','128 MB',19,'<p>당근을 잘 볶으려면 당근의 크기를 모두 비슷하게 만들고 볶아야 한다.&nbsp;</p>

<p>상근이는 당근 N개를 가지고 있다. 상근이는 한 번에 당근 하나를 칼로 두 조각으로 낼 수 있다. 즉, 무게가 w인 당근을 잘라서 무게가 w<sub>left</sub>와 w<sub>right</sub>인 두 당근을 만들 수 있다. (w<sub>left</sub> + w<sub>right</sub> = w)&nbsp;</p>

<p>상근이는 칼질을 무서워하기 때문에, 칼질을 되도록 적게 하려고 한다.</p>

<p>당근의 무게가 주어졌을 때, 가장 가벼운 당근과 큰 무거운 당근의 무게의&nbsp;비율이 T를 넘기 위한 최소 칼질 횟수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 비율 T와 당근의 수 N이 주어진다. T는 소수점 둘째 자리까지 주어지며, 0.5 < T < 1을 만족한다. N은 양의 정수이며, &nbsp;N ≤ 1,000이다.</p>

<p>둘째 줄에는 당근의 무게 w<sub>1</sub>, w<sub>2</sub>, ..., w<sub>N</sub>이 주어진다. w<sub>i</sub>는 10<sup>6</sup>보다 작은 양의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가장 가벼운 당근과 가장 무거운 당근의 비율이 T를 넘기 위해 필요한 칼질의 최소 횟수를 출력한다. 정답은 항상 500보다 작다.</p>

<p>소수점 오차로 인해서 생기는 오답을 막기 위해 비율이 T + 0.0001라고 풀었을 때의 정답과 T라고 풀었을 때의 정답이&nbsp;같은 입력만 주어진다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','0.80 2
1000 1400
','3
','DATA_STRUCTURE'),
                                                                                                                (6922,'BAEKJOON','https://www.acmicpc.net/problem/9244',9244,'핀볼','1초','128 MB',22,'<p>선영이는 핀볼 중독자이다. 선영이는 항상 자신이 원하는 위치에 공을 맞출 수 있다. 하지만, 공이 범퍼에 많이 튕기기 때문에, 어디로 떨어질지는 정확하게 예측하지 못한다.</p>

<p>결국 선영이는 핀볼 테이블을 선분으로, 공을 높이가 무한대인 곳에서 떨어지는 점으로 모델링했다. 공은 선분을 만나기 전까지 수직으로 떨어지며, 선분을 만난 이후에는 선분의 아랫방향으로 공이 흘러간다.</p>

<p>선분의 끝점도 선분에 포함된다. 선분은 서로 교차하지 않으며, 선분의 끝점 또한 교차하지 않는다. 선분은 수직선이나 수평선이 아니다. 또, 입력으로 주어지는 순서에는 아무 의미가 없다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 선분의 개수 N이 주어진다. (0 ≤ N ≤ 100,000) 다음 N개 줄에는 선분의 양 끝점 좌표 x<sub>1</sub> y<sub>1</sub> x<sub>2</sub> y<sub>2</sub>가 주어진다. (-1,000,000 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 1,000,000) 마지막 줄에는 공의 맨 처음 x좌표 x<sub>0</sub>이 주어진다. (-1,000,000 ≤ x<sub>0</sub> ≤ 1,000,000) 모든 좌표는 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 공의 최종 위치 x좌표를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p><img alt="" src=https://www.acmicpc.net/upload/images/pinball.png"></p>

				</div>
				</div>','2
-1 1 1 -1
1 -2 2 -3
0
','2
','DATA_STRUCTURE'),
                                                                                                                (6923,'BAEKJOON','https://www.acmicpc.net/problem/9275',9275,'토끼와 상근','2초','128 MB',17,'<p>상근이는 지금 사악한 토끼들에게 위협받고 있다. 다행히도 상근이는 젊은 시절 편의점 아르바이트로 어마어마한 돈을 모은 덕분에 집에 초고성능&nbsp;감시카메라를 설치할 수가 있다. 이&nbsp;카메라는 매우 섬세하게 영상을 분석하여 몇 개의 점과 선으로 이루어진 영상을 전송해 준다. 하지만, 이 점과 선들로는 지금 집에&nbsp;토끼가 들어왔는지 안전한지의 여부를&nbsp;명확히 구분할 수가 없기&nbsp;때문에 상근이는 마음 놓고 잠을 잘 수가 없다.</p>

<p>상근이는 두 가지&nbsp;사실을 알고 있다. 모든 토끼는 네 개의 발을 갖고 있으며, 그 네 개의 발을 잇는 몸통으로 이루어져 있다는 것이다.</p>

<p>이제 상근이를 위해 감시 카메라가 포착한 영상에 토끼가 있을 가능성이 있는지를 판정하는 프로그램을 작성해주도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 테스트 케이스로 이루어져 있다.</p>

<p>테스트 케이스의&nbsp;첫 줄에는 두 정수 n과 m이 공백으로 구분되어 주어진다. (0 ≤ n ≤ 10 000, 0 ≤ m ≤ 20 000)</p>

<p>n은 영상에 등장한 점의 개수이며, m은 선의 개수이다.</p>

<p>다음 m줄엔 두 정수 x와 y가 주어진다.&nbsp;(1 ≤ x, y ≤ n)</p>

<p>이는 x번째 점과 y번째 점을 직접&nbsp;잇는 선분이 존재한다는 의미이다.</p>

<p>모든 테스트 케이스에 대해&nbsp;어떤 두 점도 두 개 이상의 선분으로 연결되어 있지 않으며, 어떤 점도 자기 자신과 연결되어 있지 않다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 입력에 대해, 만일 토끼가 존재할 가능성이 있다면 "YES" 를, 토끼가 없다면 "NO" 를 출력하면 된다. 만일 영상이 연결되어 있는 상태를 유지하며&nbsp;몇 개의 점과 선을 제거하고 정확히 4개의 발을 가진 몸통을 만들 수 있다면, 토끼는 존재할 수 있다.</p>

<p>영상이 연결되어 있다는 것은 모든 두 점이 하나 혹은 그 이상의 선을 통해 연결되어 있다는 것을 의미하며, 발이라는 것은&nbsp;정확히 하나의 다른 점과만 연결되며 단 하나의 선분으로 직접 연결되어 있는 한 점을 의미한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 1
1 2
5 4
1 2
1 3
1 4
1 5
','NO
YES
','DATA_STRUCTURE'),
                                                                                                                (6924,'BAEKJOON','https://www.acmicpc.net/problem/9281',9281,'전차','1초','256 MB',22,'<p>서울의 교통 정체를 해소하기 위해서 김상근 시장은 전차를 도입했다. 전차의 좌석은 N행 2열로 이루어진 격자 형태이다. 행은 1부터 N까지 번호가 매겨져 있고, 열은 1과 2로 번호가 매겨져 있다.</p>

<p>두 좌석 (R<sub>A</sub>, C<sub>A</sub>)와 (R<sub>B</sub>, C<sub>B</sub>) 사이의 거리는 각 정사각형의 중이 떨어진 거리로 \(\sqrt{(R_A-R_B)^{2}+(C_A-C_B)^{2}}\) 이다.</p>

<p>대부분의 사람들은 대중 교통을 이용할 때, 다른 승객들과 되도록 멀리 떨어져서 앉으려고 한다. 즉, 승객이 전차 안에 들어서면 각각의 빈 자리에 대해서 그 자리와 가장 가까운 사람이 앉아있는 자리와의 거리를 계산하고, 그 값이 가장 큰 자리에 앉게 된다. 그러한 자리가 여러개인 경우에는 행의 번호가 작은 자리에 앉고, 행의 번호가 작은 자리도 여러개라면 열의 번호가 작은 자리에 앉게 된다. 자리를 한 번 앉으면 열차에서 내릴때까지 계속 그 자리에 앉아있게 된다. 열차가 비어있는 경우에 탑승한 승객은 1행 1열 자리에 앉게 된다.</p>

<p>전차에 탑승한 승객의 하차한 승객의 정보가 주어진다. 이때, 각 승객이 어떤 자리에 앉는지 구하는 프로그램을 작성하시오.</p>

<p>정보는 총 M줄로 이루어져 있으며, 입력으로 주어진 순서대로 1번부터 M번이다. 총 두 종류의 정보가 존재하며, E는 전차에 탑승한 정보, L은 전차에서 하차한 정보이다. 하차한 정보가 주어질 때는, 몇 번째 정보에서 탑승한 손님인지도 함께 주어진다.</p>

<p>승객이 탑승하는 정보가 주어질 때는 빈 자리가 적어도 하나 있는 데이터만 입력으로 주어진다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 행의 수 N과 정보의 수 M이 주어진다. (1 ≤ N ≤ 150,000, 1 ≤ M ≤ 30,000) 다음 M개 줄에는 승객의 탑승 및 하차 정보가 주어진다. L이 주어진 경우에는 P<sub>K</sub> (1 ≤ P<sub>K</sub> ≤ K)가 함께 주어지며, P<sub>K</sub>번째 정보에서 탑승한 손님이 내린다는 뜻이다. 항상 P<sub>K</sub>번째 정보는 E이며, 한 승객이 두 번 내리는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>E가 입력으로 주어질 때 마다 그 승객이 앉은 자리를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 7
E
E
E
L 2
E
L 1
E
','1 1
3 2
1 2
3 1
1 1
','DATA_STRUCTURE'),
                                                                                                                (6925,'BAEKJOON','https://www.acmicpc.net/problem/9318',9318,'위성 사진','2초','256 MB',17,'<p>상근이는 위성 사진 여러장을 이용해서 지도를 만들고 있다. 위성에는 카메라가 달려있고, 카메라는 한 영역을 찍는다. 이러한 위성 사진 여러 장을 합치면, 큰 사진을 만들 수 있다.</p>

<p>위성 사진 여러 장이 주어졌을 때, 사진이 찍힌 영역의 넓이를 구하는 프로그램을 작성하시오. 사진은 모두 직사각형이다. 한 영역이 여러 사진에 찍혀있을 수도 있다. 이런 경우에 그 영역의 넓이는 한 번만 더해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스의 수는 100개를 넘지 않는다.</p>

<p>각 테스트 케이스의 첫째 줄에는 사진의 수 n (1 ≤ n ≤ 1000)이 주어진다. 다음 n개 줄에는 위성 사진의 남서쪽과 복동쪽 꼭짓점을 나타내는 네 정수 x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>가 주어진다. (0 ≤ x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub> ≤ 1,000,000, x<sub>1</sub> < x<sub>2</sub>, y<sub>1</sub> < y<sub>2</sub>) 모든 위성 사진은 직사각형이고, 다른 두 꼭짓점은 (x<sub>1</sub>, y<sub>2</sub>)와 (x<sub>2</sub>, y<sub>1</sub>) 이다.</p>

<p>모든 좌표는 이차원 평면 위에 있으며, 지구는 평면이라고 가정한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 위성 사진이 찍은 전체 영역의 넓이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
3
0 6 20 16
14 0 24 10
50 50 60 60
2
0 0 20 10
10 4 14 8
','376
200
','DATA_STRUCTURE'),
                                                                                                                (6927,'BAEKJOON','https://www.acmicpc.net/problem/9345',9345,'디지털 비디오 디스크(DVDs)','2초','256 MB',18,'<p>최근 유튜브와 같은 온라인 비디오 스트리밍 서비스 때문에 DVD 대여점들이 자취를 감추고 있다. 이러한 어려운 상황 속에서, DVD 대여점 주인들은 실낱같은 희망을 잡고자 인기있는 N개의 DVD들로 구성된 시리즈를 구매한다(각 DVD들은 0번부터 N-1 까지 이루어져 있다).</p>

<p>ACM 대여점의 주인 원주연&nbsp;또한 울며 겨자먹기로 인기있는 시리즈물을 구매했고, 진열을 하기 위해 맞춤형 선반을 주문제작 하였다(맟춤제작이기 때문에 선반의 번호 또한 0번부터 N-1 까지 이루어져 있다). 주연이는 매우 정갈한 사람이기 때문에&nbsp;DVD를 진열할 때&nbsp;i번 DVD는 i번&nbsp;선반에 진열을 한다.</p>

<p>이 시리즈의 열렬한 팬인 민호는 주연이네 대여점에&nbsp;시리즈가 입고되었다는 소식을 듣고 찾아왔다. 시리즈물은 연속으로 봐야 흥미가 안떨어지기 때문에 민호는 L번부터 R번까지의 DVD들을 빌리려고 한다. 민호는 주연이가 매우 정갈한 성격인 것임을 알기에 주연이를 믿고 실제 DVD들의 번호를 확인하지 않고 L번 선반부터 R번 선반까지 존재하는 DVD들을 들고 카운터에 가져왔다.</p>

<p>그러나, 민호는 간과한 사실이 있다. 주연이네 대여점에는 진상 손님인 진일이가 찾아온다는 것이였다. 진일이는 선반 A 에 있는 DVD와 선반 B에 있는 DVD를 서로 바꿔 놓는다. 이러한 진일이의 몰상식한 행동때문에 민호와 같이 주연이를 믿고 DVD의 번호를 확인 안하는&nbsp;선량한 고객들이 피해를 입는 사례들이 속출하였다. 아무 이유가 없는 묻지마 테러로 인해 가게매출이 떨어질 위기에 처하자 주연이는&nbsp;진일이가 보일때마다 쫒아 냈지만, 시도때도없이 찾아오는 진일이의 진상짓을 막기에는 역부족이였다.</p>

<p>이러한 주연이를 보고 안타까운 마음이 든 민호는 주연이를 위해&nbsp;프로그램을 작성하기로 결심을 한다. 의욕이 넘치는 민호의 마음과는 달리 실력이 따라주지 못해 프로그램의 기능은 조촐하기만 하다. 프로그램의 기능은 다음과 같다.</p>

<ol>
	<li>손님이 L번 선반부터 R번 선반까지에 있는 DVD들을 가져 왔을때 실제로 DVD가 L번부터 R번까지 있나 확인을 해 줄 수 있다.</li>
	<li>DVD의 순서는 상관이 없다. 예를 들어 손님이 2번 선반부터 4번 선반까지에 있는 DVD를 가져왔을 때 DVD가 2, 3, 4 순서로 진열되어 있건, 4, 2, 3 순서로 진열되어 있건 상관이 없다는 얘기다. 즉 L번부터 R번까지의 DVD가 있으면 된다.</li>
</ol>

<p>문제의 단순화를위해 고객이 DVD를 빌려가면, 그 즉시 시청한뒤 바로 반납한다고 가정한다.&nbsp;또한&nbsp;가져다 놓는 위치는 빌리기 전과 동일하다(4, 3, 2 순서로 진열되어 있었으면 다시 4, 3, 2 순서로 진열한다).</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 테스트 케이스의 수 T가 주어진다. (T ≤ 20 인 자연수)</p>

<p>각각의 테스트 케이스 첫 번째 줄에는 DVD들의 수를 의미하는 정수 N 과 대여점에서 일어나는 사건의 수를 의미하는 정수&nbsp;K 가 주어진다.&nbsp;(1 ≤ N ≤ 100,000 , 1 ≤ K ≤ 50,000)</p>

<p>이어서 대여점에서 일어나는 사건 K 개가 주어진다. 각각의 줄은 세 정수 Q, A, B 을 포함한다.&nbsp;(Q는 0또는 1이고, 0 ≤&nbsp;A ≤ B <&nbsp;N )</p>

<p>Q는 0 일때, 진상 손님 진일이가 선반 A의 DVD와 선반 B의 DVD를 서로 바꿔 끼우는 사건을 의미한다.&nbsp;</p>

<p>Q가 1&nbsp;일때는 손님이 선반 A부터 선반 B에 있는 DVD를 카운터에 가져오는 사건을 의미한다. 위에서도 언급했듯이 이 사건이 DVD들의 위치를 바꾸는 일은&nbsp;일어나지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>손님이 DVD를 카운터에 가져왔을 때 손님이 원하는 DVD가 전부 존재하면, (A번 선반부터 B번 선반까지에 있는 DVD를 전부 가져왔을 때 순서에 상관없이 A번 DVD부터 B번 DVD까지 있다면)&nbsp;"YES"를 출력하고, 그렇지 않다면 "NO"를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
5 8
1 0 4
1 1 2
0 1 3
1 2 2
1 1 3
1 0 0
1 0 2
1 2 4
5 5
0 1 2
0 2 3
0 1 3
1 0 1
1 0 2
','YES
YES
YES
YES
YES
NO
NO
YES
NO
','DATA_STRUCTURE'),
                                                                                                                (6929,'BAEKJOON','https://www.acmicpc.net/problem/9426',9426,'중앙값 측정','1초','256 MB',16,'<p>기상학에서 주요 사용하는 대표값은 중앙값이다. (중앙값의 정의는 힌트에 나와있다)</p>

<p>상근이는 1초에 한 번씩 온도를 재는 기계를 가지고 있고, 이 기계에 들어갈 소프트웨어를 작성하려고 한다. 기계에는 작은 디지털 디스플레이가 하나 달려있다. 매 초마다 디스플레이는 지난 K초동안 측정한 온도의 중앙값을 화면에 보여준다.</p>

<p>상근이는 소프트웨어를 기계에 올리기 전에 컴퓨터에서 테스트해보려고 한다.</p>

<p>총 N초 동안 측정한 온도가 주어졌을 때, 디스플레이에 표시된 중앙값의 합을 구하는 프로그램을 작성하시오. 즉, N개의 수가 주어졌을 때, 길이가 K인 연속 부분 수열 N-K+1개의 중앙값의 합을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 250,000, 1 ≤ K ≤ 5,000, K ≤ N)</p>

<p>둘째 줄부터 N개 줄에 측정한 온도가 순서대로 주어진다. 온도는 0보다 크거나 같고, 65535보다 작거나 같은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>길이가 K인 모든 연속 부분 수열의 중앙값의 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>수 K개의 중앙값은 ((K+1)/2)번째로 작은 숫자이다. 인덱싱은 1번 부터 시작하며, K가 홀수인 경우를 처리하기 위해 1을 더한다.</p>

<p>예를 들어, (1, 2, 6, 5, 4, 3)의 중앙값은 3이고, (11, 13, 12, 14, 15)의 중앙값은 13이다.&nbsp;</p>

				</div>
				</div>','10 3
3
4
5
6
7
8
9
10
11
12
','60
','DATA_STRUCTURE'),
                                                                                                                (6939,'BAEKJOON','https://www.acmicpc.net/problem/9463',9463,'순열 그래프','5초','256 MB',16,'<p>그래프 G는 정점의 집합 V와 간선의 집합 E로 이루어져 있고, G = (V, E)로 나타낸다. 대부분의 경우에 V와 E는 명시되어 있다. 일부 그래프의 경우에는 집합이 명시되어 있지 않다. 예를 들어, 순열 그래프는 간선의 집합이 명시되어 있지 않다.</p>

<p>{1, 2, 3, 4, 5}로 이루어진 두 순열 (2, 5, 4, 1, 3)과 (1, 5, 3, 2, 4)가 있다. 평행선을 그리고, 그 위에 순열에 적힌 숫자 순서대로 정점을 그린다. 그 다음 같은 숫자끼리 선분을 연결한다. 아래 그림과 같이 교차하는 선분의 쌍은 총 여섯 개라는 것을 알 수 있다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/perm1.png" style="width: 388.333px; height: 104.167px;"></p>

<p>교차하는 쌍은 순열 그래프의 간선이 된다. 순열 그래프의 정점은 숫자가 되고, 간선은 교차하는 쌍이 된다. 위의 예를 이용해 순열 그래프를 만들면 V = {1, 2, 3, 4, 5}, E = {(1,2), (1,4), (1,5), (2,3), (2,5), (3,4)}. 위의 두 순열을 이용해 순열 그래프를 그리면 아래 그림과 같이 된다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/perm2.png" style="height:150px; width:232px"></p>

<p>{1, 2, ..., n}으로 이루어진 두 순열이 주어졌을 때, 두 순열을 이용해 만든 순열 그래프의 간선의 개수를 구하는 프로그램을 작성하시오. 예를 들어, (2, 5, 4, 1, 3)과 (1, 5, 3, 2, 4)로 만든 순열 그래프의 간선의 개수는 6개이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n이 주어진다. 둘째 줄과 셋째 줄에는 두 순열이 주어진다. 순열은 {1, 2, ..., n}으로 이루어져 있고, 공백으로 구분되어져 있다. (1 ≤ n ≤ 100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스 마다, 입력으로 주어진 두 순열로 만든 순열 그래프의 간선의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
5
2 5 4 1 3
1 5 3 2 4
7
5 6 7 1 2 3 4
5 6 7 1 2 3 4
7
1 5 3 4 2 7 6
7 1 5 3 4 2 6
','6
0
5
','DATA_STRUCTURE'),
                                                                                                                (6930,'BAEKJOON','https://www.acmicpc.net/problem/9482',9482,'가까운 만유인력','5초','128 MB',22,'<p>우리는&nbsp;복잡한 태양계에서 무지 멀리 떨어져 있는 두 물체에 대한 중력효과를 계산하고 싶지 않을 뿐더러 계산해도 무시할 정도로 작아서 컴퓨터만 고생한다. 그래서 우리는 k보다 작은 거리에 있는 두 물체만 고려하고 싶다. 우주에서 n개의 점이 주어져 있다면 두 물체 사이의 거리가 k보다 작은 경우는 얼마나 있는가?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>각 테스트 케이스에 대해, 맨 첫줄은 두개의 정수,&nbsp;n (2≤n≤100,000)&nbsp;과 k (1≤k≤10<sup>9</sup>) 로 이루어져 있는데 n은 점의 개수고 k는 허용되는 최대 거리다. 다음 n줄은 각각 세개의 정수,&nbsp;x, y,&nbsp;z (-10<sup>9</sup>≤x,y,z≤10<sup>9</sup>) 로 이루어져 있고 (x,y,z)가 한 점이다. 각 테스트 케이스에 대해 중복되는 점은 없고 거리가 k이하인 경우가 100,000가지를 넘지 않는다고 하자. 입력의 마지막은 두개의 0만 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해 각 줄에&nbsp;k보다 작은 거리에 있는 점들의 쌍의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 2
0 0 0
1 0 0
1 2 0
1 2 3
1000 1000 1000
1001 1001 1000
1001 999 1001
7 3
0 0 0
1 0 0
1 2 0
1 2 3
-1000 1000 -1000
-1001 1001 -1000
-1001 999 -1001
7 4
0 0 0
1 0 0
1 2 0
1 2 3
1000 -1000 1000
1001 -1001 1000
1001 -999 1001
0 0
','3
6
9
','DATA_STRUCTURE'),
                                                                                                                (6933,'BAEKJOON','https://www.acmicpc.net/problem/9489',9489,'사촌','3초','128 MB',12,'<p>증가하는 정수 수열을 이용해서 트리를 만드는 방법은 다음과 같다.</p>

<ul>
	<li>첫 번째 정수는 트리의 루트 노드이다.</li>
	<li>다음에 등장하는 연속된 수의 집합은 루트의 자식을 나타낸다. 이 집합에 포함되는 수의 첫 번째 수는 항상 루트 노드+1보다 크다.</li>
	<li>그 다음부터는 모든 연속된 수의 집합은 아직 자식이 없는 노드의 자식이 된다. 그러한 노드가 여러 가지 인 경우에는 가장 작은 수를 가지는 노드의 자식이 된다.</li>
	<li>집합은 수가 연속하지 않는 곳에서 구분된다.</li>
</ul>

<p>예를 들어, 수열 1 3 4 5 8 9 15 30 31 32를 위의 규칙을 이용해 트리를 만들면 아래 그림과 같이 된다.</p>

<p style="text-align: center;"><img alt="" src=https://www.acmicpc.net/upload/images/cc.png" style="height:245px; width:320px"></p>

<p>두 노드의 부모는 다르지만, 두 부모가 형제(sibling)일 때 두 노드를 사촌이라고 한다.</p>

<p>수열 특정 노드 번호 k가 주어졌을 때, k의 사촌의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 노드의 수 n과 사촌의 수를 구해야 하는 노드의 번호 k가 주어진다. (1 ≤ n ≤ 1,000, 1 ≤ k ≤ 1,000,000) 다음 줄에는 총 n개의 수가 주어지며, 모든 수는 1보다 크거나 같고, 1,000,000보다 작거나 같다. 입력으로 주어지는 수열은 항상 증가한다. k는 항상 수열에 포함되는 수이다.</p>

<p>입력의 마지막 줄에는 0이 두 개 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스 마다, k의 사촌의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 15
1 3 4 5 8 9 15 30 31 32
12 9
3 5 6 8 9 10 13 15 16 22 23 25
10 4
1 3 4 5 8 9 15 30 31 32
0 0
','5
1
0
','DATA_STRUCTURE'),
                                                                                                                (6940,'BAEKJOON','https://www.acmicpc.net/problem/9541',9541,'역사 시간','10초','128 MB',28,'<p>현수는 서강대학교에서 한국사를 강의하는 교수이다. 현수는 총 n개의 역사적 사건을 한 수업시간에 하나씩 강의하려고 한다. 이제, 각 강의에 어떤 역사적 사건을 강의할지 결정하려고 한다.</p>

<p>모든 사건은 발생한 특정 구간 [a<sub>i</sub>, b<sub>i</sub>]이 있다. 두 사건이 발생한 구간이 겹치는 경우 두 사건을 연관되었다고 한다. 연관된 사건을 최대한 가까운 시간에 강의하면 학생들의 이해도가 높아진다. 또, 연관된 사건이 아닌 경우에는 일어난 순서를 지키면서 강의해야 한다. 즉, A와 B가 연관된 사건이 아니고, A가 B보다 먼저 일어났다면, A는 B보다 먼저 강의해야 한다.</p>

<p>현수가 강의해야 하는 사건의 구간이 모두 주어졌을 때, 두 연관된 사건이 떨어진 거리의 최댓값 k의 최솟값을 구하는 프로그램을 작성하시오. i번째 강의와 j번째 강의 사이의 거리는 |i - j|이다</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다.</p>

<p>각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 50,000)이 주어진다. 다음 n개 줄에는 사건의 구간 a<sub>i</sub>와 b<sub>i</sub>가 주어진다. (-10<sup>9</sup> ≤ a<sub>i</sub> ≤ b<sub>i</sub> ≤ 10<sup>9</sup>) 두 구간이 같은 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 테스트 케이스 마다, 가장 작은 k를 출력한다.&nbsp;다음 n개 줄에는 강의 순서를 입력과 같은 형식으로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
3
1 6
2 3
4 5
','1
2 3
1 6
4 5
','DATA_STRUCTURE'),
                                                                                                                (6947,'BAEKJOON','https://www.acmicpc.net/problem/9575',9575,'행운의 수','1초','128 MB',7,'<p>한슬이는 5와 8이 행운의 수라고 생각한다. 그래서 한슬이는 각 자리가 5와 8로만 이뤄져 있는 수를 행운의 수라고 한다.</p>

<p>정수 수열 A, B, C가 주어졌을 때 세 수열에서 각각 하나의 정수를 골라서 만들 수 있는 서로 다른 행운의 수의 개수를 구해보자.</p>

<p>예를 들어 A = [1, 10, 100], B = [3, 53], C = [4, 54]라고 한다면, 행운의 수를 만드는 방법은 8 = 1 + 3 + 4, 58 = 1 + 3 + 54, 58 = 1 + 53 + 4와 같이 총 3가지가 있다. 58은 2가지 방법으로 만들 수 있으니, 서로 다른 행운의 수의 개수는 8과 58, 총 2개이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 수가 주어진다.</p>

<p>각 테스트 케이스의 첫째 줄에 A의 크기 N이 주어지고, 둘째 줄에 수열 A의 원소가 주어진다. 수열 A의 원소는 공백으로 구분되어 있다.</p>

<p>다음 셋째 줄에는 B의 크기 M, 넷째 줄에는 수열 B의 원소, 다섯째 줄에는 C의 크기 K, 여섯째 줄에는 C의 원소가 주어지며, 수열 A의 정보와 같은 형식으로 되어 있다.</p>

<p>수열의 크기는 50을 넘지 않는 양의 정수이고, 수열의 원소는 30,000보다 작거나 같은 양의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 테스트 케이스마다 입력으로 주어진 수열을 이용해 만들 수 있는 서로 다른 행운의 수의 개수를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
6
100 1 10 100 1 1
7
3 53 53 53 53 53 53
6
4 54 4 54 4 54
1
47
1
500
1
33
','2
0
','DATA_STRUCTURE'),
                                                                                                                (6946,'BAEKJOON','https://www.acmicpc.net/problem/9623',9623,'부분 수열의 길이','3초','256 MB',17,'<p>길이가 N인 정수 수열과 정수 X가 주어진다. 이때, 합이 X보다 크거나 같은 연속 부분 수열 중에서 길이가 가장 짧은 것을 찾는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 N (1 ≤ N ≤ 500,000)과 X (-10<sup>9</sup> ≤ X ≤ 10<sup>9</sup>)가 주어진다. 둘째 줄에는 수열에 들어있는 정수 N개가 주어진다. 이 정수는 -10<sup>9</sup>보다 크거나 같고, 10<sup>9</sup>보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 합이 X보다 크거나 같은 연속 부분 수열 중 가장 짧은 길이를 출력한다. 만약, 그러한 배열이 없는 경우에는 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
5 4
1 2 1 2 1
6 -2
-5 -6 -7 -8 -9 -10
5 3
-1 1 1 1 -1
','3
-1
3
','DATA_STRUCTURE'),
                                                                                                                (6956,'BAEKJOON','https://www.acmicpc.net/problem/9630',9630,'TV 송신기','1초','128 MB',24,'<p>시장은 새로운 TV 송신 시스템을 도입하기로 했다. 도시는 길이가 D인 선분 위에 여러 개의 빌딩이 놓여져 있는 형태이다. 빌딩의 너비는 무시할 수 있을만큼 작다. 일부 빌딩의 옥상에는 TV 송신기 있으며, 그 크기도 무시할 수 있다.</p>

<p>TV 송신기는 TV 신호를 모든 방향으로 전송한다. 신호는 직선으로 전송되며, 빌딩을 통과할 수 없다. 도시의 일부분은 기존에 설치된 송신기로 TV 신호를 수신할 수 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/69ffbe8c-ce04-4aea-b63e-9d28606310fb/-/preview/" style="width: 363.333px; height: 185.833px;"></p>

<p>TV 신호를 받을 수 있는 선분을 찾고 그 길이를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 빌딩의 수 N (1 ≤ N ≤ 3·10<sup>5</sup>)과 도시의 길이 D(1 ≤ D ≤ 10<sup>9</sup>)가 주어진다.</p>

<p>다음 N개 줄에는 i번째 빌딩의 정보를 나타내는 세 개의 정수가 주어진다.</p>

<ol>
	<li>빌딩의 옥상에 송신기가 설치된 경우에 첫 번째 정수는 1이고, 설치되지 않은 경우에는 0이다.</li>
	<li>두 번째 정수는 빌딩이 도시의 왼쪽 끝으로부터 떨어진 거리 X<sub>i</sub> (0 ≤ X<sub>i</sub> ≤ D) 이다.</li>
	<li>세 번째 정수는 빌딩의 높이 H<sub>i</sub> (1 ≤ H<sub>i</sub> ≤ 10<sup>9</sup>) 이다.</li>
</ol>

<p>빌딩은 왼쪽으로부터 떨어진 거리가 증가하는 순으로 주어진다. 두 빌딩이 같은 곳에 있는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 구한 정답을 출력한다. 오차는 최대 10<sup>-3</sup>까지 허용된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 10
1 2 6
0 4 3
0 8 2
','6.000000
','DATA_STRUCTURE'),
                                                                                                                (6964,'BAEKJOON','https://www.acmicpc.net/problem/9938',9938,'방 청소','1초','256 MB',18,'<p>은기는 술병 N개(1부터 N까지 번호가 매겨져 있다)와 서랍 L개(1부터 L까지 번호가 매겨져 있다)를 가지고 있다. 술병은 은기의 방 바닥에 흩어져 있고, 어린이날을 맞이해 방 청소를 하려고 한다. &nbsp;서랍에는 술병이 하나 들어갈 수 있다. 나중에 원하는 술을 빠르게 찾을 수 있게 하기 위해 은기는 각각의 술병이 들어갈 수 있는 서랍의 번호 A<sub>i</sub>와 B<sub>i</sub>를 공책에 적어 놓았다.</p>

<p>은기는 술병을 1번부터 N번까지 순서대로 정리할 것이고, 각각의 술병에 대해서 다음과 같은 과정을 거친다.</p>

<ol>
	<li>서랍 A<sub>i</sub>가 비어있다면, i번 술을 그 서랍에 보관한다.</li>
	<li>서랍 B<sub>i</sub>가 비어있다면, i번 술을 그 서랍에 보관한다.</li>
	<li>A<sub>i</sub>에 들어있는 술을 다른 서랍으로 이동시킨다.(다른 서랍은 A<sub>i</sub>에 들어있는 술이 들어갈 수 있는 서랍 중 하나이다) 만약, 그 서랍에도 이미 술이 들어있다면, 그 술을 다른 서랍으로 이동시킨다. 이런 과정을 거쳐서 빈 서랍을 하나 찾아 술을 모두 이동할 수 있는 경우에는, 술을 이동시키고 i번 술을 A<sub>i</sub>에 보관한다. 불가능한 경우에는 다음 규칙으로 넘어간다.</li>
	<li>B<sub>i</sub>에 들어있는 술을 다른 서랍으로 이동시킨다. 만약, 그 서랍에도 이미 술이 들어있다면, 그 술을 다른 서랍으로 이동시킨다. 이런 과정을 거쳐서 빈 서랍을 하나 찾아 술을 모두 이동할 수 있는 경우에는, 술을 이동시키고 i번 술을 B<sub>i</sub>에 보관한다. 불가능한 경우에는 다음 규칙으로 넘어간다.</li>
	<li>위의 과정이 모두 불가능한 경우에는 i번 술을 그 자리에서 마셔버린다. (은기는 전혀 취하지 않는다)</li>
</ol>

<p>각각의 술에 대해서, 서랍에 보관할 수 있는지, 그 자리에서 마셔버리는지를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 L이 주어진다. (1 ≤ N, L ≤ 300,000)</p>

<p>다음 N개 줄에는 A<sub>i</sub>와 B<sub>i</sub>가 주어진다. (1 ≤ A<sub>i</sub>, B<sub>i</sub> ≤ L, A<sub>i</sub> ≠ B<sub>i</sub>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1번 술부터 N번 술까지 순서대로 보관할 수 있는지, 그 자리에서 먹어야 하는지를 출력한다.</p>

<p>보관할 수 있는 경우에는 "LADICA"를, 먹어버려야 하는 경우에는 "SMECE"를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>처음 6개의 술은 규칙 1에 의해서 1, 3, 5, 7, 9, 2번 서랍에 보관할 수 있다.</p>

<p>7번째 술은 규칙 3을 적용할 수 있다. 1번 서랍에 들어있는 술을 2로, 2번 서랍에 들어있는 술을 3으로, 3번 서랍에 들어있는 술을 4번으로 옮길 수 있다.</p>

<p>8번째 술은 8번 서랍에 넣을 수 있다.</p>

<p>9번째 술은 규칙 3을 적용할 수 있다. 서랍 7에 들어있는 술을 8로, 8에 들어있는 술은 2로, 2에 들어있는 술을 1로, 1에 들어있는 술을 5로, 5에 들어있는 술을 6으로 옮길 수 있다.</p>

				</div>
				</div>','9 10
1 2
3 4
5 6
7 8
9 10
2 3
1 5
8 2
7 9
','LADICA
LADICA
LADICA
LADICA
LADICA
LADICA
LADICA
LADICA
LADICA
','DATA_STRUCTURE'),
                                                                                                                (6970,'BAEKJOON','https://www.acmicpc.net/problem/9992',9992,'비밀 메시지','1초','128 MB',14,'<p>상근이는 창영이가 보낸 비밀 메시지를 받았다. 메시지는 알파벳 대문자로만 이루어져 있으며, 길이는 2보다 크거나 같다.</p>

<p>메시지를 해독하려면 메시지에 연산을 수행해야 한다. 연산을 하려면 문자열 S에 S의 일부(전부는 안됨) 문자를 앞에서부터 지운 문자열 또는 S의 일부(전부는 안됨) 문자를 뒤에서부터 지운 문자열을 S의 앞이나 뒤에 붙여야 한다.</p>

<p>예를 들어, 문자열 ABC에 연산을 수행할 수 있는 방법은 총 8가지가 있다.</p>

<ul>
	<li>AABC (A + ABC)</li>
	<li>ABABC (AB + ABC)</li>
	<li>BCABC (BC + ABC)</li>
	<li>CABC (C + ABC)</li>
	<li>ABCA (ABC + A)</li>
	<li>ABCAB (ABC + AB)</li>
	<li>ABCBC (ABC + BC)</li>
	<li>ABCC (ABC + C)</li>
</ul>

<p>상근이가 해독을 완료한 문자열이 입력으로 주어진다. 이때, 이 문자열을 만드는 방법의 수를 출력한다. 연산은 여러 번 수행할 수 있다. 만든 문자열이 같더라도, 연산의 방법이 다르다면 다른 방법으로 친다. 예를 들어, AA에서 AAA를 만드는 방법은 총 4가지가 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 해독 완료한 문자열이 주어진다. 길이는 100을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 입력으로 주어진 문자열을 만드는 방법의 수를 출력한다. 처음 문자열의 길이는 2보다 크거나 같아야 한다. 방법의 수가 매우 커질 수 있기 때문에, 2014로 나눈 나머지를 출력한다. 만약, 불가능한 경우에는 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>ABABA를 만드는 방법은 총 8가지가 있다.</p>

<ol>
	<li>ABA에서 시작 -> AB + ABA</li>
	<li>ABA에서 시작 -> ABA + BA</li>
	<li>AB에서 시작 -> AB + A -> AB + ABA</li>
	<li>AB에서 시작 -> AB + A -> ABA + BA</li>
	<li>BA에서 시작 -> A + BA -> AB + ABA</li>
	<li>BA에서 시작 -> A + BA -> ABA + BA</li>
	<li>ABAB에서 시작 -> ABAB + A</li>
	<li>BABA에서 시작 -> A + BABA</li>
</ol>

				</div>
				</div>','ABABA
','8
','DATA_STRUCTURE'),
                                                                                                                (6975,'BAEKJOON','https://www.acmicpc.net/problem/10000',10000,'원 영역','1초','256 MB',17,'<p>x축 위에 원이 N개 있다. 원은 서로 교차하지 않는다. 하지만, 접할 수는 있다.</p>

<p>원으로 만들어지는 영역이 몇 개인지 구하는 프로그램을 작성하시오.</p>

<p>영역은 점의 집합으로 모든 두 점은 원을 교차하지 않는 연속되는 곡선으로 연결될 수 있어야 한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/c360da99-845f-4fdb-b1f6-60b809ef640b/-/preview/" style="width: 201px; height: 201px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 원의 개수 N(1 ≤ N ≤ 300,000)이 주어진다.</p>

<p>다음 N개 줄에는 각 원의 정보 x<sub>i</sub>와 r<sub>i</sub>가 정수로 주어진다. x<sub>i</sub>는 원의 중심 좌표이며, r<sub>i</sub>는 반지름이다.&nbsp;(-10<sup>9</sup> ≤ x<sub>i</sub> ≤ 10<sup>9</sup>, 1 ≤ r<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>입력으로 주어지는 원은 항상 유일하다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 원으로 인해서 만들어지는 영역의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
1 3
5 1
','3
','DATA_STRUCTURE'),
                                                                                                                (6976,'BAEKJOON','https://www.acmicpc.net/problem/10007',10007,'레이저','3초','512 MB',20,'<p>재현이는 얼마 전 게임을 만들었다. 게임의 이름은 "유재민"이고, 게임의 주인공은 유재민이다.</p>

<p>유재민은 (0, 0)에서 레이저 빔을 발사하는 역할을 한다. 게임의 목표는, 유재민을 잘 조종해서 좌표평면 상에 있는 선분을 최대한 많이 맞추는 것이다. 유재민은 최대 K번 레이저 빔을 발사할 수 있으며, 레이저 빔이 선분의 끝점을 지나도, 맞췄다는 판정이 난다.</p>

<p>애석하게도, 재현이는 게임을 만들 때 몇 가지 처리를 하지 못했고, 결국 한번 맞췄던 선분을 다시 맞췄을 경우 게임 프로그램이 크래시 되는 버그를 발견했다. 처음에는 당황했지만, 그래도 이런 게임도 나름 재미있을 것 같아서, 재현이는 이 게임을 최적으로 플레이 하려고 한다. 재현이를 도와서, 현재의 제약 조건 상황에서 맞출 수 있는 선분의 최대 개수를 구하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 k, n이 주어진다.&nbsp;(1 ≤ k ≤ 100, 1 ≤ n ≤ 500 000)</p>

<p>이후 n개의 줄에 선분이 x1, y1, x2, y2 (1 ≤ x1, y1, x2, y2 ≤ 1 000 000)의 형태로 주어진다. (x1, y1)과 (x2, y2)를 잇는다는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한번 맞췄던 선분을 다시 맞추지 않는다는 조건 하에, 최대 K개의 레이저 빔을 쏘아서, 맞출 수 있는 최대 개수의 선분을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10007/1.png" style="height:216px; width:215px"></p>

				</div>
				</div>','3 6
1 2 2 4
3 1 5 1
3 2 2 3
3 3 3 4
2 2 2 2
6 1 3 5
','5
','DATA_STRUCTURE'),
                                                                                                                (6987,'BAEKJOON','https://www.acmicpc.net/problem/10060',10060,'감시 카메라','4초','512 MB',21,'<p>홍준이는 한국에서 손에 꼽히는 부자 중 한 명이다. 홍준이의 집은 N개의 방이 원형으로 나열된 형식으로 구성되어 있다. 홍준이는 자신의 집에 K개의 감시 카메라를 설치했다. 각 감시 카메라는 원형으로 나열된 방들 중 일부 연속된 구간을 감시한다. 홍준이는 모든 방을 다 감시하고 싶어 하는데, 이미 설치된 K개의 감시 카메라 중 몇 개는 필요하지 않다는 것을 깨달았다.</p>

<p>홍준이의 방은 1번 방부터 N번 방까지 원형으로 배열되어 있다. 즉, 1번 방 양 옆에는 2번 방과 N번 방이 있고, N번 방 양 옆에는 N-1번 방과 1번 방이 있다.</p>

<p>K개의 감시 카메라가 감시하는 구간에 대한 정보가 주어졌을 때, 모든 방을 감시하기 위해 필요한 최소 감시 카메라 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 방의 개수 N과 감시 카메라의 개수 K가 주어진다. (3 ≤ N ≤ 10<sup>6</sup>,&nbsp;1 ≤ K ≤ 10<sup>6</sup>)</p>

<p>다음 K개의 줄에 각 감시 카메라에 대한 정보 a<sub>i</sub>와 b<sub>i</sub>가 주어진다. (1&nbsp;≤ a<sub>i</sub>, b<sub>i</sub>,&nbsp;≤ N)</p>

<p>a<sub>i</sub>&nbsp;≤ b<sub>i</sub> 인 경우, a<sub>i</sub>&nbsp;≤ j&nbsp;≤ b<sub>i</sub>&nbsp;를 만족하는 j번 방이 감시 받는다는 것을 의미하고, a<sub>i</sub> > b<sub>i</sub>&nbsp;인 경우, 1&nbsp;≤ j&nbsp;≤ b<sub>i</sub> 혹은 a<sub>i</sub>&nbsp;≤ j&nbsp;≤ N 을 만족하는 j번 방이 감시 받는다는 것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>홍준이가 모든 방을 감시하기 위해 필요한 감시 카메라의 최소 개수를 출력한다. 만약, 모든 방을 감시하는 것이 불가능하다면,&nbsp; <code>impossible</code>을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','100 7
1 50
50 70
70 90
90 40
20 60
60 80
80 20
','3
','DATA_STRUCTURE'),
                                                                                                                (6999,'BAEKJOON','https://www.acmicpc.net/problem/10070',10070,'벽','3초','256 MB',21,'<p>지안지아는 똑같은 크기의 벽돌을 쌓아서 벽을 만들고 있다. 이 벽은 n열의 벽돌로 되어 있는데, 각 열은 왼쪽부터 오른쪽으로 차례대로 0부터 n-1까지 번호가 매겨져 있다. 각 열의 높이는 서로 다를 수 있다. 열의 높이는 이 열에 쌓인 벽돌의 수이다.</p>

<p>지안지아는 다음과 같이 벽을 만든다. 처음에는 어느 열에도 벽돌이 없다. 다음, 지안지아는 k 단계에 걸쳐 벽돌을 더하거나 또는 빼거나 한다. k 단계가 다 끝나면 벽을 다 쌓은 것이다. 매 단계마다 지안지아는 연속된 벽돌 열의 범위와 높이 h를 받고, 다음과 같은 절차에 따라 정해진 일을 한다.</p>

<ul>
	<li>벽돌을 더하는 단계에서는, 지안지아는 주어진 범위에 해당하는 열들 중 h장 미만의 벽돌이 쌓인 열들에 벽돌을 더해서 정확히 벽돌 h장이 쌓이게 한다. h장 이상 벽돌이 있는 열에는 아무 일도 하지 않는다.</li>
	<li>벽돌을 빼는 단계에는, 지안지아는 주어진 범위에 해당하는 열들 중 h장 초과의 벽돌이 쌓인 열들에서 벽돌을 빼서 정확히 벽돌 h장이 쌓이게 한다. h장 이하 벽돌이 있는 열에는 아무 일도 하지 않는다.</li>
</ul>

<p>당신이 할 일은 벽의 최종 모양을 결정하는 것이다.</p>

<p>10열의 벽돌이 있고 6단계를 거쳐 벽을 만든다고 가정하자. 아래 표의 모든 범위는 양 끝을 포함한다. 각 단계가 끝났을 때 벽의 모양은 아래 그림과 같다.</p>

<table class="table table-bordered" style="width:50%">
	<thead>
		<tr>
			<th>단계</th>
			<th>하는 일</th>
			<th>범위</th>
			<th>높이</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>0</td>
			<td>더하기</td>
			<td>1열부터 8열까지</td>
			<td>4</td>
		</tr>
		<tr>
			<td>1</td>
			<td>빼기</td>
			<td>4열부터 9열까지</td>
			<td>1</td>
		</tr>
		<tr>
			<td>2</td>
			<td>빼기</td>
			<td>3열부터 6열까지</td>
			<td>5</td>
		</tr>
		<tr>
			<td>3</td>
			<td>더하기</td>
			<td>0열부터 5열까지</td>
			<td>3</td>
		</tr>
		<tr>
			<td>4</td>
			<td>더하기</td>
			<td>2열</td>
			<td>5</td>
		</tr>
		<tr>
			<td>5</td>
			<td>빼기</td>
			<td>6열부터 7열까지</td>
			<td>0</td>
		</tr>
	</tbody>
</table>

<p>처음에 모든 열에는 벽돌이 없기 때문에, 단계 0이 끝나면 1열부터 8열까지는 모두 4장의 벽돌이 있다. 0열과 9열은 비어 있다. 단계 1에서는, 4열부터 8열까지는 벽돌이 빠져서 모든 열에 각각 벽돌이 1장이 있고, 9열은 계속 비어 있다. 주어진 범위 밖인 0열부터 3열은 아무 변화가 없다. 단계 2는 아무 변화가 없는데, 3열부터 6열까지 5장을 초과하여 벽돌이 있는 열이 없기 때문이다. 단계 3이 끝나면 0, 4, 5열의 벽돌은 3장으로 늘어난다. 단계 4가 끝나면 2열에는 벽돌이 5장 있다. 단계 5는 6열과 7열의 모든 벽돌을 없앤다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/a39a54bd-2692-4c40-9e57-99bfb3ff9992/-/preview/" style="width: 279px; height: 508px;"></p>

<p>각 단계에서 하는 일이 주어졌을 때, 모든 단계가 끝난 다음 각 열에 남아 있는 벽돌의 수를 계산하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 벽에 있는 열의 수 n과 단계의 수 k가 주어진다.</p>

<p>둘째 줄부터 총 k개의 줄에 걸쳐서 단계 i에서 하는 일이 주어진다. op, left, right, height로 이루어져 있으며, 아래와 같은 의미를 갖는다.</p>

<ul>
	<li>op: 1이면 더하는 단계, 2이면 빼는 단계이다.</li>
	<li>left와 right: 각 단계에 해당하는 열의 범위이다. left 열에서 시작하고, right 열에서 끝난다. (양 끝점 left와 right도 포함된다) 항상 left ≤ right이다.</li>
	<li>height: 각 단계에서 주어지는 높이이다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 단계가 끝난 다음 각 열에 남아 있는 벽돌의 수를 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 6
1 1 8 4
2 4 9 1
2 3 6 5
1 0 5 3
1 2 2 5
2 6 7 0
','3
4
5
4
3
3
0
0
1
0
','DATA_STRUCTURE'),
                                                                                                                (7002,'BAEKJOON','https://www.acmicpc.net/problem/10076',10076,'휴가','5초','64 MB',23,'<p>지안지아는 타이완에서의 휴가를 계획하고 있다. 휴가동안 지안지아는 도시에서 도시로 이동하고 도시 안의 관광지들을 방문할 것이다.</p>

<p>타이완에는 하나의 고속도로를 따라서 n개의 도시들이 위치한다. 이 도시들은 순서대로 0부터 n-1까지의 번호가 붙어있다. 임의의 i(0 < i < n-1)에 대해서, 도시 i의 인접한 도시는 도시 i-1과 i+1이다. 도시 0과 인접한 도시는 도시 1뿐이고, 도시 n-1과 인접한 도시는 도시 n-2뿐이다.</p>

<p>각 도시에는 여러 관광지들이 있다. 지안지아는 d일 동안의 휴가를 얻었고 가능한 많은 관광지들을 방문하고 싶다. 지안지아는 휴가를 시작할 도시를 선택했다. 휴가기간동안 매일 지안지아는 인접한 도시로 움직이거나 또는 현재 도시의 관광지들을 모두 방문한다. 그러나 두 행동을 하루에 모두 할수는 없다. 지안지아는 한 도시에 여러 번 머물더라도 같은 도시안의 관광지들을 결코 두 번 방문하지는 않는다. 지안지아가 가능한 많은 서로 다른 관광지들을 방문하도록 도와주자.</p>

<p>지안지아는 7일의 휴가를 얻었고, (아래 표와 같이) 5개의 도시가 있고 도시 2에서 휴가를 시작하였다. 첫 번째 날 지안지아는 도시 2의 20개 관광지를 방문한다. 두 번째 날 지안지아는 도시 2에 서 도시 3으로 이동하고 세 번째 날 도시 3의 30개 관광지들을 방문한다. 다음 3일동안 지안지아 는 도시 3에서 도시 0으로 이동해서 일곱 번째 날에 도시 0의 10개 관광지들을 방문한다. 따라서 지안지아가 방문한 관광지의 총 개수는 20 + 30 + 10 = 60이고 이것은 그가 도시 2에서 시작해서 7일 동안 방문할 수 있는 관광지들의 최대 개수이다.</p>

<table class="table table-bordered" style="width:20%">
	<thead>
		<tr>
			<th>도시</th>
			<th>관광지 개수</th>
		</tr>
	</thead>
	<tbody>
	</tbody>
	<tbody>
		<tr>
			<td>0</td>
			<td>10</td>
		</tr>
		<tr>
			<td>1</td>
			<td>2</td>
		</tr>
		<tr>
			<td>2</td>
			<td>20</td>
		</tr>
		<tr>
			<td>3</td>
			<td>30</td>
		</tr>
		<tr>
			<td>4</td>
			<td>1</td>
		</tr>
	</tbody>
</table>

<table class="table table-bordered" style="width:30%">
	<thead>
		<tr>
			<th>일</th>
			<th>행동</th>
		</tr>
	</thead>
	<tbody>
	</tbody>
	<tbody>
		<tr>
			<td>1</td>
			<td>도시 2의 관광지들을 방문</td>
		</tr>
		<tr>
			<td>2</td>
			<td>도시 2에서 도시 3으로 이동</td>
		</tr>
		<tr>
			<td>3</td>
			<td>도시 3의 관광지들을 방문</td>
		</tr>
		<tr>
			<td>4</td>
			<td>도시 3에서 도시 2로 이동</td>
		</tr>
		<tr>
			<td>5</td>
			<td>도시 2에서 도시 1로 이동</td>
		</tr>
		<tr>
			<td>6</td>
			<td>도시 1에서 도시 0으로 이동</td>
		</tr>
		<tr>
			<td>7</td>
			<td>도시 0의 관광지들을 방문</td>
		</tr>
	</tbody>
</table>

<p>지안지아가 방문할 수 있는 관광지들의 최대 개수를 계산하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 도시의 개수 n, 시작 도시의 번호 start, 휴가일의 수 d가 주어진다.</p>

<p>둘째 줄에는 도시 i의 관광지 개수가 0번 도시부터 순서대로 공백으로 구분해 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>지안지아가 방문할 수 있는 관광지의 최대 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2 7
10 2 20 30 1
','60
','DATA_STRUCTURE'),
                                                                                                                (6965,'BAEKJOON','https://www.acmicpc.net/problem/10129',10129,'작은 새','2초','256 MB',20,'<p>경기과학고의 뒤뜰에는 일렬로 된 n개의 나무로 이루어진 숲이 있다. 그 중 첫 번째 나무 위에는 마지막 나무의 위로 올라가고 싶어하는 작은 새가 한 마리 있다. 그 새는 몸집이 매우 작기 때문에 한 번의 비행으로 날아갈 수 있는 거리에 한계가 있다. 만약 새가 i번째 나무 위에 있다면, 이 새는 한 번의 비행으로 i+1, i+2, …, i+k번째 나무 중 하나로 갈 수 있으며 그보다 멀리 떨어진 나무로는 가지 못한다.</p>

<p>또한, 작은 새에게 지금 있는 나무보다 높은 나무로 올라가는 일은 낮은 나무로 내려가는 일보다 더 힘든 일이다. 작은 새는 자기가 현재 위치한 나무보다 <strong>같거나 높은 </strong>높이의 나무로 날아가면 피로감을 느낀다고 한다.</p>

<p>작은 새의 목표는 자신이 <strong>피로감을 느끼는 횟수</strong>를 최소화하면서 마지막 나무에 도달하는 것이다. 또한, 이 작은 새에게는 똑같이 최소한의 피로로 마지막 나무로 가고 싶어 하는 친구 새들이 있으며 이들의 k값은 서로 다를 수 있다. 작은 새와 친구 새들이 그들의 목표를 달성할 수 있도록 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 나무의 수를 나타내는 정수 n (2 ≤ n ≤ 1,000,000)이 주어진다.</p>

<p>다음 줄에는 n개의 정수 d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n&nbsp;</sub>(1 ≤ d<sub>i</sub> ≤ 10<sup>9</sup>) 가 주어진다. d<sub>i</sub>는 i번째 나무의 높이를 의미한다.</p>

<p>세 번째 줄에는 마지막 나무로 날아가고 싶어하는 새의 수 q (1 ≤ q ≤ 25)가 주어진다.</p>

<p>다음 q개 줄 중 i번째 줄에는 i번째 새가 한 번의 비행으로 날아갈 수 있는 거리인 k<sub>i</sub> (1 ≤ k<sub>i</sub> ≤ n-1)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>당신의 프로그램은 q줄에 걸쳐 답을 출력해야 한다. 출력의 i번째 줄에는 i번째 새가 마지막 나무에 도달할 때까지 피로감을 느끼는 횟수의 최솟값을 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제의 첫 번째 새는 1, 3, 5, 7, 8, 9번 나무를 거쳐 간다. 이 새는 3번째 나무에서 5번째 나무로 갈 때와 7번째 나무에서 8번째 나무로 갈 때, 총 두 번 피로감을 느낀다.</p>

				</div>
				</div>','9
4 6 3 6 3 7 2 6 5
2
2
5
','2
1
','DATA_STRUCTURE'),
                                                                                                                (6978,'BAEKJOON','https://www.acmicpc.net/problem/10167',10167,'금광','3초','256 MB',21,'<p>황금의 땅이라는 별명을 가진 나라가 있다. 이 나라에는 개발 되지 않은 많은 금광들이 존재한다. 이 금광들을 지도상에 표시할 때, 평면상의 점들로 표현한다.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/c94a9ed0-f79e-4fef-8873-47dfce1d88bd/-/preview/" style="width: 250px; height: 165px;"></p>

<p style="text-align: center;">그림-1</p>

<p>각 점 p<sub>i</sub>에는 양수 또는 음수의 정수 값 w<sub>i</sub>가 주어진다. 이 w<sub>i</sub>는 금광을 개발한다면 얻게 되는 이익 또는 손해를 나타낸다. w<sub>i</sub>가 양수이면, w<sub>i</sub>만큼의 이익이 발생함을 나타낸다. w<sub>i</sub>가 음수이면, |w<sub>i</sub>| 만큼의 손해가 발생함을 나타낸다.&nbsp;</p>

<p>금광 개발업자는 x축 또는 y축과 평행한 변들을 가진 직사각형 모양의 땅 R을 사서 R에 포함된 금광들을 모두 개발할 것이다. 이때 금광들을 개발하여 얻게 되는 개발 이익은 금광들의 w<sub>i</sub>들의 합이다.&nbsp;</p>

<p>개발업자는 R에 포함된 금광들의 개발 이익이 최대가 되는 직사각형 영역 R을 찾을 것이다. 예를 들어서, 위의 그림-1에서 개발 이익이 최대가 되는 영역 R은 그림-2에서 보여 지는 것과 같고 개발 이익은 7이다.&nbsp;</p>

<p>금광들의 좌표와 금광을 개발하면 얻게 되는 이익 또는 손해가 주어질 때, 직사각형 모양의 땅을 사서 얻게 되는 최대 개발 이익을 출력하는 프로그램을 작성하시오.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/dbc65c4c-888e-4c98-9716-2267098ce480/-/preview/" style="width: 250px; height: 165px;"></p>

<p style="text-align: center;">그림-2</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 금광들의 개수 N (1 ≤ N ≤ 3,000)이 주어진다. 이어지는 N개의 줄 각각에는 금광의 좌표 (x, y)를 나타내는 음이 아닌 두 정수 x와 y(0 ≤ x, y ≤ 10<sup>9</sup>), 그리고 금광을 개발하면 얻게 되는 이익 또는 손해를 나타내는 정수 w(-10<sup>9</sup> ≤ w ≤ 10<sup>9</sup>)가 주어진다. 금광의 좌표는 모두 서로 다르며 w > 0인 금광은 적어도 하나 존재한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 한 줄로 이루어진다. 금광 개발업자가 직사각형 모양의 땅 R을 사서 얻을 수 있는 최대 개발 이익을 출력한다. 계산 과정에서 32비트 정수 변수가 표현할 수 있는 범위를 넘어서 64비트 정수 변수(long long type)를 사용해야 할 수도 있음에 주의하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
2 8 2
5 5 3
3 3 -1
10 2 5
9 7 -2
6 7 -1
7 3 -1
','7
','DATA_STRUCTURE'),
                                                                                                                (6985,'BAEKJOON','https://www.acmicpc.net/problem/10169',10169,'안전한 비상연락망','1초','64 MB',22,'<p>산골에 N 개의 마을이 있으며 각각 두 마을을 잇는 M 개의 도로가 있다. 이 도로들은 전체 마을들을 모두 연결하고 있다. 즉, 어떤 마을에서든 다른 마을로 (하나 이상의 도로를 거쳐서) 갈 수 있다. 또한 어떤 인접한 두 마을은 두 개 이상의 도로로 바로 연결되기도 한다. 여러 가지 급한 상황이 생길 수 있기 때문에 전체 마을들을 연결하는 비상연락망을 구성하여 급한 상황을 알리기로 하였다. 비상연락망에 들어가는 도로의 경우에는 특별히 잘 관리해야 하므로 각 도로마다 관리 비용이 발생한다. 물론 비상연락망은 전체 관리 비용이 최소가 되도록 만든다.</p>

<p>이 지역에는 가끔 산사태가 발생하는데, 산사태가 발생하여 특정한 도로가 통행 불가능이 될 수 있다. 다행히도 통행 불가능이 되는 경우 오직 하나의 도로만이 그렇게 된다고 한다.&nbsp;</p>

<p>그러한 상황에 대비하기 위해서 각 도로마다, 그 도로가 통행 불가능이 되었다고 가정하고 비상연락망을 구성할 경우 전체 최소 비용이 얼마가 되는지 알고 싶다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/8afa3d21-e3bb-4699-8dd9-6884c55930b1/-/preview/" style="width: 208px; height: 211px;"></p>

<p style="text-align: center;">그림-1</p>

<p>그림-1은 어떤 산골마을의 예이다. 원이 마을이며, 선분이 도로이고, 도로 옆의 수는 그 도로에 해당하는 비용이다.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/a7d171bc-f378-461c-a2a7-30bfa190ceea/-/preview/" style="width: 208px; height: 211px;"></p>

<p style="text-align: center;">그림-2</p>

<p>그림-2는 모든 도로가 통행이 가능할 때의 비상연락망 구성이며, 굵은 선으로 표현된 도로들이 비상연락망에 포함된 것이다. 이때 전체 비용은 13이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/dc5c5037-d685-4b18-af20-35c0e062d0bc/-/preview/" style="width: 208px; height: 211px;"></p>

<p style="text-align: center;">그림-3</p>

<p>그림-3은 2번과 5번 마을을 잇는 도로가 통행 불가능인 경우의 비상연락망이며, 비용은 14이다. 그림-4는 1번과 2번 마을을 잇는 도로가 통행 불가능인 경우이며, 비용은 15이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/5af3b9cb-8b54-4fcf-81a1-374b99f8366e/-/preview/" style="width: 208px; height: 211px;"></p>

<p style="text-align: center;">그림-4</p>

<p>마을의 수와 연결하는 도로들, 그리고 각 도로에 해당하는 비용을 입력으로 받아서 각각의 도로에 대해서 그 도로가 통행 불가능인 경우의 비상연락망을 구성하는 최소 비용을 출력하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에는 마을의 수 N (2 ≤ N ≤ 100,000)과 도로의 수 M (2 ≤ M ≤ 300,000)이 자연수로 주어진다. 각 마을은 1번부터 번호가 붙은 것으로 생각한다. 이후 M 개의 줄에는 각각 3개의 자연수가 주어지는데, 첫 두 자연수는 해당 도로가 잇는 두 마을의 번호이며, 세 번째 자연수는 그 도로가 비상연락망에 포함될 경우의 관리 비용이다. 비용은 1 이상 10<sup>9</sup> 이하이다. 하나의 마을 쌍에 대해 여러 개의 도로가 존재할 수도 있으며, 서로 다른 도로가 같은 비용 값을 가질 수도 있음에 주의하라.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력에는 M개의 줄이 있어야하며, 각 줄에는 하나의 자연수가 있어야 한다. I 번째 줄에는 입력에 I 번째로 주어진 도로가 통행 불가능인 경우 비상연락망의 최소 비용을 자연수로 출력한다. 단, 비상연락망이 존재하지 않는다면 -1을 출력해야 한다. 비용의 값이 커질 수 있으므로 64비트 정수 변수(long long type)를 사용해야 할 수도 있음에 주의하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 9
1 2 1
3 1 4
4 3 6
2 4 7
2 5 2
5 3 5
1 5 3
5 4 7
2 4 8
','15
14
14
13
14
13
13
13
13
','DATA_STRUCTURE'),
                                                                                                                (7030,'BAEKJOON','https://www.acmicpc.net/problem/10534',10534,'락페스티벌','1초','256 MB',20,'<p>덕휘는 로맨틱펀치의 팬이다. 어느 날 그가 사는 마을에 로맨틱펀치가 락페스티벌 행사에 초청받아 공연을 왔다! 덕휘는 기뻐 날뛰기 시작했다. 그러나 마을 사람들은 조용한 것을 좋아해서 로맨틱펀치를 내쫓았다. 덕휘는 화가 나서 이렇게 된 이상 자신의 저택 뒤뜰에 로맨틱펀치를 초청하여 공연을 부탁하려고 한다.</p>

<p>그러나 뒤뜰을 쓴 지 오래돼서 이곳저곳에 잡초가 자라 있다. 잡초를 깎기는 귀찮은 덕휘는 남아있는 맨땅 중 그 면적이 가장 넓은 곳을 무대로 쓰려고 한다. 맨땅은 여러 개의 직사각형들로 이루어져 있고, 인접해 있는 직사각형들은 하나의 맨땅으로 친다. 이때, 모서리에서만 만나는 두 땅도 인접한 것으로 친다.</p>

<p>덕휘의 저택 뒤뜰에 있는 맨땅들 중 가장 넓은 면적은 얼마인지 알아내시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 잡초가 없는 땅 정보의 개수 N이 주어진다. (0 < N ≤ 50,000)</p>

<p>이어서 각 줄에 땅의 위치와 넓이 정보가 직사각형 형태로 주어진다. 차례대로 X, Y, W, H이며, 이는 땅의 제일 왼쪽 아래 지점이 (X, Y)이고 너비가 W, 높이가 H라는 뜻이다. 모든 땅의 변은 x축, y축에 평행하다. (0 < W, H ≤ 500)</p>

<p>입력으로 주어지는 땅의 모서리 좌표와 면적 값은 모두 32bit 정수 자료형으로 처리 가능하다. 또한, 입력의 모든 직사각형은 서로 겹치지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가장 넓은 땅 묶음의 면적을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제를 그림으로 나타내면 다음과 같다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images2/park.png" style="height:159px; width:290px"></p>

<p>그림에는 총 4개의 땅 묶음이 존재한다.</p>

<ul>
	<li>3, 4번: 넓이 16</li>
	<li>7, 1번: 넓이 20</li>
	<li>0, 2, 6번: 넓이 15</li>
	<li>5번: 넓이 16</li>
</ul>

<p>따라서 가장 큰 면적은 20이다.</p>

				</div>
				</div>','8
14 1 2 2
16 9 1 5
11 3 5 2
3 4 2 5
5 9 3 2
21 3 2 8
13 2 1 1
13 8 3 5
','20
','DATA_STRUCTURE'),
                                                                                                                (7036,'BAEKJOON','https://www.acmicpc.net/problem/10546',10546,'배부른 마라토너','1초','256 MB',7,'<p>마라토너라면 국적과 나이를 불문하고&nbsp;누구나 참가하고 싶어하는&nbsp;백준 마라톤 대회가 열린다. 42.195km를 달리는 이 마라톤은 모두가 참가하고 싶어했던 만큼 매년 모두가 완주해왔다. 단, 한 명만 빼고!&nbsp;</p>

<p>모두가 참가하고 싶어서 안달인데 이런 백준 마라톤 대회에 참가해 놓고 완주하지 못한 배부른&nbsp;참가자&nbsp;한 명은 누굴까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 참가자 수 N이&nbsp;주어진다. (1 ≤ N ≤ 10<sup>5</sup>)</p>

<p>N개의 줄에는 참가자의 이름이 주어진다.</p>

<p>추가적으로 주어지는 N-1개의 줄에는 완주한 참가자의 이름이 쓰여져 있다.&nbsp;</p>

<p>참가자들의 이름은 길이가 1보다 크거나 같고, 20보다 작거나 같은 문자열이고, 알파벳 소문자로만 이루어져 있다.</p>

<p>참가자들 중엔 동명이인이 있을 수도 있다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>마라톤을 완주하지 못한 참가자의 이름을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
leo
kiki
eden
eden
kiki
','leo
','DATA_STRUCTURE'),
                                                                                                                (7048,'BAEKJOON','https://www.acmicpc.net/problem/10605',10605,'드래곤 죽이기','2초','256 MB',17,'<p>드래곤 나라에는 N개의 도시와 M개의 도로가 있다. 도시들은 1번 부터 N번까지 번호가 붙어 있으며 각 도로는 두개의 도시를 연결한다. 이 N개의 도시에는 전체 합이 K마리인 D<sub>1</sub>, D<sub>2</sub>, ... D<sub>K</sub>드래곤이 살고 있다. 도시 C<sub>i</sub>에 살고 있는 드래곤 D<sub>i</sub>는 처음에 S<sub>i</sub>의 머리를 가지고 있다. 드래곤이 살아있는 동안 매 분 N<sub>i</sub>개의 새로운 머리가 자란다. 드래곤은 하나 이상의 머리가 남아 있으면 생존할 수 있다.</p>

<p>우린 드래곤을 처치하기 위해 워리어를 고용할것이다. 매 분마다 각 워리어는 인접한 도시로 이동하거나 자신이 머물고 있는 도시의 드래곤의 머리 하나를 자를 수 있다. 우리는 워리어가 매 분마다 취할 전략을 정할 수 있다. 또한 우리는 각 워리어가 머무는 최초 도시를 지정할 수 있다.</p>

<p>유한한 시간에 모든 드래곤을 죽이기 위해 필요한 최소 워리어 수를 구하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>여러 개의 테스트 케이스가 주어진다. 각 테스트 케이스의 첫 번째 줄에는 세개의 정수 N, M, K (1&nbsp;≤ N ≤ 300, 0 ≤ M ≤ N(N-1), 1 ≤ K ≤ 1000)가 주어진다. 그 후 M개의 줄이 주어진다. 각 줄에는 도시 a와 b 사이의 연결을 가리키는 두개의 정수 a, b (1 ≤ a ≠ b ≤ N)가 주어진다. 이후 K개의 줄이 주어진다. K개 줄의 i번째 줄에는 드래곤 D<sub>i</sub>에 대한 값 C<sub>i</sub>, S<sub>i</sub>, N<sub>i</sub> (1 ≤ C<sub>i</sub> ≤ N, 1 ≤ S<sub>i</sub> ≤ 10<sup>5</sup>, 0 ≤ N<sub>i</sub> ≤ 10<sup>5</sup>)이 주어진다. 0 0 0이 입력되면 테스트 케이스는 종료된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해 결과는 모든 드래곤을 죽일 수 잇는 최소 워리어 수를 출력해야한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 1 1
1 2
1 7 4
4 4 2
1 2
2 4
4 1
1 3
1 2 3
2 3 1
0 0 0
','5
2
','DATA_STRUCTURE'),
                                                                                                                (7000,'BAEKJOON','https://www.acmicpc.net/problem/10717',10717,'성벽','10초','512 MB',21,'<p>역사학자인 JOI 교수는 이전에 존재했던 IOI 왕국에 대해 연구하고 있다.</p>

<p>과거의 조사에 따르면, IOI 왕국은 세로 H 크기에 가로 W 크기이며, IOI 왕국의 수도는 방어를 위해 성벽으로 둘러싸여 있었다.</p>

<p>IOI 왕국의 수도를 둘러싸는 성벽은 다음과 같은 형태를 하고 있다:</p>

<ul>
	<li>성벽의 크기 s(s ≥ 3)가 있다.</li>
	<li>크기 s의 성벽은 s × s의 정사각형 영역에서 안의 (s-2) × (s-2) 정사각형 영역을 제외한 테두리 모양을 하고 있다.</li>
</ul>

<p>또 다른 조사에 의하면, 수도를 둘러싼 성벽의 크기는 L 이상이었다. 그리고 어떤 칸들에는 오래된 나무가 있는데, 나무가 있는 위치에는 성벽이 존재하지 않았음을 알고 있다.</p>

<p>JOI 교수는 이러한 사실들을 바탕으로 있을 수 있는 성벽의 가지 수를 알고 싶어한다. 이때, 성벽의 크기가 같더라도 위치가 다르면 서로 다른 성벽으로 간주한다.</p>

<p>IOI 왕국의 크기와, 성벽의 최소 크기, 그리고 나무의 위치들이 주어졌을 때 가능한 성벽의 가지 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에는 정수 H, W, L, P가 공백으로 구분되어 주어진다. 이는 IOI 왕국의 크기가 세로 H, 가로 W이며 성벽의 최소 크기는 L, 나무의 개수가 P라는 뜻이다.</p>

<p>다음 P 개의 줄에 나무의 위치가 A<sub>i</sub>, B<sub>i</sub>가 공백으로 구분되어 주어진다. 이는 나무가 A<sub>i</sub>번째 줄, B<sub>i</sub>번째 칸에 있음을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 가능한 성벽의 가지 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5 3 2
2 2
4 3
','4
','DATA_STRUCTURE'),
                                                                                                                (6993,'BAEKJOON','https://www.acmicpc.net/problem/10733',10733,'\(I\)교신자 1','3초','256 MB',9,'<p>방학 동안 어떤 일을 겪었는지 몰라도 현종이는 수 \(I\)를 신성시하는 \(I\)교에 입교하였다.</p>

<p>\(I\)교에서는 \(I\)는 물론,&nbsp;\(I\)와 사칙연산을 이용해 만들 수 있는 다른 많은 수를&nbsp;좋은 수라고 생각한다. \(I\)교에서 좋은 수들을 만드는 활동을 왕성히 펼치던 현종이는 아래와 같은 놀이를 통해 좋은 수들을 많이 만들어 좀 더 많은 사람에게 \(I\)교를 포교하고자 하였다.</p>

<p>이 놀이를 하기 위해서는 몇 개의 준비물이 필요하다.</p>

<ul>
	<li>앞/뒷면에 \(I\)가 그려진 카드 \(A\)개, \(+\)가 그려진 카드&nbsp;\(B\)개, \(\times\)가 그려진 카드&nbsp;\(C\)개.</li>
	<li>무한히 많은 개수의 \(I\)가 들어있는 스택. 이 스택은 수 \(I\)에 대한 무한한 믿음, 감사, 사랑을 의미하며, 또한 \(I\)에 내재한&nbsp;절대적인 진리와 불멸성을 상징한다.</li>
</ul>

<p>준비물이 마련되었으면, 놀이를 시작하자!&nbsp;우선 현종이는&nbsp;현재 가지고 있는 카드를 섞는다. 이는 \(I\)가 세상에 내려와 다른 만물과 어우러져 조화를 이루고 사랑으로 감싸줌을 의미한다.&nbsp;그다음 현종이는 카드를&nbsp;섞인 순서대로 뽑는데, 카드를 뽑을 때마다&nbsp;뽑힌 카드가&nbsp;어떤 카드인지에 따라 다음과 같은 작업을 수행할 것이다.</p>

<ul>
	<li>\(I\)가 그려진 카드가 뽑히면 : 스택에 \(I\)를 넣는다.</li>
	<li>\(+\)가 그려진 카드가 뽑히면 : 스택의 가장 위에 있는 두 수를 뽑은 후,&nbsp;이 두 수를&nbsp;더한 수를&nbsp;스택에&nbsp;넣는다.</li>
	<li>\(\times\)가 그려진 카드가&nbsp;뽑히면 : 스택의 가장 위에 있는 두 수를 뽑은 후, 이 두 수를&nbsp;곱한 수를 스택에 넣는다.</li>
</ul>

<p>모든 과정이 끝나면 스택에는 좋은 수들이 많이 쌓여 있을 것이다. 현종이는 스택에 있는 수많은 수&nbsp;중에서 스택의 가장 위에 있는 수는 가장 좋은 수일 것으로&nbsp;생각했다. 그렇게 생각했었다. 하지만 곧 현종이는 깨달았다. 다른 수들도 모두 좋은 수들일진대 감히 우열을 따질 수 있겠는가! 스택의 가장 위에 있는 수만이 아니라 그 밑에 있는 수들도 모두 좋은 수들일&nbsp;것이며, 수들은 카드의 배열에 따라&nbsp;모습을 바꾸어 현종이에게 자애로운 웃음을 지어줄 것이다!</p>

<p>그래서 현종이는 가능한 모든 카드 배열에 대해, 작업을 끝냈을 때&nbsp;스택의 가장 위에 있는 수들의 합을 구하기로 하였다. 또한, 가장 위에 있는 수뿐만 아니라 두 번째로 위에 있는 수들의 합, 세 번째로 위에 있는 수들의 합, ...,&nbsp;&nbsp;\(K\)번째로 위에 있는 수들의 합을 모두&nbsp;구하기로 하였다. 그러나 현종이는 가능한 카드 배열의 개수가 너무 많다는 것을 알고 당신에게 \(I\)교의 아름다움을 알리는 겸 이 일을 맡겼다. 현종이를 도와주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 \(I&nbsp;(1 \leq I \leq 10^9)\), \(A\), \(B\), \(C\) \((0 \leq A,B,C \leq 40)\), \(K&nbsp;(1 \leq K \leq 40)\)를 나타내는 다섯 정수가 공백으로 구분되어 주어진다. \(I\)는 \(I \)이며, \(A\)는 \(I\)가 그려진 카드의 개수, \(B\)는 \(+\)가 그려진&nbsp;카드의 개수, \(C\)는 \(\times\)가 그려진&nbsp;카드의 개수, \(K\)는 구하고자 하는 합의 개수이다.</p>

<p>이 문제는 세&nbsp;개의 부분 문제로 이루어져 있다.</p>

<p><a href="https://www.acmicpc.net/problem/10733" style="line-height: 1.6em;">1번 문제</a>의 입력은&nbsp;\(0&nbsp;\leq A+B+C \leq 15\)을 만족하며 해결하면 10점을 얻을 수 있다.</p>

<p><a href="https://www.acmicpc.net/problem/10734" style="line-height: 20.7999992370605px;">2번 문제</a>의 입력은&nbsp;\(K=1\)을 만족하며 해결하면 20점을 얻을 수 있다.</p>

<p><a href="https://www.acmicpc.net/problem/10735" style="line-height: 20.7999992370605px;">3번 문제</a>의 입력은 다른 제한이 없으며 해결하면 70점을 얻을 수 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>\(i\)번째 줄에&nbsp;모든 카드 배열에 대해 작업을 끝낸 후의 모든 스택에 대해 맨 위에서 \(i\)번째에 있는 수들의 합을 출력한다. 숫자가 너무 커질 수 있으므로 \(1,000,000,007\)로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1 1 1 1 1','10','DATA_STRUCTURE'),
                                                                                                                (7011,'BAEKJOON','https://www.acmicpc.net/problem/10773',10773,'제로','1초','256 MB',7,'<p>나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.</p>

<p>재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.</p>

<p>재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.</p>

<p>재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)</p>

<p>이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 "0" 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.</p>

<p>정수가 "0"일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 2<sup>31</sup>-1보다 작거나 같은 정수이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 2의 경우를 시뮬레이션 해보면,</p>

<ul>
	<li>[1]</li>
	<li>[1,3]</li>
	<li>[1,3,5]</li>
	<li>[1,3,5,4]</li>
	<li>[1,3,5] (0을 불렀기 때문에 최근의 수를 지운다)</li>
	<li>[1,3] (0을 불렀기 때문에 그 다음 최근의 수를 지운다)</li>
	<li>[1,3,7]</li>
	<li>[1,3] (0을 불렀기 때문에 최근의 수를 지운다)</li>
	<li>[1] (0을 불렀기 때문에 그 다음 최근의 수를 지운다)</li>
	<li>[1,6]</li>
</ul>

<p>합은 7이다.</p>

				</div>
				</div>','4
3
0
4
0
','0
','DATA_STRUCTURE'),
                                                                                                                (7013,'BAEKJOON','https://www.acmicpc.net/problem/10775',10775,'공항','1초(추가시간없음)','256 MB',14,'<p>오늘은 신승원의 생일이다.</p>

<p>박승원은 생일을 맞아 신승원에게 인천국제공항을 선물로 줬다.</p>

<p>공항에는 G개의 게이트가 있으며 각각은 1에서 G까지의 번호를 가지고 있다.</p>

<p>공항에는 P개의 비행기가 순서대로 도착할 예정이며, 당신은 i번째 비행기를 1번부터 g<sub>i</sub> (1 ≤ g<sub>i</sub> ≤ G) 번째 게이트중 하나에 영구적으로 도킹하려 한다. 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다.</p>

<p>신승원은 가장 많은 비행기를 공항에 도킹시켜서 박승원을 행복하게 하고 싶어한다. 승원이는 비행기를 최대 몇 대 도킹시킬 수 있는가?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 게이트의 수 G (1 ≤ G ≤ 10<sup>5</sup>)가 주어진다.</p>

<p>두 번째 줄에는 비행기의 수 P (1 ≤ P ≤ 10<sup>5</sup>)가 주어진다.</p>

<p>이후 P개의 줄에 g<sub>i</sub> (1 ≤ g<sub>i</sub> ≤ G) 가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>승원이가 도킹시킬 수 있는 최대의 비행기 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 1 : [2][?][?][1] 형태로 도킹시킬 수 있다. 3번째 비행기는 도킹시킬 수 없다.</p>

<p>예제 2 : [1][2][3][?] 형태로 도킹 시킬 수 있고, 4번째 비행기는 절대 도킹 시킬 수 없어서 이후 추가적인 도킹은 불가능하다.</p>

<p>&nbsp;</p>

				</div>
				</div>','4
3
4
1
1
','2
','DATA_STRUCTURE'),
                                                                                                                (7019,'BAEKJOON','https://www.acmicpc.net/problem/10799',10799,'쇠막대기','1초','256 MB',9,'<p>여러 개의 쇠막대기를 레이저로 절단하려고 한다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다. 쇠막대기와 레이저의 배치는 다음 조건을 만족한다.</p>

<ul>
	<li>쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.</li>
	<li>각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.</li>
	<li>레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다. </li>
</ul>

<p>아래 그림은 위 조건을 만족하는 예를 보여준다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10799/1.png" style="height:142px; width:267px"></p>

<p>이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다.</p>

<ol>
	<li>레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반드시 레이저를 표현한다.</li>
	<li>쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다. </li>
</ol>

<p>위 예의 괄호 표현은 그림 위에 주어져 있다.</p>

<p>쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다. </p>

<p>쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>한 줄에 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 공백없이 주어진다. 괄호 문자의 개수는 최대 100,000이다. </p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','()(((()())(())()))(())
','17
','DATA_STRUCTURE'),
                                                                                                                (7018,'BAEKJOON','https://www.acmicpc.net/problem/10815',10815,'숫자 카드','2초','256 MB',6,'<p>숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다.&nbsp;정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는&nbsp;-10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자&nbsp;카드에 같은 수가 적혀있는 경우는 없다.</p>

<p>셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도&nbsp;-10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각&nbsp;수가 적힌 숫자 카드를&nbsp;상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
6 3 2 10 -10
8
10 9 -5 2 3 4 5 -10
','1 0 0 1 1 0 0 1
','DATA_STRUCTURE'),
                                                                                                                (7020,'BAEKJOON','https://www.acmicpc.net/problem/10816',10816,'숫자 카드 2','1초','256 MB',7,'<p>숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.</p>

<p>셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
6 3 2 10 10 10 -10 -10 7 3
8
10 9 -5 2 3 4 5 -10
','3 0 0 1 2 0 0 2
','DATA_STRUCTURE'),
                                                                                                                (7021,'BAEKJOON','https://www.acmicpc.net/problem/10828',10828,'스택','0.5초(추가시간없음)','256 MB',7,'<p>정수를 저장하는&nbsp;스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.</p>

<p>명령은 총 다섯 가지이다.</p>

<ul>
	<li>push X: 정수 X를 스택에 넣는 연산이다.</li>
	<li>pop: 스택에서 가장 위에 있는&nbsp;정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
	<li>size: 스택에 들어있는 정수의 개수를 출력한다.</li>
	<li>empty: 스택이 비어있으면 1, 아니면 0을 출력한다.</li>
	<li>top: 스택의 가장 위에 있는 정수를 출력한다.&nbsp;만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다.&nbsp;둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','14
push 1
push 2
top
size
empty
pop
pop
pop
size
empty
pop
push 3
empty
top
','2
2
0
2
1
-1
0
1
-1
0
3
','DATA_STRUCTURE'),
                                                                                                                (7024,'BAEKJOON','https://www.acmicpc.net/problem/10845',10845,'큐','0.5초(추가시간없음)','256 MB',7,'<p>정수를 저장하는 큐를&nbsp;구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.</p>

<p>명령은 총 여섯 가지이다.</p>

<ul>
	<li>push X: 정수 X를 큐에 넣는 연산이다.</li>
	<li>pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
	<li>size: 큐에 들어있는 정수의 개수를 출력한다.</li>
	<li>empty: 큐가&nbsp;비어있으면 1, 아니면 0을 출력한다.</li>
	<li>front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
	<li>back:&nbsp;큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','15
push 1
push 2
front
back
size
empty
pop
pop
pop
size
empty
pop
push 3
empty
front
','1
2
2
0
1
2
-1
0
1
-1
0
3
','DATA_STRUCTURE'),
                                                                                                                (7027,'BAEKJOON','https://www.acmicpc.net/problem/10848',10848,'팔렘방의 다리','2초','256 MB',23,'<p>도시 팔렘방 시에는 무시강이라는 이름의 강이 있어 도시가 두 구역으로 나뉘어 있다. 두 구역을 구역 A와 구역 B라고 부르자.</p>

<p>각 구역에는 강변을 따라 정확히 1,000,000,001개의 빌딩이 있고, 순서 대로 0 부터 1,000,000,000까지 번호가 붙어 있다. 인접한 빌딩 간의 거리는 정확히 1 단위거리이다. 강의 폭도 1단위거리이다. 구역 A의 빌딩 i는 구역 B의 빌딩 i의 정확히 강 건너편에 위치한다.</p>

<p><em>N</em>명의 시민이 도시에서 살면서 일하고 있다. 시민 <em>i</em>는 구역 <em>P</em><sub><em>i</em></sub>의 빌딩 <em>S</em><sub><em>i</em></sub>에 살고 있고 사무실은 구역 <em>Q</em><sub><em>i</em></sub>의 빌딩 <em>T</em><sub><em>i</em></sub>에 있다. 사는 곳과 사무실이 다른 구역에 있는 경우에는 배를 타고 강을 건넜어야 했다. 물론 배를 타는 것이 불편하기 때문에 정부는 최대 <em>K</em>개의 다리를 건설해서 모든 시민이 배를 타지 않고 자동차로 출근이 가능하도록 만들고 싶다. 다리는 강 방향에 수직이라야 하며 겹칠 수 없다.</p>

<p><em>D</em><sub><em>i</em></sub>를 최대 <em>K</em>개의 다리들이 건설된 후 시민 <em>i</em>가 사는 곳에서 사무실 까지 운전해서 갈 수 있는 최소 거리라고 하자. <em>D</em><sub>1</sub> + <em>D</em><sub>2</sub> + ... + <em>D</em><sub><em>N</em></sub>의 값 최소가 되도록 다리를 건설하는 방법을 알아내는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에는 <em>K</em>와 <em>N</em>이 주어진다. 이후 <em>N</em>개의 줄에는 4개의 값 <em>P</em><sub><em>i</em></sub>, <em>S</em><sub><em>i</em></sub>, <em>Q</em><sub><em>i</em></sub>, <em>T</em><sub><em>i</em></sub>가 각각 주어진다.</p>

<ul>
	<li><em>P</em><sub><em>i</em></sub>와 <em>Q</em><sub><em>i</em></sub>는 한글자 A 혹은 B이다.</li>
	<li>0 ≤ <em>S</em><sub><em>i</em></sub>, <em>T</em><sub><em>i</em></sub> ≤ 1, 000, 000, 000</li>
	<li>사는 곳이나 사무실이 서로 다른 시민에 대해서 같은 빌딩에 위치할 수 있고, 한 시민의 사는 곳이 다른 시민의 사무실과 같은 빌딩에 위치하는 것도 가능하다.</li>
	<li>1 ≤ K ≤ 2</li>
	<li>1 ≤ N ≤ 100, 000</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 단 한줄이며 출근 거리 합의 최솟값을 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>두 입력 예 모두에 대한 그림이다.
</p>
<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10848/1.png" style="height:214px; width:416px"></p>

<p>입력 예 1에 대한 가능한 해답이다. 분홍색 부분이 다리이다.
</p>


<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10848/2.png" style="height:210px; width:410px"></p>

<p>입력 예 2에 대한 가능한 해답이다.
</p>


<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10848/3.png" style="height:216px; width:410px"></p>
				</div>
				</div>','1 5
B 0 A 4
B 1 B 3
A 5 B 7
B 2 A 6
B 1 A 7
','24
','DATA_STRUCTURE'),
                                                                                                                (7028,'BAEKJOON','https://www.acmicpc.net/problem/10866',10866,'덱','0.5초(추가시간없음)','256 MB',7,'<p>정수를 저장하는 덱(Deque)를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.</p>

<p>명령은 총 여덟 가지이다.</p>

<ul>
	<li>push_front X: 정수 X를 덱의 앞에 넣는다.</li>
	<li>push_back X: 정수 X를 덱의 뒤에 넣는다.</li>
	<li>pop_front: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
	<li>pop_back: 덱의 가장 뒤에&nbsp;있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
	<li>size: 덱에 들어있는 정수의 개수를 출력한다.</li>
	<li>empty: 덱이 비어있으면 1을, 아니면 0을 출력한다.</li>
	<li>front: 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
	<li>back: 덱의 가장 뒤에 있는 정수를 출력한다.&nbsp;만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','15
push_back 1
push_front 2
front
back
size
empty
pop_front
pop_back
pop_front
size
empty
pop_back
push_front 3
empty
front
','2
1
2
0
2
1
-1
0
1
-1
0
3
','DATA_STRUCTURE'),
                                                                                                                (7033,'BAEKJOON','https://www.acmicpc.net/problem/10868',10868,'최솟값','1초','256 MB',15,'<p>N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.</p>

<p>여기서 a번째라는 것은 입력되는 순서로 a번째라는 이야기이다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중에서 최솟값을 찾아야 한다. 각각의 정수들은 1이상 1,000,000,000이하의 값을 갖는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N, M이 주어진다. 다음 N개의 줄에는 N개의 정수가 주어진다. 다음 M개의 줄에는 a, b의 쌍이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>M개의 줄에 입력받은 순서대로 각 a, b에 대한 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 4
75
30
100
38
50
51
52
20
81
5
1 10
3 5
6 9
8 10
','5
38
20
5
','DATA_STRUCTURE'),
                                                                                                                (7032,'BAEKJOON','https://www.acmicpc.net/problem/10883',10883,'분할','1초','256 MB',18,'<p>경근이는 2차원 배열을 분할 정복하여 푸는 문제 “여왕벌”을 접하고 나서 2차원 배열을 분할 했을 때 배열이 어떻게 나뉘는지에 대해 관심이 생겼다.</p>

<p>배열을 분할하는 과정에서 현재 보고 있는 배열의 크기가 N × M 일 때 경근이는 이 배열을 최대한 크기가 비슷한 네 개의 배열로 나눈다. 정확하게 말하면 N ×M 크기의 배열은 \(\lfloor\)N/2\(\rfloor\) × \(\lfloor\)M/2\(\rfloor\), \(\lceil\)N/2\(\rceil\) × \(\lfloor\)M/2\(\rfloor\), \(\lfloor\)N/2\(\rfloor\) × \(\lceil\)M/2\(\rceil\), \(\lceil\)N/2\(\rceil\) × \(\lceil\)M/2\(\rceil\) 크기의 네 배열로 나눈다. \(\lfloor\)x\(\rfloor\)의 값은 x의 값에서 소수점 이하를 버림한 값이고, \(\lceil\)x\(\rceil\)의 값은 x의 값에서 소수점 이하를 올림한 값이다. 예를 들어 4 × 5 크기의 배열은 2 × 2 크기의 배열 두 개와 2 × 3 크기의 배열 두 개로 나뉘게 될 것이고, 5 × 5 크기의 배열은 2 × 2, 3 × 2, 2 × 3, 3 × 3 크기의 네 배열로 나뉘게 될 것이다.</p>

<p>만약 현재 보고 있는 배열의 N, M 중 단 하나라도 1이 되면 경근이는 분할을 중지하고 특별히 처리한다. 따라서 N × M 크기의 배열은 분할 결과 여러 개의 1 × K 크기의 (혹은 돌려서 K × 1 크기의 배열인데, K가 같으면 같은 종류라고 생각하자) 배열로 나뉘게 된다. N, M 이 주어질 때, N × M 크기의 배열을 분할하는 과정을 모두 끝낸 다음 생기는 1 × K 크기의 배열 종류의 개수와 각 종류에 대한 K 값과 그 개수를 출력하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T(1 ≤ T ≤ 10,000)가 주어진다. 이후 T 개의 테스트 케이스가 주어진다.</p>

<p>각 테스트 케이스는 처음 배열의 크기 N, M (1 ≤ N, M ≤ 10<sup>18</sup>)이 공백 하나로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 N × M 크기의 배열을 모두 분할한 다음 생기는 1 × K 크기의 배열의 종류의 개수를 출력한다. 이 값을 C 라고 하자.</p>

<p>다음 C 개의 줄에는 각 1 × K 크기의 배열에 대해 K 와 그 개수를 공백 하나로 구분하여 출력한다. 출력되는 K 는 오름차순이어야 하며, 개수는 너무 많을 수 있으므로 1,234,567,891로 나눈 나머지를 출력한다.</p>

<p>두 테스트 케이스 사이에 빈 줄을 출력하면 안 된다. 정확한 출력 형식은 입출력 예시를 참고한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
4 4
4 5
5 5
','1
1 16
2
1 12
2 4
2
1 13
2 6
','DATA_STRUCTURE'),
                                                                                                                (7035,'BAEKJOON','https://www.acmicpc.net/problem/10921',10921,'팀들','4초','512 MB',24,'<p>0번 부터 N-1번까지 번호가 매겨진 학생 N명이 있다. 선생님은 학생들을 위해 날마다 하나 이상의 프로젝트들을 준비한다. 각 프로젝트는 정해진 날에 학생들끼리 모인 팀에 의해 해결되어야한다. 물론 프로젝트들은 서로 다른 난이도를 가질 수 있다. 선생님은 각 프로젝트 별로 난이도에 따라 맡을 팀의 크기를 정해놓았다.</p>

<p>학생들마다 서로 들어갈 수 있는 팀의 크기가 다를 수 있다. 자세히 말하자면 i번 학생은 자신이 속하는 팀의 크기가 A[i]이상 B[i]이하가 되어야 한다. 각 날 별로 한 학생은 최대 하나의 팀에만 속할 수 있으며, 어떤 팀에도 속하지 않은 학생이 나올 수도 있다. 그리고 구성된 하나의 팀은 하나의 프로젝트만 맡는다.</p>

<p>선생님은 이미 다음 Q일 동안의 프로젝트들을 계획해놓았다. 선생님의 계획이 성사되도록 학생들이 팀을 구성할 수 있을지 판단하는 프로그램을 작성하시오.</p>

<p>N = 4명의 학생이 있고, Q = 2일 동안의 계획이 잡혀있다. 그리고 학생들이 속하는 팀 크기의 제한은 아래 표와 같다.</p>

<table class="table table-bordered" style="width:30%">
	<thead>
		<tr>
			<th>학생</th>
			<th>0</th>
			<th>1</th>
			<th>2</th>
			<th>3</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>A</th>
			<td>1</td>
			<td>2</td>
			<td>2</td>
			<td>2</td>
		</tr>
		<tr>
			<th>B</th>
			<td>2</td>
			<td>3</td>
			<td>3</td>
			<td>4</td>
		</tr>
	</tbody>
</table>

<p>첫째 날에는 M = 2개의 프로젝트가 계획 되어있다. 그리고 프로젝트를 해결하기 위해 정해놓은 팀의 크기는 K[0] = 1, K[1] = 3이다. 이 계획은 0번 학생이 팀의 크기가 1인 프로젝트에 참여 하고, 나머지 학생들이 팀의 크기가 3인 프로젝트에 참여하면 성사될 수 있다.</p>

<p>둘째 날에도 M = 2개의 프로젝트가 계획되어 있으며, 프로젝트를 해결하기 위해 정해놓은 팀의 크기는 K[0] = 1, K[1] = 1이다. 크기가 1인 팀에 들어갈 수 있는 학생이 한 명 밖에 없으므로이 경우에는 계획이 성사될 수 없다.</p>

<p>모든 학생에 대한 정보가 주어진다: N, A, B와 총 Q개의 날에 해당하는 정보가 주어지는데, 하루 에 하나씩이다. 각 정보는 그날 주어진 프로젝트의 수 M과 길이 M인 수열 K로 이루어지는데, K는 각 프로젝트에 필요한 팀의 크기를 저장하고 있다. 각각의 날마다, 여러분의 프로그램은 모든 팀을 구성할 수 있는지 여부를 리턴해야 한다.</p>

<p>다음 함수 init 와 can을 구현해야 한다:</p>

<ul>
	<li>init(N, A, B) ? 그레이더는 맨 처음 이 함수를 정확히 한 번만 호출한다.
	<ul>
		<li>N: 학생의 수.</li>
		<li>A: 길이가 N인 배열: A[i]는 학생 i가 들어갈 수 있는 최소의 팀 크기이다.</li>
		<li>B: 길이가 N인 배열: B[i]는 학생 i가 들어갈 수 있는 최대의 팀 크기이다.</li>
		<li>이 함수는 리턴 값이 없다.</li>
		<li>각 i = 0, ..., N-1 인 경우에 대하여 1 ≤ A[i] ≤ B[i] ≤ N이 만족된다.</li>
	</ul>
	</li>
	<li>can(M, K) ? init을 일단 호출한 뒤, 그레이더는 이 함수를 차례로 Q번 연속으로 호출하는데, 각 날짜에 대해서 한번씩 호출한다.
	<ul>
		<li>M: 이날 잡혀 있는 프로젝트의 수.</li>
		<li>K: 길이 M인 배열로, 각각의 프로젝트에 정해진 팀 크기.</li>
		<li>이 함수의 리턴값은 만약 모든 팀을 구성할 수 있다면 1이고, 그렇지 못하면 0이다.</li>
		<li>1 ≤ M ≤ N 을 만족하며, 각각 i = 0, ..., M-1에 대하여 1 ≤ K[i] ≤ N 이다. 모든 K[i] 값들의 총합은 N을 넘을 수 있다.</li>
	</ul>
	</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<ul>
	<li>1번 줄: N</li>
	<li>2번 ~ N+1번 줄: A[i] B[i]</li>
	<li>N+2번 줄: Q</li>
	<li>N+3 ~ N+Q+2번 줄: M K[0] K[1] … K[M - 1]</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 날짜에 대해서 can의 리턴값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2 4
1 2
2 3
2 3
2
2 1 3
2 1 1
','1
0
','DATA_STRUCTURE'),
                                                                                                                (7039,'BAEKJOON','https://www.acmicpc.net/problem/10922',10922,'말','2초','512 MB',20,'<p>만수르는 조상들과 마찬가지로 말을 키우는 것을 좋아한다. 그는 카자흐스탄에서 말을 제일 많이&nbsp;갖고 있다. 그렇지만 꼭 항상 그랬던 것은 아닌데, N년 전에만 해도 만수르는 그저 젊은이일 뿐이어서 말이 한마리밖에 없었다. 만수르는 돈을 많이 벌어서 부자가 되고 싶었다.</p>

<p>시간순으로 매 해를 0번 해부터 N-1번 해로 번호를 매기자. (즉, N-1번 해가 가장 최근이다.) 해마다 날씨는 말이 자라는데 영향을 미친다. 만수르가 기억하기로는, i번 해에 말의 마릿수가 늘어난 비율은 양의 정수 X[i]이다. 만약 i번 해 연초에 말이 h마리가 있었다면, 그 해 연말에는 말이 모두 h×X[i]마리가 된다.</p>

<p>말은 매해 연말에만 팔 수 있다. 만수르가 기억하기로 i번 해의 말값은 양의 정수 Y[i]였다. 즉, 매해 연말에 갖고 있는 말 중 팔 수 있는 말의 수에는 제약이 없고, 말 한마리 값은 Y[i]로 모두 같다.</p>

<p>만수르는 지난 N년 동안, 말을 파는 시기를 잘 정했다면 얼마나 많은 돈을 벌 수 있었을지가 궁금해졌다. 당신이 만수르를 방문했을 때 이 질문을 받게 되었다.</p>

<p>저녁동안 만수르의 기억은 점점 정확해져서, 총 M번의 수정을 하게 된다. 수정을 한 번 할 때마다 X[i]의 값 중 하나, 또는 Y[i]의 값 중 하나가 바뀐다. 수정을 한 번 할 때마다 만수르는 말을 팔아 서 벌 수 있는 돈의 최댓값을 물어본다. 만수르가 수정할 때마다, 수정된 내용들은 누적된다. 즉, 만수르에게 대답할 때는 지금까지 만수르가 한 수정들을 모두 반영해야 한다. 한 X[i] 또는 Y[i]가 여러 번 수정되는 경우도 가능하다.</p>

<p>만수르의 질문에 대한 답은 매우 큰 수일 수 있다. 큰 수를 다룰 때 생기는 문제를 피하기 위해서, 답을 10<sup>9</sup>+7로 나눈 나머지를 알려주면 된다.</p>

<p>N = 3년에 대해서 다음과 같은 정보가 주어졌다고 하자.</p>

<table class="table table-bordered" style="width:20%">
	<thead>
		<tr>
			<th>&nbsp;</th>
			<th>0</th>
			<th>1</th>
			<th>2</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>X</th>
			<td>2</td>
			<td>1</td>
			<td>3</td>
		</tr>
		<tr>
			<th>Y</th>
			<td>3</td>
			<td>4</td>
			<td>1</td>
		</tr>
	</tbody>
</table>

<p>이 초기 정보를 가지고, 만수르는 1번 해 연말에 모든 말을 다 팔았다면 가장 많은 돈을 벌 수 있다. 전체 과정은 다음과 같다.</p>

<ul>
	<li>처음에 만수르는 말이 한 마리 있다.</li>
	<li>0번 해 연말에 만수르는 1×X[0] = 2마리의 말이 있다.</li>
	<li>1번 해 연말에 만수르는 2×X[1] = 2마리의 말이 있다.</li>
	<li>이제 말 두 마리를 모두 팔 수 있다. 전체 이익은 2×Y[1] = 8이다.</li>
</ul>

<p>이제, M = 1번 수정을 하여 Y[1]이 2로 바뀌었다.</p>

<p>수정 후의 정보는 다음과 같다.</p>

<table class="table table-bordered" style="width:20%">
	<thead>
		<tr>
			<th>&nbsp;</th>
			<th>0</th>
			<th>1</th>
			<th>2</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>X</th>
			<td>2</td>
			<td>1</td>
			<td>3</td>
		</tr>
		<tr>
			<th>Y</th>
			<td>3</td>
			<td>2</td>
			<td>1</td>
		</tr>
	</tbody>
</table>

<p>이 경우, 최적해 중 하나는 한 마리를 0번 해 연말에 팔고 2번 해 연말에 세 마리를 파는 것이다. 전체 과정은 다음과 같다</p>

<ul>
	<li>처음에 만수르는 말이 한 마리 있다.</li>
	<li>0번 해 연말에 만수르는 1×X[0] = 2마리의 말이 있다.</li>
	<li>이제 이 중 한 마리를 Y[0] = 3에 팔 수 있고, 한 마리가 남아 있다.</li>
	<li>1번 해 연말에 만수르는 1×X[1] = 1마리의 말이 있다.</li>
	<li>2번 해 연말에 만수르는 1×X[2] = 3마리의 말이 있다.</li>
	<li>이제 말 세 마리를 모두 3×Y[2] = 3에 팔 수 있다. 전체 이익은 3 + 3 = 6이다.</li>
</ul>

<p>N, X, Y와 수정된 내용의 리스트가 주어진다. 첫 번째 수정을 하기 전과, 매번 수정을 한 다음에 대해서 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 10<sup>9</sup>+7로 나눈 나머지를 구하라. 이를 위해서 함수 init, updateX, updateY를 구현해야 한다.</p>

<ul>
	<li>init(N, X, Y) ? 그레이더는 이 함수를 맨 처음 정확히 한 번 호출한다.
	<ul>
		<li>N: 전체 해 수</li>
		<li>X: 길이 N인 배열. 0 ≤ i ≤ N-1일 때, X[i]는 i번 해 연말에 말의 마릿수가 늘어난 비율이다.</li>
		<li>Y: 길이 N인 배열. 0 ≤ i ≤ N-1일 때, Y[i]는 i번 해 연말에 말 한마리의 값이다.</li>
		<li>X와 Y는 만수르가 처음에 준 값을 나타낸다. (수정을 하기 전의 값)</li>
		<li>init 함수가 종료한 후, 배열 X와 Y는 유효한 주소에 있으며, 원한다면 이 배열의 내용을 수정할 수 있다.</li>
		<li>이 함수는 X와 Y의 초기값을 가지고 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 10<sup>9</sup>+7로 나눈 나머지를 리턴해야 한다.</li>
	</ul>
	</li>
	<li>updateX(pos, val)
	<ul>
		<li>pos: 0, ..., N-1 범위 내의 정수.</li>
		<li>val: X[pos]의 새로운 값.</li>
		<li>이 함수는 주어진 정보에 따라 수정을 한 후, 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 10<sup>9</sup>+7로 나눈 나머지를 리턴해야 한다.</li>
	</ul>
	</li>
	<li>updateY(pos, val)
	<ul>
		<li>pos: 0, ..., N-1 범위 내의 정수.</li>
		<li>val: Y[pos]의 새로운 값.</li>
		<li>이 함수는 주어진 정보에 따라 수정을 한 후, 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 10<sup>9</sup>+7로 나눈 나머지를 리턴해야 한다.</li>
	</ul>
	</li>
</ul>

<p>모든 X[i]와 Y[i]의 값은 항상 (즉, 처음에도, 매번 수정을 한 다음에도) 1이상 10<sup>9</sup>이하를 만족한다.</p>

<p>init을 호출한 후, 그레이더는 updateX와 updateY를 여러 번 호출할 것이다. updateX와 updateY의 전체 호출 회수는 M이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<ul>
	<li>1번 줄: N</li>
	<li>2번 줄: X[0] … X[N - 1]</li>
	<li>3번 줄: Y[0] … Y[N - 1]</li>
	<li>4번 줄: M</li>
	<li>5 ~ M + 4번 줄: type pos val에 해당하는 세 숫자 (type=1이면 updateX이고 type=2이면 updateY).</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>처음 init의 리턴값을 출력하고, 차례로 updateX와 updateY의 모든 호출에 대한 리턴값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
2 1 3
3 4 1
1
2 1 2
','8
6
','DATA_STRUCTURE'),
                                                                                                                (7043,'BAEKJOON','https://www.acmicpc.net/problem/10999',10999,'구간 합 구하기 2','2초','256 MB',17,'<p>어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째부터 4번째 수에&nbsp;6을&nbsp;더하면 1, 2, 9, 10, 5가 되고, 여기서 2번째부터 5번째까지 합을 구하라고 한다면 26을 출력하면 되는 것이다. 그리고 그 상태에서 1번째부터 3번째 수에&nbsp;2를 빼고&nbsp;2번째부터 5번째까지 합을 구하라고 한다면 22가 될 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c 또는 a, b, c, d가 주어지는데, a가 1인 경우 b번째 수부터 c번째 수에 d를&nbsp;더하고, a가 2인 경우에는 b번째 수부터 c번째 수의 합을 구하여 출력하면 된다.</p>

<p>입력으로 주어지는 모든 수는 -2<sup>63</sup>보다 크거나 같고, 2<sup>63</sup>-1보다 작거나 같은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -2<sup>63</sup>보다 크거나 같고, 2<sup>63</sup>-1보다 작거나 같은 정수이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2 2
1
2
3
4
5
1 3 4 6
2 2 5
1 1 3 -2
2 2 5
','26
22
','DATA_STRUCTURE'),
                                                                                                                (7045,'BAEKJOON','https://www.acmicpc.net/problem/11000',11000,'강의실 배정','1초','256 MB',11,'<p>수강신청의 마스터 김종혜 선생님에게 새로운 과제가 주어졌다.&nbsp;</p>

<p>김종혜 선생님한테는 S<sub>i</sub>에 시작해서 T<sub>i</sub>에 끝나는 N개의 수업이 주어지는데, 최소의 강의실을 사용해서 모든 수업을 가능하게 해야 한다.&nbsp;</p>

<p>참고로, 수업이 끝난 직후에 다음 수업을 시작할 수 있다. (즉, T<sub>i</sub> ≤ S<sub>j</sub> 일 경우 i 수업과 j 수업은 같이 들을 수 있다.)</p>

<p>수강신청 대충한 게 찔리면, 선생님을 도와드리자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 N이 주어진다. (1 ≤ N ≤ 200,000)</p>

<p>이후 N개의 줄에 S<sub>i</sub>, T<sub>i</sub>가 주어진다. (0 ≤ S<sub>i</sub> < T<sub>i</sub>&nbsp;≤&nbsp;10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>강의실의 개수를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 3
2 4
3 5
','2
','DATA_STRUCTURE'),
                                                                                                                (7047,'BAEKJOON','https://www.acmicpc.net/problem/11003',11003,'최솟값 찾기','2.4초(하단참고)','512 MB',16,'<p>N개의 수 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>과 L이 주어진다.</p>

<p>D<sub>i</sub> = A<sub>i-L+1</sub> ~ A<sub>i</sub> 중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. 이때, i ≤&nbsp;0 인 A<sub>i</sub>는 무시하고 D를 구해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 L이 주어진다. (1 ≤ L ≤ N ≤ 5,000,000)</p>

<p>둘째 줄에는 N개의 수 A<sub>i</sub>가 주어진다. (-10<sup>9</sup> ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 D<sub>i</sub>를 공백으로 구분하여 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12 3
1 5 2 3 6 2 3 7 3 5 2 6
','1 1 1 2 2 2 2 2 3 3 2 2','DATA_STRUCTURE'),
                                                                                                                (7046,'BAEKJOON','https://www.acmicpc.net/problem/11027',11027,'교환','1초','256 MB',21,'<p>길이 N의 배열 A와 정수 M이 있고. 지학이는 다음과 같은 프로그램을 짰다.</p>

<pre>for i<-1 to M do
    for j<-i+1 to N do
        if A[i]>A[j] then
            swap(A[i],A[j])
</pre>

<p>지학이는 이 프로그램에서 swap 함수가 몇번 작동되는지 궁금해서 여러분을 찾았다. 몇번 작동하는가?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스에는 다음과 같은 정보들이 주어진다.</p>

<p>첫 번째 줄에 자연수 N, M이 주어진다. (N, M < 10<sup>5</sup>)</p>

<p>두 번째 줄에 배열 A의 원소가 주어진다. (-10<sup>9</sup> ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 교환 횟수를 한 줄에 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
2 1 3
4 1
3 2 -1 -10
','1
3
','DATA_STRUCTURE'),
                                                                                                                (7061,'BAEKJOON','https://www.acmicpc.net/problem/11085',11085,'군사 이동','2초','256 MB',13,'<p>전쟁 당시 Baekjoon World의 국왕은 Cube World를 공격할 작전을 세운 적이 있습니다. Baekjoon World와 Cube World는 p개의 지점과 w개의 길로 표현됩니다. 모든 길은 양방향이며, 각 길마다 너비가 존재하여 이에 비례하는 수의 군사가 지나갈 수 있습니다.</p>

<p>Baekjoon World의 국왕은 군사들이 뭉치는 것이 유리하다고 생각해서, 미리 Cube World로 가는 경로를 정해 두고 그 경로로만 모든 군사를 보냈습니다. Baekjoon World의 국왕은 총명해서, 경로 상에 있는 길 중 너비가 가장 좁은 길의 너비를 최대화하는 경로를 택했습니다.</p>

<p>그런데 전쟁 때문에 어느 길로 보냈는지에 대한 기록이 불타 없어져 버렸습니다. 전쟁사를 완성하려면 이 기록이 꼭 필요합니다. 위대한 과학자인 당신이 다시 복구해 주세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 p와 w가 공백을 사이에 두고 주어집니다. (2 ≤ p ≤ 1 000; 1 ≤ w ≤ 50 000)</p>

<p>다음 줄에 Baekjoon World의 수도 c와 Cube World의 수도 v가 공백을 사이에 두고 주어집니다. (0 ≤ c, v < p; c ≠ v)</p>

<p>다음 w줄에 길이 연결하는 두 지점 w<sub>start</sub>, w<sub>end</sub>,와 길의 너비 w<sub>width</sub>가 공백을 사이에 두고 주어집니다. (0 ≤ w<sub>start</sub>, w<sub>end</sub> < p; w<sub>start</sub> ≠ w<sub>end</sub>; 1 ≤ w<sub>width</sub> ≤ 1 000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 Baekjoon World의 국왕이 정한 경로 상에 있는 길 중 너비가 가장 좁은 길의 너비를 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 11
3 5
0 1 15
0 2 23
1 2 16
1 3 27
2 4 3
2 6 21
3 4 14
3 5 10
4 5 50
4 6 9
5 6 42
','16
','DATA_STRUCTURE'),
                                                                                                                (7077,'BAEKJOON','https://www.acmicpc.net/problem/11279',11279,'최대 힙','1초(추가시간없음)(하단참고)','256 MB',9,'<p>널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.</p>

<ol>
	<li>배열에 자연수 x를 넣는다.</li>
	<li>배열에서 가장 큰 값을 출력하고, <span style="line-height:1.6em">그 값을 배열에서 제거한다. </span></li>
</ol>

<p><span style="line-height:1.6em">프로그램은 처음에 비어있는 배열에서 시작하게 된다.</span></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 2<sup>31</sup>보다 작다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','13
0
1
2
0
0
3
2
1
0
0
0
0
0
','0
2
1
3
2
1
0
0
','DATA_STRUCTURE'),
                                                                                                                (7079,'BAEKJOON','https://www.acmicpc.net/problem/11286',11286,'절댓값 힙','1초(추가시간없음)(하단참고)','256 MB',10,'<p>절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.</p>

<ol>
	<li>배열에 정수 x (x&nbsp;≠ 0)를 넣는다.</li>
	<li>배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.</li>
</ol>

<p>프로그램은 처음에 비어있는 배열에서 시작하게 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면&nbsp;배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 정수는 -2<sup>31</sup>보다 크고,&nbsp;2<sup>31</sup>보다 작다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 절댓값이 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','18
1
-1
0
0
0
1
1
-1
-1
2
-2
0
0
0
0
0
0
0
','-1
1
0
-1
-1
1
1
-2
2
0
','DATA_STRUCTURE'),
                                                                                                                (7088,'BAEKJOON','https://www.acmicpc.net/problem/11384',11384,'빨간 직사각형','1초','512 MB',21,'<p>N × M 크기의 격자판이 있다. 격자판의 각 칸은 빨간색 또는 파란색으로 색칠되어 있다. 편의상 i행 j열 (1 ≤ i ≤ N, 1 ≤ j ≤ M)의 격자를 (i, j)로 표시한다.</p>

<p>주어진 격자판 내에서 빨간색 격자로만 이루어진 직사각형의 개수를 세는 프로그램을 작성하자. 여기서 직사각형은 1 ≤ x<sub>1</sub> ≤ x<sub>2</sub> ≤ N, 1 ≤ y<sub>1</sub> ≤ y<sub>2</sub> ≤ M를 만족하는 네 개의 정수 x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>에 의해 결정되며, x<sub>1</sub> ≤ x ≤ x<sub>2</sub>와 y<sub>1</sub> ≤ y ≤ y<sub>2</sub>를 만족하는 모든 격자 (x, y)를 일컫는다. 예를 들어 x<sub>1</sub> = 2, y<sub>1</sub> = 3, x<sub>2</sub> = 4, y<sub>2</sub> = 4라면, 6개의 격자 (2, 3), (2, 4), (3, 3), (3, 4), (4, 3), (4, 4)가 모두 한 직사각형에 속한다. 두 직사각형이 서로 다르다는 것은 [x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>]이 서로 다르다는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 행의 수 N (1 ≤ N ≤ 3,000)과 열의 수 M (1 ≤ M ≤ 3,000)이 공백을 사이로 두고 주어진다.</p>

<p>다음 N개의 줄의 각 줄에는 M개의 문자가 주어진다. 이 중 i (1 ≤ i ≤ N)번째 줄은 주어진 격자판의 i번째 행의 격자에 칠해진 색들을 나타내며, 이 중 j번째 문자는 (i, j)에 칠해진 색을 나타낸다. 모든 문자는 R 또는 B로만 구성된다. R은 해당 칸이 빨간색임을, B는 해당 칸이 파란색임을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 빨간색 격자로만 이루어진 직사각형의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>5개의 직사각형은 다음과 같다. ([x1, y1, x2, y2]으로 나타냄)</p>

<ul>
	<li>[1, 1, 1, 1]</li>
	<li>[1, 1, 1, 2]</li>
	<li>[1, 2, 1, 2]</li>
	<li>[1, 1, 2, 1]</li>
	<li>[2, 1, 2, 1]</li>
</ul>

				</div>
				</div>','2 2
RR
RB
','5
','DATA_STRUCTURE'),
                                                                                                                (7098,'BAEKJOON','https://www.acmicpc.net/problem/11505',11505,'구간 곱 구하기','1초','256 MB',15,'<p>어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 곱을 구하려 한다. 만약에 1, 2, 3, 4, 5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 곱을 구하라고 한다면 240을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 곱을 구하라고 한다면 48이&nbsp;될 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수의 개수 N(1 ≤ N ≤&nbsp;1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 곱을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1 번째 줄까지 세 개의 정수 a,b,c가 주어지는데, a가 1인 경우 b번째 수를 c로 바꾸고 a가 2인 경우에는 b부터 c까지의 곱을 구하여 출력하면 된다.</p>

<p>입력으로 주어지는 모든 수는 0보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 K줄에 걸쳐 구한 구간의 곱을 1,000,000,007로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2 2
1
2
3
4
5
1 3 6
2 2 5
1 5 2
2 3 5
','240
48
','DATA_STRUCTURE'),
                                                                                                                (7107,'BAEKJOON','https://www.acmicpc.net/problem/11531',11531,'ACM 대회 채점','1초','256 MB',4,'<p>이 대회의 채점 프로그램은 각 팀별로 시간 순서대로 쌓인&nbsp;제출 로그를 분석하여 결과를 낸다. 각각의 로그는 제출 시각, 문제 이름, 제출 결과(통과, 실패)를 포함하고 있다. 예를 들어, 어떤 팀의 가상 제출 로그가 아래와 같다고 하자.</p>

<pre>3 E right
10 A wrong
30 C wrong
50 B wrong
100 A wrong
200 A right
250 C wrong
300 D right</pre>

<p>팀의 순위를 산정하기 위한 점수는 푼 문제 수를 우선으로, 푼 문제 수가 같다면 페널티를 기준으로 매겨진다. 페널티는 푼 문제에 대해서만 매겨지며, 문제를 맞힌 시각 + 틀린 횟수*20으로 정해진다. 만일 아무 문제도 풀지 못했다면 페널티는 0이다.</p>

<p>위의 예제에서, 우리는 이 팀이 세 개의 문제를 해결했음을 알 수가 있다. 대회 시각 3분째에 첫 제출로&nbsp;문제 E를 해결했으며, 문제 A에 대해서는 세 번을 제출하여 200분째에&nbsp;정답을 받았고, 문제 D는 300분째에 한 번의 제출로 해결하였다. 위 로그를 기반으로 산정한 페널티는 543이 되는데, 이는 E를 해결한 시각 3과 A를 해결한 시각 200, A를 두 번 틀린 페널티 40, D를 해결한 시각 300을 더한 값이다. 문제 B와 C에 대해서도 제출 기록은 있지만, 해결하지 못했으므로 페널티에는 영향을 주지 않았다.</p>

<p>대회 룰에 따르면, 만일 팀이 어떤 문제를 해결했다면 그 문제에 대한 추가적인 제출은 모두 무시된다(따라서 로그에도 남지 않는다). 제출 시각이 연속적으로 기록되지 않고 이산화되어있기 때문에, 같은 시각에 여러 제출이&nbsp;있을 수도 있다. 하지만 제출 자체는 시간 순으로 이루어졌으므로, 같은 시각에 같은 문제를 제출한 로그가 남아 있다면 마지막 제출을 제외한 모든 제출은 오답이었을 것이다.</p>

<p>두 번째 예시로, 아래의 제출 로그를 보자.</p>

<pre>7 H right
15 B wrong
30 E wrong
35 E right
80 B wrong
80 B right
100 D wrong
100 C wrong
300 C right
300 D wrong</pre>

<p>위 팀은 4개의 문제를 해결했으며, 총 페널티는 502가 된다. 이는 H번에 대해 7, E번에 대해 35+20, B번에 대해 80+40, C번에 대해 300+20을 합산한 값이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>로그가 n줄에 걸쳐 주어진다. (0 ≤ n ≤ 100)</p>

<p>각 로그는 공백으로 구분된 세 파트로 이루어지며,&nbsp;정수 m, 문제 이름, 결과를 의미한다. (0 ≤ m&nbsp;≤ 300, 문제 이름은 알파벳 대문자, 결과는 "right"&nbsp;또는 "wrong")</p>

<p>로그는 제출 시각이 감소하지 않는 순서로 주어지며, 동일한 시각에 제출된 로그가 여러 개일 수도 있다.</p>

<p>모든 로그가&nbsp;주어진&nbsp;뒤&nbsp;마지막 줄엔&nbsp;정수 -1 하나가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>푼 문제 수와 총 걸린 시간(페널티 포함)을&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 E right
10 A wrong
30 C wrong
50 B wrong
100 A wrong
200 A right
250 C wrong
300 D right
-1
','3 543
','DATA_STRUCTURE'),
                                                                                                                (7100,'BAEKJOON','https://www.acmicpc.net/problem/11652',11652,'카드','1초','256 MB',7,'<p>준규는 숫자 카드 N장을 가지고 있다. 숫자 카드에는 정수가 하나 적혀있는데, 적혀있는 수는 -2<sup>62</sup>보다 크거나 같고, 2<sup>62</sup>보다 작거나 같다.</p>

<p>준규가 가지고 있는 카드가 주어졌을 때, 가장 많이 가지고 있는 정수를 구하는 프로그램을 작성하시오. 만약, 가장 많이 가지고 있는 정수가 여러 가지라면, 작은 것을 출력한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 준규가 가지고 있는 숫자 카드의 개수 N (1 ≤&nbsp;N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 숫자 카드에 적혀있는 정수가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 준규가 가장 많이 가지고 있는 정수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1
2
1
2
1
','1
','DATA_STRUCTURE'),
                                                                                                                (7102,'BAEKJOON','https://www.acmicpc.net/problem/11658',11658,'구간 합 구하기 3','1초','256 MB',17,'<p>N×N개의 수가 N×N 크기의 표에 채워져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 표의 i행 j열은 (i, j)로 나타낸다. (x<sub>1</sub>, y<sub>1</sub>)부터 (x<sub>2</sub>, y<sub>2</sub>)까지 합이란 x<sub>1</sub> ≤ x ≤ x<sub>2</sub>, y<sub>1</sub> ≤ y ≤ y<sub>2</sub>를 만족하는 모든 (x, y)에 있는 수의 합이다.</p>

<p>예를 들어, N = 4이고, 표가 아래와 같이 채워져 있는 경우를 살펴보자.</p>

<table class="table table-bordered" style="width:20%">
	<tbody>
		<tr>
			<td style="text-align:center">1</td>
			<td style="text-align:center">2</td>
			<td style="text-align:center">3</td>
			<td style="text-align:center">4</td>
		</tr>
		<tr>
			<td style="text-align:center">2</td>
			<td style="text-align:center">3</td>
			<td style="text-align:center">4</td>
			<td style="text-align:center">5</td>
		</tr>
		<tr>
			<td style="text-align:center">3</td>
			<td style="text-align:center">4</td>
			<td style="text-align:center">5</td>
			<td style="text-align:center">6</td>
		</tr>
		<tr>
			<td style="text-align:center">4</td>
			<td style="text-align:center">5</td>
			<td style="text-align:center">6</td>
			<td style="text-align:center">7</td>
		</tr>
	</tbody>
</table>

<p>여기서 (2, 2)부터 (3, 4)까지 합을 구하면 3+4+5+4+5+6 = 27이 된다. (2, 3)을 7로 바꾸고 (2, 2)부터 (3, 4)까지 합을 구하면 3+7+5+4+5+6=30 이 된다.</p>

<p>표에 채워져 있는 수와 변경하는 연산과 합을 구하는 연산이 주어졌을 때, 이를 처리하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 표의 크기 N과 수행해야 하는 연산의 수 M이 주어진다. (1 ≤ N ≤ 1024, 1 ≤ M ≤ 100,000) 둘째 줄부터 N개의 줄에는 표에 채워져있는 수가 1행부터 차례대로 주어진다. 다음 M개의 줄에는 네 개의 정수 w, x, y, c 또는 다섯 개의 정수 w, x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>가 주어진다. w = 0인 경우는 (x, y)를 c (1 ≤ c ≤ 1,000)로 바꾸는 연산이고, w = 1인 경우는 (x<sub>1</sub>, y<sub>1</sub>)부터 (x<sub>2</sub>, y<sub>2</sub>)의 합을 구해 출력하는 연산이다. (1 ≤ x<sub>1</sub> ≤ x<sub>2</sub> ≤ N, 1 ≤ y<sub>1</sub> ≤ y<sub>2</sub> ≤ N) 표에 채워져 있는 수는 1,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>w = 1인 입력마다 구한 합을 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5
1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 7
1 2 2 3 4
0 2 3 7
1 2 2 3 4
0 3 4 5
1 3 4 3 4
','27
30
5
','DATA_STRUCTURE'),
                                                                                                                (7101,'BAEKJOON','https://www.acmicpc.net/problem/11666',11666,'워크스테이션 배정','10초','256 MB',13,'<p>찬솔이는 최근 새로 만들어진 슈퍼컴퓨터의 관리를 맡고 있다. 그의 업무는, 연구원들이 슈퍼컴퓨터로 계산을 하려 할 때마다 워크스테이션을 연구원들에게 배정해 주는 것이다.</p>

<p>여기까지는 좋은데, 찬솔이는 매우 게을러서 연구원들이 올 때마다 기계를 잠금 해제하는 것을 귀찮아하기 시작했다. 원격 조종도 가능하긴 한데 아무튼 귀찮은 모양이다. 결국 찬솔이는 보안 규정을 무시하고, 연구원들이 떠나기 전에 워크스테이션을 잠그고 떠나지 말아줄 것을 부탁하기로 했다. 이렇게 하면, 새 연구원들이 왔을 때 잠금이 풀린 빈 워크스테이션에 배정해주면 되니까, 훨씬 일이 덜 귀찮아질 것이다.</p>

<p>애석하게도, 빈 워크스테이션은 m분을 초과하는 시간동안 작업이 없을 때, 자동으로 잠겨진다. 즉 찬솔이가 귀찮게 다시 잠금을 풀어야 한다는 것을 뜻한다. 찬솔이는 각각의 연구원들의 슈퍼컴퓨터 사용 스케줄을 모두 가지고 있다. 찬솔이가 최적의 방법을 사용해서 워크스테이션을 배정한다면, 잠금 해제를 몇번 덜 할 수 있을까? 워크스테이션은 충분하다고 가정해도 괜찮다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 다음과 같이 주어진다 :&nbsp;</p>

<ul>
	<li>첫 번째 줄에 연구원의 수 n (1 ≤ n ≤ 300 000), 워크스테이션이 자동으로 잠기는 기준 시간 m (1 ≤ m ≤ 10<sup>8</sup>) 이 주어진다.&nbsp;</li>
	<li>n개의 줄에 a와 s가 주어진다. (1 ≤ a, s ≤ 10<sup>8</sup>) 연구원들은 a분에 도착해서, 정확히 s분동안 머무른다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>찬솔이가 절약할 수 있는 잠금 해제 횟수의 최댓값을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5
1 5
6 3
14 6
','2
','DATA_STRUCTURE'),
                                                                                                                (7109,'BAEKJOON','https://www.acmicpc.net/problem/11796',11796,'수행평가 1','1초','256 MB',14,'<p>최재현은 이번 알고리즘 수행 평가를 위한 문제를 만들지 못한 관계로, 선생님께 대신 길이가 N인 수열 A를 뇌물로 드렸다.</p>

<p>수열 A는 길이가 N이며, M보다 작거나 같은 자연수로 이루어진 수열이다. 재현이는 모든 원소가 M보다 작거나 같은 수열을 아름답다고 생각하고, 선생님도 그렇게 생각할 거라고 생각해서 이를 뇌물로 드렸다.&nbsp;</p>

<p>애석하게도, 구재현 역시 이번 알고리즘 수행 평가를 위한 문제를 만들지 못했고, 급해진 재현이는 빨리 자신만의 아름다운 수열 B를 만들어서 선생님께 드리려고 결심했다.</p>

<p>하지만, 선생님은 이미 재현이에게 아름다운 수열 A를 받았고 충분히 감동하신 상태이다. 선생님은 재현이가 준 수열 B가 "재현이의 수열 A의 <strong>연속된 부분 수열</strong>이라면" 재현이의 수열이 표절이라고 판단하고 재현이에게 F를 줄 예정이다.&nbsp;</p>

<p>시간이 없는 재현이는, 수열의 길이를 최소화해서 선생님에게 드릴 예정이다. 재현이가 만들 수 있는 수열의 최소 길이와, 해당 길이를 가지는 수열의 개수를 10^9 + 7로 나눈 나머지를 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 N, M이 주어진다. (1 <= N, M <= 100000)</p>

<p>두 번째 줄에 N개의 정수 Ai가 주어진다. (1 <= Ai <= M)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>수열의 최소 길이와, 그러한 수열의 개수를 10^9 + 7로 나눈 나머지를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8 2
1 2 1 1 2 2 2 2
','3 3
','DATA_STRUCTURE'),
                                                                                                                (7116,'BAEKJOON','https://www.acmicpc.net/problem/11833',11833,'돌 무게 재기','1초','256 MB',20,'<p>승현이는 N개의 돌을 주워서 무게가 증가하는 순서대로 놓았습니다. 두 돌의 무게가 같은 경우는 없습니다. 가장 가벼운 돌에게는 1순위, 두 번째로 가벼운 돌에게는 2순위, ..., 가장 무거운 돌에게는 N순위가 주어졌습니다.</p>

<p>승현이에게는 양팔 저울이 있어서 모든 돌을 양팔 저울 위에 임의의 순서대로 놓기로 했습니다. 승현이가 어떤 순서대로 저울의 어떤 접시에 돌을 놓을 것인지는 알려져 있습니다.</p>

<p>여러분은 승현이가 돌을 얹을 때마다 저울이 어느 쪽으로 기우는지 알아내는 프로그램을 작성해야 합니다. 승현이는 각 돌의 정확한 무게를 알려주지 않습니다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 돌의 수 N (1≤N≤100, 000)이 주어집니다. 다음 N개 줄에는 두 개의 정수 R(1≤R≤N)과 S(1≤S≤2)이 주어집니다. R은 저울에 얹을 돌의 순위이고 S는 돌을 얹을 저울의 접시 번호입니다. 모든 R은 서로 다릅니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>저울에 돌을 얹을 때마다, 만약 저울이 1번 접시 쪽으로 기울면(1번 쪽이 더 무거우면) <strong>></strong>를, 2번 접시 쪽으로 기울면(2번 쪽이 더 무거우면) <strong><</strong>를, 어느 쪽이 더 무거운지 확실히 할 수 없다면 <strong>?</strong>를 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
3 1
2 1
4 2
5 1
','<
>
>
?
>
','DATA_STRUCTURE'),
                                                                                                                (7136,'BAEKJOON','https://www.acmicpc.net/problem/11866',11866,'요세푸스 문제 0','2초','512 MB',6,'<p>요세푸스 문제는 다음과 같다.</p>

<p>1번부터 N번까지 N명의 사람이 원을 이루면서&nbsp;앉아있고, 양의 정수 K(≤ N)가&nbsp;주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.</p>

<p>N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가&nbsp;빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>예제와 같이 요세푸스 순열을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 3
','<3, 6, 2, 7, 5, 1, 4>
','DATA_STRUCTURE'),
                                                                                                                (7138,'BAEKJOON','https://www.acmicpc.net/problem/11873',11873,'최대 직사각형','3초','512 MB',18,'<p>1과 0으로 이루어진 NxM크기의 행렬이 주어졌을 때, 1로만 이루어진 가장 큰 직사각형 부분 행렬 찾는 프로그램을 작성하시오.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 N과 M이 주어진다. (1 ≤ N,M ≤ 1,000) 다음 N개의 줄에는 공백으로 구분된 M개의 수가 주어진다. 마지막 줄에는 0이 두 개가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서 가장 큰 직사각형의 넓이를 출력한다. 만약 그런 직사각형이 없을 때는 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5
0 1 0 1 1
1 1 1 1 1
0 1 1 1 0
1 1 1 1 1
3 4
1 1 1 1
1 1 1 1
1 1 1 1
6 6
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0
','9
12
0
','DATA_STRUCTURE'),
                                                                                                                (7139,'BAEKJOON','https://www.acmicpc.net/problem/11882',11882,'괄호 채우기','1초','256 MB',20,'<p>괄호열이란 2개의 기호 <code>(</code>와 <code>)</code>를 이용해서 만들 수 있는 모든 문자열을 말합니다. 괄호열에 "<code>+</code>"과 "<code>1</code>"을 적당히 끼워넣으면 올바른 수식이 만들어질 때, 우리는 이를 올바른 괄호열이라고 합니다. 예로 들어, "<code>(()(()))</code>", "<code>()(()(())())</code>"은 올바른 괄호열이고, "<code>)(</code>", "<code>(()))()</code>"은 올바른 괄호열이 아닙니다.</p>

<p>저는 여러분에게 괄호열을 활용한 아주 쉬운 문제를 내고, 입력 데이터를 만들었습니다. 각 입력 데이터에는 올바른 괄호열이 들어가 있습니다. 그런데 이 채점 데이터를 열어보니, 괄호열의 일부가 아래와 같이 <code>?</code>로 바뀌어 있었습니다! 불행 중 다행으로, 각 <code>?</code>는 무조건 1개의 <code>(</code> 또는 <code>)</code> 기호가 깨진 것임을 알 수 있었습니다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11882/1.png" style="height: 102.5px; width: 360.833px;"></p>

<p>저는 모든 입력 데이터를 복구하고자 합니다. 그러나 단순하게 복구하면 데이터가 제가 의도했던 것보다 훨씬 쉬워질 것 같으니, 저는 왼쪽에서 i번째에 위치한 <code>?</code>마다 <code>(</code>로 바꾸는데 드는 비용 l<sub>i</sub>와 <code>)</code>로 바꾸는데 드는 비용 r<sub>i</sub>를 계산해 놓았습니다.</p>

<p>여러분은 비용이 가장 적게 들도록 각 물음표를 <code>(</code> 또는 <code>)</code>로 적당히 치환하여 올바른 괄호열을 만들어 내는 프로그램을 작성해야 합니다. 괄호열을 복구하는 데 드는 총 비용은 각 물음표를 <code>(</code>나 <code>)</code>로 바꾸는 데 드는 비용의 합입니다. 이러한 경우가 여러 개 있으면 아무거나 만들면 됩니다. 제가 좋은 데이터를 만들 수 있도록 도와주세요! ㅠㅠ</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 손상된 괄호열의 길이 N (N은 짝수, 2 ≤ N ≤ 100,000)이 주어지고, 두 번째 줄에 <code>(</code>, <code>)</code>, <code>?</code>로만 구성된 손상된 괄호열이 주어집니다. 손상된 괄호열에서 <code>?</code>의 빈도수를 Q (1 ≤ Q ≤ N)라고 할 때, Q개 줄에 두 자연수 l<sub>i</sub>와 r<sub>i</sub> (1 ≤ l<sub>i</sub>, r<sub>i</sub> ≤ 10<sup>5</sup>)가 공백을 사이로 두고 주어집니다. (1 ≤ i ≤ Q)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 최소 비용을 출력하고, 두 번째 줄에 복구한 괄호열을 출력합니다. 최소 비용으로 만들 수 있는 괄호열이 여러 개 있으면 아무거나 출력하면 됩니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
(??)
3 5
7 4
','7
(())
','DATA_STRUCTURE'),
                                                                                                                (7141,'BAEKJOON','https://www.acmicpc.net/problem/11897',11897,'간선 파괴','3초','128 MB',20,'<p>승현이는 곧 개최되는 KOI 전국본선을 대비하기 위해 그래프 이론을 공부하고 있습니다. 요즘 승현이는 깊이우선탐색(DFS)과 너비우선탐색(BFS)의 매력에 푹 빠져 있고, 이를 이용한 문제들을 풀고 있다고 합니다. 지금 승현이는 V개 정점과 E개 간선으로 구성된 무향 그래프가 주어질 때 컴포넌트의 수를 세는 문제를 풀고 있습니다. 문제에서는 편의상 정점들에는 1,2,?,V의 번호를, 간선들에는 1,2,?,E의 번호를 붙이고, 중복된 간선은 없다고 가정했습니다.</p>

<p>참고: 여기서 무향 그래프가 간선으로 서로 연결되지 않은 몇 개의 그룹으로 나뉘어 있을 때, 각 연결된 정점들의 부분집합을 컴포넌트라고 합니다. 예로 들어, 아래 [그림 1]에서는 {1,2,5,8}, {3}, {4,6,7}이 각각 하나의 컴포넌트를 이루고 있습니다. [그림 2]와 같이 그래프 전체가 하나의 컴포넌트로 구성되어 있을 수도 있습니다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11897/1.png" style="height: 117.5px; width: 375.833px;"></p>

<p>승현이는 당연히 문제를 보자마자 코딩을 시작하여 DFS를 사용한 올바른 코드를 작성했지만 0점을 받았습니다. 승현이의 선생님께서 코드를 보고 "재귀 함수를 사용했다"면서 채점조차 하지 않았기 때문입니다.(?) 화가 난 승현이는 주어진 그래프에서 <code>l</code>,&nbsp;<code>l+1</code>,&nbsp;<code>l+2</code>, ...,&nbsp;<code>r-1</code>,&nbsp;<code>r</code>번 간선들을 <code>destroy(l, r)</code> 함수로 파괴하기 시작합니다. (번호가 연속적인 이유는 파괴하기 편해서라고 합니다.)</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11897/2.png" style="height: 109.167px; width: 333.333px;"></p>

<p style="text-align: center;">[그림 3] 위 그림에서 간선 위에 쓰인 빨간색 번호는 그 간선의 번호를 의미합니다. 승현이가 <code>destroy(3, 5)</code>를 호출하여 3, 4, 5번 간선이 파괴되었습니다.</p>

<p>그러나 승현이보다 유능한 프로그래머인 여러분은 재귀 함수를 이용하지 않고 컴포넌트의 수를 구할 수 있기 때문에, 간선이 파괴된 그래프의 컴포넌트 수를 구한 뒤 <code>recover(l, r)</code> 함수를 호출해 파괴된 <code>l</code>, <code>l+1</code>, <code>l+2</code>, ..., <code>r-1</code>, <code>r</code>번 간선들을 복구하여 승현이를 약올리고자 합니다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11897/3.png" style="height: 120px; width: 340.833px;"></p>

<p style="text-align: center;">[그림 4] 위 그림에서 여러분은 파괴된 그래프의 컴포넌트 수(2)를 구한 뒤 <code>recover(3, 5)</code> 함수를 호출하여 간선을 복원했습니다.</p>

<p>그러자 승현이는 <code>destroy</code> 함수를 계속 호출했고, 이에 일일이 대응하기에 지친 여러분은 프로그램을 작성하여 이 복잡한 작업을 대신 하게 하려고 합니다. 이제 프로그램을 작성하면 되겠네요! :)</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 주어진 그래프의 정점의 수 V, 간선의 수 E가 공백을 사이로 두고 주어집니다. 이후 E개 줄에 간선들의 정보가 주어집니다. 이 중 i (1 ≤ i ≤ E)번째 줄에는 두 개의 정수 u<sub>i</sub>,v<sub>i</sub> (1 ≤ u<sub>i</sub>, v<sub>i</sub> ≤ V)가 공백을 사이로 두고 주어지는데, 이는 그래프에서 두 정점 u<sub>i</sub>와 v<sub>i</sub> 사이에 i번 간선이 그여 있다는 것을 의미합니다. 위에서 명시했듯이, 그래프에서 두 노드 사이에 간선은 최대 1개 존재하며, 주어진 그래프는 무향 그래프입니다.</p>

<p>그 다음 줄에 승현이가 <code>destroy</code> 함수를 호출한 횟수 Q가 주어집니다. 이후 Q개 줄에 <code>destroy</code> 함수의 파라미터 l과 r (1 ≤ l ≤ r ≤ E)이 공백을 사이로 두고 주어집니다. (5 ≤ V ≤ 700, 1 ≤ E ≤ 123,456, 1 ≤ Q ≤ 50,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>여러분은 승현이가 <code>destroy</code> 함수를 호출할 때마다 파괴된 그래프의 컴포넌트 수를 구하여 한 줄에 하나씩 출력한 뒤, 그래프를 다시 복원해야 합니다. 승현이는 자비롭기 때문에 여러분이 그래프를 복구한 후에야 <code>destroy</code> 함수를 호출합니다.</p>

<p>&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>위 [그림 3]에서 주어진 그래프와 같습니다.</p>

<p>&nbsp;</p>

				</div>
				</div>','5 6
1 3
2 5
1 4
2 3
1 5
5 4
2
3 5
1 6
','2
5
','DATA_STRUCTURE'),
                                                                                                                (7143,'BAEKJOON','https://www.acmicpc.net/problem/11915',11915,'전선 연결하기','1초','64 MB',22,'<p>석환이는 "Lightballb"라는 상품을 판매합니다. Lightballb 한 세트에는 두 개의 같은 자연수 번호가 적혀 있는 공이 들어있습니다. 이 공은 평상시에는 공의 역할을 하다가, 같은 번호가 쓰여 있는 두 공을 전선으로 연결하면 전구의 역할을 한다고 합니다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11915/1.png" style="height: 107.5px; width: 340px;"></p>

<ol>
	<li>같은 번호가 쓰여 있는 두 개의 공이 전선으로 연결되어 있으므로 전구가 켜집니다.</li>
	<li>한 공에 전선이 연결되어 있으므로 전구는 켜지지 않습니다.</li>
	<li>전선이 연결되어 있지 않으므로 전구는 켜지지 않습니다.</li>
	<li>서로 다른 번호가 쓰여 있는 두 개의 공이 전선으로 연결되어 있으므로 전구가 켜지지 않습니다.</li>
</ol>

<p>승현이는 석환이의 상품이 전혀 팔리지 않는다는 소식을 듣고, 석환이를 돕기 위해 n개의 Lightballb 세트를 구매했습니다. 따라서 승현이는 2n개의 공을 가지고 있으며, 1 이상 n 이하의 모든 자연수 k에 대해 k가 적혀 있는 공은 정확히 2개입니다.</p>

<p>승현이는 방대한 공들을 보관할만한 장소를 찾다가, 아래와 같이 생긴 길쭉한 보관함을 찾고 그 안에 공을 무작위로 넣었습니다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11915/2.png" style="height: 46.6667px; width: 345.833px;"></p>

<p>다음 날, 승현이는 공을 사용하기 위해 보관함에서 공을 꺼내려고 시도했지만, 공들은 꼼짝도 하지 않았습니다! 공이 반짝반짝 빛나는 모습을 보고 싶던 승현이는 절망감에 빠졌습니다. 낙담하고 있던 그 때, 승현이는 전선이 보관함을 뚫고 들어간다는 사실을 알아냈습니다! 승현이는 공들에 전선을 잘 꽂아 모든 공들이 빛나는 모습을 보고자 합니다.</p>

<p>무턱대고 전선을 끼우면 고장이 날 우려가 있기 때문에, 승현이는 미리 전선을 어떻게 연결할지에 대한 계획을 수립하려고 합니다. 우선, 승현이는 보관함과 전선이 움직이는 것을 방지하기 위해, 이들을 반드시 바닥 위에 놓기로 했습니다. 하지만, 이것만으로는 위험에 대비할 수 없다고 생각한 승현이는 다음과 같은 규칙을 세웁니다.</p>

<ol>
	<li>합선의 우려가 있으므로, 전선끼리 서로 교차하면 안 된다.</li>
	<li>한 전선의 모든 부분은 보관함의 위에 있거나 보관함의 아래에 있어야 한다.</li>
</ol>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11915/3.png" style="height: 349.167px; width: 335.833px;"></p>

<p>위 3개의 그림 모두 보관함을 위에서 내려다본 모습을 나타낸 것입니다.</p>

<ul>
	<li>(A)는 모든 규칙을 만족합니다.</li>
	<li>(B)는 2번 공을 잇는 전선과 3번 공을 잇는 전선이 교차하므로 1번 규칙을 만족하지 않습니다.</li>
	<li>(C)는 4번 공을 잇는 전선이 보관함의 위에 있기도 하면서 보관함의 아래에도 있기도 하므로(?) 2번 규칙을 만족하지 않습니다.</li>
</ul>

<p>승현이는 위 규칙을 만족하면서 전선을 연결하여 모든 공이 빛나도록 할 수 있는 방법이 존재하는지 알고자 합니다. 하지만 전구의 개수가 너무 많아 스스로 해결할 수 없었고, 여러분에게 도움을 요청했습니다. 승현이의 보관함에 적혀 있는 공의 번호가 차례대로 주어질 때, 각 공의 전선이 보관함 위에 있어야 하는지, 아래에 있어야 하는지를 결정하는 프로그램을 작성하세요.</p>

<p>&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 자연수 n이 주어집니다.</p>

<p>두 번째 줄에 a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>2n - 1</sub>, a<sub>2n</sub>이 공백을 사이로 두고 차례대로 주어집니다. 여기서 a<sub>i</sub>는 승현이의 보관함에서 왼쪽에서부터 i번째에 위치한 공에 적혀 있는 번호를 나타냅니다.</p>

<ul>
	<li>1 ≤ n ≤ 300, 000</li>
	<li>모든 i (1 ≤ i ≤ 2n)에 대해, 1 ≤ a<sub>i</sub> ≤ n</li>
	<li>모든 k (1 ≤ k ≤ n)에 대해, k는 수열 a에서 정확히 2번 나타납니다.</li>
</ul>

<p>&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>만약 주어진 조건을 만족하면서 모든 공을 빛나게 하는 방법이 존재하지 않는다면, "IMPOSSIBLE" (따옴표 제외)를 출력합니다.</p>

<p>만약 방법이 존재한다면, 첫 번째 줄에 길이가 2n인 문자열을 출력합니다. 이 중 i (1 ≤ i ≤ 2n)번째 글자는, 왼쪽에서 i번째에 위치한 공에 꽂는 전선이 보관함 위에 있어야 한다면 ^, 보관함 아래에 있어야 한다면 v이어야 합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2 3 2 3 1 4 4
','^^v^v^vv
','DATA_STRUCTURE'),
                                                                                                                (7140,'BAEKJOON','https://www.acmicpc.net/problem/11920',11920,'버블 정렬','1초','64 MB',19,'<p>버블 정렬이란, 두 인접한 원소를 검사하여 자리를 바꾸는 방식으로 길이가 N인 수열을 정렬하는 알고리즘이다. 버블 정렬은 아래와 같은 단계를 총 N번 진행하면 된다.</p>

<ul>
	<li>첫 번째 값과 두 번째 값을 비교하여 첫 번째 값이 더 크면 자리를 바꾼다.</li>
	<li>두 번째 값과 세 번째 값을 비교하여 두 번째 값이 더 크면 자리를 바꾼다.</li>
	<li>…</li>
	<li>N - 1번째 값과 N번째 값을 비교하여 N - 1번째 값이 더 크면 자리를 바꾼다.</li>
</ul>

<p>세찬이는 버블 정렬의 결과는 당연히 알기에 버블 정렬의 중간 과정을 알아보려고 한다. 하지만 N이 매우 크므로 위와 같은 단계를 K번 하면 시간이 오래 걸린다. 세찬이를 도와 버블 정렬의 중간 과정을 구하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 N과 K가 주어진다.</p>

<p>두 번째 줄에는 처음 수열의 상태가 주어진다. 즉, 처음 수열을 이루는 N개의 정수가 공백을 사이로 두고 차례대로 주어진다.</p>

<ul>
	<li>1 ≤ N ≤ 100,000</li>
	<li>1 ≤ K ≤ N</li>
	<li>수열의 각 항은 1 이상 1,000,000,000 이하의 정수이다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>위 단계를 K번 한 후 수열의 상태를 출력한다.</p>

<p>&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 1
62 23 32 15
','23 32 15 62
','DATA_STRUCTURE'),
                                                                                                                (7144,'BAEKJOON','https://www.acmicpc.net/problem/11932',11932,'트리와 K번째 수','1.5초','512 MB',22,'<p>1번부터 N번까지 번호가 붙여진 N개의 정점과 N-1개의 간선으로 구성된 트리가 있다. 트리의 각 정점에는 가중치가 있다. 이때 M개의 질문에 대해 다음의 연산을 수행해야 한다.</p>

<p>연산 X Y K : 정점 X와 Y를 잇는 경로 상에서 K번째로 작은 가중치를 출력한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 두 개의 양의 정수 N과 M이 주어진다. (1 ≤ N, M ≤ 100,000)</p>

<p>둘째 줄에는 각 정점의 가중치를 나타내는 N개의 정수가 주어진다. i번째 정수는 i번 정점의 가중치이다. 이 가중치는 모두 서로 다른 값들이며 int 범위이다.</p>

<p>다음 N-1개의 각 줄에는 트리의 간선 (X, Y)를 나타내는 두 정수 X와 Y가 주어진다.</p>

<p>다음 M개의 각 줄에는 연산을 나타내는 세 양의 정수 X Y K가 주어진다. X, Y는 1 이상이고 N 이하이다. K는 1 이상이고 X와 Y를 잇는 경로 상의 정점의 개수 이하이다. X와 Y가 같다면, 경로 상의 정점의 개수는 1개라 간주한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>M개의 줄에 걸쳐서 각 연산에 해당하는 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 2
1 2 3
1 2
3 1
2 3 1
1 3 2
','1
3
','DATA_STRUCTURE'),
                                                                                                                (7152,'BAEKJOON','https://www.acmicpc.net/problem/11941',11941,'핀볼','1초','512 MB',22,'<p>상수는 Pinball이라는 게임을 좋아합니다. Pinball의 규칙은 다음과 같습니다.</p>

<p>Pinball의 놀이판은 (M+2)행 N열의 정사각형 격자들로 구성된 격자판입니다. 놀이판의 첫 번째 줄은 판의 꼭대기이고, (M+2)번째 줄은 바닥입니다. i번째 행의 j번째 열에 있는 정사각형 격자는 (i,j)로 표현됩니다.</p>

<p>공은 놀이판의 첫 번째 줄에 있는 격자들 중 하나에 나타나서, 바닥을 향해 수직으로 떨어집니다. 다시 말해, 만약 어떤 공이 (1, i) (1 ≤ i ≤ N)에 나타났다면, 이는 (j, i) (2 ≤ j ≤ M+1)을 통과하여, 바닥의 (M+2, i) 격자에 도착할 것입니다. 상수는 공을 성공적으로 되받아 친다면 점수를 얻게 됩니다.</p>

<p>어느 날, 상수는 공을 되받아치기 어렵다는 것을 눈치챘는데, 공이 바닥의 어떤 격자에나 등장할 수 있기 때문입니다. 상수는 아래에 설명된 장치들을 놀이판 위에 적절하게 설치하여 공이 도달할 수 있는 바닥의 격자가 단 하나 있도록 하려고 합니다.</p>

<p>1이상 M 이하의 번호가 붙은 M개의 장치들이 있습니다. 각 장치는 놀이판의 행들과 평행합니다. i (1 ≤ i ≤ M)번째 장치는 (i+1, A<sub>i</sub>)부터 (i+1, B<sub>i</sub>)까지의 격자들에 위치해 있습니다. 따라서 이 장치는 총 B<sub>i</sub>?A<sub>i</sub>+1개의 격자들을 덮습니다. 만약 공이 이 장치가 설치되어 있는 격자에 닿는다면, 공은 (i+1, C<sub>i</sub>)로 운반될 것입니다. 그 이후, 이동한 공은 C<sub>i</sub>번 열을 따라 수직하게 떨어질 것입니다. 하나의 장치는 공과 한 번 이상 상호 작용하지 않을 것입니다.</p>

<p>상수가 i번째 장치를 설치하기 위해서는 D<sub>i</sub>원을 지불해야 합니다. 상수는 M개의 장치들 중 일부를 골라서 놀이판에 설치하여, 공이 도달할 수 있는 바닥의 격자가 단 하나 존재하도록 할 것입니다. 상수는 장치들을 효율적으로 설치하여 총 비용을 줄이고자 합니다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11941/1.png" style="height:195px; text-align:center; width:193px"></p>

<p>그림: Pinball의 놀이판의 예시입니다. M = 2, N = 4. 공이 첫 번째 행(꼭대기)의 격자 (1, 2)에 등장합니다. 그 다음, 이 공은 (2, 2)로 움직인 후 1번 장치에 의하여 (2, 3)으로 이동할 것입니다. 이 공은 마침내 바닥의 격자 (4, 3)에 도착합니다.</p>

<p>놀이판의 크기와 장치들의 정보가 주어질 때, 공이 도달할 수 있는 바닥 격자가 단 하나 존재하도록 장치들을 설치하기 위한 최소 비용을 구하는 프로그램을 작성하세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로부터 다음 데이터를 입력받으세요:</p>

<ul>
	<li>입력의 첫 번째 줄에는 두 개의 정수 M,N이 공백을 사이로 두고 주어집니다. 이것은 이 놀이판이 (M+2)개의 행과 N개의 열을 가지고 있으며 장치의 수는 M개임을 의미합니다.</li>
	<li>다음 M개 줄들 중 i번째 줄 (1 ≤ i ≤ M)에는 네 개의 정수 A<sub>i</sub>,B<sub>i</sub>,C<sub>i</sub>,D<sub>i</sub>가 공백을 사이로 두고 주어집니다. 이것은 i번째 장치가 (i+1, A<sub>i</sub>)에서부터 (i+1,&nbsp;B<sub>i</sub>)까지의 격자에 설치되어 있다는 것을 의미합니다. i번째 장치는 총 B<sub>i</sub>?A<sub>i</sub>+1개의 격자를 덮습니다. i번째 장치는 자신이 덮고 있는 격자에 도달한 공을 (i+1, C<sub>i</sub>)로 운반할 것입니다. i번째 장치를 설치하기 위해서 D<sub>i</sub>원의 비용이 발생합니다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력의 첫 번째 줄에 공이 도달할 수 있는 바닥 격자가 단 하나 존재하도록 장치들을 설치하기 위한 최소 비용을 출력하세요. 만약 이 조건을 만족하도록 장치를 놓는 것이 불가능하다면, ?1을 출력하세요.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>놀이판과 장치들의 위치는 아래 그림과 같습니다. 각 장치 위에 쓰인 수들은 이 장치를 설치하기 위해 필요한 비용을 나타냅니다.</p>

<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11941/2.png" style="height:322px; width:278px"></p>

<p>다섯 개의 장치들 중 2번째, 4번째, 5번째 장치를 두면, 놀이판은 아래와 같게 됩니다.</p>

<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11941/3.png" style="height:322px; width:276px"></p>

<p>그러면, 꼭대기의 어떤 격자에 공이 등장하더라도 이 공은 바닥의 (7, 3)에 도달할 것입니다. 이들 장치를 설치하는 데에 드는 총 비용은 25원입니다. 여러분은 25를 출력해야 하는데, 25원보다 적은 비용을 들이면서 공이 도달할 수 있는 바닥의 격자가 단 하나 존재하도록 할 수 없기 때문입니다.</p>

				</div>
				</div>','5 6
2 4 3 5
1 2 2 8
3 6 5 2
4 6 4 7
2 4 3 10
','25
','DATA_STRUCTURE'),
                                                                                                                (7163,'BAEKJOON','https://www.acmicpc.net/problem/11989',11989,'단층','2초','256 MB',23,'<p>먼 옛날, IOI 문명이라는 고도의 문명이 번성했다. 그러나 화산 분화로 인해이 고도의 문명은 결국 망하고 말았다. IOI 문명은 직선 모양의 하천을 따라 번영하였고, IOI 문명이 멸망했을 때, 그 지표면은 평평했다. IOI 문명의 유적지는 좌표 평면의 x축으로 간주할 수있다. y축은 높이 방향을 나타낸다. 즉, 좌표 평면에서, 직선 y = 0 은 지표를, 영역 y > 0 은 지상을, 영역 y < 0 은 지하를 나타낸다. 또한 IOI 문명이 멸망했을 때, a 년전 (a ? 0) 지층은 직선 y = -a 의 위치에 있었다.</p>

<p>IOI 문명이 멸망한 후 IOI 문명의 유적지에서는 Q 번의 지각 변동이 일어났다. i 번째 (1 ? i ? Q)의 지각 변동은 위치 X<sub>i</sub>, 방향 D<sub>i</sub>, 변동의 양 L<sub>i</sub>로 표현된다. D<sub>i</sub>는 1 또는 2이다. i번째의 지각 변동은 다음과 같이 일어난다.</p>

<ul>
	<li>지층의 이동이 다음과 같이 일어난다.
	<ul>
		<li>D<sub>i</sub> = 1 일 때, 단층이 점 (X<sub>i</sub>, 0)을 지나는 기울기 1의 직선을 따라 만들어져, 이 직선보다 위쪽의 영역에 있는 지층이, 직선을 따라 높이 L<sub>i</sub>만큼 이동한다. 즉, 이 직선보다 위쪽에 있는 점 (x, y)는 점 (x + L<sub>i</sub>, y + L<sub>i</sub>)로 이동한다.</li>
	</ul>

	<ul>
		<li>D<sub>i</sub> = 2 일 때, 단층이 점 (X<sub>i</sub>, 0)을 지나는 기울기 -1의 직선을 따라 만들어져, 이 직선보다 위쪽의 영역에 있는 지층이, 직선을 따라 높이 L<sub>i</sub>만큼 이동한다. 즉, 이 직선보다 위쪽에 있는 점 (x, y)는 점 (x - L<sub>i</sub>, y + L<sub>i</sub>)로 이동한다.</li>
	</ul>
	</li>
	<li>그 직후, 영역 y > 0 의 지층이 풍화에 의해 모두 사라진다.</li>
</ul>

<p>시간이 흘러 현대에, 고고학자 JOI 박사는 IOI 문명의 유적을 발굴하기로했다. JOI 박사는 어느 위치의 표면의 지층이 IOI 문명이 멸망하기 몇 년전의 지층인지 알고 싶다. 그동안 어떤 지각 변동이 일어났는지는 알고 있다. 당신의 작업은 JOI 박사를 대신하여 1 ? i ? N 을 만족하는 각각의 정수 i에 대해, 점 (i-1, 0)과 점 (i, 0) 사이의 표면의 지층이 IOI 문명이 멸망하기 몇 년 전의 지층인가를 알아내는 것이다.</p>

<p>IOI 문명의 유적지에 일어난 지각변동의 정보가 주어졌을 때, 모든 정수 i (1 ? i ? N)에 대해 점 (i - 1, 0)과 점 (i, 0) 사이의 표면의 지층 이 IOI 문명이 멸망하기 몇 년 전의 지층인가를 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준입력으로 아래의 정보를 읽어들여라.</p>

<p>첫째 줄에는 두 개의 정수 N, Q가 공백을 사이에 두고 주어진다. 이는 답을 구해야 하는 지층의 수가 N, 지각변동의 수가 Q라는 것을 나타낸다.</p>

<p>이어 Q개의 줄 중 i번째 줄 (1 ? i ? Q) 에는, 세 개의 정수 X<sub>i</sub>, D<sub>i</sub>, L<sub>i</sub>가 공백을 사이에 두고 주어진다. 이는 지각변동의 위치가 X<sub>i</sub>, 방향이 D<sub>i</sub>, 변동의 양이 L<sub>i</sub>이었다는 것을 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 N개의 줄로 되어있다.</p>

<p>표준출력의 i번째 줄 (1 ? i ? N) 에는, 점 (i ? 1, 0) 과 점 (i, 0) 의 사이의 지표의 지층이 IOI 문명이 멸망하기 몇 년 전의 지층인가를 나타내는 정수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 2
12 1 3
2 2 2
','3
3
5
5
5
5
5
5
2
2
','DATA_STRUCTURE'),
                                                                                                                (7156,'BAEKJOON','https://www.acmicpc.net/problem/12009',12009,'중국 잡동사니 가게의 소 장식품 (Platinum)','5초','512 MB',24,'<p>농부 John은 자기 집을 좀 더 꾸밀 필요가 있다고 생각했습니다. 중국 물품 가게에 갔다가 그는 섬세한 유리 소 장식품을 발견했고, 벽난로 선반에 놓으면 딱 적당할 것 같아서 그만 구매하기로 했습니다.</p>

<p>소 장식품의 모양은 아래에 나와있는 것처럼 (3 <= N, M <= 500) 인 N x M 형태의 문자 배열로 적혀있고, 소문자 영어가 (각각이 다른 색인) 장식품의 각 부분을 나타냅니다. . 기호는 아무것도 없는 빈 공간입니다.</p>

<pre>...............
...............
x..x...........
xxxx...........
xxxxaaaaaaa...
.xx.aaaaaaaaa..
....aaaaaaa.aa.
....ll...ll....
....vv...vv....
...............
</pre>

<p>안타깝게도 농부 John이 이 장식품을 구매하기 바로 직전에 이놈의 황소가 가게를 가로질러 날아가더니, 농부 John이 사기로 했던 장식물 말고도 선반에 있던 다른 여러 장식물까지 박살내버렸네요! 농부 John의 조각상은 3조각으로 나뉘었는데, 결국 바닥에 떨어져있는 (4 <= K <= 100)인 모두 K개의 조각들 사이에 섞여서 사라져버렸네요. 각 조각은 위의 소 조각상처럼 문자 배열로 적혀있습니다.</p>

<p>농부 John이 (바닥에 떨어진 K조각 중) 다시 이어붙여 소로 만들 수 있는 3조각의 조합을 얼마나 만들 수 있는지 파악하도록 도와주세요.</p>

<p>바닥에 떨어진 조각은 가로로 혹은 세로로 뒤집어져 있거나, 90도씩 회전되어 있을 수 있습니다. 그래서 K개의 주어진 조각의 배열에서, 원래 모양대로 만들 수 있는 3개의 조각의 조합을 찾기 위해, 조각을 이동하거나, 뒤집거나, 90도씩 회전할 수 있습니다. 그렇게 조각들을 놓았을 때, 놓여진 3조각이 각각의 원래 조각과 색상까지 완전히 동일하게 일치해야 합니다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄은 단일 정수 K가 주어집니다. 다음 줄부터는 K + 1개의 조각을 설명합니다. 첫 번째 조각은 원래 소 장식품의 모양이 기술되고, 다음 줄 부터는 K개의 조각들의 모양을 설명합니다.</p>

<p>각각의 조각 설명은 두 정수 R, C (1 <= R, C <= 100) 이 적혀있는 줄로 시작합니다. 뒤따라 나오는 R개의 줄에는 각 칸의 색을 표현하는 한 줄에 C개씩의 소문자 알파벳이 나옵니다. 각 조각은 수직 / 수평으로 이어져있고 적어도 하나의 비어있는 칸이 있습니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>원래 조각을 만들 수 있는 조각 i, j, k (i < j < k)의 조합의 개수를 출력하세요.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>세 해결방법은 조각 (0, 1, 2), (0, 2, 4), (1, 3, 4) 를 사용합니다.</p>

				</div>
				</div>','5
5 5
aaaaa
..a..
bbabb
..a..
aaaaa
3 5
..abb
..a..
aaaaa
5 2
a.
a.
aa
a.
a.
1 2
bb
1 5
bbabb
2 5
aaaaa
..a..
','3
','DATA_STRUCTURE'),
                                                                                                                (7145,'BAEKJOON','https://www.acmicpc.net/problem/12016',12016,'라운드 로빈 스케줄러','2초','512 MB',18,'<p>싱글 CPU에서 여러개의 작업을 실행할 때, 스케줄러는 어떤 작업을 언제 실행해야할지 CPU에게 알려준다.</p>

<p>이번 문제에서 살펴볼 스케줄러는 라운드 로빈 스케줄러이다. 총 작업은 N개가 있으며, 0번부터 N-1번까지 번호가 매겨져 있다. 스케줄러는 각 작업을 0번 작업부터 순서대로 한 번에 1초씩 실행시킨다. 모든 작업을 순서대로 실행시킨 후에는 다시 0번 작업부터 실행을 시작한다. 이때,&nbsp;완료된 작업이 있으면, 그 작업은 앞으로 실행시키지 않는다.</p>

<p>각 작업을 수행해야하는 시간이 주어졌을 때, 각 작업이 언제 완료되는지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 작업의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째에는 각 작업을 수행해야하는 시간이 공백으로 구분되어 주어진다. 각 작업을 수행해야하는 시간은 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 N개의 줄에 각 작업을 완료하는데 필요한 시간을 0번 작업부터 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2 1 2 4
','5
2
6
9
','DATA_STRUCTURE'),
                                                                                                                (7165,'BAEKJOON','https://www.acmicpc.net/problem/12108',12108,'약수 지우기 게임 2','2초','512 MB',19,'<p>A와 B가 약수 지우기 게임을 한다. 약수 지우기 게임은 두 사람이 즐기는 게임이다.</p>

<p>칠판에 여러 개의 자연수가 적혀 있다. 각 사람은 자신의 턴에 칠판에 적힌 자연수 하나를 지우고, 그 자연수의 약수 중 칠판에 남아 있는 수들을 모두 지운다. 예를 들어, 칠판에 2,3,4,5,6이 적혀 있을 때, 6을 지우면, 그 약수인 2와 3 역시 지워야 한다. 자신의 턴에 숫자를 지우지 않을 수는 없다. 마지막 숫자를 지우는 사람이 승리한다.</p>

<p>A와 B가 최적의 방법으로 게임을 하며, A가 게임을 먼저 시작할 때, 이기는 사람을 출력하고 싶겠지만, 문제를 어렵게 만들기 위한 출제자의 악랄한 의도에 따라, 게임을 변형하여 A가 처음에 지우는 수를 랜덤으로 정하기로 했다. 그러므로 A가 처음에 어떤 수를 가져가게 되는가에 따라 이기는 사람과, B가 이기기 위한 전략이 달라질 수 있다. 처음 지우는 수를 제외하고는 A와 B는 최적의 방법으로 게임을 한다.</p>

<p>각 경우에 대해 B가 이기기 위한 전략을 출력하면 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. N은 30보다 작은 자연수이다.</p>

<p>둘째 줄에 칠판에 적힌 N개의 자연수 X<sub>i</sub>(<30)가 공백을 사이에 두고 오름차순으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>N개의 줄에, (X<sub>i</sub>)를 출력하고, A가 처음에 X<sub>i</sub>를 지웠을 경우 B가 이기기 위해 지워야 하는 수를 공백을 사이에 두고 오름차순으로 모두 출력한다. 만약 B가 이길 수 없다면 A를 출력한다. 예제 출력을 참고하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 예제의 경우, A는 처음에 6과 3,2,1을 지운다. 칠판에 남은 수는 4,5로, B가 어떤 하나를 지우더라도 A는 나머지 하나를 지워 이길 수 있다. 또한, A가 처음에 5와 1을 지우면, 남은 수는 2,3,4,6으로, 2에는 3, 3에는 2, 4에는 6, 6에는 4를 지워 이길 수 있다.</p>

<p>세 번째 예제의 경우, A가 2를 지운 경우 B가 3을 지우고, A가 3을 지운 경우 B가 2를 지우면 남은 수는 4,6으로 B의 승리이다. A가 4를 지운 경우 B가 6을 지우고, A가 6을 지운 경우 B가 4를 지우면 모든 수를 지워 B의 승리이다. 각각의 경우에서 B가 다른 수를 지운다면 이길 수 없다.</p>

				</div>
				</div>','6
1 2 3 4 5 6
','(1) 5 6
(2) 6
(3) 4 6
(4) 3
(5) A
(6) A
','DATA_STRUCTURE'),
                                                                                                                (7166,'BAEKJOON','https://www.acmicpc.net/problem/12144',12144,'영어와 프랑스어 (Large)','5초','512 MB',22,'<p>영선이의 부모님은 집에서 영어와 프랑스어를 이용해 영선이와 대화한다. 영선이는 많은 단어를 들었지만, 어떤 단어가 프랑스어이고 어떤 단어가 영어인지는 모른다.</p>

<p>영선이는 영어로 이루어진 문장 하나와 프랑스어로 이루어진 문장 하나를 알고있다. 그리고, 영어인지 프랑스어인지 모르는 문장을 여러 개 알고 있다.</p>

<p>단어가 영어 문장에서 나타났으면 이 단어는 영어이고, 프랑스어 문장에서 나타났으면 이 단어는 프랑스어이다.</p>

<p>영선이가 들은 모든 문장이 주어졌을 때, 영어이면서 프랑스어인 단어의 최소 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. (1 ≤ T ≤ 25)</p>

<p>각 테스트 케이스의 첫째 줄에는 문장의 개수 N이 주어진다. (2 ≤ N ≤ 200) 둘째 줄부터 N개의 줄에는 문장이 주어진다.</p>

<p>문장은 단어로 이루어져 있으며, 단어는 공백으로 구분되어져 있다. 단어는 알파벳 소문자로만 이루어져 있고, 길이는 10을 넘지 않는다.</p>

<p>첫 번째 문장은 영어 문장이고, 두 번째 문장은 프랑스어 문장이다. 나머지 문장은 어떤 언어인지 알 수 없는 문장이다.</p>

<p>첫 두 문장은 각각 최대 1,000개의 단어로 이루어져 있고, 나머지 문장은 최대 10개의 단어로 이루어져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 테스트 케이스 마다 영어이면서 프랑스어인 단어의 최소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2
he loves to eat baguettes
il aime manger des baguettes
4
a b c d e
f g h i j
a b c i j
f g h d e
4
he drove into a cul de sac
elle a conduit sa voiture
il a conduit dans un cul de sac
il mange pendant que il conduit sa voiture
6
adieu joie de vivre je ne regrette rien
adieu joie de vivre je ne regrette rien
a b c d e
f g h i j
a b c i j
f g h d e
','Case #1: 1
Case #2: 4
Case #3: 3
Case #4: 8
','DATA_STRUCTURE'),
                                                                                                                (7178,'BAEKJOON','https://www.acmicpc.net/problem/12456',12456,'모닝커피 (Large)','5초','512 MB',16,'<p>호토 코코아(이하, 코코아)는 아침의 하루를 커피를 마시는 것으로 시작한다.</p>

<p>코코아의 찬장에는 <strong>N</strong> 종류의 커피가 있고, <strong>i</strong>번의 커피는 <strong>c<sub>i</sub></strong> 잔 분이 남아있으며, 오늘부터 유통기한까지 <strong>t<sub>i</sub></strong> 일 남았다. 그녀는 i번 (1 ≤&nbsp;<strong>i</strong>&nbsp;≤&nbsp;<strong>N</strong>) 종류의 커피를 1잔 마시면, <strong>s<sub>i</sub></strong>만큼의 만족도를 얻는다. 유통기한이 지난 커피는 마실 수 없다. (그러나, 딱 <strong>t<sub>i</sub></strong>일째에는 그 커피를 마실 수 있다.)</p>

<p>예를 들어, <strong>t<sub>i</sub></strong>=1인 경우, 오늘 중에 그 커피를 마시던가, 버리던가 해야 한다.</p>

<p>코코아는 커피를 하루에 한잔, 아침에밖에 마시지 않는다. 찬장에 커피가 하나도 없으면, 만족도를 얻을수 없다. 오늘부터 시작해서 커피를 마시는 것으로, <strong>K</strong>일에 코코아가 얻을수 있는 만족도 합계의 최대를 구하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 제일 첫 줄은 테스트케이스 T이다, 그 뒤로 T개의 테스트 케이스가 입력된다. 각각의 테스트케이스는 1개의 공백으로 구분된 2개의 양의 정수가 포함된 행으로 시작한다.&nbsp; 첫 정수는 커피의 종류 N을 의미하며, 다음 정수는 최대로 얻을 수 있는 만족도를 계산할 날짜인 K를 의미한다. 그 뒤에 N개의 커피 종류에 대한 남아있는 커피 개수, 유통기한, 만족도를 아래의 포맷으로 입력받는다.</p>

<pre>ci ti si</pre>

<p>값의 범위</p>

<ul>
	<li>1 ≤&nbsp;<strong>T</strong>&nbsp;≤ 100</li>
	<li>1 ≤&nbsp;<strong>c<sub>i</sub></strong>&nbsp;≤ K</li>
	<li>1 ≤&nbsp;<strong>t<sub>i</sub></strong>&nbsp;≤ K</li>
	<li>1 ≤&nbsp;<strong>s<sub>i</sub></strong>&nbsp;≤ 1000</li>
	<li>1 ≤&nbsp;<strong>N</strong>&nbsp;≤ 100</li>
	<li>1 ≤&nbsp;<strong>K</strong>&nbsp;≤ 2 * 10<sup>12</sup>&nbsp;(32bit 정수형을 초과하는 것에 주의)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다</p>

<pre>Case #X: Y</pre>

<p>을 1행씩 출력한다, X는 테스트 케이스의 번호, Y는 만족도 합계의 최대를 표시한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
2 3
2 2 2
3 3 1
2 3
1 3 2
1 3 1
5 5
5 5 1
4 4 2
3 3 3
2 2 4
1 1 5
','Case #1: 5
Case #2: 3
Case #3: 15
','DATA_STRUCTURE'),
                                                                                                                (7203,'BAEKJOON','https://www.acmicpc.net/problem/12731',12731,'열차 시간표(Small)','5초','512 MB',11,'<p>어떤 철도 노선이 두 역- A역과 B역-을 가지고 있다.</p>

<p>&nbsp;</p>

<p style="text-align: center;"><img alt="IMG_9330.JPG" src="https://upload.acmicpc.net/0c37c6e6-2d0b-4599-b54d-cafab7524805/-/crop/1841x1693/0,0/-/preview/" style="height: 340px; width: 370px;"></p>

<p>열차들은 하루에 A역에서 B역으로, 혹은 B역에서 A역으로 여러 번 운행할 수 있다. 만약 열차가 A역에서 B역(혹은 B역에서 A역) 으로 도착하면, 다시 원래 역으로 돌아가기 위한 시간, 즉 회차시간을 필요로 한다. 예를 들어, 열차가 12:00에 도착했으며, 회차시간이 0분이라면, 열차는 12:00에 바로 역을 떠날 수 있다.</p>

<p>열차 시간표에는 A역과 B역 사이의 모든 열차의 출발시각과 도착시각이 적혀져 있다. 철도회사는 시간표대로 열차를 운행시키기 위해 A역과 B역에서 첫차로 출발시켜야 하는 차량의 개수를 알아야 한다. 열차가 A역 혹은 B역을 출발하려면, 출발 준비가 된 차량이 존재해야 한다. 두 역 사이의 선로에는 대피선이 설치되어 있기 때문에 열차는 반드시 출발한 순서대로 도착할 필요가 없으며, 시간표에 적혀져 있는 열차 이외의 열차는 운행하지 않는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 테스트 케이스의 개수 N을 입력받는다.</p>

<p>각 테스트케이스는 여러 줄로 이루어져 있다, 첫 번째 줄은 회차 시간 T가 분으로 주어지며, 다음 줄에는 A에서 B로 가는 열차의 수인 NA, B에서 A로 가는 열차의 수 NB가 공백으로 구분되어서 입력된다. 다음 NA개의 줄에는 A에서 B로 이동하는 열차의 정보가 주어진다.</p>

<p>각 줄은 두 부분으로 나뉘며, HH:MM 포맷으로 출발 시간과 도착 시간이 주어진다. 각 열차의 출발 시각은 도착 시각보다 이르며, 모든 출발과 도착은 하루 안에 일어난다. 시간과 분은 모두 2자리이며, 빈 자리는 0으로 채우며, 24시간제이다(00:00~23:59)</p>

<p>NA개의 줄 뒤에는, B에서 A로 가는 열차의 출발시각과 도착 시각이 NB 줄만큼 주어진다.</p>

<p>제한</p>

<ul>
	<li>1 ≤&nbsp;<strong>N</strong>&nbsp;≤ 100</li>
	<li>0 ≤&nbsp;<strong>NA</strong>,&nbsp;<strong>NB</strong>&nbsp;≤ 20</li>
	<li>0 ≤&nbsp;<strong>T</strong>&nbsp;≤ 5</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트케이스마다, Case #<strong>x</strong>: "뒤에 A역과 B역에서 출발시켜야 하는 차량의 수를 공백으로 구분하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
5
3 2
09:00 12:00
10:00 13:00
11:00 12:30
12:02 15:00
09:00 10:30
2
2 0
09:00 09:01
12:00 12:02
','Case #1: 2 2
Case #2: 2 0
','DATA_STRUCTURE'),
                                                                                                                (7199,'BAEKJOON','https://www.acmicpc.net/problem/12732',12732,'열차 시간표(Large)','5초','512 MB',11,'<p>어떤 철도 노선이 두 역- A역과 B역-을 가지고 있다.</p>

<p style="text-align: center;"><br>
<img alt="IMG_6360.JPG" src="https://upload.acmicpc.net/1fe0025c-4d35-485c-bb65-ab15396bc715/-/crop/2588x2361/676,0/-/preview/" style="height: 312.5px; width: 343.333px;"></p>

<p>열차들은 하루에 A역에서 B역으로, 혹은 B역에서 A역으로 여러 번 운행할 수 있다. 만약 열차가 A역에서 B역(혹은 B역에서 A역) 으로 도착하면, 다시 원래 역으로 돌아가기 위한 시간, 즉 회차시간을 필요로 한다. 예를 들어, 열차가 12:00에 도착했으며, 회차시간이 0분이라면, 열차는 12:00에 바로 역을 떠날 수 있다.</p>

<p>열차 시간표에는 A역과 B역 사이의 모든 열차의 출발시각과 도착시각이 적혀져 있다. 철도회사는 시간표대로 열차를 운행시키기 위해 A역과 B역에서 첫차로 출발시켜야 하는 차량의 개수를 알아야 한다. 열차가 A역 혹은 B역을 출발하려면, 출발 준비가 된 차량이 존재해야 한다. 두 역 사이의 선로에는 대피선이 설치되어 있기 때문에 열차는 반드시 출발한 순서대로 도착할 필요가 없으며, 시간표에 적혀져 있는 열차 이외의 열차는 운행하지 않는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 테스트 케이스의 개수 N을 입력받는다.</p>

<p>각 테스트케이스는 여러 줄로 이루어져 있다, 첫 번째 줄은 회차 시간 T가 분으로 주어지며, 다음 줄에는 A에서 B로 가는 열차의 수인 NA, B에서 A로 가는 열차의 수 NB가 공백으로 구분되어서 입력된다. 다음 NA개의 줄에는 A에서 B로 이동하는 열차의 정보가 주어진다.</p>

<p>각 줄은 두 부분으로 나뉘며, HH:MM 포맷으로 출발 시간과 도착 시간이 주어진다. 각 열차의 출발 시각은 도착 시각보다 이르며, 모든 출발과 도착은 하루 안에 일어난다. 시간과 분은 모두 2자리이며, 빈 자리는 0으로 채우며, 24시간제이다(00:00~23:59)</p>

<p>NA개의 줄 뒤에는, B에서 A로 가는 열차의 출발시각과 도착 시각이 NB 줄만큼 주어진다.</p>

<p>제한</p>

<ul>
	<li>1 ≤&nbsp;<strong>N</strong>&nbsp;≤ 100</li>
	<li>0 ≤&nbsp;<strong>NA</strong>,&nbsp;<strong>NB</strong>&nbsp;≤ 100</li>
	<li>0 ≤&nbsp;<strong>T</strong>&nbsp;≤ 60</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트케이스마다, Case #<strong>x</strong>: "뒤에 A역과 B역에서 출발시켜야 하는 차량의 수를 공백으로 구분하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
5
3 2
09:00 12:00
10:00 13:00
11:00 12:30
12:02 15:00
09:00 10:30
2
2 0
09:00 09:01
12:00 12:02','Case #1: 2 2
Case #2: 2 0
','DATA_STRUCTURE'),
                                                                                                                (7201,'BAEKJOON','https://www.acmicpc.net/problem/12741',12741,'쓰담쓰담','1초','256 MB',17,'<p>카이스트에는 신입생이 N명이 들어왔다. 그들에게는 1부터 N까지의 번호가 붙어있고, i번째 사람의 키는 A<sub>i</sub>이다. 처음에 신입생은 번호순으로 일렬로 차례로 서 있다. 강한필은 신입생을 X번 쓰다듬으려고 한다. 그가 한 번 신입생을 쓰다듬을 때 L번째 사람부터 R번째 사람까지 쓰다듬는다. (L과 R은 쓰다듬을 때마다 바뀐다.)</p>

<p>그는 신입생을 쓰다듬을 때 부드럽게 쓰다듬기를 원하기 때문에 L ≤ j < R을 만족하는 정수 j에 대하여 j+1번째 사람의 키가 j번째 사람의 키보다 작지 않기를 원한다. 그렇지 않으면 강한필이 쓰다듬을 때에 화를 낼 것이다. 몇몇 신입생들은 쓰다듬어지기를, 몇몇은 그렇지 않기를 원하기 때문에, 신입생들은 중간에 L번째 사람과 R번째 사람이 Y번 자리를 바꾼다. (L과 R은 자리를 바꿀 때마다 바뀔 수 있다.) 신입생들의 수와 키, 강한필이 쓰다듬는 정보, 신입생들이 자리를 바꾼 정보가 주어질 때, 강한필이 쓰다듬을 때마다 화를 내는지 내지 않는지 출력하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 문제에서 주어진 N(1 ≤ N ≤ 100000)과 X+Y (1 ≤ X + Y ≤ 100000)과 공백을 사이에 두고 주어진다.</p>

<p>둘째 줄에는 키를 나타내는 N개의 정수 A<sub>i</sub> (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)가 주어진다.</p>

<p>그 이후 X+Y개의 줄에는 공백을 사이에 둔 3개의 자연수가 주어지고, Q, L, R이라 하자. (Q = 1 또는 2, 1 ≤ L ≤ R ≤ N)</p>

<p>Q가 1이면 강한필이 L번째 사람부터 R번째 사람까지 쓰다듬는다는 뜻이고, Q가 2이면 L번째 사람과 R번째 사람이 서로 자리를 바꾼다는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 X개의 줄로 이루어져 있다.</p>

<p>i번째 줄에, 강한필이 i번째로 신입생을 쓰다듬을 때, 화를 낸다면 “HSS090”을, 화를 내지 않는다면 “CS204”를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 6
1 3 5 2 4
1 1 3
2 2 4
1 1 3
1 2 4
2 4 5
1 4 5
','CS204
CS204
HSS090
HSS090
','DATA_STRUCTURE'),
                                                                                                                (7204,'BAEKJOON','https://www.acmicpc.net/problem/12744',12744,'팬케이크 쌓기','2초','256 MB',13,'<p>지용이는 팬케이크를 잘 굽는 제빵사다. 어느 날, 지용이는 크기가 다른 앞뒤 구분이 되어있는 팬케이크를 N (1 ≤ N ≤ 6)개 만들었다. 이 N개의 팬케이크의 크기는 크기 순으로 정렬하면 1,2, … , N이다. 지용이는 생각 없이 팬케이크를 만들었기 때문에, 팬케이크를 만든 순서의 역순대로 팬케이크를 쌓아 놓았는데, 쌓아 놓은 순서가 팬케이크 크기 순이 아닐 수도 있다. 지용이는 최소 횟수의 뒤집기를 통해 팬케이크들이 위로 갈수록 크기가 작아지고, 모두 올바른 방향으로 쌓여지도록 만들고 싶다.</p>

<p>여기서 뒤집기란 다음과 같다: 1 ≤ i ≤ N인 임의의 i를 고르고 위에서부터 1 ~ i번째 팬케이크를 통째로 뒤집어서 순서를 완전히 거꾸로 바꾸고, 앞뒤 구분을 바꾼다. 예를 들어, i = 3을 골랐다면, 1(+) 2(+) 3(+) 4(+) 5(+) → 3(-) 2(-) 1(-) 4(+) 5(+)와 같이 팬케이크의 위치가 바뀐다. (여기서 +는 앞면, -는 뒷면을 의미한다)</p>

<p>이 문제를 해결하여 지용이를 도와주자</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 N이 주어진다.</p>

<p>두 번째 줄부터 N + 1번째 줄에는 팬케이크의 크기와 현재 방향이 띄어쓰기로 구분되어 주어진다. (팬케이크의 방향은 앞면이라면 +, 뒷면이라면 -로 주어질 것이다.)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>조건을 만족하는 뒤집기의 최소 횟수를 구하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 +
2 +
3 +
4 +
5 +
','0
','DATA_STRUCTURE'),
                                                                                                                (7205,'BAEKJOON','https://www.acmicpc.net/problem/12747',12747,'색칠 공부 (Small)','2초','256 MB',15,'<p>종원이는 정n각형의 꼭짓점을 k개의 색으로 칠하려고 한다. 이때 정다각형을 돌려서 같은 경우나, 뒤집어서 같은 경우, 또는 임의의 다른 두 색 X, Y를 선택해 X색의 점들을 모두 Y색으로 바꾸고 Y색의 점들을 모두 X색으로 바꾸는 과정을 유한 번 반복해서 (X색의 점들이나 Y색의 점들이 없었을 수 있음) 돌리거나 뒤집을 때 같은 모양이 되는 경우를 모두 같은 한 가지의 경우로 생각한다.</p>

<p>숙제를 새벽까지 하느라 머리가 복잡해진 종원이는 안타깝게도 이 문제를 풀지 못하였다. 그래서 종원이는 여러분들에게 도움을 요청하였다. 종원이를 도와주기 위해 정n각형의 꼭짓점을 k개의 색으로 칠하는 서로 다른 경우의 수를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 n, k가 주어진다.</p>

<p>n, k의 제한은 다음과 같다.</p>

<p>3 ≤ n ≤ 6, 1 ≤ k ≤ 5</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>조건을 만족시키면서, 정n각형의 꼭짓점을 k개의 색으로 칠하는 서로 다른 경우의 수를 1,000,000,007로 나눈 나머지를 구하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 2
','8
','DATA_STRUCTURE'),
                                                                                                                (7200,'BAEKJOON','https://www.acmicpc.net/problem/12757',12757,'전설의 JBNU','2초','128 MB',13,'<p>전설의 프로그래머 윤준하는 독자적인 데이터베이스 시스템 JBNU(Jeong Bo Neoh Um)를 만들었다.</p>

<p>준하가 생각한 데이터베이스의 기본 골자는 데이터에 접근하기 위한 Key와 그 데이터를 나타내는 Value로 구성되어 있다. 사용자는 Key를 알고 있어야만 원하는 데이터에 접근할 수 있다.</p>

<p>하지만 준하는 건망증이 심해 Key를 매번 잊어버리기 일쑤였다. 따라서 준하는 JBNU를 개조하여 잘못된 Key를 입력하더라도 그 잘못된 Key와 제일 근접한 Key를 찾아주는 메커니즘을 도입하였다.</p>

<p>Key와 Value는 항상 정수로 되어있다. 가장 근접한 Key란 두 수의 차이가 가장 작은 Key를 의미한다. 또한, 정보의 정확성을 위해 두 수의 차이가 K보다 큰 경우는 Key로 인정하지 않기로 하였다.</p>

<p>프로젝트 베끼기의 달인 승균이는 데이터베이스 시간에 JBNU를 모방하기로 했다.&nbsp;그러나 준하는 전설이기 때문에 그가 만든 프로그램은 찾을 방법이 없었고, 하는 수 없이 같은 조원인 당신에게 맡기려고 한다.</p>

<p>JBNU의 초기 데이터 상태가 주어질 때, 데이터 추가, 수정 및 검색을 지원하는 프로그램을 작성해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 초기 데이터의 개수인 \(N(1 \le N \le 100,000)\) 과 명령 횟수인 \(M(1 \le M \le 100,000)\), 가장 근접한 Key까지의 거리의 제한인 \(K(1 \le K \le 10,000)\)가 주어진다.&nbsp;</p>

<p>입력의 둘째 줄부터 N개의 줄에는 초기 데이터인 Key와 Value 값이 주어진다. 모든 Key와 Value는 \(1,000,000,000\) 이하의 음이 아닌 정수이다. 같은 Key를 갖는 데이터는 없다.</p>

<p>다음 M개의 줄에는 아래와 같은 명령이 주어진다.</p>

<ul>
	<li>1 Key Value : 해당 Key와 Value를 가진 데이터를 추가한다. Key가 이미 존재하는 입력은 주어지지 않는다.</li>
	<li>2 Key Value : 해당 Key로 검색된 데이터를 Value로 변경한다. 조건을 만족하는 유일한 Key가 없는 경우 무시한다.</li>
	<li>3 Key : 해당 Key로 검색된 데이터를 출력한다. 조건을 만족하는 Key가 없는 경우 -1을 출력한다. 만약 해당하는 Key가 두 개 이상 존재한다면 ?를 출력한다. 모든 출력은 개행을 포함해야 한다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 줄에 걸쳐 3번 명령에 대한 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 7 5
1 10
5 20
9 30
15 40
50 50
3 2
2 0 35
3 2
3 7
3 100
1 97 123
3 100
','10
35
?
-1
123
','DATA_STRUCTURE'),
                                                                                                                (7167,'BAEKJOON','https://www.acmicpc.net/problem/12764',12764,'싸지방에 간 준하','1초','128 MB',13,'<p>현재 대한민국 해군에 소속되어있는 준하는 문제를 풀기 위해 매일같이 사이버 지식 정보방 통칭 싸지방에 다닌다.&nbsp;그러나 최근 문제가 생겼다. 싸지방에 사람이 몰려 컴퓨터 수가 모자라게 된 것이다. 이런 사태를 도저히 용납할 수 없었던 준하는 곧 전역하는 선임을 설득해 민원을 넣도록 하는 데 성공했다.</p>

<p>마침내 부대에서는 민원을 받아들이기로 하였고, 컴퓨터를 증설하기로 했다. 또한, 컴퓨터 간의 사용률에 따라 다른 성능의 컴퓨터를 설치하고자 한다.</p>

<p>하지만 예산이 부족해 사람 수 만큼 컴퓨터를 살 수가 없었다. 고심에 고심을 거듭한 준하는 모든 사람이 항상 정해진 시간에 싸지방을 이용한다는 사실을 발견했다.</p>

<p>컴퓨터가 있는 자리에는 1번부터 순서대로 번호가 매겨져 있다. 모든 사람은 싸지방에 들어왔을 때 비어있는 자리 중에서 번호가 가장 작은 자리에 앉는 것이 규칙이다.</p>

<p>준하가 발견한 사실과 이용 규칙을 가지고, 모든 사람이 기다리지 않고 싸지방을 이용할 수 있는 컴퓨터의 최소 개수와 자리별로 몇 명의 사람이 사용했는가를 구하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 사람의 수를 나타내는 \(N\)이 주어진다. \((1 \le N \le 100,000)\) 둘째 줄부터 \(N\)개의 줄에 걸쳐서 각 사람의 컴퓨터 이용 시작 시각 \(P\)와 종료 시각 \(Q\)가 주어진다. \((0 \le P \lt Q \le 1,000,000)\)</p>

<p>시작 시각이나 종료 시각이 다른 사람과 겹치는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 사람이 모든 사람이 기다리지 않아도 되는 컴퓨터의 최소 개수 \(X\)를 출력한다.</p>

<p>둘째 줄에는 1번 자리부터 \(X\)번 자리까지 순서대로 각 자리를 사용한 사람의 수를 띄어쓰기 간격으로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
20 50
10 100
30 120
60 110
80 90
','4
1 2 1 1
','DATA_STRUCTURE'),
                                                                                                                (7182,'BAEKJOON','https://www.acmicpc.net/problem/12789',12789,'도키도키 간식드리미','1초','128 MB',8,'<p>인하대학교 학생회에서는 중간, 기말고사 때마다 시험 공부에 지친 학우들을 위해 간식을 나눠주는 간식 드리미 행사를 실시한다. 승환이는 시험 기간이 될 때마다 간식을 받을 생각에 두근두근 설레서 시험 공부에 집중을 못 한다. 이번 중간고사에서도 역시 승환이는 설레는 가슴을 안고 간식을 받기 위해 미리 공지된 장소에 시간 맞춰 도착했다. 그런데 이게 무슨 날벼락인가! 그 곳에는 이미 모든 학생들이 모여있었고, 승환이는 마지막 번호표를 받게 되었다. 설상가상으로 몇몇 양심에 털이 난 학생들이 새치기를 거듭한 끝에 대기열의 순서마저 엉망이 되고 말았다. 간식을 나눠주고 있던 인규는 학우들의 터져 나오는 불만에 번호표 순서로만 간식을 줄 수 있다고 말했다.&nbsp;</p>

<p>그제야 학생들이 순서대로 줄을 서려고 했지만 공간이 너무 협소해서 마음대로 이동할 수 없었다. 다행히도 대기열의 왼쪽에는 1열로 설 수 있는 공간이 존재하여 이 공간을 잘 이용하면 모두가 순서대로 간식을 받을 수 있을지도 모른다. 자칫 간식을 못 받게 될지도 모른다는 위기감을 느낀 승환이는 자신의 컴퓨터 알고리즘적 지식을 활용해 과연 모든 사람들이 순서대로 간식을 받을 수 있는지 확인하는 프로그램을 만들기로 했다. 만약 불가능 하다면 승환이는 이번 중간고사를 망치게 될 것 이고 가능하다면 힘을 얻어 중간고사를 잘 볼 수 있을지도 모른다.</p>

<p>사람들은 현재 1열로 줄을 서있고, 맨 앞의 사람만 이동이 가능하다. 인규는 번호표 순서대로만 통과할 수 있는 라인을 만들어 두었다. 이 라인과 대기열의 맨 앞 사람 사이에는 한 사람씩 1열이 들어갈 수 있는 공간이 있다. 현재 대기열의 사람들은 이 공간으로 올 수 있지만 반대는 불가능하다. 승환이를 도와 프로그램을 완성하라.</p>

<p>현재 간식 배부 공간을 그림으로 나타내면 다음과 같다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12789/1.png" style="height:169px; width:306px"></p>

<p>위 예제는 다음 그림과 같이 움직였을 때 모두가 순서대로 간식을 받을 수 있다..</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12789/2.png" style="height: 99.1667px; width: 391.667px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫째 줄에는 현재 승환이의 앞에 서 있는 학생들의 수 <em>N</em>(1 ≤ <em>N</em> ≤ 1,000,자연수)이 주어진다.</p>

<p>다음 줄에는 승환이 앞에 서있는 모든 학생들의 번호표(1,2,...,<em>N</em>) 순서가 앞에서부터 뒤 순서로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>승환이가 무사히 간식을 받을 수 있으면 "Nice"(따옴표는 제외)를 출력하고 그렇지 않다면 "Sad"(따옴표는 제외)를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
5 4 1 3 2
','Nice
','DATA_STRUCTURE'),
                                                                                                                (7180,'BAEKJOON','https://www.acmicpc.net/problem/12795',12795,'반평면 땅따먹기','2초','128 MB',21,'<p>어려서부터 땅따먹기를 곧잘 즐기던 구사과는, 땅따먹기로 입신의 경지에 다다르게 되었다. 그래서 구사과는 자신만이 할 수 있는 새로운 땅따먹기 게임을 만들었는데, 이름하여 반평면 땅따먹기이다.</p>

<p>반평면 땅따먹기의 규칙은 땅따먹기보다 좀 더 간단하다. 땅따먹기 특이점을 넘긴 능력을 보유한 구사과는 땅따먹기에서만큼은 뭐든지 할 수 있다. 이를테면 무한히 먼 곳으로부터 손가락으로 돌을 쳐 무한히 멀리 직선으로 날아가도록 할 수 있다. 반평면 땅따먹기는 이 능력을 이용한 게임으로, 구사과가 점령하는 돌을 쳐서 날릴 때마다 그 자취인 직선을 기준으로 나뉘는 두 영역 중 (0, -∞)를 포함하는 쪽 전부를 점령하게 된다.</p>

<p>무한한 2차원 평면 위에서 게임을 하던 구사과는 문득 현재 자신이 점령한 땅의 모양에 관해서 궁금해졌다. 하지만 땅따먹기 이외에는 젬병인 구사과는 정작 자신이 점령한 땅에 대해서는 잘 알지 못했다. 높은 곳을 좋아하는 구사과는 종종 자신이 점령한 땅 중 해당 x좌표에서 가장 높은 y좌표가 몇인지 알고 싶었다.</p>

<p>우수한 프로그래머인 당신만이 구사과의 유일한 희망이다. 구사과가 게임을 진행한 정보가 주어질 때 이를 토대로 구사과의 궁금증을 해결해주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 게임을 진행한 정보의 개수 <em>Q</em>(1 ≤ <em>Q</em> ≤ 200,000)이 주어지며, 이어서 <em>Q</em> 줄에 걸쳐 각 정보가 주어진다. 각 줄의 첫 번째 숫자가 1일 경우 이어서 2개의 정수 <em>a</em>, <em>b</em>(|<em>a</em>| ≤ 1,000,000, |<em>b</em>| ≤ 1,000,000,000,000)가 주어지며 이는 구사과가 y = <em>a</em>x + <em>b</em> 형태의 직선을 따라 돌을 날렸음을 의미한다. 각 줄의 첫 번째 숫자가 2일 경우 이어서 1개의 정수 <em>x</em>(|<em>x</em>| ≤ 1,000,000,000,000)이 주어지며, 이는 구사과가 현재까지 점령한 땅 중 해당 x 좌표에서 가장 높은 y값을 궁금해함을 의미한다. 첫 번째 정보는 무조건 1로 시작함이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 구사과의 궁금증에 대하여 해당하는 y값을 한 줄에 걸쳐 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 1 2
1 2 3
2 -100
2 100
','-98
203
','DATA_STRUCTURE'),
                                                                                                                (7186,'BAEKJOON','https://www.acmicpc.net/problem/12798',12798,'게나디는 머리가 좋습니다','2초','256 MB',20,'<p>2016년 현재, 인간들은 2차원 배열을 활용하여 정사각형 격자로 된 세상을 편하게 관리하고 있었다. 이를 보고 있던 꿀벌 게나디는 벌집을 관리할 때도 배열을 활용하여 관리하면 편리할 것이라고 생각하였다. 하지만 벌집은 정육각형 모양의 칸들로 이루어져 있기에 인간들이 사용하는 배열을 그대로 사용할 수는 없었고, 어쩔 수 없이 벌집에 맞는 배열을 발명할 수밖에 없었다.</p>

<p>게나디가 사는 벌집은 아래 그림과 같이 정육각형 모양의 칸이 서로 붙어 있는 형태이다. 게나디는 우선 벌집의 각 칸을 명확히 나타내기 위해 각 칸에 2차원 좌표를 다음과 같은 방법으로 부여하기로 하였다.</p>

<ul>
	<li>자신이 서 있는 칸을 기준인 (0, 0)으로 잡는다.</li>
	<li>그 외의 칸에는 귀납적으로 좌표를 부여한다. 어떤 칸의 좌표가 (<em>x</em>, <em>y</em>)라면, 인접한 6개의 칸의 좌표는 아래 [그림 1]과 같이 정의된다.</li>
</ul>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12798/img1.png" style="height:200px; width:192px"></p>

<p>[그림 2]는 위의 방식으로 벌집의 각 칸에 좌표를 부여한 것이다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12798/img2.png" style="height: 297.5px; width: 363.333px;"></p>

<p>이러한 식으로 좌표를 정하면 벌집의 각 칸의 좌표가 유일하게 결정된다는 것을 성공적으로 증명한 게나디는 이제 꿀벌들도 문명의 이기를 맛볼 수 있겠구나! 하고 좋아하며 이 발상을 모든 꿀벌에게 알리려고 했으나, 문득 그 전에 최소한의 검증을 해 보는 게 좋지 않을까 하는 생각이 들어, 일단 인간들이 사용하는 배열로는 간단하게 풀 수 있다는 문제를 벌집 버전으로 바꾸어 해결해보기로 하였다. 인터넷의 도움을 받아 게나디는 아래 문제를 해결하기로 하였다:</p>

<hr>
<p>게나디는 벌집의 모든 칸에 0을 적어 놓았다. 이때 다음과 같은 연산을 지원하는 자료구조를 구현하라.</p>

<ol>
	<li>더하기: (<em>x</em>, <em>y</em>)와의 거리가 <em>r</em> 이하인 모든 칸에 1을 더하라. 서로 다른 두 칸 A, B 사이의 거리는 벌집에서 인접한 칸으로만 이동하여 A에서 출발하여 B에 도착하기 위해 이동해야 하는 최소 횟수를 의미한다. 같은 칸 사이의 거리는 특별히 0으로 정의한다.</li>
</ol>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12798/img3.png" style="height: 137.5px; width: 358.333px;"></p>

<ol start="2">
	<li>찾아보기: (<em>x</em>, <em>y</em>)에 어떤 값이 적혀 있는지 출력하라.</li>
</ol>

<hr>
<p>게나디를 위해 문제를 해결해주는 프로그램을 작성하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 게나디가 사는 벌집의 크기 <em>N</em> (1 ≤ <em>N</em> ≤ 2,000)과 연산의 수 <em>Q</em> (1 ≤&nbsp;<em>Q</em> ≤ 200,000)가 공백을 사이로 두고 주어진다. 게나디는 (0, 0)과의 거리가 <em>N</em> 이하인 칸들에만 관심을 가진다고 하자.</p>

<p>다음 <em>Q</em>개 줄에는 연산의 정보가 주어진다.</p>

<ul>
	<li>1번 종류의 연산을 한다면, "<code>1 x y r</code>"과 같은 형식으로 입력이 주어진다. (<em>x</em>, <em>y</em>)와의 거리가 <em>r</em> 이하인 모든 칸들은 (0, 0)과의 거리가 <em>N</em> 이하임이 보장된다.</li>
	<li>2번 종류의 연산을 한다면, "<code>2 x y</code>"과 같은 형식으로 입력이 주어진다. (<em>x</em>, <em>y</em>)과 (0, 0)과의 거리는 <em>N</em> 이하임이 보장된다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 종류의 연산이 주어질 때마다 해당 칸에 적힌 수를 한 줄에 하나씩 출력한다. 적어도 하나의 2번 연산이 주어짐이 보장된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12798/img4.png" style="height:297px; width:839px"></p>

				</div>
				</div>','5 6
1 1 1 2
2 2 3
2 3 4
1 -1 -1 3
2 0 0
2 3 -1
','1
0
2
0
','DATA_STRUCTURE'),
                                                                                                                (7190,'BAEKJOON','https://www.acmicpc.net/problem/12837',12837,'가계부 (Hard)','1초','512 MB',15,'<p>살아있는 화석이라고 불리는 월곡이는 돈에 찌들려 살아가고 있다. 그에게 있어 수입과 지출을 관리하는 것은 굉장히 중요한 문제이다. 스마트폰에 가계부 어플리케이션을 설치해서 사용하려 했지만, 월곡이는 굉장히 오래 살았기에 원하는 정보를 얻기에는 동작 속도가 너무나도 느렸다. 가끔 입력을 빼먹은 것이 생기면 다시 추가하고 계산하는 것도 느려서, 성격이 급한 월곡이는 결국 스마트폰을 부숴버리고 말았다. 월곡이를 도와주는 프로그램을 작성하기 위해, 아래와 같은 동작들을 처리하는 프로그램을 작성하시오.</p>

<p>작성될 가계부 프로그램은 두 가지 동작을 처리해야 한다. 첫 번째는 월곡이의 생후 p일에 수입/지출 내용을 추가하는 것이다. 수입은 양수, 지출은 음수의 형태로 입력이 들어온다. 두 번째는 월곡이의 생후 p일부터 q일까지 잔고가 변화한 값을 구하고 출력하는 것이다. 월곡이가 빚을 지고 있을 수도 있기에 어떤 i에 대해서 생후 i일의 잔고는 음수일 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 월곡이가 살아온 날 N, 쿼리의 개수 Q가 주어진다. (N ≤ 10<sup>6</sup>, Q ≤ 10<sup>5</sup>)</p>

<p>둘째 줄부터 Q+1번째 줄까지는 아래와 같은 형식의 쿼리가 주어진다.</p>

<ul>
	<li>1 p x : 생후 p일에 x를 추가한다. (1 ≤ p ≤ N, -2×10<sup>9</sup> ≤ x ≤ 2×10<sup>9</sup>)</li>
	<li>2 p q : 생후 p일부터 q일까지 변화한 양을 출력한다. (1 ≤ p ≤ q ≤ N)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 2 쿼리에 대해 계산된 값을 각 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 6
1 3 10000
1 4 -5000
1 7 -3000
2 1 10
1 6 35000
2 4 10
','2000
27000
','DATA_STRUCTURE'),
                                                                                                                (7197,'BAEKJOON','https://www.acmicpc.net/problem/12846',12846,'무서운 아르바이트','1초','512 MB',16,'<p>성화는 악독하기로 유명한 편의점 사장이다. 그의 편의점에는 특이한 임금 체계를 가지고 있다.</p>

<ul>
	<li>각 날마다 일의 차이때문에 일마다 급여가 정해져 있다.</li>
	<li>돈은 당일에 주지 않고 퇴직을 할 때 한번에 준다.</li>
	<li>성화는 욕심쟁이라서 해당 일을 한 동안 중 가장 일급이 작을 때를 기준으로 급여를 지급한다.</li>
	<li>일급이 다른 것을 들키지 않기 위하여 한번이라도 퇴직한 자를 다시 취직 시키지 않는다. (만약 취직을 한다면, 일을 시작 한 날부터 끝날 때까지 하루도 빠지면 안 된다.)</li>
</ul>

<p>준수는 n+1일 후에 001에 월세를 내야 해서 성화가 사장으로 있는 편의점에 취직하려 한다. 다행히 주변 퇴직자들의 얘기로 급여에 관련해 파악했다. 또한 퇴직자들의 급여 통계를 통해 당장 n일 후까지 일급 정보를 알아냈다. 최대로 많이 일했을 때가 최대 이익이 아닐 수 있다.</p>

<p>어제까지 과제를 제출하고 지금도 001에서 자고 있는 준수를 위해 코딩 잘하는 여러분이 일을 해서 벌 수 있는 최대 이익을 준수에게 알려주도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>일을 할 수 있는 날의 수 (0 < n ≤&nbsp;100000) 가 주어진다.</p>

<p>그 다음 줄 에는 1일부터 n일 까지 일급 T<sub>i</sub> 가 순서대로 주어진다. (0 < T<sub>i</sub> ≤&nbsp;1,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>준수가 일을 해서 벌 수 있는 최대 이익을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
10 20 30 20 10
','60
','DATA_STRUCTURE'),
                                                                                                                (7196,'BAEKJOON','https://www.acmicpc.net/problem/12856',12856,'홍준이는 색칠을 좋아해','2초','512 MB',21,'<p>홍준이는 색칠을 좋아해요.</p>

<p>홍준이는 생일 선물로 n개의 벽돌을 선물 받았고 일렬로 늘어놓았습니다. 편의상 가장 왼쪽의 벽돌이 1번 벽돌이고 가장 오른쪽의 n번 벽돌까지 순서대로 있다고 하겠습니다. i번 벽돌의 색은 처음에 i번 색깔이었습니다. 그리고 각 벽돌의 ‘다채도’는 0이었습니다.</p>

<p>색칠을 좋아하는 홍준이는 이제 연속한 벽돌들에 같은 색을 칠하려고 합니다. i번 벽돌의 색이 현재 y이고, 홍준이가 x라는 색으로 칠하려고 한다면, 그 돌의 다채도는 |x-y|만큼 증가하게 됩니다.</p>

<p>홍준이는 m번의 작업을 합니다. 작업은 다음 두 가지 중 하나입니다.</p>

<ol>
	<li>L번째 벽돌부터 R번째 벽돌까지 색깔 X로 칠합니다.</li>
	<li>L번째 벽돌부터 R번째 벽돌까지의 다채도의 합을 구합니다.</li>
</ol>

<p>홍준이를 도와주는 프로그램을 작성하세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 벽돌의 개수를 나타내는 n과 작업의 수 m이 주어집니다. (1 ≤ n, m ≤ 100,000)</p>

<p>둘째 줄부터 m개의 줄은 작업의 종류를 알려주는 하나의 정수 Type(1 또는 2)으로 시작한다.</p>

<p>Type이 1이라면, 작업 1을 나타내는 3개의 정수 L, R, X가 주어진다. (1 ≤ L ≤ R ≤ n, 1 ≤ X ≤ 100,000,000)</p>

<p>Type이 2라면, 작업 2를 나타내는 2개의 정수 L, R이 주어진다. (1 ≤ L ≤ R ≤ n)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>작업 2를 수행할 때마다 구간의 다채도의 합을 한 줄에 하나씩 순서대로 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
1 1 3 4
2 1 1
2 2 2
2 3 3
','3
2
1
','DATA_STRUCTURE'),
                                                                                                                (7202,'BAEKJOON','https://www.acmicpc.net/problem/12867',12867,'N차원 여행','2초','512 MB',9,'<p>수빈이는 여행을 좋아한다. 더 이상 지구에서 여행할 곳이 없어진 수빈이는 N차원 우주로 여행을 떠났다. 우주의 각 점은 좌표 N개로 이루어 지며, 각각의 좌표는 1부터 N까지 인덱스가 매겨져 있다.</p>

<p>수빈이는 원점(모든 좌표가 0인 곳)에서 &nbsp;여행을 시작하며, 아래와 같은 방법으로 움직인다.</p>

<ul>
	<li>첫 번째로 움직일 좌표의 인덱스를 고른다. (1부터 N까지 중의 하나)</li>
	<li>그 다음, 그 좌표의 값을 1만큼 증가시킨 곳이나 감소시킨 곳으로 이동한다. (다른 좌표는 이동하기 전과 같아야 한다)</li>
</ul>

<p>수빈이는 여행을 떠나기 전에 여행 계획을 작성해 놓았고, 같은 점을 두 번 이상 방문하는지 아닌지 알아보려고 한다.</p>

<p>수빈이가 여행 계획에서 고른 좌표 인덱스와, 좌표가 증가하는 방향으로 이동했는지, 감소하는 방향으로 이동했는지가 주어진다. 수빈이가 첫 번째 점과 마지막 점을 포함한 모든 점을 중복해서 방문하지 않게 방문할 수 있다면 1을, 아니면 0을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (1 ≤ N ≤ 1,000,000,000)이 주어진다.</p>

<p>둘째 줄에는 수빈이의 여행 계획의 길이 M (1 ≤ M ≤ 50)이 주어진다.</p>

<p>셋째 줄에는 수빈이가 여행 계획에서 고른 좌표의 인덱스가 순서대로 주어진다.</p>

<p>넷째 줄에는 증가하는 방향으로 이동할 것인지, 감소하는 방향으로 이동할 것인지를 나타내는 문자열이 주어지며, +는 증가하는 방향, -는 감소하는 방향을 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 점을 중복해서 방문하지 않을 수 있으면 1을, 아니면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 2의 경우에&nbsp;(0,0) -> (1,0) -> (1,1) -> (0,1) -> (0,0)으로 이동하게 되어서 (0, 0)을 두 번 방문하게 되고, 예제 3의 경우에는&nbsp;(0,0,0) -> (1,0,0) -> (1,1,0) -> (1,1,1) -> (0,1,1) -> (0,0,1) 으로 방문하게 되어서 모든 점을 중복하지 않게 방문한다.</p>

<p>&nbsp;</p>

				</div>
				</div>','1
1
1
+
','1
','DATA_STRUCTURE'),
                                                                                                                (7208,'BAEKJOON','https://www.acmicpc.net/problem/12873',12873,'기념품','2초','512 MB',7,'<p>백준이는 BOJ 알고리즘 캠프 참가자 중 한 명에게 기념품을 주려고 한다. 하지만, 많은 참가자 중에서 어떤 사람을 뽑아서 기념품을 줘야하는지 고민이 되기 시작했다. 따라서, 백준이는 게임을 통해서 기념품을 받을 사람을 정하기로 결정했다.</p>

<p>게임이 시작하기 전에 모든 참가자 N명은 원을 이루어서 앉아있다. 다음, 1부터 N까지 번호가 적혀있는 티셔츠를 시계방향으로 입는다. 이 티셔츠는 게임에 사용되지 않으며, 게임을 쉽게 하기 위해서 입는 티셔츠이다.</p>

<p>게임은 단계로 이루어져 있으며, 첫 단계는 1단계이다. 각 단계가 시작될 때, 백준이는 어떤 참가자의 앞에 서있다. 그 다음, "하나"를 외친다. 그 다음, 시계 방향으로 다음 사람에게 이동하며 "둘"을 외친다. 이 과정은 t단계인 경우에 t<sup>3</sup>을 외칠 때 까지 진행한다. 예를 들어, 1단계에서는 1까지 외치며, 2단계에서는 8까지, 3단계에서는 27까지 외친다.</p>

<p>각 단계가 끝난 경우에, 백준이가 앞에 서 있는 사람은 게임에서 제외된다. (t단계인 경우에 t<sup>3</sup>을 외칠 때 앞에 있던 사람) 사람이 제거된 후에는 백준이는 시계 방향으로 다음 사람에게 이동한다. 1단계에서 백준이는 티셔츠 1번을 입고 있는 사람의 앞에 있다. 게임은 원에 한 명이 남을 때 까지 진행되며, 마지막 남은 사람이 기념품을 가져가게 된다.</p>

<p>참가자의 수 N이 주어졌을 때, 어떤 티셔츠를 입고 있는 사람이 기념품을 받는지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 BOJ 캠프 참가자의 수 N (1 ≤ N ≤ 5,000)이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 기념품을 받는 사람이 입고 있는 티셔츠의 번호를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
','2
','DATA_STRUCTURE'),
                                                                                                                (7209,'BAEKJOON','https://www.acmicpc.net/problem/12876',12876,'반평면 땅따먹기 2','4초','512 MB',23,'<p>원소가 하나도 없는 공집합 상태의 정수 쌍들(pairs of integers) 집합이 있을 때, n개의 연산이 주어진다. 각 연산은 세 가지 유형 중 하나이다.</p>

<ol>
	<li>정수 쌍 (a, b)를 집합에 추가</li>
	<li>i번째 연산에서 추가했던 정수 쌍을 집합에서 제거</li>
	<li>주어지는 정수 x에 대하여 집합에 남아있는 모든 원소 (a, b) 중 ax+b의 최댓값을 출력</li>
</ol>

<p>주어진 연산을 수행하는 프로그램을 작성해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 연산의 개수를 나타내는 n 이 주어집니다. (1 ≤ n ≤ 300,000)</p>

<p>둘째 줄부터 n개의 줄은 연산의 종류를 알려주는 하나의 정수 Type(1, 2, 3 중 하나)으로 시작한다.</p>

<p>Type이 1이라면, 연산 1에 해당하는 2개의 정수 a, b가 주어진다. (-10<sup>9</sup>&nbsp;≤ a, b ≤ 10<sup>9</sup>)</p>

<p>Type이 2라면, 연산 2에 해당하는 1개의 정수 i(1 ≤ i ≤ n)가 주어진다. i는 해당 연산의 번호보다 작고, i번째 연산은 1번 연산이며 해당 연산으로 추가된 정수 쌍은 이전에 또 제거된 적이 없다.</p>

<p>Type이 3이라면, 연산 3에 해당하는 1개의 정수 x가 주어진다. (-10<sup>9</sup>&nbsp;≤ x ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>연산 3을 수행할 때마다&nbsp;답을 순서대로 한 줄에 하나씩 출력한다. 만약 정수 쌍들의 집합이 공집합이라면 “EMPTY”를 출력한다. (따옴표 제외)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
3 1
1 2 3
3 1
1 -1 100
3 1
2 4
3 1
','EMPTY
5
99
5
','DATA_STRUCTURE'),
                                                                                                                (7210,'BAEKJOON','https://www.acmicpc.net/problem/12877',12877,'먹이 사슬','2초','512 MB',17,'<p>BOJ 행성에는 N마리의 동물들이 살고 있습니다. 민호는 이 동물들을 구분하기 위해 1, 2, ..., N의&nbsp;번호를 붙였습니다. 또한 BOJ 행성에 살고 있는 모든 동물들은 A, B, C의 세 종류 중 하나입니다. 민호는 재미있는 점을 발견 했는데 A는 B를 먹고 B는 C를 먹고 C는 A를 먹는다는 사실 입니다.</p>

<p>오랜 기간 행성을 관찰한 민호는 자신이 기록한 내용을 기반으로 BOJ 행성의 생태 지도를 그려보려 합니다. 민호가 기록한 내용은 아래 두 종류 중 하나입니다.</p>

<ul>
	<li>타입 1: x와 y는 같은 종류입니다.</li>
	<li>타입 2: x는 y를 먹습니다.</li>
</ul>

<p>K개의 기록을 1번부터 2번, 3번 … K번까지 순서대로 참고하여 생태 지도를&nbsp;그려가던 중, 민호는 이제까지 그려온 생태 지도와 모순되는 경우나 x와 y가 올바른 동물의 번호가 아닌 경우가 있다는 것을 발견했습니다.</p>

<p>어디서부터 잘못된 건지 찾기 힘들었던 민호는 1번부터 K번까지의 기록을 따라 생태 지도를 그리다 잘못된 기록을 만나면 그 기록은 넘어가기로 했습니다.</p>

<p>민호가 그냥 넘어가야 할 정보는 총 몇 개인지 계산하는 프로그램을 작성해 봅시다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 N, K (1 ≤ N ≤ 50,000, 0 ≤&nbsp;K ≤ 100,000) 이 공백을 구분으로 주어집니다.</p>

<p>각각은 동물의 수와 민호가 기록한 내용의 수를 의미합니다.</p>

<p>두 번째 줄부터 K개의 줄에 걸쳐 민호가 기록한 내용이 주어집니다. 각각의 기록은 t<sub>i</sub>, x<sub>i</sub>, y<sub>i</sub>입니다. t<sub>i</sub>는 1 또는 2이며 x<sub>i</sub>, y<sub>i</sub>는 32비트 부호있는 정수중 하나입니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>민호가 건너 뛰어야 할 잘못된 기록의 수를 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
','3
','DATA_STRUCTURE'),
                                                                                                                (7211,'BAEKJOON','https://www.acmicpc.net/problem/12893',12893,'적의 적','2초','512 MB',12,'<p>살면서 너무 많은 적을 만든 용재는 매일 불안에 떨며 지낸다. 언제 들이닥칠지 모르는 적을 대비해 용재는 친구를 만들기로 했다. 하지만 아무것도 없는 관계에서 친구를 만들기는 힘들어서, 용재는 적의 적은 친구 이론을 이용하기로 했다.</p>

<p>적의 적은 친구 이론이란, A와 적대 관계인 B가 있고, B와 적대 관계인 C가 있을 때 A와 C는 우호 관계에 있다는 이론을 말한다. 하지만 이 이론에는 치명적인 단점이 있다. 바로 C와 적대 관계인 D가 있다면, A 역시 D와 적대관계가 되는 것이다. 하지만 또 생각해보면 D와 적대관계인 E가 있다면 E는 A, C와 우호 관계가 된다. 같은 맥락으로, B와 D 역시 우호 관계가 된다.</p>

<p>이 이론에 따라 친구를 사귀게 되면 적도 늘어나겠지만 어쨌거나 용재는 친구가 절실하다. 하지만 아직 이 이론은 전 우주상에서 엄밀히 증명된 적이 없다. 따라서 용재는 이론을 적용하기 전에 먼저 자신의 주위 N명에 관해서 이 이론이 성립하는지를 먼저 검증하고 싶다. 용재를 도와 이 이론이 성립할 수 있는지를 알아보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 용재 주위 사람의 수 N(1 ≤ N ≤ 2,000)과 적대관계의 수 M(0 ≤ M ≤ 1,000,000)이 주어진다. 두 번째 줄부터 M개의 줄에 거쳐 서로 적대관계에 있는 사람의 번호 A, B(1 ≤ A, B ≤ N)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>이론이 성립할 수 있다면 1, 그렇지 않다면 0을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
1 2
2 3
1 3
','0
','DATA_STRUCTURE'),
                                                                                                                (7215,'BAEKJOON','https://www.acmicpc.net/problem/12895',12895,'화려한 마을','2초','512 MB',18,'<p>민호가 관리하는 천나라에는 N개의 집이 있다. 민호는 집을 쉽게 관리하기 위해 각각의 집을 1번, 2번, … N번으로 부르기로 했다.</p>

<p>어느 날 미적 감각에 눈을 뜬 민호는 특정 구간의 집들의 색들을 새롭게 칠하거나, 특정 구간의 집들에 존재하는 색의 수를 알고 싶어졌다.</p>

<p>작업은 다음과 같은 두가지로 이루어 진다.</p>

<ol>
	<li>“C x y z” : x번과 y번, 그리고 그 사이에 있는 모든 집을 z번 색으로 색칠한다.</li>
	<li>“Q x y” : x번과&nbsp;y번, 그리고 그 사이에 있는 모든 집에 존재하는 색의 가짓수를 출력한다.</li>
</ol>

<p>민호가 사용할 색의 종류는 (1번, 2번, … T번) 이라 하고 처음 모든 집은 1번으로 색칠되어 있다고 생각한다.</p>

<p>민호가 해야하는 작업을 시뮬레이션 해보는 프로그램을 작성하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 N, T, Q (1 ≤ N ≤ 100,000, 1 ≤ T ≤ 30, 1 ≤ Q ≤ 100,000)이 공백을 구분으로 주어진다. 각각 천나라에 존재하는 집의 개수, 사용할 색의 개수, 작업의 개수를 의미한다.</p>

<p>두 번째 줄부터 작업이 주어진다. 작업은 “C x y z” 또는 “Q x y” 둘 중에 하나의 형식으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>작업이 “Q x y”일 때의 경우&nbsp;x번과&nbsp;y번, 그리고 그 사이에 있는 모든 집에 존재하는 색의 가짓수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 2 4
C 1 1 2
Q 1 2
C 2 2 2
Q 1 2
','2
1
','DATA_STRUCTURE'),
                                                                                                                (7216,'BAEKJOON','https://www.acmicpc.net/problem/12899',12899,'데이터 구조','2초','512 MB',17,'<p>자연수를 저장하는 데이터베이스 S에 대해 다음의 쿼리를 처리합시다.</p>

<p>유형 1 : S에 자연수 X를 추가한다.</p>

<p>유형 2 : S에 포함된 숫자 중 X번째로 작은 수를 응답하고 그 수를 삭제한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 사전에 있는 쿼리의 수 N 이 주어집니다. (1 ≤ N ≤ 2,000,000)</p>

<p>둘째 줄부터 N개의 줄에 걸쳐 각 쿼리를 나타내는 2개의 정수 T X가 주어집니다.</p>

<p>T가 1이라면 S에 추가할 X가 주어지는 것입니다. (1 ≤ X ≤ 2,000,000)</p>

<p>T가 2라면 X는 S에서 삭제해야 할 몇 번째로 작은 수인지를 나타냅니다. S에 최소 X개의 원소가 있음이 보장됩니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>유형 2의 쿼리 개수만큼의 줄에 각 쿼리에 대한 답을 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 11
1 29
1 89
2 2
2 2
','29
89
','DATA_STRUCTURE'),
                                                                                                                (7217,'BAEKJOON','https://www.acmicpc.net/problem/12906',12906,'새로운 하노이 탑','5초','512 MB',13,'<p>오늘은 새로운 하노이 탑 게임을 해보려고 한다. 이 게임의 규칙은 다음과 같다.</p>

<ul>
	<li>막대는 총 세 가지 종류가 있다. 막대 A, 막대 B, 막대 C</li>
	<li>게임이 시작될 때, 각각의 막대에는 0개 또는 그 이상의 원판이 놓여져 있다.</li>
	<li>모든 원판의 크기는 같으며, 원판의 종류도 A, B, C로 세 가지가 있다. 원판은 원판 A, 원판 B, 원판 C와 같이 표현한다.</li>
	<li>한 번 움직이는 것은 한 막대의 가장 위에 있는 원판을 다른 막대의 가장 위로 옮기는 것이다.</li>
	<li>게임의 목표는 막대 A에는 원판 A만, 막대 B는 원판 B만, 막대 C는 원판 C만 놓여져 있어야 한다.</li>
	<li>되도록 최소로 움직여야 한다.</li>
</ul>

<p>막대 A, 막대 B, 막대 C에 놓여져 있는 원판의 상태가 주어졌을 때, 게임의 목표를 달성하는데 필요한 움직임의 최소 횟수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 막대 A에 놓여져 있는 원판의 개수와 막대 A의 상태, 둘째 줄에 막대 B에 놓여져 있는 원판의 개수와 막대 B의 상태, 셋째 줄에 막대 C에 놓여져 있는 원판의 개수와 막대 C의 상태가 주어진다. 막대의 상태는 밑에 있는 원판부터 주어진다.</p>

<p>각 막대의 상태는 A, B, C로만 이루어진 문자열이며, 모든 막대에 놓여져 있는 원판 개수의 합은 1보다 크거나 같고, 10보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>게임의 목표를 달성하는데 필요한 움직임의 최소 횟수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 2의 경우에 다음과 같이 움직이면 된다.</p>

<ul>
	<li>원판 A를 막대 A로</li>
	<li>원판 C를 막대 C로</li>
	<li>원판 A를 막대 C로</li>
	<li>원판 B를 막대 B로</li>
	<li>원판 A를 막대 A로</li>
</ul>

<p>예제 3의 경우에 다음과 같이 움직이면 된다.</p>

<ul>
	<li>원판 A를 막대 C로</li>
	<li>원판 B를 막대 B로</li>
	<li>원판 A를 막대 B로</li>
	<li>원판 C를 막대 C로</li>
	<li>원판 A를 막대 A로</li>
</ul>

				</div>
				</div>','1 A
2 AA
2 AA
','4
','DATA_STRUCTURE'),
                                                                                                                (7218,'BAEKJOON','https://www.acmicpc.net/problem/12914',12914,'곰을 위한 레스토랑','2초','512 MB',13,'<p>원래 곰은 밥을 먹을 때 식탁에 앉아서 먹지 않는다. 그런데, 요즘에는 의자에 앉아서 밥을 먹는 곰이 일부 있다고 한다.</p>

<p>강호는 곰을 위한 거대한 레스토랑의 웨이터이다. 이 레스토랑은 무한 개의 의자를 가지고 있고, 한 줄로 놓여져 있다. 의자는 입구에서 가까운 것부터 1번, 2번, ... 으로 번호가 매겨져 있다.</p>

<p>곰은 매우 크기 때문에, 붙어서 앉을 수 없다. 두 곰이 의자에 앉았을 때, 두 곰이 앉은 의자의 번호의 차이는 d보다 크거나 같아야 한다.</p>

<p>예를 들어, d=10인 경우에, 두 곰이 47번과 57번 의자에 앉을 수는 있지만, 47번과 56번 의자에 앉을 수는 없다.</p>

<p>레스토랑은 방금 문을 열었고, 모든 의자는 비어있다.</p>

<p>오늘은 총 N명의 곰이 레스토랑을 방문할 것이고, 한 번에 곰 한마리씩 도착한다. 곰은 레스토랑이 문을 닫을 때까지 의자에서 일어나지 않는다.</p>

<p>레스토랑을 방문하는 곰은 각자 원하는 자리가 있다. i번째 곰이 원하는 자리를 A[i]라고 했을 때, 그 곰의 자리는 A[i]보다 크거나 같아야 한다.</p>

<p>곰을 자리로 안내할 때, 강호는 곰이 앉을 수 있는 의자 중에서 번호가 가장 작은 것을 선택하려고 한다.</p>

<p>곰이 원하는 자리가 도착하는 순서대로 주어졌을 때, 각각의 곰이 어디에 앉는지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 곰의 수 N과 d가 주어진다. (1 ≤ N ≤ 1000, 1 ≤ d ≤ 10<sup>6</sup>)</p>

<p>둘째 줄에는 곰이 원하는 자리가 도착하는 순서대로 주어진다. 곰이 원하는 자리는 1보다 크거나 같고, 10<sup>6</sup>보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>곰이 도착하는 순서대로 앉는 자리를 공백으로 구분해 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 10
1 21 11 7
','1 21 11 31
','DATA_STRUCTURE'),
                                                                                                                (7222,'BAEKJOON','https://www.acmicpc.net/problem/12963',12963,'달리기','2초','512 MB',18,'<p>민혁이는 달리기 대회를 개최하려고 한다. 이 대회는 N개의 교차로로 이루어져있는 도시에서 열리며, 교차로의 번호는 0부터 N-1까지이다.</p>

<p>도시에는 도로가 M개가 있으며, 도로에도 0번부터 M-1번까지 번호가 매겨져 있다. 도로는 양방향이며, 두 교차로를 연결한다. 같은 교차로를 연결하는 도로는 없으며, 두 교차로를 직접 연결하는 도로는 최대 1개이다. 도로 네트워크는 모두 연결되어있지 않을 수도 있다. 즉, 임의의 두 교차로 사이에 경로가 없을 수도 있다.</p>

<p>달리기 대회의 규칙은 매우 간단하다. 참가자는 0번 교차로에서 출발해서 N-1번 교차로에 도착하면 된다. 이때, i번 도로는 3<sup>i</sup>명만 지나갈 수 있다. 예를 들어, 2번 도로의 경우에는 9명만 지나갈 수 있다. 10번째로 2번 도로를 지나가려고 하는 사람은 해당 도로를 이용할 수 없다.</p>

<p>도로의 정보가 주어졌을 때, 0번 교차로에서 출발해서 N-1번 교차로에 도착할 수 있는 사람의 최대 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 도시의 수 N과 도로의 수 M이 주어진다. (2 ≤ N ≤ 2000, 0 ≤ M ≤ 2000)</p>

<p>둘째 줄부터 M개의 줄에는 도로의 정보 a, b가 0번 도로부터 순서대로 주어진다. (0 ≤ a, b < N, a ≠ b) 같은 도로가 여러 번 주어지는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>0번 교차로에서 출발해서 N-1번 교차로에 도착할 수 있는 사람의 최대 수를 1,000,000,007로 나눈 나머지를&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 2
0 1
1 2
','1
','DATA_STRUCTURE'),
                                                                                                                (7229,'BAEKJOON','https://www.acmicpc.net/problem/12974',12974,'시간 여행과 Multiset','2초','512 MB',19,'<p>성관이는 시간 여행을 할 수 있는 타임머신을 개발했다! 하지만, 이 문제는 알고리즘 문제이기 때문에, 그는 무엇인가 멋진 일을 하는 대신 multiset에 시간 여행을 적용하기로 했다.</p>

<p>시간 여행이 포함된 multiset은, 다음과 같은 기능을 제공한다.</p>

<ol>
	<li>특정 시간 t로 가서, multiset에 정수 x를 추가한다.</li>
	<li>특정 시간 t로 가서, multiset에서 정수 x를 제거한다. (시간 t에 multiset에 정수 x가 존재함은 보장된다.)</li>
	<li>특정 시간 t에 multiset에 정수 x가 몇 개 존재하는지 출력한다.</li>
</ol>

<p>예를 들어 설명해보자. 정수 1이 시간 2에 두 개 추가되고, 시간 5에 하나&nbsp;제거되었다고 하자. 이때, 정수 1은 시간 2~4 동안은 2개, 시간 5~에는 1개가 존재한다. 만약 시간 4에서 정수 1을 하나 제거하였다면, 이제 정수 1은 시간 2~3 동안 2개, 시간 4동안 1개, 시간 5~에는 존재하지 않는다. 이 상황에서, 시간 5에서 정수 1을 하나 제거하는 연산은, 정수 1이 그 시점에 존재하지 않으므로 조건에 맞지 않는 연산이다. (따라서 입력으로 들어오지 않는다.)</p>

<p>위와 같은 동작을 구현하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에는 질의의 개수 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>다음 N개의 줄에는 질의의 정보가 주어진다. 각 질의는 세 개의 자연수 a<sub>i</sub>, t<sub>i</sub>, x<sub>i</sub>를 갖는다. (1 ≤ a<sub>i</sub> ≤ 3, 1 ≤ t<sub>i</sub>, x<sub>i</sub> ≤ 10<sup>9</sup>) a<sub>i</sub>는 질의의 종류를 의미한다. t<sub>i</sub>, x<sub>i</sub>는 본문의 질의 설명에 나타나는 변수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>a<sub>i</sub>가 3인 질의가 주어질 때마다, 그 질의의 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
1 1 5
3 5 5
1 2 5
3 6 5
2 3 5
3 7 5
','1
2
1
','DATA_STRUCTURE'),
                                                                                                                (7233,'BAEKJOON','https://www.acmicpc.net/problem/12985',12985,'비밀 회선','1초','512 MB',16,'<p>A.N.S.I.(Ajou Nerd Standards Institution)의 회원들은 서로간의 비밀 회선을 가지고 있다. 모든 회원들은 각자 너드력 V를 가지고 있으며, 1차원 좌표 상에 살고 있다. 비밀 회선을 연결하기 위해서는 이 너드력을 버틸 수 있는 특수한 자재가 필요하다. 하나의 회선을 완성하기 위해 필요한 자재의 개수는 (두 회원간의 거리) X (두 회원의 너드력 중 더 높은 너드력 Vmax)이다.</p>

<p>A.N.S.I.회원들은 서로 친하기 때문에, 모든 회원쌍 간에 직통으로 통하는 비밀 회선이 하나씩 필요하다. 이때 필요한 자재의 총 개수는 몇개일까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 A.N.S.I.의 회원수 N(1 ≤ N ≤ 50,000)이 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 회원들의 너드력 V와 위치 X가 주어진다. (0 ≤ V, X ≤ 50,000)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄에 필요한 자재의 총 개수를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3 1
2 5
2 6
4 3
','57
','DATA_STRUCTURE'),
                                                                                                                (7235,'BAEKJOON','https://www.acmicpc.net/problem/12986',12986,'화려한 마을2','2초','512 MB',19,'<p>민호가 관리하는 천나라에는 N개의 집이 있다. 민호는 집을 쉽게 관리하기 위해 각각의 집을 1번, 2번, … N번으로 부르기로 했다.</p>

<p>어느 날 미적 감각에 눈을 뜬 민호는 천나라에 존재하는 모든 집에 페인트 칠을 했다. 하지만 페인트마다 밝기가 다 다르기 때문에 자짓 잘못하다가는 미관을 해칠 수 있다고 생각을 해 집의 번호가 증가한다면 어두워 지지 않는 방향으로 페인트를 칠하였다.</p>

<p>이렇게 모두 페인트를 칠한 뒤 민호는 특정 구간에 있는 집들에 존재하는 페인트의 밝기들 중 가장 많은 것의 개수가 궁금해졌다.</p>

<p>이를 알아보는 프로그램을 만들어 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 N, Q (1 ≤ N ≤ 100,000, 1 ≤ Q ≤ 100,000)이 공백을 구분으로 주어진다.</p>

<p>각각 천나라에 존재하는 집의 수와 민호가 궁금해 하는 특정 구간의 수이다.</p>

<p>두 번째 줄에는 1번 집부터 N번 집까지 차례대로 칠해진 페인트의 밝기(-100,000 ≤ P ≤ 100,000) 가 주어진다.</p>

<p>세 번째 줄부터 Q개의 줄에 걸쳐 특정 구간이 주어진다. 이는 X, Y (1 ≤ X ≤ Y ≤ N) 으로 이루어 져 있으며 궁금해 하는 특정 구간이 X번 집부터 Y번 집까지라는것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q개의 줄에 걸쳐 각 구간에 가장 많이 등장하는 페인트 밝기의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 3
-1 -1 1 1 1 1 3 10 10 10
2 3
1 10
5 10
','1
4
3
','DATA_STRUCTURE'),
                                                                                                                (7238,'BAEKJOON','https://www.acmicpc.net/problem/13030',13030,'홍준이와 트리','2초','512 MB',19,'<p>1번 정점이 루트인 N개의 정점으로 구성된 트리가 주어진다.</p>

<p>처음에 모든 정점들은 0의 가중치를 가지고 있다. Q의 쿼리가 주어진다. 쿼리는 다음 2가지 중 하나이다.</p>

<ul>
	<li>유형 1: 입력으로 “1 v x k”가 주어진다. 정점 v의 가중치에 x를 더한다. 정점 v와 거리가 1인 모든 자식 노드들의 가중치에는 x-k를 더한다. 정점 v와 거리가 i(i>1)인 모든 자식 노드들의 가중치에는 x-(i × k)만큼을 더한다. (1 ≤&nbsp;v ≤ n, 0 ≤&nbsp;x, k < 10<sup>9</sup>+7)</li>
	<li>유형 2: 입력으로 “2 v”가 주어진다. 정점 v의 가중치를 10<sup>9</sup>+7로 나눈 나머지를 출력한다. (1 ≤&nbsp;v ≤ n)</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정점의 개수 N(1≤N≤300000)과 쿼리의 개수 Q(1≤Q≤300000)가 주어진다.</p>

<p>둘째 줄에 N-1개의 정수 p<sub>2</sub>, p<sub>3</sub>, ... , p<sub>n</sub>이 주어진다. p<sub>k</sub>(1 ≤ p<sub>k</sub>&nbsp; < k)는 정점 k의 부모를 나타낸다.</p>

<p>셋째 줄부터 Q개의 줄에 걸쳐 쿼리가 주어진다. 각 쿼리의 첫 번째 정수 q는 1 또는 2의 값을 가지는 정수인데, 해당 쿼리가 어느 유형에 속하는지를 알려주는 값이다. 이후 해당 유형에 따른 정보가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>유형 2가 입력으로 주어질 때마다 유형 2의 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
1 1
1 1 2 1
2 1
2 2
','2
1
','DATA_STRUCTURE'),
                                                                                                                (7250,'BAEKJOON','https://www.acmicpc.net/problem/13123',13123,'계산 실수','3초','256 MB',22,'<p>수찬이는 수학 시험을 칠 때 문제를 다 풀어놓고 덧셈 또는 뺄셈을 잘못 하여 문제를 틀려버리는 안타까운 상황을 많이 경험한 바 있다. 예를 들어, 지난 7월 6일 시행된 2016학년도 7월 고3 전국연합학력평가의 수학 가형 시험에서, 그는 아래와 같이 뺄셈을 잘못하여 상당히 쉬운 문제를 틀렸다고 한다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13123/fig1.png" style="height:399px; width:376px"></p>

<p style="text-align:center">무엇이 잘못되었을까?</p>

<p>어떻게 하면 이렇게 허무한 실수를 하지 않을지 고심하던 그는, 문득 계산은 계산기가 자신보다 훨씬 잘 한다는 것을 깨달았고, 덧셈 또는 뺄셈을 해야 할 때마다 계산기를 두드려 답을 찾으면 실수를 하지 않을 것이라고 생각하였다. 수찬이는 그 다음 날 계산기를 구매하였고, 계산을 할 일이 생길 때마다 계산기를 사용하며 실수를 하지 않는 자신의 모습에 흡족해했다.</p>

<p>잠시 수찬이가 사용하는 계산기에 대해 알아보자. 수찬이는 덧셈과 뺄셈만 하면 되기 때문에, 계산기는 아래 그림과 같이 계산 과정을 보여주는 화면과 입력을 위한 버튼들로만 구성된, 아주 단순한 구조이다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13123/fig2.png" style="height:144px; width:117px"></p>

<p style="text-align:center">수찬이의 계산기</p>

<p>계산하는 방법 역시 간단하다. 숫자를 나타내는 버튼들(‘<code>0</code>’-‘<code>9</code>’)과 연산 기호(‘<code>+</code>’, ‘<code>-</code>’)를 나타내는 버튼들을 가지고 수식을 입력한 후, ‘<code>=</code>’ 버튼을 누르면 계산 결과를 알 수 있다. 초기화 버튼 ‘<code>AC</code>’를 누르면 계산기의 전체 상태가 처음 상태로 초기화된다. 계산기의 화면은, 숫자를 입력할 때에는 현재 입력되고 있는 수의 값을 보여주고, 연산 기호를 입력했을 때에는 현재까지의 계산 결과를 보여준다. 수찬이의 계산기는 완벽하기에, 수의 범위에는 제한이 없으며, 0으로 시작하는 수를 입력해도 관계 없다. 다만, 연산 기호를 잘못 입력하는 실수를 방지하기 위해, 연산 기호가 연속해서 나올 경우 <em>가장 나중에 나온 것</em>만을 취하고, 수식이 연산 기호로 시작할 경우 <em>앞에 0을 붙였다고 가정</em>하며, 수식이 연산 기호로 끝날 경우 <em>무시</em>한다.</p>

<p>예를 들어, ‘<code>-15+0035-+-3-</code>’을 계산기에 순서대로 입력하고, 마지막에 ‘=’ 버튼을 누르는 과정을 표로 나타내면 다음과 같다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13123/1.png" style="height:300px; width:283px"></p>

<p style="text-align:center">‘<code>-15+0035-+-3-</code>’를 계산기에 입력하는 과정</p>

<p>이 설명을 본 여러분은 당연히 수찬이가 사용하는 계산기가 완벽하다고 생각할 것이다. 수찬이도 처음에는 그렇게 생각했으나, 계산기를 오랫동안 사용하면서 작은 문제점을 하나 발견하였다. 그 문제점은, 수찬이의 계산기에는 다른 계산기와는 달리 현재 입력하고 있는 수만을 초기화시키는 ‘<code>C</code>’ 버튼이 없기에, 계산기에 숫자를 잘못 입력했을 때에는 ‘<code>AC</code>’ 버튼을 눌러 수식을 처음부터 다시 입력할 수밖에 없어 시간 낭비가 심하다는 것이다.</p>

<p>불편해도 꾹 참고 계산기를 사용할 수도 있겠지만, 편리함을 추구하는 수찬이는 다음과 같은 자료구조를 구현하여 고난에서 벗어나고자 한다.</p>

<hr>
<p>‘<code>0</code>’, ‘<code>1</code>’, ‘<code>2</code>’, ‘<code>3</code>’, ‘<code>4</code>’, ‘<code>5</code>’, ‘<code>6</code>’, ‘<code>7</code>’, ‘<code>8</code>’, ‘<code>9</code>’, ‘<code>+</code>’, ‘<code>-</code>’로만 이루어진, 길이가 <em>N</em>인 문자열 <em>S</em>가 있다.</p>

<p>편의상 어떤 문자열 <em>X</em>에 대해 <em>X</em>[<em>i</em>..<em>j</em>]를 <em>X</em>의 <em>i</em>번째 문자, (<em>i</em> + 1)번째 문자, ..., (<em>j</em> ? 1)번째 문자, <em>j</em>번째 문자를 이어 붙인 부분문자열로 정의하자. (단 1 ≤ <em>i</em> ≤ <em>j</em> ≤ |<em>X</em>|)</p>

<p>이때 아래의 두 연산을 지원하는 자료구조를 구현하라.</p>

<ol>
	<li>바꾸기: <em>S</em>[<em>a</em>..<em>b</em>]를 길이가 <em>b</em> ? <em>a</em> + 1인 새로운 문자열 <em>T</em>로 대체하라. 다시 말해, 모든 <em>a</em> ≤ <em>i</em> ≤ <em>b</em>에 대해 <em>S</em>[<em>i</em>]의 값을 <em>T</em>[<em>i</em> ? <em>a</em> + 1]로 바꿔라.</li>
	<li>계산하기: ‘<code>AC</code>’ 버튼을 누른 후, <em>S</em>[<em>a</em>..<em>b</em>]를 계산기에 입력하고, ‘<code>=</code>’ 버튼을 눌렀을 때 계산기의 화면에 보이는 계산 결과를 구하라.</li>
</ol>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 문자열의 길이 <em>N</em> (1 ≤ <em>N</em> ≤ 200 000)이 주어진다.</p>

<p>두 번째 줄에 문자열 <em>S</em>가 주어진다. <em>S</em>의 길이는 <em>N</em>임이 보장된다.</p>

<p>세 번째 줄에 질의의 수 <em>Q</em> (1 ≤ <em>Q</em> ≤ 300 000)가 주어진다.</p>

<p>다음 <em>Q</em>개의 줄에는 연산의 정보가 주어진다. 각 줄의 입력 형식은 아래와 같다.</p>

<ul>
	<li>‘바꾸기’ 연산을 한다면, “1 <em>a</em> <em>b</em> <em>T</em>”와 같은 형식으로 입력이 주어진다. 이때 <em>a</em>, <em>b</em>는 정수이며 1 ≤ <em>a</em> ≤ <em>b</em> ≤ <em>N</em>을 만족하고, <em>T</em>는 길이가 <em>b</em> ? <em>a</em> + 1인 문자열이다. 모든 ‘바꾸기’ 연산에서 주어지는 문자열 <em>T</em>의 길이의 합은 200 000 이하임이 보장된다.</li>
	<li>‘계산하기’ 연산을 한다면, “2 <em>a</em> <em>b</em>”와 같은 형식으로 입력이 주어진다. 이때 <em>a</em>, <em>b</em>는 정수이며 1 ≤ <em>a</em> ≤ <em>b</em> ≤ <em>N</em>을 만족한다. 적어도 하나의 ‘계산하기’ 연산이 주어짐이 보장된다.</li>
</ul>

<p>주어지는 모든 문자열은 ‘<code>0</code>’, ‘<code>1</code>’, ‘<code>2</code>’, ‘<code>3</code>’, ‘<code>4</code>’, ‘<code>5</code>’, ‘<code>6</code>’, ‘<code>7</code>’, ‘<code>8</code>’, ‘<code>9</code>’, ‘<code>+</code>’, ‘<code>-</code>’로만 이루어져 있음이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>‘계산하기’ 연산이 주어질 때마다 계산 결과를 10<sup>9</sup> + 7로 나눈 나머지를 한 줄에 하나씩 출력한다. 어떤 정수 <em>x</em>를 10<sup>9</sup> + 7로 나눈 나머지는, 두 정수 <em>q</em>와 <em>r</em>(0 ≤ <em>r</em> < 10<sup>9</sup> + 7)이 <em>x</em> = <em>q</em> ·(10<sup>9</sup> + 7) + <em>r</em>를 만족할 때, <em>r</em>의 값이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<ol>
	<li>“<code>153+0174-1</code>”를 계산하면 153 + 174 ? 1 = 326이다.</li>
	<li>“<code>3+0174-</code>”를 계산하면 3 + 174 = 177이다.</li>
	<li>이 연산 이후, S는 “<code>15+3-+43-1</code>”이다.</li>
	<li>“<code>5+3-+43</code>”을 계산하면 5 + 3 + 43 = 51이다.</li>
	<li>이 연산 이후, <em>S</em>는 “<code>5-221043-1</code>”이다.</li>
	<li>“<code>21043-</code>”을 계산하면 21043이다.</li>
	<li>“<code>5-221043-1</code>”을 계산하면 5 ? 221043 ? 1 = ?221039이고, 이를 10<sup>9</sup> + 7로 나눈 나머지를 구하면 999778968이다.</li>
	<li>“<code>-</code>”을 계산하면 0이다. 처음 ‘<code>-</code>’ 버튼을 누를 때 수식이 0?이 되었다가, ‘<code>=</code>’ 버튼을 누르면서 마지막의 ‘<code>-</code>’이 무시되어 수식이 0으로 바뀌게 된다.</li>
</ol>

				</div>
				</div>','10
153+0174-1
8
2 1 10
2 3 9
1 3 8 +3-+43
2 2 8
1 1 8 5-221043
2 4 9
2 1 10
2 2 2
','326
177
51
21043
999778968
0
','DATA_STRUCTURE'),
                                                                                                                (7254,'BAEKJOON','https://www.acmicpc.net/problem/13146',13146,'같은 수로 만들기 2','2초','512 MB',16,'<p>n(1 ≤ n ≤ 1,000,000)개의 자연수 A[1], A[2], A[3], …, A[n]이 있다. 이 자연수에 Add(i)라는 연산을 하면, A[i]가 1만큼 증가한다. 이때, A[i]만 증가하는 것이 아니고, A[i]의 좌우로 인접한 같은 수의 그룹이 한번에 1씩 증가한다. A[1]과 A[n]은 인접해 있지 않다.</p>

<p>예를 들어 수가&nbsp;{1, 1, 1, 1, 3, 3, 1} 이었다고 해 보자. Add(2)를 하면 A[2]의 좌우로 인접한 같은 수가&nbsp;1씩 증가하니까 {2, 2, 2, 2, 3, 3, 1}이 된다. 여기서 Add(4)를 하면 {3, 3, 3, 3, 3, 3, 1}이 되고, 여기서 Add(1)을 하면 {4, 4, 4, 4, 4, 4, 1}이 된다.</p>

<p>이와 같이 Add라는 연산을 사용하여 A[1]=A[2]=A[3]=…=A[n]이 되도록 하려 한다. 이때, 최소 회수로 Add연산을 사용하는 방법을 찾는 것이 문제이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 차례로 A[1], A[2], …, A[n]이 주어진다. 모든 입력은 1,000,000,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소의 Add연산 사용 회수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1
5
10
','9
','DATA_STRUCTURE'),
                                                                                                                (7257,'BAEKJOON','https://www.acmicpc.net/problem/13167',13167,'포스터','2초','512 MB',20,'<p>2016년 8월 20일, 알고리즘 대통령을 뽑는 선거가 있다. 이 선거는 알고리즘계의 정상을 노리는 사람이라면 누구나 출마할 수 있다. 특히 올해에는 갑작스러운 알고리즘 붐으로 그 출마자의 수가 월등히 많아 홍보 기간부터 치열한 경쟁이 일고 있다.</p>

<p>그중 가장 문제가 되는 것은 포스터다. 출마자들은 모두 자신을 홍보하는 직사각형 모양의 포스터가 하나씩 있는데, 이 포스터가 크기도 제각각인 데다 그 수도 많아서 거리의 벽이 온통 포스터로 도배되어버렸다. 다른 출마자의 포스터로 인해 자신의 포스터가 가려지면 그 위에 다시 붙이는 등 여러 문제가 발생하자 UCPC(Ultra Capsyong Prominent Center of Algorithm)가 이를 규제하기 위해 나섰다.</p>

<p>총 N명의 출마자에게 각자 1번부터 N번까지의 서로 다른 후보 번호가 주어진다. 각 출마자는 한 벽에 한 장씩, 1번부터 후보 번호의 순서대로 벽에 포스터를 붙이게 된다. 나중에 붙인 출마자의 포스터가 이전에 붙여져 있던 포스터를 덮을 수 있다.</p>

<p>2차원 좌표계로 나타낼 수 있는 아주 큰 벽이 있다. 이 벽면에 N명의 출마자가 모두 포스터를 붙인 뒤 벽면을 바라봤을 때 각 출마자별로 출마자의 포스터가 보이는 넓이를 계산하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 출마자의 수 N (1 ≤ N ≤ 5,000)이 주어진다. 두 번째 줄부터 N개의 줄에는 1번부터 N번 후보의 포스터 정보가 한 줄 씩 주어진다. 포스터 정보는 4개의 정수 x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>로 이루어지며, 이는 좌측 하단 (x<sub>1</sub>, y<sub>1</sub>)부터 우측 상단 (x<sub>2</sub>, y<sub>2</sub>)까지의 공간을 차지하는 포스터를 해당 좌표 범위에 붙인다는 의미이다(x<sub>1</sub>&nbsp;< x<sub>2</sub>, &nbsp;y<sub>1</sub> < y<sub>2</sub>). 각 좌표의 범위는 -1,000,000,000보다 크거나 같고, 1,000,000,000보다 작거나 같다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1번 후보부터 N번 후보의 포스터가 보이는 넓이를 줄로 구분하여 총 N개의 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13167/1.png" style="height:205px; width:292px"></p>

<ul>
	<li>1번 후보자 : 파란색 포스터 / 2번 후보자 : 초록색 포스터</li>
	<li>3번 후보자 : 주황색 포스터 / 4번 후보자 : 노란색 포스터</li>
</ul>

<p>&nbsp;</p>

				</div>
				</div>','4
0 0 8 7
2 3 11 11
5 1 10 6
1 4 7 8
','23
41
21
24
','DATA_STRUCTURE'),
                                                                                                                (7253,'BAEKJOON','https://www.acmicpc.net/problem/13203',13203,'읽어내기','4초','256 MB',20,'<p>고대 유적을 발굴하던 성원이는 커다란 비석을 찾아내었고, 학계에 보고하기 위해 그 비석에 적힌 글을 해독하고 있다. 하지만 이 비석은 오랜 세월을 거치며 글자들이 지워져 잘 보이지 않게 되었다.</p>

<p>이 비석이 만들어질 당시의 사람들은 비석에 왕의 이름을 써 놓는 것을 좋아했다. 비석의 글자들 중 일부 (연속하지 않아도 된다)를 골라 순서대로 조합하여 왕의 이름이 되는 경우의 수가 많을수록 더 좋아했다고 한다. 또 이 당시 사람들은 말을 길게 하는 것을 좋아하지 않아 왕의 이름은 항상 5글자 이내였다고 한다.</p>

<p>방사선 연대 측정을 통해 이 비석이 묻힐 당시의 왕의 이름을 알게 된 성원이는 이 비석에 왕의 이름을 읽어낼 수 있는 경우의 수가 몇 가지인지 알고 싶게 되었다. 그런데 비석의 글씨는 잘 보이지 않으므로 연구가 진행됨에 따라 비석의 일부의 해석이 달라질 수 있고, 그 때마다 이름을 읽어내는 경우의 수를 알고 싶어한다. 성원이를 도와 경우의 수를 계산하는 프로그램을 작성해 주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 테스트 케이스의 수 <em>T</em> 가 주어진다.</p>

<p>각 테스트 케이스의 첫 번째 줄에는 비석의 글자 수 <em>N</em>(1 ≤ <em>N</em> ≤ 200, 000)과 왕의 이름의 길이 <em>M</em>(1 ≤ <em>M</em> ≤ 5), 그리고 비석의 해석이 바뀌는 횟수 <em>Q</em>(0 ≤ <em>Q</em> ≤ 100, 000)가 주어진다. 둘째 줄에는 비석에 적힌 글의 첫 번째 해석이 하나의 문자열로 주어진다. 이는 영어 알파벳 대문자로만 구성되어 있다. 셋째 줄에는 왕의 이름이 하나의 문자열로 주어지며, 마찬가지로 영어 알파벳 대문자로만 구성되어 있다. 넷째 줄부터 <em>Q</em>개의 줄에는 한 줄마다 두 개의 정수 <em>A<sub>i</sub></em> , <em>B<sub>i</sub></em> 와 문자열 <em>S<sub>i</sub></em> 가 주어진다. (1 ≤ <em>A<sub>i</sub></em> ≤ <em>B<sub>i</sub></em> ≤ N, len(<em>S<sub>i</sub></em>) = <em>B<sub>i</sub></em> ? <em>A<sub>i</sub></em> + 1) 이는 비석의 <em>A<sub>i</sub></em> 번째 문자부터 <em>B<sub>i</sub></em> 번째 문자까지의 해석이 <em>S<sub>i</sub></em> 로 바뀐다는 뜻이다. <em>S<sub>i</sub></em> 의 길이 총합은 2, 000, 000 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다, <em>Q</em> + 1개의 줄에 한 줄에 하나의 정수를 출력한다. <em>i</em>번째 줄에는 비석의 <em>i</em>번째 해석에서 왕의 이름을 읽을 수 있는 경우의 수를 출력한다. 답이 커질 수 있으므로 1, 000, 000, 007로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
20 5 1
MIDASMIDASMIDASMIDAS
MIDAS
2 19 MMMIIIIDDDDAAAASSS
','56
1024
','DATA_STRUCTURE'),
                                                                                                                (7185,'BAEKJOON','https://www.acmicpc.net/problem/13208',13208,'승현이와 승현이','2초','256 MB',22,'<p>석환나라에는 조승현이라는 이름을 가진 사람이 두 명이 있다. 헷갈리니까 한 명은 조승현13 이라 하고 한 명은 조승현16 이라 하자. 이 둘은 원래 서로의 존재를 모르고 있다가 얼마전에 뉴스를 보고 알게 되었다. 자신과 같은 이름을 가진 사람이 존재한다는 것이 너무 신기했던 그 둘은 연락처를 알아내서 서로 연락하는 사이가 되었다.</p>

<p>어느 날 그 들은 상대방이 사는 도시에 대해 궁금해졌다. 전화로 서로의 도시에 대해 설명해주다가 지친 그 들은 결국 상대방의 도시에 여행을 가기로 결정했다.</p>

<p>석환나라는 <em>N</em> 개의 도시로 이루어져 있고 도시마다 번호가 1부터 <em>N</em> 까지 붙어있다. 그 사이에 도시들을 연결하는 도로 <em>M</em> 개가 있다. 하나의 도로는 도시 두개를 연결하고 그 사이를 양방향으로 다닐 수 있게 한다. 그리고 임의의 한 도시에서 출발하여 도로를 적당히 거쳐가면 다른 모든 도시에 도착할 수 있음이 보장되어있다.</p>

<p>현재 조승현13은 <em>S</em> 번 도시에 있고 조승현16은 <em>E</em> 번 도시에 살고있다. 이 둘은 상대방에게 자신의 도시로 가는 길을 설명해주기 위해 전화로 연락을 유지하면서 다음과 같은 방법으로 여행한다.</p>

<ol>
	<li>0일차에 조승현13은 <em>S</em> 번 도시에, 조승현16은 <em>E</em> 번 도시에 있다.</li>
	<li><em>i</em>일차 (<em>i</em> ≥ 0)의 아침에 둘은 전화로 연락하여 오늘 누가 움직일지 결정한다. 하루에 둘 중 한 명만 움직일 수 있다.</li>
	<li>이동하기로 결정된 사람은 현재 위치한 도시에 연결된 도로 중 하나를 골라 그 도로를 따라 이동하고, 반대편 도시에 도착하면 이동을 마친다. 이 과정은 석양이 지기 전에 항상 완료된다.</li>
	<li><em>i</em>일차의 석양이 진 후에 둘은 다시 전화로 연락하여 서로의 생사를 확인한다.</li>
	<li>생사를 확인한 직후에 조승현13이 <em>E</em>번 도시에, 조승현16이 <em>S</em>번 도시에 있는 상태라면 여행을 종료한다. 그렇지 않다면, 숙소에서 자고 일어난 후 2번 과정으로 돌아가 반복한다.</li>
</ol>

<p>전화로 연락하기 위해서는 각자 갖고 있는 전화기가 일정 수준 이상의 무선 신호 출력을 낼 수 있어야 한다. 각 도시 <em>i</em> 마다 무선 신호가 잘 퍼지는지 아닌지를 나타내는 양의 정수 <em>C<sub>i</sub></em> 가 있을 때, 두 도시 <em>a</em>, <em>b</em> 사이에서 전화를 하려면 전화기가 <em>C<sub>a</sub></em> × <em>C<sub>b</sub></em> 이상의 출력을 낼 수 있어야 한다. 이 법칙은 이상한 일이지만 두 명이 같은 도시 안에 있어도 여전히 적용된다.</p>

<p>두 조승현은 여행을 시작하기전에 똑같은 전화기를 하나씩 사서 여행이 끝날 때 까지 그 전화기만 사용할 것이다. 전화기의 가격은 전화기가 낼 수 있는 출력에 비례하기 때문에, 어떻게 여행하느냐에 따라 필요한 전화기의 가격이 변한다. <em>S</em> 와 <em>E</em> 가 주어졌을 때, 여행을 무사히 마치기 위해 필요한 전화기의 출력의 최솟값을 구해서 두 조승현을 만족시켜주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>주의 : 이 문제의 입력은 하나의 테스트 케이스로 구성되어 있다.</p>

<p>첫 번째 줄에 도시의 수 <em>N</em> (2 ≤ <em>N</em> ≤ 500)과 도로의 수 <em>M</em> (1 ≤ <em>M</em> ≤ 3, 000)이 주어진다. 두 번째 줄에 <em>N</em> 개의 정수가 주어진다. <em>i</em>번째 정수는 <em>C<sub>i</sub></em> (1 ≤ <em>C<sub>i</sub></em> ≤ 40, 000) 를 나타내며 이것은 <em>i</em>번 도시의 무선 신호 상수를 나타낸다.</p>

<p>이후로 <em>M</em> 개의 줄에 걸쳐 2개의 정수 <em>a</em>, <em>b</em> (1 ≤ <em>a</em>, <em>b</em> ≤ <em>N</em>, <em>a</em>&nbsp;≠&nbsp;<em>b</em>) 가 공백으로 구분되어 주어지는데, 이것은 도시 <em>a</em>와 도시 <em>b</em> 사이를 잇는 도로가 존재함을 뜻한다.</p>

<p>그 다음 줄에 질문의 수 <em>Q</em> (1 ≤ <em>Q</em> ≤ <em><sub>n</sub></em>C<sub>2</sub>) 가 주어진다. 이후로 <em>Q</em> 개의 줄에 걸쳐 2개의 정수 <em>S</em>, <em>E</em> (1 ≤ <em>S</em>, <em>E</em> ≤ <em>N</em>, <em>S</em> ≠ <em>E</em>) 가 공백으로 구분되어 주어지는데, 이것은 처음에 조승현13이 <em>S</em> 번 도시에 있고 조승현16이 <em>E</em> 번 도시에 있을 때의 상황을 뜻하는 것이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em> 개의 줄에 각 질문에 대해 여행을 성공적으로 마치기 위해 필요한 전화기의 출력의 최솟값을 구하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
5 1 3 100 12
1 2
2 3
3 1
4 3
4 5
3
1 2
2 3
5 3
','5
3
100
','DATA_STRUCTURE'),
                                                                                                                (7221,'BAEKJOON','https://www.acmicpc.net/problem/13303',13303,'장애물 경기','2초','512 MB',18,'<p>평면 상에서 어떤 점의 위치를 나타내기 위해 좌표를 이용하면 매우 편리하다. <그림 1>에서 예로 보인 것처럼 기준점(이를 원점이라 부른다)에서 우측으로 거리가 4, 위로 거리가 3에 놓인 빨간 점의 좌표는 (4, 3)로 표시한다. 좌표를 이용하면 평면 상에 있는 어떤 점의 위치도 쉽게 나타낼 수 있다. 즉, 기준점에서 오른쪽으로 거리가 x, 위로 거리가 y에 놓인 점의 좌표는 (x, y)로 나타낸다. 기준점(원점)의 좌표는 (0, 0)이 된다.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13303/1.png" style="height:156px; width:183px"></p>

<p style="text-align: center;"><그림 1></p>

<p>장애물이 설치된 넓은 들판에서 재미있는 달리기 시합이 벌어진다. 들판 곳곳에 수직방향(남북방향)으로 된 담장 모양의 장애물이 설치되어 있다. 선수는 출발지점에서 동쪽방향으로 달리기 시작하다가 장애물을 만나면 남쪽 또는 북쪽으로 달려 장애물을 피해가야 한다. 장애물 끝에 다다르면 다시 선수는 동쪽으로만 달릴 수 있다.&nbsp;</p>

<p>이 달리기의 목표는 결승선으로 지정된 (무한히 긴) 수직선에 가장 짧은 거리를 달려 도달하는 것이다. 달리기 시작 전에 모든 장애물에 대한 정보가 선수에게 주어진다. 즉, 어떤 크기의 장애물이 어느 위치에 놓여있는지에 대한 정보가 선수에게 주어지고, 선수는 장애물을 피해가면서 가장 짧은 거리를 달려 결승선에 도착해야 한다.</p>

<p>선수의 출발지점 및 각 장애물 양 끝점의 위치는 (x, y) 좌표를 사용하여 표시한다. 모든 좌표 값은 정수로 주어지고, 출발지점의 x 좌표는 0이다. 각 장애물은 수직선분으로 볼 수 있고, 이때 양 끝점의 x 좌표는 동일하기 때문에 장애물에 대한 정보는 세 값 [x, y<sub>l</sub>, y<sub>h</sub>] (y<sub>l</sub> < y<sub>h</sub>)으로 나타낼 수 있다. 이 세 값은 장애물이 설치된 곳의 x 좌표와 양 끝점의 y 좌표를 나타낸다.&nbsp;</p>

<p>x 좌표가 동일한 두 장애물이 겹치거나 또는 한 점에서 만나는 경우는 없다.&nbsp;</p>

<p>선수가 동쪽으로 달리다가 장애물의 끝 점을 만나면 계속 동쪽으로 달려간다.&nbsp;</p>

<p><그림 2>의 예를 보자. 출발지점이 (0, 43), 결승선의 x 좌표가 70이고, 4개의 수직 장애물에 대한 정보가 각각 [20, 30, 50], [30, 10, 38], [45, 35, 55], [55, 50, 70]인 경우, 최단의 이동경로는 점선으로 표시한 것처럼 (0, 43) → (20, 43) → (20, 50) → (45, 50) → (45, 55) → (55, 55) → (55, 50) → (70, 50)이 되고, 이때의 총 이동거리는 87이다. 또한 도착지 점의 y 좌표는 50이 된다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13303/2.png" style="height:240px; width:277px"></p>

<p style="text-align: center;"><그림 2></p>

<p><그림 3>의 예에선 서로 다른 최단경로가 다음과 같이 4개가 있다</p>

<ol>
	<li>(0, 40) → (20, 40) → (20, 50) → (35, 50) → (35, 60) → (70, 60)</li>
	<li>(0, 40) → (20, 40) → (20, 50) → (35, 50) → (35, 40) → (70, 40)</li>
	<li>(0, 40) → (20, 40) → (20, 30) → (50, 30) → (50, 40) → (70, 40)</li>
	<li>(0, 40) → (20, 40) → (20, 30) → (50, 30) → (50, 20) → (70, 20)</li>
</ol>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13303/3.png" style="height:237px; width:273px"></p>

<p style="text-align: center;"><그림 3></p>

<p><그림 3>에서 보인 경로 가운데 경로 ②와 경로 ③은 달리는 경로는 다르지만 도착지점은 동일하다.</p>

<p>출발지점의 y 좌표, 결승선의 x 좌표, N개의 장애물에 대한 정보가 주어질 때 이동 규칙을 따르는 최단경로를 모두 찾은 후, 도착지점이 서로 다른 최단경로의 도착지점의 y 좌표 값을 오름차순으로 차례로 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 장애물의 개수를 나타내는 정수 N (1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 출발지점의 y 좌표와 결승선의 x 좌표를 나타내는 두 정수가 차례로 주어진다. 이어지는 N 개의 줄 각각엔 장애물의 정보를 나타내는 세 정수 [x, y<sub>l</sub>, y<sub>h</sub>] (y<sub>l</sub> < y<sub>h</sub>)가 차례로 주어진다. 문제에서 사용되는 모든 좌표 (x, y)에 대해, 0 ≤ x ≤ 1,000,000이고 0 ≤ y ≤ 2,000,000이다. 모든 장애물의 x 좌표는 0보다 크고 결승선의 x 좌표보다 작다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 첫 번째 줄에는 최단경로의 길이를 출력한다. 두 번째 줄엔 최단경로들의 서로 다른 도착지점의 개수 k와, k개의 도착지점의 y 좌표를 오름차순으로 차례로 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
43 70
30 10 38
20 30 50
45 35 55
55 50 70
','87
1 50
','DATA_STRUCTURE'),
                                                                                                                (7220,'BAEKJOON','https://www.acmicpc.net/problem/13306',13306,'트리','2초','512 MB',17,'<p>트리 T는 아래 그림 1과 같은 구조를 가지고 있으며 원은 ‘정점’이라 하고, 정점과 정점을 연결하는 선을 ‘에지’라 한다. 특히 가장 위에 위치한 정점을 ‘루트’라 하는데 오직 하나만 있다. N개의 정점들은 숫자 1부터 N으로 표현하고 루트는 항상 1이다.</p>

<p>두 정점 v와 w를 연결하는 경로는 정점들의 순서리스트 (v<sub>0</sub>, v<sub>1</sub>, ..., v<sub>m</sub>)로, 정점 v<sub>i</sub>와 v<sub>i+1</sub>은 에지로 연결되고 v<sub>0</sub> = v, v<sub>m</sub> = w이다. 트리에서는 임의의 두 정점 v와 w 사이에 항상 두 정점을 연결하는 경로가 오직 하나만 존재한다. 예를 들어, 그림 1에서 정점 3과 11 사이의 유일한 경로는 (3, 4, 1, 7, 11)이다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13306/1.png" style="height:228px; width:211px"></p>

<p style="text-align: center;">그림 1</p>

<p>각 정점 v에서 루트 r과 연결하는 유일한 경로 P에 대해서 정점 v와 에지로 연결된 정점 중에서 P상에 있는 정점을 v의 ‘부모 정점’이라고 한다. 예를 들어, 그림 1에서 4, 7, 9의 부모 정점은 1이고, 2와 11의 부모 정점은 7이다.</p>

<p>트리 T에서 어떤 두 정점을 연결하는 에지를 제거하면 그 두 정점 외에도 경로가 존재하지 않는 정점 쌍이 있을 수 있다. 여러분은 “정점 v와 w를 연결하는 경로가 존재하는가?”와 같은 질의에 답해야 한다. 예를 들어, 그림 1에서 7과 11 사이의 에지를 제거하면 8과 5를 연결하는 경로는 존재하지 않는다.&nbsp;</p>

<p>트리 정보가 주어지고, 에지의 제거 정보와 질의가 임의의 순서로 주어질 때, 작업을 순서대로 수행하며 질의에 대한 답을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 트리의 정점의 개수와 질의의 개수를 나타내는 두 정수 N과 Q (1 ≤ N, Q ≤ 200,000)가 주어진다. 다음 N-1개의 줄의 i번째 줄에는 정점 i+1의 부모 정점을 나타내는 정수 a가 주어진다 (1 ≤ a ≤ N). 다음 (N-1)+Q개의 줄 중에서 N-1개는 (1)의 형태로, Q개는 (2)의 형태로 주어진다. (1) 두 정수 x와 b가 주어진다(x = 0, 2 ≤ b ≤ N). 이것은 b의 부모 정점과 b를 연결하는 에지를 제거함을 의미한다. 각 줄의 b는 모두 다르다. (2) 세 정수 x, c, d가 주어진다 (x = 1, 1 ≤ c, d ≤ N). 이것은 c와 d를 연결하는 경로가 존재하는 지 묻는 질의를 의미한다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 질의에 대한 답을 순서대로 Q개의 줄에 출력한다. 각 줄마다 경로가 존재하면 <code>YES</code>를 아니면 <code>NO</code>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
1
1
1 2 3
0 3
1 2 3
1 1 2
0 2
','YES
NO
YES
','DATA_STRUCTURE'),
                                                                                                                (7223,'BAEKJOON','https://www.acmicpc.net/problem/13309',13309,'트리','2초','512 MB',20,'<p>트리 T는 아래 그림 1과 같은 구조를 가지고 있으며 원은 ‘정점’이라 하고, 정점과 정점을 연결하는 선을 ‘에지’라 한다. 특히 가장 위에 위치한 정점을 ‘루트’라 하는데 오직 하나만 있다. N개의 정점들은 숫자 1부터 N으로 표현하고 루트는 항상 1이다.</p>

<p>두 정점 v와 w를 연결하는 경로는 정점들의 순서리스트 (v<sub>0</sub>, v<sub>1</sub>, ..., v<sub>m</sub>)로, 정점 v<sub>i</sub>와 v<sub>i+1</sub>은 에지로 연결되고 v<sub>0</sub>&nbsp;= v, v<sub>m</sub>&nbsp;= w이다. 트리에서는 임의의 두 정점 v와 w 사이에 항상 두 정점을 연결하는 경로가 오직 하나만 존재한다. 예를 들어, 그림 1에서 정점 3과 11 사이의 유일한 경로는 (3, 4, 1, 7, 11)이다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13306/1.png" style="height:228px; width:211px"></p>

<p style="text-align:center">그림 1</p>

<p>각 정점 v에서 루트 r과 연결하는 유일한 경로 P에 대해서 정점 v와 에지로 연결된 정점 중에서 P상에 있는 정점을 v의 ‘부모 정점’이라고 한다. 예를 들어, 그림 1에서 4, 7, 9의 부모 정점은 1이고, 2와 11의 부모 정점은 7이다.</p>

<p>트리 T에서 어떤 두 정점을 연결하는 에지를 제거하면 그 두 정점 외에도 경로가 존재하지 않는 정점 쌍이 있을 수 있다. 여러분은 “정점 v와 w를 연결하는 경로가 존재하는가?”와 같은 질의에 답해야 한다. 예를 들어, 그림 1에서 7과 11 사이의 에지를 제거하면 8과 5를 연결하는 경로는 존재하지 않는다.&nbsp;</p>

<p>트리 정보가 주어지고, 에지의 제거 정보와 질의가 임의의 순서로 주어질 때, 작업을 순서대로 수행하며 질의에 대한 답을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 트리의 정점의 개수와 질의의 개수를 나타내는 두 정수 N과 Q (1 ≤ N, Q ≤ 200,000)가 주어진다. 다음 N-1개의 줄의 i번째 줄에는 정점 i+1의 부모 정점을 나타내는 정수 a가 주어진다 (1 ≤ a ≤ N). 다음 Q개의 줄 각각에는 세 정수 b, c, d가 주어진다. d = 0이면, b와 c를 연결하는 경로가 존재하는 지 묻는 질의만 수행함을 의미한다. d = 1이면, b와 c를 연결하는 경로가 존재하는 지 묻는 질의를 수행하고, 대답이 “<code>YES</code>”이면, 이어서 b의 부모 정점과 b를 연결하는 에지를 제거한다. 대답이 “<code>NO</code>”이면, c의 부모 정점과 c를 연결하는 에지를 제거한다. 만약 제거하려는 에지가 원래 존재하지 않거나 이미 제거된 경우에는 제거되는 에지가 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 질의에 대한 답을 순서대로 Q개의 줄에 출력한다. 각 줄마다 경로가 존재하면&nbsp;<code>YES</code>를 아니면&nbsp;<code>NO</code>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
1
1
2 3 1
1 3 0
2 3 1
1 3 1
','YES
YES
NO
NO
','DATA_STRUCTURE'),
                                                                                                                (7219,'BAEKJOON','https://www.acmicpc.net/problem/13323',13323,'BOJ 수열 1','2초','512 MB',23,'<p>수열 A<sub>1</sub>, A<sub>2</sub> .. A<sub>N</sub> 이 주어진다.</p>

<p>B<sub>1</sub> < B<sub>2</sub> < ... < B<sub>N</sub> 을 만족하면서, |B<sub>1</sub> - A<sub>1</sub>| + |B<sub>2</sub> - A<sub>2</sub>| ... |B<sub>N</sub> - A<sub>N</sub>| 을 최소화하는 수열 B가 존재할 때, 당신은 그러한 값의 가능한 최솟값을 출력해야 한다.</p>

<p>수열 A와 B는 정수로만 이루어진 수열이고, 수열 B의 원소는 32비트 정수형 범위 안에 들어있어야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 N이 주어진다. (N ≤ 1,000,000) 두 번째 줄에 수열 A의 원소가 순서대로 주어진다. (0 ≤ A<sub>i</sub> ≤ 2 ×&nbsp;10<sup>9</sup>)&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가능한 |B<sub>1</sub> - A<sub>1</sub>| + |B<sub>2</sub> - A<sub>2</sub>| ... |B<sub>N</sub> - A<sub>N</sub>| 값의 최소를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>B = {6,7,8,13,14,15,18} 수열이 |B<sub>1</sub> - A<sub>1</sub>| + |B<sub>2</sub> - A<sub>2</sub>| ... |B<sub>N</sub> - A<sub>N</sub>| 값을 최소화한다. 최소화된 값은 13이다.&nbsp;</p>

				</div>
				</div>','7
9 4 8 20 14 15 18
','13
','DATA_STRUCTURE'),
                                                                                                                (7224,'BAEKJOON','https://www.acmicpc.net/problem/13324',13324,'BOJ 수열 2','2초','512 MB',24,'<p>수열 A<sub>1</sub>, A<sub>2</sub>&nbsp;.. A<sub>N</sub>&nbsp;이 주어진다.</p>

<p>B<sub>1</sub>&nbsp;< B<sub>2</sub>&nbsp;< ... < B<sub>N</sub>&nbsp;을 만족하면서, |B<sub>1</sub>&nbsp;- A<sub>1</sub>| + |B<sub>2</sub>&nbsp;- A<sub>2</sub>| ... |B<sub>N</sub>&nbsp;- A<sub>N</sub>| 을 최소화하는 수열 B가 존재할 때, 당신은 그러한 값의 가능한 최솟값을 출력해야 한다.</p>

<p>수열 A와 B는 정수로만 이루어진 수열이고, 수열 B의 원소는 32비트 정수형 범위 안에 들어있어야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 N이 주어진다. (N ≤ 1,000,000)&nbsp;두 번째 줄에 수열 A의 원소가 순서대로 주어진다. (0 ≤ A<sub>i</sub>&nbsp;≤ 2 ×&nbsp;10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>|B<sub>1</sub>&nbsp;- A<sub>1</sub>| + |B<sub>2</sub>&nbsp;- A<sub>2</sub>| ... |B<sub>N</sub>&nbsp;- A<sub>N</sub>| 값을 최소화하는 수열을 아무거나 출력한다. 각각의 원소를 N개의 줄에 걸쳐서 출력해야 한다. 출력한 수열의 각 원소는, 32비트 정수형 범위 안에 들어가야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>B = {6,7,8,13,14,15,18} 수열이 |B<sub>1</sub>&nbsp;- A<sub>1</sub>| + |B<sub>2</sub>&nbsp;- A<sub>2</sub>| ... |B<sub>N</sub>&nbsp;- A<sub>N</sub>| 값을 최소화한다. 최소화된 값은 13이다.&nbsp;</p>

				</div>
				</div>','7
9 4 8 20 14 15 18
','6
7
8
13
14
15
18
','DATA_STRUCTURE'),
                                                                                                                (7227,'BAEKJOON','https://www.acmicpc.net/problem/13334',13334,'철로','1초','512 MB',14,'<p>집과 사무실을 통근하는 n명의 사람들이 있다. 각 사람의 집과 사무실은 수평선 상에 있는 서로 다른 점에 위치하고 있다. 임의의 두 사람 A, B에 대하여, A의 집 혹은 사무실의 위치가 B의 집 혹은 사무실의 위치와 같을 수 있다. 통근을 하는 사람들의 편의를 위하여 일직선 상의 어떤 두 점을 잇는 철로를 건설하여, 기차를 운행하려고 한다. 제한된 예산 때문에, 철로의 길이는 d로 정해져 있다. 집과 사무실의 위치 모두 철로 선분에 포함되는 사람들의 수가 최대가 되도록, 철로 선분을 정하고자 한다.</p>

<p>양의 정수 d와 n 개의 정수쌍, (h<sub>i</sub>, o<sub>i</sub>), 1 ≤ i ≤ n,이 주어져 있다. 여기서 h<sub>i</sub>와 o<sub>i</sub>는 사람 i의 집과 사무실의 위치이다. 길이 d의 모든 선분 L에 대하여, 집과 사무실의 위치가 모두 L에 포함되는 사람들의 최대 수를 구하는 프로그램을 작성하시오.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13334/1.png" style="height: 116.667px; width: 351.667px;"></p>

<p style="text-align: center;">그림 1. 8 명의 집과 사무실의 위치</p>

<p>그림 1 에 있는 예를 고려해보자. 여기서 n = 8, (h<sub>1</sub>, o<sub>1</sub>) = (5, 40), (h<sub>2</sub>, o<sub>2</sub>) = (35, 25), (h<sub>3</sub>, o<sub>3</sub>) = (10, 20), (h<sub>4</sub>, o<sub>4</sub>) = (10, 25), (h<sub>5</sub>, o<sub>5</sub>) = (30, 50), (h<sub>6</sub>, o<sub>6</sub>) = (50, 60), (h<sub>7</sub>, o<sub>7</sub>) = (30, 25), (h<sub>8</sub>, o<sub>8</sub>) = (80, 100)이고, d = 30이다. 이 예에서, 위치 10 과 40 사이의 빨간색 선분 L이, 가장 많은 사람들에 대하여 집과 사무실 위치 모두 포함되는 선분 중 하나이다. 따라서 답은 4 이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 표준입력을 사용한다. 첫 번째 줄에 사람 수를 나타내는 양의 정수 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 각 줄에 정수 쌍 (h<sub>i</sub>, o<sub>i</sub>)가 주어진다. 여기서 h<sub>i</sub>와 o<sub>i</sub>는 ?100,000,000이상, 100,000,000이하의 서로 다른 정수이다. 마지막 줄에, 철로의 길이를 나타내는 정수 d (1 ≤ d ≤ 200,000,000)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 표준출력을 사용한다. 길이 d의 임의의 선분에 대하여, 집과 사무실 위치가 모두 그 선분에 포함되는 사람들의 최대 수를 한 줄에 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
5 40
35 25
10 20
10 25
30 50
50 60
30 25
80 100
30
','4
','DATA_STRUCTURE'),
                                                                                                                (7230,'BAEKJOON','https://www.acmicpc.net/problem/13335',13335,'트럭','1초','512 MB',10,'<p>강을 가로지르는 하나의 차선으로 된 다리가 하나 있다. 이 다리를 n 개의 트럭이 건너가려고 한다. 트럭의 순서는 바꿀 수 없으며, 트럭의 무게는 서로 같지 않을 수 있다. 다리 위에는 단지 w 대의 트럭만 동시에 올라갈 수 있다. 다리의 길이는 w 단위길이(unit distance)이며, 각 트럭들은 하나의 단위시간(unit time)에 하나의 단위길이만큼만 이동할 수 있다고 가정한다. 동시에 다리 위에 올라가 있는 트럭들의 무게의 합은 다리의 최대하중인 L보다 작거나 같아야 한다. 참고로, 다리 위에 완전히 올라가지 못한 트럭의 무게는 다리 위의 트럭들의 무게의 합을 계산할 때 포함하지 않는다고 가정한다.</p>

<p>예를 들어, 다리의 길이 w는 2, 다리의 최대하중 L은 10, 다리를 건너려는 트럭이 트럭의 무게가 [7, 4, 5, 6]인 순서대로 다리를 오른쪽에서 왼쪽으로 건넌다고 하자. 이 경우 모든 트럭이 다리를 건너는 최단시간은 아래의 그림에서 보는 것과 같이 8 이다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13335/1.png" style="height: 123.333px; width: 384.167px;"></p>

<p style="text-align: center;">Figure 1. 본문의 예에 대해 트럭들이 다리를 건너는 과정.</p>

<p>다리의 길이와 다리의 최대하중, 그리고 다리를 건너려는 트럭들의 무게가 순서대로 주어졌을 때, 모든 트럭이 다리를 건너는 최단시간을 구하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력 데이터는 표준입력을 사용한다. 입력은 두 줄로 이루어진다. 입력의 첫 번째 줄에는 세 개의 정수 n (1 ≤ n ≤ 1,000) , w (1 ≤ w ≤ 100) and L (10 ≤ L ≤ 1,000)이 주어지는데, n은 다리를 건너는 트럭의 수, w는 다리의 길이, 그리고 L은 다리의 최대하중을 나타낸다. 입력의 두 번째 줄에는 n개의 정수 a<sub>1</sub>, a<sub>2</sub>, ? , a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 10)가 주어지는데, a<sub>i</sub>는 i번째 트럭의 무게를 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 표준출력을 사용한다. 모든 트럭들이 다리를 건너는 최단시간을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2 10
7 4 5 6
','8
','DATA_STRUCTURE'),
                                                                                                                (7240,'BAEKJOON','https://www.acmicpc.net/problem/13361',13361,'최고인 대장장이 토르비욘','7초','512 MB',21,'<p><em>전성기 시절의 오버워치는 지구 상에서 가장 진보된 최첨단 무기를 보유했으며, 그 무기의 출처는 바로 토르비욘 린드홀름이라는 전무후무한 기술자의 작업장이었다.</em></p>

<p>하지만 이런 토르비욘에게도 진상손님이 있었으니....</p>

<p>진상 손님 한조는 만우절을 기념해 동생인 겐지에게 이상한 검을 선물하겠다며 토르비욘에게 말도 안되는 주문을 했다.</p>

<p>토르비욘이 받은 괴상한 주문은 아래와 같다.</p>

<p><em>직사각형 모양의 철판을 한 줄로 용접해서 만들며 절대 자르지 않을 것</em>.</p>

<p><em>명색이 검이므로 철판을 이을 때는 너비가 점점 줄어들어야 한다. 너비가 더 커지거나 같은 길이로도 이어 붙일 수 없다.</em></p>

<p><em>검은 가장 길게 만들어야 할 것.</em></p>

<p>다행히도 토르비욘이 가진 모든 철판들을 이용해서 한조가 원하는 검을 만들 수 있다. 토르비욘은 실물을 만들기 전에 견적을 내보려고 한다. 세상에서 가장 긴 검을 만들기 전에 검을 건조시킬 높은 작업장을 먼저 지어야 하기 때문이다.</p>

<p>검의 길이를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 철판의 개수인 정수 n이 입력된다.&nbsp;(1 ≤ n ≤ 250 000)</p>

<p>이후 입력되는 n개의 줄에는 철판의 길이인 s와 t가 입력된다.&nbsp;(1 ≤ s ≤ t ≤ 10<sup>9</sup>&nbsp;nm)</p>

<p>n개의 철판을 모두 사용하여 검을 만드는 방법이 존재하는 입력만 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>n개의 철판을 모두 사용해 만들 수 있는 가장 긴 검의 길이를 구하여라. 검의 너비는 반드시 줄어들어야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
50000 160000
50000 100000
50000 100000
','200000
','DATA_STRUCTURE'),
                                                                                                                (7246,'BAEKJOON','https://www.acmicpc.net/problem/13414',13414,'수강신청','1초','256 MB',8,'<p>국민대학교에서는 매 학기 시작 전 종합정보시스템에서 수강신청을 한다. 매 수강신청마다 아주 많은 학생들이 몰려 서버에 많은 부하가 가기 때문에, 국민대학교에서는 수강신청 부하 관리 시스템을 도입하기로 결정하였다. 새로운 관리 시스템은 다음과 같은 방식으로 동작한다.</p>

<ol>
	<li>수강신청 버튼이 활성화 된 후, 수강신청 버튼을 조금이라도 빨리 누른 학생이 대기목록에 먼저 들어간다.</li>
	<li>이미 대기열에 들어가 있는 상태에서 다시 수강신청 버튼을 누를 경우 <u>대기목록의 맨 뒤</u>로 밀려난다.</li>
	<li>잠시 후 수강신청 버튼이 비활성화 되면, 대기목록에서 가장 앞에 있는 학생부터 <strong>자동으로 수강신청이 완료</strong>되며, 수강 가능 인원이 꽉 찰 경우 나머지 대기목록은 무시하고 수강신청을 종료한다.</li>
</ol>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13414/B1.png" style="height: 135px; width: 379.167px;"></p>

<p>위의 표는 최대 수강 가능 인원이 3명인 알고리즘 수업에 대해 6명의 학생이 수강신청을 진행한 모습이다. 버튼이 비활성화 된 후, 먼저 규칙 1을 적용하여 클릭을 2번 이상 한 학생의 중복된 대기목록을 삭제한다. 중복된 목록을 제거한 후, 맨 앞에서부터 최대 수강 가능 인원인 3명을 선정한다. 표의 맨 오른쪽에는 그 최종결과를 나타낸 모습이다. 이와 같은 방법을 이용하여 최종적으로 수강신청에 성공한 인원을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력 데이터는 표준 입력을 사용한다. 입력은 1개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 과목의 수강 가능 인원 K(1 ≤ K ≤ 100,000)와 학생들이 버튼을 클릭한 순서를 기록한 대기목록의 길이 L(1 ≤ L ≤ 500,000)이 주어진다. 두 번째 줄부터 L개의 줄에는 수강신청을 버튼을 클릭한 학생의 학번이 클릭 순서대로 주어진다. 학번은 8자리의 숫자로 이루어져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 표준 출력을 사용한다. 입력받은 데이터에 대해, 수강신청 관리 시스템의 규칙을 적용한 후 수강신청에 성공한 인원의 학번을 한 줄에 1개씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 8
20103324
20133221
20133221
20093778
20140101
01234567
20093778
20103325
','20103324
20133221
20140101
','DATA_STRUCTURE'),
                                                                                                                (7247,'BAEKJOON','https://www.acmicpc.net/problem/13415',13415,'정렬 게임','1초','128 MB',15,'<p>즐거운 컴퓨터 프로그래밍 시간! 이번 시간의 수업 내용은 정렬이었다. 학생들은 오름차순 또는 내림차순으로 입력받은 값을 정렬해보기 시작하였다. 수업이 끝나갈 무렵, 오늘도 어김없이 조교의 과제가 주어졌다. 과제 이름은 정렬 게임. 과제 내용은 다음과 같다. 처음에 임의의 수열이 있고, 처음 위치부터 지정된 위치까지 오름차순, 내림차순, 오름차순, 내림차순, ... 의 순서를 반복하여 정렬하였을 때, 어떠한 수가 나타나는지 출력하는 프로그램을 작성하는 것이었다.</p>

<p>예를 들어, 과제로 주어진 수열이 [4,1,2,3] 이고, 처음 위치부터 3번째 원소까지 오름차순, 그 다음 2번째 원소까지 내림차순으로 정렬한 결과를 출력하라고 할 경우를 보자. 처음 오름차순 정렬을 수행하면 [1,2,4,3] 이 되고, 여기서 2번째 원소까지 내림차순으로 정렬하면 [2,1,4,3] 이 된다. 그리고 이것이 최종 정답이 된다. 정렬 게임에서 오름차순, 내림차순을 1번씩 하는 것을 <strong>한 세트를 진행했다</strong>고 정의한다. 수열과 K개의 세트가 주어질 때, 최종 수열을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력 데이터는 표준 입력을 사용한다. 입력은 1개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 수열의 개수 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>입력의 두 번째 줄에는 N개의 수열의 원소가 공백으로 구분되어 주어진다. 수열의 원소는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.</p>

<p>입력의 세 번째 줄에는 세트의 개수 K가 주어진다. (1 ≤ K ≤ 100,000)</p>

<p>입력의 네 번째 줄부터 한 줄에 한 개씩 오름차순, 내림차순을 하는 구간을 뜻하는 두 수 A, B가 주어진다. 이는 1번째 원소부터 A번째 원소까지 오름차순 정렬을 한 후, 1번째 원소부터 B번째 원소까지 내림차순 정렬을 해야함을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 표준 출력을 사용한다. 입력받은 데이터에 대해, K개의 세트를 모두 진행하고 난 뒤 수열의 모든 원소를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
4 1 2 3
1
3 2
','2 1 4 3
','DATA_STRUCTURE'),
                                                                                                                (7252,'BAEKJOON','https://www.acmicpc.net/problem/13445',13445,'부분 수열 XOR','1초','512 MB',19,'<p>길이가 N인 수열이 주어졌을 때, 부분 수열의 XOR이 K보다 작은 것의 개수를 구하는 프로그램을 작성하시오.</p>

<p>수열의 부분 수열이란 수열의 연속된 일부분 A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>를 의미한다. 부분 수열의 XOR이란 A<sub>i</sub>^A<sub>i+1</sub>^...^A<sub>j</sub>를 의미한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ K ≤ 1,000,000)</p>

<p>둘째 줄에 A<sub>i</sub>가 순서대로 주어진다. (1 ≤ A<sub>i</sub> ≤ 100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>부분 수열의 XOR이 K보다 작은 것의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
4 1 3 2 7
','3
','DATA_STRUCTURE'),
                                                                                                                (7260,'BAEKJOON','https://www.acmicpc.net/problem/13504',13504,'XOR 합','10초','512 MB',18,'<p>N개의 수로 이루어진 수열 A가 주어진다.&nbsp;</p>

<p>수열 A에서 연속된 부분 수열을 고르려고 한다. 부분 수열의 XOR 합이란, 부분 수열에 들어있는 모든 원소를 XOR한 값을 의미한다.</p>

<p>수열 A가 주어졌을 때, XOR 합이 가장 큰 부분 수열을 찾는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. (1 ≤ T ≤ 10)</p>

<p>각 테스트 케이스의 첫째 줄에는 배열의 크기 N (1 ≤ N ≤ 100,000), 둘째 줄에는 수열 A에 들어있는 수가 주어진다. 수열 A에 들어있는 수는 32비트 부호있는 정수 범위 안에 들어가는 음이 아닌 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 테스트 케이스마다 수열 A의 연속된 부분 수열 중에서 XOR 합이 가장 큰 부분 수열의 XOR 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
5
3 7 7 7 0
5
3 8 2 6 4
','7
15
','DATA_STRUCTURE'),
                                                                                                                (7261,'BAEKJOON','https://www.acmicpc.net/problem/13505',13505,'두 수 XOR','2초','512 MB',18,'<p>N개의 수가 주어졌을 때, XOR한 값이 가장 큰 두 수를 찾는 프로그램을 작성하시오.</p>

<p>즉, A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub> 중에서 i ≠ j이면서&nbsp;A<sub>i</sub> XOR A<sub>j</sub> 가 가장 큰 것을 찾아야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2&nbsp;≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 N개의 수가 주어진다. 입력으로 주어지는 수는 1,000,000,000보다 작거나 같은 음이 아닌 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 XOR한 값이 가장 큰 두 수의 XOR한 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 4 5
','7
','DATA_STRUCTURE'),
                                                                                                                (7259,'BAEKJOON','https://www.acmicpc.net/problem/13509',13509,'가장 가까운 두 점 2','2초','512 MB',20,'<p>두 점 A(x<sub>1</sub>, y<sub>1</sub>)와 B(x<sub>2</sub>, y<sub>2</sub>) 사이의 거리 D(A, B)는 다음과 같이 구한다.</p>

<p>D(A, B) =&nbsp;|x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>|</p>

<p>점 N개 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어졌을 때, 각각의 점 A<sub>i</sub>마다 가장 가까운 점 A<sub>j</sub>와의 거리 D(A<sub>i</sub>, A<sub>j</sub>) (i ≠ j)를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 200,000)이 주어진다. 둘째 줄부터 N개의 줄에는 점 A<sub>i</sub>의 좌표 x와 y가 주어진다. (-10,000,000 ≤ x, y ≤ 10,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 점 A<sub>i</sub>마다 가장 가까운 점과의 거리를 출력한다. A<sub>1</sub>부터 A<sub>N</sub>까지 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
0 0
0 1
1 0
1 1
','1
1
1
1
','DATA_STRUCTURE'),
                                                                                                                (7262,'BAEKJOON','https://www.acmicpc.net/problem/13510',13510,'트리와 쿼리 1','2초','512 MB',20,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다.</p>

<p>아래의 두 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i c</code>: i번 간선의 비용을 c로 바꾼다.</li>
	<li><code>2 u v</code>: u에서 v로 가는 단순 경로에 존재하는 비용 중에서 가장 큰 것을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v와 비용 w가 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

<p>간선의 비용은 항상&nbsp;1,000,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2 1
2 3 2
3
2 1 2
1 1 3
2 1 2
','1
3
','DATA_STRUCTURE'),
                                                                                                                (7263,'BAEKJOON','https://www.acmicpc.net/problem/13511',13511,'트리와 쿼리 2','2초','512 MB',18,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다.</p>

<p>아래의 두 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 u&nbsp;v</code>: u에서 v로 가는 경로의 비용을 출력한다.</li>
	<li><code>2 u v k</code>: u에서 v로 가는 경로에 존재하는 정점 중에서 k번째&nbsp;정점을 출력한다. k는 u에서 v로 가는 경로에 포함된 정점의 수보다 작거나 같다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v와 간선의 비용 w가 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

<p>간선의 비용은 항상&nbsp;1,000,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
1 2 1
2 4 1
2 5 2
1 3 1
3 6 2
2
1 4 6
2 4 6 4
','5
3
','DATA_STRUCTURE'),
                                                                                                                (7264,'BAEKJOON','https://www.acmicpc.net/problem/13512',13512,'트리와 쿼리 3','2초','512 MB',20,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 가장 처음에 모든 정점의 색은 흰색이다.</p>

<p>아래의 두 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i</code>: i번 정점의 색을 바꾼다. (흰색 -> 검정색, 검정색 -> 흰색)</li>
	<li><code>2 v</code>: 1번 정점에서 v번 정점으로 가는 경로에 존재하는 첫 번째 검정 정점의 번호를 출력한다. 만약, 그러한 정점이 없으면 -1을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9
1 2
1 3
2 4
2 9
5 9
7 9
8 9
6 8
8
2 3
1 8
2 6
2 7
1 2
2 9
1 2
2 9
','-1
8
-1
2
-1
','DATA_STRUCTURE'),
                                                                                                                (7265,'BAEKJOON','https://www.acmicpc.net/problem/13513',13513,'트리와 쿼리 4','2초','512 MB',23,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 가장 처음에 모든 정점의 색은 흰색이다.</p>

<p>아래의 두 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i</code>: i번 정점의 색을 바꾼다. (흰색 -> 검정색, 검정색 -> 흰색)</li>
	<li><code>2</code>: 모든 흰색 정점 a와 b에&nbsp;대해서, 가장 먼 거리를 출력한다. 이때, a와 b는 같아도 된다. 만약, 흰색 정점이 없다면 -1을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v와 간선의 거리&nbsp;w가 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

<p>간선의 거리는&nbsp;항상 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2 1
1 3 1
7
2
1 1
2
1 2
2
1 3
2
','2
2
0
-1
','DATA_STRUCTURE'),
                                                                                                                (7266,'BAEKJOON','https://www.acmicpc.net/problem/13514',13514,'트리와 쿼리 5','2초','512 MB',22,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 가장 처음에 모든 정점의 색은 검정색이다.</p>

<p>아래의 두 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i</code>: i번 정점의 색을 바꾼다. (흰색 -> 검정색, 검정색 -> 흰색)</li>
	<li><code>2 v</code>: 모든 흰색 정점 u와 v까지의 거리 중에서 가장 가까운 거리를 출력한다. 이때, u와 v는 같아도 된다. v가 흰색이면 정답은 0이다. 트리에 흰색 정점이 없으면 -1을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 2
1 3
2 4
1 5
1 6
4 7
7 8
5 9
1 10
10
1 6
1 6
1 6
2 3
1 1
1 1
2 3
2 10
2 4
2 6
','2
2
2
3
0
','DATA_STRUCTURE'),
                                                                                                                (7267,'BAEKJOON','https://www.acmicpc.net/problem/13515',13515,'트리와 쿼리 6','2초','512 MB',25,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 가장 처음에 모든 정점의 색은 검정색이다.</p>

<p>아래의 두 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i</code>: i번 정점의 색을 바꾼다. (흰색 -> 검정색, 검정색 -> 흰색)</li>
	<li><code>2 u</code>: u와 연결된 정점 v의 개수를 센다. 두 정점이 연결되었다는 것은 두 정점을 연결하는 경로상의 모든 정점의 색이 같다는 것을 의미한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
1 3
1 4
1 5
3
2 1
1 1
2 1
','5
1
','DATA_STRUCTURE'),
                                                                                                                (7269,'BAEKJOON','https://www.acmicpc.net/problem/13516',13516,'트리와 쿼리 7','2초','512 MB',26,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 정점의 색은 검정색 또는 흰색이며 가중치를 가지고 있다.</p>

<p>아래의 세&nbsp;쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i</code>: i번 정점의 색을 바꾼다. (흰색 -> 검정색, 검정색 -> 흰색)</li>
	<li><code>2 u</code>: u와 연결된 정점 v 중에서 가중치가 가장 큰 것을 구해 출력한다. 두 정점이 연결되었다는 것은 두 정점을 연결하는 경로상의 모든 정점의 색이 같다는 것을 의미한다. 이때, u와 v는 같을 수도 있다.</li>
	<li><code>3 u w</code>: u번 정점의 가중치를 w로 바꾼다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.</p>

<p>다음 줄에는 1번 정점부터 N번 정점까지 색이 주어진다. 색은 0 또는 1이며, 0은 검정색, 1은 흰색을 나타낸다. 그 다음 줄에는 각 정점의 가중치가 1번 정점부터 순서대로 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

<p>모든 가중치는 10<sup>9</sup>보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
1 3
1 4
1 5
0 1 1 1 1
1 2 3 4 5
3
2 1
1 1
2 1
','1
5
','DATA_STRUCTURE'),
                                                                                                                (7268,'BAEKJOON','https://www.acmicpc.net/problem/13517',13517,'트리와 쿼리 8','2초','512 MB',22,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다.&nbsp;정점은&nbsp;가중치를 가지고 있다.</p>

<p>아래의 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>u v k</code>: u에서 v로 가는 경로에 존재하는 정점의 가중치 중에서 k번째 작은 가중치를&nbsp;출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 정점의 가중치가 1번 정점부터 순서대로 주어진다.</p>

<p>셋째&nbsp;줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

<p>정점의 가중치는 항상&nbsp;1,000,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
105 2 9 3 8 5 7 7
1 2
1 3
1 4
3 5
3 6
3 7
4 8
5
2 5 1
2 5 2
2 5 3
2 5 4
7 8 2
','2
8
9
105
7
','DATA_STRUCTURE'),
                                                                                                                (7270,'BAEKJOON','https://www.acmicpc.net/problem/13519',13519,'트리와 쿼리 10','2초','512 MB',23,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다.&nbsp;정점은&nbsp;가중치를 가지고 있다.</p>

<p>아래의 두 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 u v</code>: u에서 v로 가는 경로에서 최대 연속합(비어있을 수도 있기 때문에 정답은 0보다 크거나 같다)을 구해 출력한다.</li>
	<li><code>2 u v w</code>: u에서 v로 가는 경로 상에 있는 모든 정점의 가중치를 w로 바꾼다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 정점의 가중치가 1번 정점부터 순서대로 주어진다.</p>

<p>셋째&nbsp;줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

<p>정점의 가중치는 절댓값이&nbsp;10,000보다 작거나 같은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
-3 -2 1 2 3
1 2
2 3
1 4
4 5
3
1 2 5
2 3 4 2
1 2 5
','5
9
','DATA_STRUCTURE'),
                                                                                                                (7271,'BAEKJOON','https://www.acmicpc.net/problem/13536',13536,'괄호 부분 문자열 쿼리','2초','512 MB',19,'<p>괄호 문자열은 다음과 같이 정의된다.</p>

<ol>
	<li>빈 문자열은 괄호 문자열이다.</li>
	<li>S가 괄호 문자열일 때, (S)도 괄호 문자열이다.</li>
	<li>S와 T가 괄호 문자열이라면, ST도 괄호 문자열이다.</li>
	<li>모든 괄호 문자열은 위의 3개 규칙으로만 만들 수 있다.</li>
</ol>

<p>(와 )로 이루어진 문자열 S = s<sub>1</sub>s<sub>2</sub>...s<sub>N</sub>과 M개의 쿼리가 주어진다. 각각의 쿼리는 l<sub>i</sub>와 r<sub>i</sub>(1 ≤ l<sub>i</sub> ≤ r<sub>i</sub> ≤ n)로 이루어져 있다. 각각의 쿼리에 대해서 다음을 구해야 한다.</p>

<ul>
	<li>S의 부분 문자열 s<sub>l<sub>i</sub></sub>, s<sub>l<sub>i+1</sub></sub>, ..., s<sub>r<sub>i</sub></sub>의 부분 수열&nbsp;중에서 괄호 문자열이면서 가장 긴 것의 길이를 출력한다.</li>
</ul>

<p>문자열&nbsp;S = s<sub>1</sub>s<sub>2</sub>...s<sub>N</sub>의 길이가 |x|인 부분 수열이란, 1 ≤ k<sub>1</sub> < k<sub>2</sub> < ..., K<sub>|x|</sub> ≤ N을 만족하는 문자열 x = s<sub>k<sub>1</sub></sub>s<sub>k<sub>2</sub></sub>...s<sub>k<sub>|x|</sub></sub>를 의미한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 문자열 S가 주어진다. (1 ≤ N ≤ 1,000,000)</p>

<p>둘째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p>

<p>셋째 줄부터 M개의 줄에 쿼리 l<sub>i</sub>와 r<sub>i</sub>가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 정답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','())(())(())(
7
1 1
2 3
1 2
1 12
8 12
5 11
2 10
','0
0
2
10
4
6
6
','DATA_STRUCTURE'),
                                                                                                                (7249,'BAEKJOON','https://www.acmicpc.net/problem/13537',13537,'수열과 쿼리 1','1초','512 MB',18,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>i j k</code>: A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>로 이루어진 부분 수열 중에서 k보다 큰 원소의 개수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리 i, j, k가 한 줄에 하나씩 주어진다. (1 ≤ i ≤ j ≤ N, 1 ≤ k ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
5 1 2 3 4
3
2 4 1
4 4 4
1 5 2
','2
0
3
','DATA_STRUCTURE'),
                                                                                                                (7225,'BAEKJOON','https://www.acmicpc.net/problem/13538',13538,'XOR 쿼리','2초','512 MB',22,'<p>비어있는 배열 A가 주어졌을 때, 다음과 같은 5가지 쿼리를 수행하는 프로그램을 작성하시오. 배열의 인덱스는 1부터 시작한다.</p>

<ul>
	<li><code>1 x</code>: 배열 A의 끝에 x를 추가한다.</li>
	<li><code>2 L R x</code>: A의 L번째 수부터 R번째 수까지 중에서 x와 xor한 값이 가장 큰 y를 찾아 출력한다.</li>
	<li><code>3 k</code>: 배열 A의 마지막 k개를 제거한다.</li>
	<li><code>4 L R x</code>: A의 L번째 수부터 R번째 수까지 중에서 x보다 작거나 같은 원소의 개수를 출력한다.</li>
	<li><code>5 L R k</code>: A의 L번째 수부터 R번째 수까지 중에서 k번째로 작은 수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 쿼리의 개수 M (1 ≤ M ≤ 500,000)이 주어진다.</p>

<p>둘째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ x ≤ 500,000, 1 ≤ L ≤ R ≤ N)</p>

<p>3번 쿼리의 경우 1 ≤ k ≤ N, 5번 쿼리의 경우: k ≤ R-L+1</p>

<p>N은 쿼리를 실행하기 전 배열 A의 크기이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2,4,5번 쿼리의 정답을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 8
5 1 1 1
1 2
2 2 2 7
2 2 2 7
1 1
4 2 2 2
2 1 2 3
4 1 3 5
1 6
','8
2
2
1
8
2
','DATA_STRUCTURE'),
                                                                                                                (7272,'BAEKJOON','https://www.acmicpc.net/problem/13544',13544,'수열과 쿼리 3','1초','512 MB',18,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>i j k</code>: A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>로 이루어진 부분 수열 중에서 k보다 큰 원소의 개수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub>&nbsp;≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 a, b, c가 주어진다. a, b, c를 이용해 쿼리를 만들어야 한다.</p>

<ul>
	<li>i = a xor last_ans</li>
	<li>j = b&nbsp;xor last_ans</li>
	<li>k = c&nbsp;xor last_ans</li>
</ul>

<p>last_ans는 이전 쿼리의 정답이며, 가장 처음에는 0이다. xor한 결과는&nbsp;1 ≤ i ≤ j ≤ n, 1 ≤ k ≤ 10<sup>9</sup>&nbsp;을 만족한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
5 1 2 3 4
3
2 4 1
6 6 6
1 5 2
','2
0
3
','DATA_STRUCTURE'),
                                                                                                                (7273,'BAEKJOON','https://www.acmicpc.net/problem/13553',13553,'수열과 쿼리 8','3초','512 MB',20,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>과 정수 K가 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>l r</code>: l ≤ i < j ≤ r이면서 abs(A<sub>i</sub> - A<sub>j</sub>) ≤ K인 (i, j) 쌍의 개수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)과 K (1&nbsp;≤ K ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub>&nbsp;≤ 100,000)</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리 l, r이 한 줄에 하나씩 주어진다. (1 ≤ l&nbsp;≤ r&nbsp;≤ n)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 31
1 16 32 64
4
1 4
1 2
2 4
2 3
','3
1
1
1
','DATA_STRUCTURE'),
                                                                                                                (7274,'BAEKJOON','https://www.acmicpc.net/problem/13554',13554,'수열과 쿼리 9','6초','512 MB',22,'<p>길이가 N인 두 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>과 B<sub>1</sub>, B<sub>2</sub>, ..., B<sub>N</sub>가 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>i j k</code>: i ≤ p, q ≤ j이면서 A<sub>p</sub>&nbsp;× B<sub>q</sub> ≤ k 인 (p, q)&nbsp;쌍의 개수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub>&nbsp;≤ 100,000)</p>

<p>둘째 줄에는 B<sub>1</sub>, B<sub>2</sub>, ..., B<sub>N</sub>이 주어진다. (1 ≤ B<sub>i</sub>&nbsp;≤ 100,000)</p>

<p>넷째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다섯째 줄부터 M개의 줄에는 쿼리 i, j, k가 한 줄에 하나씩 주어진다. (1 ≤ i&nbsp;≤ j&nbsp;≤ N, 1 ≤ k ≤ 100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 1 1 1 1
1 1 1 1 1
1
1 5 1
','25
','DATA_STRUCTURE'),
                                                                                                                (7276,'BAEKJOON','https://www.acmicpc.net/problem/13555',13555,'증가하는 부분 수열','2초','512 MB',17,'<p>길이가 N인&nbsp;수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>와 정수 K&nbsp;주어진다. 이때, 수열 A의 부분 수열 중에서 길이가 K이면서 증가하는 부분 수열의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)과 K (1&nbsp;≤ K ≤ 50, K ≤ N)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub>&nbsp;≤ 100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>수열 A의 부분 수열 중에서 길이가 K이면서 증가하는 부분 수열의 개수를 5,000,000로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
1 2 2 10
','2
','DATA_STRUCTURE'),
                                                                                                                (7275,'BAEKJOON','https://www.acmicpc.net/problem/13556',13556,'증가하는 부분 수열 2','2초','512 MB',20,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>와 정수 K&nbsp;주어진다. 이때, 수열 A의 부분 수열 중에서 길이가 K이면서 증가하는 서로 다른 부분 수열의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)과 K (1&nbsp;≤ K ≤ 50, K ≤ N)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub>&nbsp;≤ 100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>수열 A의 부분 수열 중에서 길이가 K이면서 증가하는 서로 다른 부분 수열의 개수를 5,000,000로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
1 2 2 10
','1
','DATA_STRUCTURE'),
                                                                                                                (7277,'BAEKJOON','https://www.acmicpc.net/problem/13557',13557,'수열과 쿼리 10','2초','512 MB',21,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이&nbsp;주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>x1 y1 x2 y2</code>: x1 ≤ i ≤ y1, x2 ≤ j ≤ y2, i ≤ j인 모든 (i, j)에 대해서 A<sub>i</sub> + ... + A<sub>j</sub>의 최댓값을 출력한다. (1 ≤ x1 ≤ x2 ≤ N, 1 ≤ y1 ≤ y2 ≤ N, x1 ≤ y1, x2 ≤ y2)</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)가 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (-100,000 ≤ A<sub>i</sub>&nbsp;≤ 100,000)</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리 x1, y1, x2, y2가&nbsp;한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
3 -2 1 -4 5 2
2
1 1 2 3
1 3 2 5
','2
3
','DATA_STRUCTURE'),
                                                                                                                (7293,'BAEKJOON','https://www.acmicpc.net/problem/13887',13887,'수열과 쿼리 12','2초','512 MB',27,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 l r</code>: S를 l번째 수부터 r번째 수까지 수로 이루어진 정렬된 집합이라고 했을 때, 다음을 출력한다. \[\left(\sum_{1 \le i < j < k \le |S|}{S_iS_jS_k}\right) \mod{10^9+7}\]</li>
	<li><code>2 x y</code>: A<sub>x</sub> = y</li>
	<li><code>3 x</code>: x번째 수를 지운다</li>
	<li><code>4 z y</code>: z번째 위치의 다음에 y를 추가한다. z = 0인 경우 가장 처음에 y를 추가하는 것이다.</li>
	<li><code>5 l r</code>: l번째 수부터 r번째 수 중에서 서로 다른 수의 개수를 출력한다.</li>
</ul>

<p>수열의 인덱스는 1부터 시작하며, 수열의 크기는 항상 1보다 크거나 같다.</p>

<p>&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다.</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

<ul>
	<li>1 ≤ N, M ≤ 100,000</li>
	<li>1 ≤ A<sub>i</sub>, y ≤ 10<sup>9</sup>+6</li>
	<li>1 ≤ x ≤ |A|</li>
	<li>1 ≤ l ≤ r ≤ |A|</li>
	<li>0 ≤ z ≤ |A|</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1번과 5번쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 2 1
8
1 1 3
5 1 5
2 2 4
1 2 4
3 3
4 0 5
1 1 2
1 1 5
','6
3
24
0
78
','DATA_STRUCTURE'),
                                                                                                                (7297,'BAEKJOON','https://www.acmicpc.net/problem/13904',13904,'과제','1초','256 MB',13,'<p>웅찬이는 과제가 많다. 하루에 한 과제를 끝낼 수 있는데, 과제마다 마감일이 있으므로 모든 과제를 끝내지 못할 수도 있다. 과제마다 끝냈을 때 얻을 수 있는 점수가 있는데, 마감일이 지난 과제는 점수를 받을 수 없다.</p>

<p>웅찬이는 가장 점수를 많이 받을 수 있도록 과제를 수행하고 싶다. 웅찬이를 도와 얻을 수 있는 점수의 최댓값을 구하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 정수 N (1 ≤ N ≤ 1,000)이 주어진다.</p>

<p>다음 줄부터 N개의 줄에는 각각 두 정수 d (1 ≤ d ≤ 1,000)와 w (1 ≤ w ≤ 100)가 주어진다. d는 과제 마감일까지 남은 일수를 의미하며, w는 과제의 점수를 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>얻을 수 있는 점수의 최댓값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제에서 다섯 번째, 네 번째, 두 번째, 첫 번째, 일곱 번째 과제 순으로 수행하고, 세 번째, 여섯 번째 과제를 포기하면 185점을 얻을 수 있다.</p>

				</div>
				</div>','7
4 60
4 40
1 20
2 50
3 30
4 10
6 5
','185
','DATA_STRUCTURE'),
                                                                                                                (7303,'BAEKJOON','https://www.acmicpc.net/problem/13905',13905,'세부','1초','256 MB',12,'<p>빼빼로 데이를 맞아 혜빈이와 숭이는 세부에 있는 섬에 놀러 갔다. 섬은 바다 위에 떠다니는 집과 집들을 연결하는 오크나무로 되어있는 다리로 이뤄져 있다. 숭이는 혜빈이에게 깜짝 이벤트를 해주기 위해 섬 관리자에게 혜빈이를 이벤트장소에 머물게 해달라고 하였다. 이벤트 당일 날 숭이는 금으로 된 빼빼로들을 들고 이벤트 장소로 이동하려 했다. 하지만 아뿔싸! 각 다리마다 다리 위를 지날 수 있는 무게 제한이 존재했다. 비싼 금빼빼로를 가면서 버리기 아깝던 숭이는 자신이 머물던 집에서 자신이 혜빈이에게 갈 수 있는 최대한의 금빼빼로만을 들고 가려고 한다. 따라서 숭이는 인공위성조차 해킹할 수 있는 당신에게 혜빈이에게 들고 갈 수 있는 최대한의 금빼빼로 개수를 알려달라고 부탁했다. 당신은 인공위성을 해킹하여 집들의 번호와 다리의 무게제한을 알아내었다. 이 정보를 가지고 빨리 숭이를 도와주자.</p>

<p>(금빼빼로 하나의 무게는 1이고, 숭이의 몸무게는 고려하지 않는다.)</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 섬에 존재하는 집의 수 N(2≤N≤100,000)와 다리의 수 M(1≤M≤300,000)이 주어진다. 두 번째 줄에는 숭이의 출발 위치(s)와 혜빈이의 위치(e)가 주어진다. (1≤s, e≤N, s≠e). 다음 M개의 줄에는 다리의 정보가 주어진다. 각 줄은 “집의 번호 h1(1≤h1≤N), 집의 번호 h2(1≤h2≤N), 다리의 무게제한 k(1≤k≤1,000,000)” 형식으로 주어진다. (h1집과 h2집은 무게제한이 k인 다리로 연결되어 있다.)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>숭이의 출발위치에서 혜빈이의 위치까지 숭이가 들고 갈 수 있는 금빼빼로의 최대 개수를 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13905/1.png" style="height:332px; width:511px"></p>

<p style="text-align:center">1-(4)->7-(4)->6-(3)->3</p>

<p style="text-align:center">min(4, 4, 3) = 3</p>

				</div>
				</div>','7 9
1 5
1 2 2
1 7 4
2 3 5
3 7 5
4 6 1
6 7 4
5 6 3
5 7 1
3 5 2
','3
','DATA_STRUCTURE'),
                                                                                                                (7304,'BAEKJOON','https://www.acmicpc.net/problem/13925',13925,'수열과 쿼리 13','2초','512 MB',20,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>1 x y v</code>: A<sub>i</sub>&nbsp;= (A<sub>i</sub>&nbsp;+ v) % MOD를&nbsp;수행한다. (x ≤ i ≤ y)</li>
	<li><code>2 x y v</code>: A<sub>i</sub> = (A<sub>i</sub>&nbsp;× v) % MOD를&nbsp;수행한다. (x ≤ i ≤ y)</li>
	<li><code>3 x y v</code>: A<sub>i</sub> = v를&nbsp;수행한다. (x ≤ i ≤ y)</li>
	<li><code>4 x y</code>: (ΣA<sub>i</sub>) % MOD를 출력한다. (x ≤ i ≤ y)</li>
</ul>

<p>여기서 MOD는 항상 10<sup>9</sup>+7이며, %는 나머지 연산을 의미한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ x ≤ y ≤ N, 1 ≤ v ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>4번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2 3 4
4
4 1 4
1 1 3 10
2 2 4 2
4 1 4
','10
69
','DATA_STRUCTURE'),
                                                                                                                (7305,'BAEKJOON','https://www.acmicpc.net/problem/13927',13927,'수열과 쿼리 14','5초','1536 MB',24,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>l r k</code>: S를 A의 l번째 수부터 r번째 수까지 수로 이루어진 오름차순으로 정렬된 집합(중복을 허용하지 않음)이라고 했을 때, k번째 수를 출력한다. 만약, k번째 수가 존재하지 않으면 -1을 출력한다.</li>
</ul>

<p>수열의 인덱스는 1부터 시작한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리를 만드는 정보인 a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, d<sub>i</sub>, k<sub>i</sub>가 한 줄에 하나씩 주어진다. (0 ≤&nbsp;a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, d<sub>i</sub>&nbsp;≤ N, 1 ≤ k<sub>i</sub> ≤ N)</p>

<p>각각의 쿼리 l<sub>i</sub>,&nbsp;r<sub>i</sub>는 다음과 같이 만든다.</p>

<p>먼저, i-1번째 쿼리의 정답을 ans<sub>i-1</sub>이라고 한다. (0번째 쿼리의 정답 ans<sub>0</sub> = 0)</p>

<ul>
	<li>l<sub>i</sub> = (a<sub>i</sub> x max(ans<sub>i-1</sub>, 0) + b<sub>i</sub>) mod N + 1</li>
	<li>r<sub>i</sub> = (c<sub>i</sub> x max(ans<sub>i-1</sub>, 0) + d<sub>i</sub>) mod N + 1</li>
</ul>

<p>만약, l<sub>i</sub> > r<sub>i</sub> 이면 l<sub>i</sub>와 r<sub>i</sub>를 바꾼다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3 2 1 2
4
0 1 0 3 2
2 0 0 3 4
1 2 1 3 2
2 0 0 3 3
','2
-1
2
3
','DATA_STRUCTURE'),
                                                                                                                (7314,'BAEKJOON','https://www.acmicpc.net/problem/13975',13975,'파일 합치기 3','2초','512 MB',12,'<p>소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서&nbsp;파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.</p>

<p>예를 들어, C1, C2, C3, C4가 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.</p>

<p>소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 1,000,000)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
4
40 30 30 50
15
1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
','300
826
','DATA_STRUCTURE'),
                                                                                                                (7319,'BAEKJOON','https://www.acmicpc.net/problem/13988',13988,'비무장 지대','3초','256 MB',23,'<p>서기 12117년, 남한과 북한은 한반도의 위대한 지성인 최석환 (gs12117) 선생을 기리기 위해서 통일을 선언했다. (1998년생 이원형과 아무 관계 없는) 대한민국의 이원형 장군은 조국의 사이버 국방을 책임지는 위대한 군인이다. 그는 지금 비무장 지대에 쌓여있는 지뢰를 어떻게 제거해야 하는지에 대해서 고민하고 있다. 비무장 지대는 0 부터 10<sup>9</sup>까지의 수직선으로 모델링할 수 있으며, 정확히 N(1 ≤ N ≤ 10<sup>6</sup>) 개의 지뢰가 묻혀 있으며, 이 중 i번째 지뢰는 X<sub>i</sub> (0 ≤ X<sub>i</sub> ≤ 10<sup>9</sup>)위치에 묻혀 있다. 지뢰가 묻혀있는 위치 X<sub>i</sub> 에서 이상이 감지된다면, 지뢰는 폭발한다.</p>

<p>핵지뢰부터 갤럭시 노트 7까지, 다양한 형태의 폭탄이 비무장 지대에 묻혀 있기 때문에, 이들의 폭발 양상은 다른 형태를 띈다. i번째 지뢰는 왼쪽으로 L<sub>i</sub>, 오른쪽으로 R<sub>i</sub> 만큼의 범위로 폭발하며, 이는 [X<sub>i</sub> ? L<sub>i</sub>, X<sub>i</sub> + R<sub>i</sub>] 폐구간이 지뢰의 폭발 범위라는 것이다. (1 ≤ L<sub>i</sub>, R<sub>i</sub> ≤ 10<sup>9</sup>) 지뢰의 폭발은 연속적인 지뢰의 폭발을 낳는다. 아직 폭발되지 않은 다른 지뢰의 중심이 폭발 범위 안에 들어간다면, 이 지뢰 역시 폭발하게 된다.</p>

<p>이원형 장군은 1개의 지뢰를 시범적으로 터트릴 예정이지만, 비무장 지대에는 다양한 문화 유산과 멸종위기 동물들이 살고 있다. 이원형 장군은 이를 최대한 보호하기 위해서, 사전 조사를 거치려고 한다. 이원형 장군은 M(1 ≤ M ≤ 300, 000) 개의 보호 구역 위치 C<sub>i</sub> (0 ≤ C<sub>i</sub> ≤ 10<sup>9</sup>)를 지정해 놓았으며, 각각의 보호 구역에 대해서, 해당 보호 구역을 파괴할 수 있는 지뢰의 개수를 구하고 싶어한다. 해당 보호 구역을 파괴할 수 있는 지뢰라는 것은, 해당 지뢰를 터트렸을 때, 연속적인 폭발 반응의 결과로 해당 보호 구역이 어떤 폭발한 지뢰의 폭발 범위 안에 들어갔음을 뜻한다.</p>

<p>젊은 시절 유능한 코이충으로 각광받던 이원형 장군이었지만, 지금은 대국민 담화를 준비해야 해서 너무나도 바쁘다. 여러분들이 이원형 장군을 대신해서 문제를 풀어주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 지뢰의 수 N, 보호구역의 수 M이 주어진다. (1 ≤ N ≤ 10<sup>6</sup>, 1 ≤ M ≤ 300, 000)</p>

<p>이후 N 개의 줄이 주어진다. 이 중 i번째 줄에는, i번 지뢰의 위치, 폭발 범위를 나타내는 세 정수 X<sub>i</sub>, L<sub>i</sub>, R<sub>i</sub>가 순서대로 주어진다. (0 ≤ X<sub>i</sub> ≤ 10<sup>9</sup>, 1 ≤ L<sub>i</sub>, R<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>이후 M 개의 줄이 주어진다. 이 중 i번째 줄에는, 보호 구역의 위치인 정수 Ci 가 주어진다. (0 ≤ C<sub>i</sub> ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>M 개의 줄에 걸쳐 각각의 보호 구역을 파괴할 수 있는 지뢰의 수를 하나의 정수로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>101에 있는 보호 구역을 터트릴 수 있는 폭탄은 없다.</p>

<p>100에 있는 보호 구역은 4번 지뢰가 터지면 파괴된다. 1, 2, 4번 지뢰를 처음에 터트리면, 4번 지뢰가 최종적으로 폭발한다.</p>

<p>0에 있는 보호 구역은 2번 지뢰가 터지면 파괴된다. 처음에 2번 지뢰를 터트려야만 2번 지뢰가 터진다.</p>

<p>14에 있는 보호 구역은 1, 3, 4번 지뢰가 터지면 파괴된다. 1, 2, 3, 4번 지뢰를 처음에 터뜨리면, 이 중 한 지뢰가 터진다. 즉 지뢰를 어떻게 터트려도 이 보호 구역은 파괴된다.</p>

				</div>
				</div>','4 4
10 5 12
4 5 6
15 1 1
20 10 80
101
100
0
14
','0
3
1
4
','DATA_STRUCTURE'),
                                                                                                                (7300,'BAEKJOON','https://www.acmicpc.net/problem/14181',14181,'함수와 쿼리','2초','512 MB',23,'<p>다음과 같은 함수가 있다.</p>

<ul>
	<li>f(1, j) = a[j], 1 ≤ j ≤ n</li>
	<li>f(i, j) = min(f(i-1, j), f(i-1, j-1)) + a[j], 2 ≤ i ≤ n, i ≤ j ≤ n</li>
</ul>

<p>여기서 a는 길이가 n인 배열이다.</p>

<p>배열 a의 값과 쿼리 x<sub>i</sub>, y<sub>i</sub>가 주어졌을 때, f(x<sub>i</sub>, y<sub>i</sub>)값을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 배열 a의 크기 n (1 ≤ n ≤ 10<sup>5</sup>)가 주어지고, 둘째 줄에 배열 a[1], a[2], ..., a[n]이 주어진다. (0 ≤ a[i] ≤ 10<sup>4</sup>)</p>

<p>다음 &nbsp;줄에는 쿼리의 개수 m (1 ≤ m ≤ 10<sup>5</sup>)가 주어지고, 다음 m개의 줄에는 쿼리 x<sub>i</sub>, y<sub>i</sub>가 주어진다. (1 ≤ x<sub>i</sub> ≤ y<sub>i</sub> ≤ n)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 f(x<sub>i</sub>, y<sub>i</sub>)를 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
2 2 3 4 3 4
4
4 5
3 4
3 4
2 3
','12
9
9
5
','DATA_STRUCTURE'),
                                                                                                                (7308,'BAEKJOON','https://www.acmicpc.net/problem/14235',14235,'크리스마스 선물','2초','512 MB',8,'<p>크리스마스에는 산타가 착한 아이들에게 선물을 나눠준다. 올해도 산타는 선물을 나눠주기 위해 많은 노력을 하고 있는데, 전세계를 돌아댕기며 착한 아이들에게 선물을 나눠줄 것이다. 하지만 산타의 썰매는 그렇게 크지 않기 때문에, 세계 곳곳에 거점들을 세워 그 곳을 방문하며 선물을 충전해 나갈 것이다. 또한, 착한 아이들을 만날 때마다 자신이 들고있는 가장 가치가 큰 선물 하나를 선물해 줄 것이다.</p>

<p>이제 산타가 선물을 나눠줄 것이다. 차례대로 방문한 아이들과 거점지의 정보들이 주어졌을 때, 아이들이 준 선물들의 가치들을 출력하시오. 만약 아이들에게 줄 선물이 없다면 -1을 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에서는 아이들과 거점지를 방문한 횟수 n이 주어진다.(1≤n≤5,000)</p>

<p>다음 n줄에는 a가 들어오고, 그 다음 a개의 숫자가 들어온다. 이는 거점지에서 a개의 선물을 충전하는 것이고, 그 숫자들이 선물의 가치이다. 만약 a가 0이라면 거점지가 아닌 아이들을 만난 것이다. 선물의 가치는 100,000보다 작은 양의 정수이다.(1≤a≤100)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>a가 0일 때마다, 아이들에게 준 선물의 가치를 출력하시오. 만약 줄 선물이 없다면 -1을 출력하라. 적어도 하나의 출력이 있음을 보장한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
0
2 3 2
0
0
0
','-1
3
2
-1
','DATA_STRUCTURE'),
                                                                                                                (7311,'BAEKJOON','https://www.acmicpc.net/problem/14258',14258,'XOR 그룹','2초','512 MB',16,'<p>N*M 격자에 서로 다른 수가 하나씩 들어가 있다. XOR 그룹이라는 것을 정의를 하여 합을 최대로 하려한다. XOR 그룹이란 위, 아래,&nbsp;오른쪽, 왼쪽으로 인접한 칸에 수가 있다면, 그 칸과 연결되어&nbsp;그 수를 모두 XOR한 값을 가지는 그룹이 된다. 만약, 중간에 수가 빠져있으면, 연결이 되지 않으므로, 한 격자판에 여러 XOR 그룹이 있을 수 있다.</p>

<p>이제 격자판에서 작은 수부터 제거해 나갈 것이다. 하나를 지울 때 마다 XOR 그룹이 변하는데, XOR그룹의 값의 합의 최대가 될 때, 그 값을 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n, m이 주어진다.(1 ≤ n, m ≤ 1,000)</p>

<p>다음 n줄에는 격자의 i번째 줄의 수&nbsp;m개가 주어진다. 수는 1,000,000보다 크지 않은 음이 아닌 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>XOR 그룹의 값의 합이 최대가 되는 값을 구하여라</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
9 1 15 16
3 4 10 6
2 5 7 11
','42
','DATA_STRUCTURE'),
                                                                                                                (7315,'BAEKJOON','https://www.acmicpc.net/problem/14259',14259,'거짓말쟁이 효빈이','2초','512 MB',12,'<p>영선이와 효빈이는 평소 전함게임을 즐겨한다. 전함게임은 n칸이 일렬로 놓여진 게임판에서 즐길 수 있는데, 공격과 수비로 역할이 나뉜다.</p>

<p>우선 수비는 전함 k개를 게임판 위에 배치하는데, 이때 전함끼리 겹치거나 맞닿아 있으면 안 된다. 전함은 일렬로 a칸을 차지한다. 그리고 전함의 위치는 공격은 볼 수가 없다.</p>

<p>전함이 다 배치되면 공격은 m번의 미사일을 발사하는데, 미사일들을 통해 하나의 전함이라도 맞춘다면 게임에서 이긴다. 이 미사일은 게임판의 한 칸을 공격한다.</p>

<p>이제 게임을 시작한다!!</p>

<p>영선이가 공격을, 효빈이가 수비를 한다. 근데 효빈이는 이 게임에서 지기 싫어 결국 거짓말을 치기로 했다. 공격입장에서 전함의 위치는 볼 수 없기 때문에, 전함에 미사일이 맞아도 안 맞았다고 말한다. 하지만 꼬리가 길면 밟히기 때문에, 논리적으로 봤을 때 전함을 어떻게든 배치하였더라도 미사일을 맞게 된다면, 패배를 인정할 것이다.</p>

<p>영선이는 거짓말을 친 사실을 알면 매우 화를 낼 것이므로, 효빈이는 몇 번째 미사일에서부터 어떻게 배치하더라도 전함이 미사일을 맞게 되는지를 알고 싶다.</p>

<p>효빈이를 대신하여, 몇번째 미사일에서 패배를 인정하면 되는지 출력하시오. 만약 마지막 미사일까지 전부 피해 이길 수 있다면 -1을 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 게임판의 칸 수 n, 전함의 개수 k, 전함이 차지하는 칸 수a가 주어진다.(1≤n,k,a≤200,000)</p>

<p>둘째 줄에는 영선이가 쏠 수 있는 미사일의 개수 m이 주어지고,(1≤m≤n)</p>

<p>셋째 줄에는 영선이가 쏠 예정인 미사일의 위치가 서로 다른 정수 m개가 주어진다. 게임판의 위치는 1부터 n까지 순서대로 매겨져 있다. 또한, 조건에 맞게 전함을 게임판에 배치할 수 있게 k와 a가 주어짐이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>효빈이가 몇번째 미사일까지 공격당할 시 패배를 인정하면 되는지 출력하시오. 만약 전부 피할 수 있다면 -1을 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','11 3 3
5
4 8 6 1 11
','3
','DATA_STRUCTURE'),
                                                                                                                (7316,'BAEKJOON','https://www.acmicpc.net/problem/14263',14263,'카드 놓기','2초','512 MB',17,'<p>영선이는 카드와 그리드를 가지고 놀고 있다. 각각의 카드는 직사각형 모양이며, 색칠되어져 있다. 두 카드가 같은 색을 가지는 경우는 없으며, 크기도 카드마다 다를 수 있다.</p>

<p>영선이는 한 번에 카드 하나씩 그리드 위에 올려놓는다. 카드를 올려놓을 때, 그리드의 변과 평행이 되게 카드를 올려놓아야 한다. 따라서, 직사각형은 그리드의 칸을 덮게 된다. 또, 카드는 겹쳐서 놓을 수 있다.&nbsp;카드가 놓이면서 어떤&nbsp;카드를 완전히 가리는 경우는 없다.</p>

<p>카드를 다 놓은 다음, 위에서 바라본 결과가 주어진다. 이때, 카드를 놓은 순서를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 그리드의 크기 N과 M이 주어진다. (1 ≤ N, M ≤ 50)</p>

<p>둘째 줄부터 N개의 줄에 그리드에 놓여진 카드의 색이 주어진다. 카드의 색은 알파벳 소문자(a-z), 대문자(A-Z), 숫자(0-9) 중 하나이며, .는 빈 칸이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 카드를 놓은 순서를 출력한다. 만약 가능한 순서가 여러 가지라면, 사전순으로 앞서는 것을 출력한다. 만약, 불가능한 경우에는 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 6
..AA..
.CAAC.
.CAAC.
','CA
','DATA_STRUCTURE'),
                                                                                                                (7317,'BAEKJOON','https://www.acmicpc.net/problem/14268',14268,'회사 문화 2','5초','512 MB',18,'<p>영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.</p>

<p>모든 칭찬에는 칭찬의 정도를 의미하는 수치가 있는데, 이 수치 또한 부하들에게 똑같이 칭찬 받는다.</p>

<p>이번에는 내리 칭찬이 실시간으로 일어날 것이다.</p>

<p>입력으로 아래와 같은 쿼리가 주어질 것이다.</p>

<ul>
	<li><code>1 i w</code>: i번째 직원이 직속 상사로부터 w만큼 칭찬을 받는다. (2 ≤ i ≤ n, 1 ≤ w ≤ 1,000)</li>
	<li><code>2 i</code>: i번째 직원이 칭찬을 받은 정도를 출력한다.</li>
</ul>

<p>직속 상사와 직속 부하관계에 대해 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 회사의 직원 수 n명, 쿼리의 개수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다.&nbsp;(2 ≤ n, m ≤ 100,000)</p>

<p>둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.</p>

<p>다음 m줄에는 위와 같이 쿼리가 주어진다. 사장은 상사가 없으므로 칭찬을 받지&nbsp;않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리가 주어질 때마다, 알맞게 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
-1 1 2 3 4
1 2 2
1 3 4
1 5 6
2 5
2 3
','12
6
','DATA_STRUCTURE'),
                                                                                                                (7320,'BAEKJOON','https://www.acmicpc.net/problem/14269',14269,'전설의 쌍검 용사','2초','512 MB',14,'<p>남규나라의 공주 Acka가 마왕한테 납치당했다. 남규나라의 왕 zych는 전설의 쌍검 용사 nein에게 공주를 구해 달라고 부탁하였다. nein은 마왕성에 쳐들어가기 위해 준비를 하고 있는데, nein은 평소에 여러 길이의 검들을 들고 다니며, 상대에 따라 그 중 두가지의 검을 한 손에 하나씩 들어 쌍검으로 싸운다.</p>

<p>nein은 남규나라의 정보부로부터 마왕성의 적들에 대한 정보들을 받았다. nein은 전설의 쌍검 용사답게 오랜 경험을 통해 각각의 적들을 어떤 검들로 상대를 하면 이길 수 있을지 알 수 있었는데, 그 정보는 다음과 같다.</p>

<p>오른손에는 정확히 A길이의 검을 사용하고, 왼손에는 B와 C 사이 길이의 검을 사용하면 적을 이길 수 있다.</p>

<p>nein은 공주 Acka를 구하기 위하여, 마왕성의 모든 적을 이길 수 있도록 검을 챙겨가려고 한다. 하지만, 모든 길이의 검을 가져간다면 너무 무거움으로 모든 적을 이길 수 있는 최소 개수의 검만 챙겨가려고 한다. 하지만 그 최소개수를 모르기 때문에 nein은 당신에게 부탁하였다. nein이 공주 Acka를 구할 수 있는 최소 검의 개수를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 마왕성의 적 n명이 주어진다.(1≤n≤100,000)</p>

<p>다음 n줄에는 적들을 쓰러트리기 위한 값 A,B,C가 주어진다.(1≤A≤1,000,000 , 1≤B≤C≤1,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>마왕성의 적을 모두 쓰러트릴 수 있는 최소 검의 개수를 구하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
3 5 10
6 11 15
3 13 15
','3
','DATA_STRUCTURE'),
                                                                                                                (7321,'BAEKJOON','https://www.acmicpc.net/problem/14274',14274,'세 점','2초','512 MB',17,'<p>크기가 무한대인 이차원 평면 위에 점이 N개 있다. 점은 0번부터 N-1번까지 번호가 매겨져 있으며, i번 점의 좌표는 (x<sub>i</sub>, y<sub>i</sub>) 이다. 두 점이 같은 x좌표를 갖거나 y좌표를 갖는 경우는 없다.</p>

<p>오늘은 N개의 점 중에 3개의 점에 색칠을 해보려고 한다. 빨간색으로 칠한 점의 번호를 r, 초록색으로 칠한 점의 번호를 g, 파란색으로 칠한 점의 번호를 b라고 하자. 이때, x<sub>r</sub> < x<sub>g</sub> < x<sub>b</sub> 이면서, y<sub>r</sub> < y<sub>b</sub> < y<sub>g</sub>를 만족하게 세 점을 색칠하려고 한다.</p>

<p>점이 주어졌을 때, 문제의 조건대로 세 개의 점을 색칠하는 방법의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. 둘째 줄부터 N개의 줄에 점의 좌표 (x, y)가 주어진다. (1 ≤ N ≤ 300,000, 0 ≤ x, y < 1,000,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 문제의 조건에 맞게 세 점을 색칠하는 방법의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9
3 5
8 10
4 1
5 4
2 3
0 7
6 2
10 0
9 8
','8
','DATA_STRUCTURE'),
                                                                                                                (7326,'BAEKJOON','https://www.acmicpc.net/problem/14287',14287,'회사 문화 3','2초','512 MB',18,'<p>영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.</p>

<p>이러한 내리 칭찬은 회사에 가장 큰 장점이 되었고, 사장 영선이는 이 장점을 이용하기 위하여 단 하루만 반대로 하기로 했다. 즉, 부하가 상사를 칭찬하면, 그 위로 쭉 사장까지 모두 칭찬을 받는다.</p>

<p>칭찬에 대한 정보는 실시간으로 주어진다.</p>

<p>입력으로 아래와 같은 쿼리가 주어질 것이다.</p>

<ul>
	<li><code>1 i w</code>: i번째 직원이 직속 부하 중 한 명으로부터 w만큼 칭찬을 받는다. (1 ≤ i ≤ n, 1 ≤ w ≤ 1,000) 부하가 없다면 입력으로 들어오지 않는다.</li>
	<li><code>2 i</code>: i번째 직원이 칭찬을 받은 정도를 출력한다. (1 ≤ i ≤ n)</li>
</ul>

<p>직속 상사와 직속 부하관계에 대해 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 회사의 직원 수 n명, 쿼리의 개수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)</p>

<p>둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.</p>

<p>다음 m줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리가 주어질 때마다, 알맞게 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 6
-1 1 2 3 4
1 2 2
1 3 4
1 4 6
2 5
2 3
2 1
','0
10
12
','DATA_STRUCTURE'),
                                                                                                                (7327,'BAEKJOON','https://www.acmicpc.net/problem/14288',14288,'회사 문화 4','2초','512 MB',18,'<p>영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.</p>

<p>이러한 내리 칭찬은 회사에 가장 큰 장점이 되었고, 사장 영선이는 이 장점을 이용하기 위하여 근무 시간 도중 도중 칭찬의 방향을 바꿀 것이다. 가장 처음에는 부하 직원 방향이다.</p>

<p>칭찬에 대한 정보는 실시간으로 주어진다.</p>

<p>입력으로 아래와 같은 쿼리가 주어질 것이다.</p>

<ul>
	<li><code>1 i w</code>: i번째 직원이 직속 상사로부터 w만큼 칭찬을 받는다. 만약, 칭찬의 방향이 상사 방향이라면, i번째 직원이 직속 부하 중 한 명으로부터 w만큼 칭찬을 받는다. (1 ≤ i ≤ n, 1 ≤ w ≤ 1,000)</li>
	<li><code>2 i</code>: i번째 직원이 칭찬을 받은 정도를 출력한다.</li>
	<li><code>3</code>: 칭찬의 방향이 부하 직원 방향이면 상사 방향으로, 상사 방향이면 부하 직원 방향으로 바꾼다.</li>
</ul>

<p>직속 상사와 직속 부하관계에 대해 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 회사의 직원 수 n명, 쿼리의 개수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)</p>

<p>둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.</p>

<p>다음 m줄에는&nbsp;쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리가 주어질 때마다, 알맞게 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 8
-1 1 2 3 4
1 2 2
3
1 3 4
3
1 4 6
2 5
2 3
2 1
','8
6
4
','DATA_STRUCTURE'),
                                                                                                                (7339,'BAEKJOON','https://www.acmicpc.net/problem/14402',14402,'야근','2초','512 MB',7,'<p>영선회사는 야근이 매우 잦은 회사이다. 다행히도 야근수당을 챙겨 주기는 하는데, 사장 nein은 매우 악덕한 사장이기 때문에 최대한 야근 수당을 안 챙겨주려 한다.</p>

<p>영선회사이 야근인지 확인하는 방법은 다음과 같다. 매우 이른 아침부터 퇴근시간까지 출입기록이 주어진다. 만약, 들어간 기록은 없는데, 나온 기록이 있다면 회사에서 야근을 한 것으로 기록된다. 또한 회사에 들어갔는데, 퇴근시간까지 나오지 않는다면, 이 또한 야근을 하는 것으로 기록된다. 출입기록에 따라서 두 기준 다 만족할 수도 있는데, 이는 야근을 두 번 한 것으로 인정된다. 하지만, 회사에 계속 있었지만 나오거나 들어가지를 않아 출입기록이 없다면 야근을 한 것으로 인정하지 않는다.</p>

<p>그리고 이 출입기록에는 치명적인 단점이 있는데, 동명이인을 구별하지 못한다는 것이다. 이름이 같은 경우, 같은 사람으로 인식하며, 둘다 회사에 남아있거나 들어간 기록 없이 나온 기록이 있는 식으로, 명확히 보이는 경우에만 복수로 야근이 인정된다.</p>

<p>영선회사의 오늘의 출입기록이 주어진다. 이 기록을 바탕으로 모든 직원의 야근 횟수의 합을 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 출입기록의 개수 q가 주어진다.( 1≤q≤100,000)</p>

<p>다음 q줄에는 이름 s와 들어간지 나간지에 대한 정보 p가 주어지는데, p는 ‘+’일 때 들어간 것이고, ‘-‘일 때 나간 것이다. 이름의 길이는 30자를 넘지 않는다. 이름은 소문자로만 이루어져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출입기록을 바탕으로 모든 직원의 야근 횟수의 합을 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
nein +
nein -
nein -
nein -
nein +
nein +
nein +
','5
','DATA_STRUCTURE'),
                                                                                                                (7342,'BAEKJOON','https://www.acmicpc.net/problem/14411',14411,'합집합','1초','256 MB',12,'<p>직교 좌표계에 존재하는 N개의 직사각형이 주어집니다. 주어진 N개의 직사각형은 중심은 모두 직교좌표계 가운데(원점)이며, 직사각형의 네 개의 변은 좌표축과 평행합니다. 각 사각형은 폭 (x 축을 따라)과 높이 (y 축을 따라)로 고유하게 식별됩니다. 아래 그림은 첫 번째 샘플 테스트를 보여줍니다.</p>

<p><img alt="" src="https://onlinejudgeimages.s3.amazonaws.com/problem/14411/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202017-02-02%20%EC%98%A4%ED%9B%84%208.15.41.png" style="height:316px; width:380px"></p>

<p dir="ltr">디자인학부 학생인 미추홀 군은 각 사각형을 특정 색상으로 채색했으며, 이제는 종이의 채색된 부분의 면적(넓이)을 알고 싶어합니다. 즉, 미추홀 군은 적어도 하나의 직사각형에 속하는 영역(모든 직사각형의 합집합)의 면적을 알고 싶습니다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p dir="ltr">첫 번째 입력 줄에는 직사각형 수인 정수 N (1 ≤ N ≤ 1 000 000)이 주어집니다.</p>

<p>다음의 N 행에는 각각 해당 사각형의 크기가 너비(X) 와 높이 (Y)로 주어지며, X와 Y는 모두 &nbsp;짝수인 정수로 (2 ≤ X, Y ≤ 10<sup>7</sup>)범위를 갖습니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한줄로 색칠된 사각형의 합집합 영역의 넓이를 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
8 2
4 4
2 6
','28
','DATA_STRUCTURE'),
                                                                                                                (7345,'BAEKJOON','https://www.acmicpc.net/problem/14427',14427,'수열과 쿼리 15','1초(하단참고)','512 MB',13,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i v</code>&nbsp;: A<sub>i</sub>를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 10<sup>9</sup>)</li>
	<li><code>2</code>&nbsp;:&nbsp;수열에서 크기가 가장 작은 값의 인덱스를&nbsp;출력한다. 그러한 값이 여러개인 경우에는 인덱스가 작은 것을 출력한다.</li>
</ul>

<p>수열의 인덱스는 1부터 시작한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
5 4 3 2 1
5
2
1 5 3
2
1 4 3
2
','5
4
3
','DATA_STRUCTURE'),
                                                                                                                (7346,'BAEKJOON','https://www.acmicpc.net/problem/14428',14428,'수열과 쿼리 16','2초','512 MB',15,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i v</code> : A<sub>i</sub>를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 10<sup>9</sup>)</li>
	<li><code>2 i j</code> : A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>에서 크기가 가장 작은 값의 인덱스를 출력한다. 그러한 값이 여러개인 경우에는 인덱스가 작은 것을 출력한다. (1 ≤ i ≤ j <span style="display: none;"> </span>≤ N, 1 ≤ v ≤ 10<sup>9</sup>)</li>
</ul>

<p>수열의 인덱스는 1부터 시작한다.<span style="display: none;"> </span></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
5 4 3 2 1
6
2 1 3
2 1 4
1 5 3
2 3 5
1 4 3
2 3 5
','3
4
4
3
','DATA_STRUCTURE'),
                                                                                                                (7348,'BAEKJOON','https://www.acmicpc.net/problem/14435',14435,'놀이기구2','2초','256 MB',24,'<p>1번부터 N번까지 번호가 매겨져있는 총 N명의 아이들이 있다. 아이들은 놀이공원에 가는걸 좋아하지만 아이들은 키제한 때문에 타지 못하는 일이 빈번하다. 놀이기구는 1번부터 M번까지 총 M개가 있으며, 모든 놀이기구는 정원이 2명이다.</p>

<p>아이 i와 아이 j가 함께 놀이기구 k를 타려면, (아이 i의 키) + (아이 j의 키) ≥&nbsp;(놀이기구 k의 키제한) 이 성립해야한다.</p>

<p>이러한 (i, j, k) 쌍이 Q개 주어지는데, 이 뜻은 아이 i와 아이 j가 놀이기구 k를 타려고 매일 시도한다는 뜻이다. 아이들의 처음 키는 모두 0cm이기 때문에 처음에는 모두 놀이기구를 타지 못하지만, 아이들은 성장기이므로 키가 쑥쑥 자란다. 구체적으로, 첫날부터 K번째 날까지 매일매일 한 명씩 키가 1씩 자라게 된다.</p>

<p>그런데 이 문제에서는 아이들의 성장세가 무섭다! 만약 (아이들이 전날 놀이기구를 탄 횟수) > (아이들이 전전날 놀이기구를 탄 횟수) 라면, 키가 1이 아니라 2만큼 자라게 된다. 단, 첫째 날과 둘째 날에는 해당되지 않는다. 매일매일 누구의 키가 자라는지 주어질 때, 첫날부터 K번째 날까지 각 날마다 아이들이 놀이기구를 총 몇번 타는지 출력하는 프로그램을 작성하여라. (단, 놀이기구를 타는 것 보다 키가 자라는 것이 먼저 일어난다)</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p dir="ltr">첫째 줄에 아이들의 수 N, 놀이기구의 수 M, 기간 K, 질문의 개수 Q가 주어진다. (1 ≤ N, M, K, Q ≤ 200,000)</p>

<p dir="ltr">둘째 줄에는 놀이기구들의 키제한이 순서대로 주어진다. (1 ≤ 키제한 ≤ 200,000)</p>

<p dir="ltr">셋째 줄에는 각 날에 키가 자라는 아이의 번호가 총 K개 주어진다. (1 ≤ 번호 ≤ N)</p>

<p>그 다음 Q줄에 걸쳐 (i, j, k) 쌍이 주어진다. (1 ≤&nbsp;i, j ≤ N, 1 ≤ k ≤ M)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>K줄에 걸쳐 각 날마다 아이들이 놀이기구를 총 몇번 타는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>둘째날까지 아이들은 놀이기구를 타지 못한다.</p>

<p>셋째날에는 아이 3과 아이 5가 놀이기구 3을 탈 수 있다.</p>

<p>넷째날에는 아이 3과 아이 5가 놀이기구 3을 탈 수 있고, 아이 1과 아이 2가 놀이기구 1, 2를 탈 수 있고, 아이 1과 아이 5가 놀이기구 2를 탈 수 있다.</p>

				</div>
				</div>','5 3 4 4
4 3 1
2 2 5 1
1 2 2
1 2 1
1 5 2
3 5 3
','0
0
1
4
','DATA_STRUCTURE'),
                                                                                                                (7355,'BAEKJOON','https://www.acmicpc.net/problem/14438',14438,'수열과 쿼리 17','2초','512 MB',15,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i v</code>&nbsp;: A<sub>i</sub>를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 10<sup>9</sup>)</li>
	<li><code>2 i j</code>&nbsp;:&nbsp;A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>에서 크기가 가장 작은 값을 출력한다. (1 ≤ i ≤ j ≤ N)</li>
</ul>

<p>수열의 인덱스는 1부터 시작한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.<span style="display: none;">&nbsp;</span></p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
5 4 3 2 1
6
2 1 3
2 1 4
1 5 3
2 3 5
1 4 3
2 3 5
','3
2
2
3
','DATA_STRUCTURE'),
                                                                                                                (7350,'BAEKJOON','https://www.acmicpc.net/problem/14458',14458,'소가 길을 건너간 이유 10','2초','512 MB',18,'<p>소가 왜 길을 건너는지는 미해결 난제지만, 농부 존의 소들이 길을 자주 건넌다는 것은 잘 알려진 사실이다. 소들이 길을 건너는 일이 너무 잦아서 건너면서 부딪히는 일도 생기는데, 존은 이 상황을 해결하고 싶다.</p>

<p>농장에는 일자형 길이 있고, 양쪽에 목초지가 N개씩 (1 ≤ N ≤ 100,000) 있다. 종별로 목초지 구조가 너무 달라서 한 목초지에는 정해진 종의 소만 방목할 수 있다. i번 목초지에는 i번 소만 방목할 수 있는 것이다. 소가 길을 건널 때는 자신의 종을 방목하는 반대편의 목초지로 이동하는 것이다.</p>

<p>목초지의 순서가 뒤죽박죽이어서, a종의 소와 b종의 소가 건너는 길이 겹칠 수도 있다. 존이 목초지 건설에 주의를 기울이지 않은 탓이다. 이때 (a,b)를 "가로지르는 쌍"이라고 하자.</p>

<p>존은 가로지르는 쌍의 수를 최소화하기 위해 농장을 옮기는 방법을 고안했다. 0 ≤ k < N인 정수 k에 대해, 맨 뒤에 있는 목초지 k개를 맨 앞으로 옮길 것이다. 예를 들어서, 목초지 번호가 차례대로 3, 7, 1, 2, 5, 4, 6이고 k=2라면, 옮긴 후의 목초지 번호는 4, 6, 3, 7, 1, 2, 5가 된다. 길의 왼쪽에 있는 목초지여도 되고 오른쪽이어도 되지만, 둘 중 하나만 된다. 가로지르는 쌍을 최소로 할 수 있도록 존을 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 N이 주어진다. 다음 N줄에는 길의 왼쪽에 있는 목초지 번호가 차례대로 주어진다. 각 종은 한 번씩 나타난다. 그 다음 N줄에는 길의 오른쪽에 있는 목초지가 같은 방식으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가로지르는 쌍의 최소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
5
4
1
3
2
1
3
2
5
4
','0
','DATA_STRUCTURE'),
                                                                                                                (7352,'BAEKJOON','https://www.acmicpc.net/problem/14459',14459,'소가 길을 건너간 이유 11','2초','512 MB',17,'<p>우리는 <a href="https://www.acmicpc.net/problem/14458">존의 고민</a>을 해결해 줄 방법을 찾았지만, 그걸 알려 주러 가다가 길을 잃었다. 존의 농장에 가긴 했지만, 2N개의 목초지는 없고 웬 <a href="https://www.acmicpc.net/problem/14466">N×N 격자</a>가 있는 것이다. 알고 보니 우리는 동명이인의 농장을 방문한 것이었다. 그 사이에 우리가 도와주려고 했던 존은 자신의 코드를 아무리 디버깅을 해 봐도 틀렸습니다나 런타임 에러가 나서 포기하고 제2안을 시도하고 있다.</p>

<p>존은 최근에 일부 종은 친하다는 것을 알게 되었다. 존의 농장에는 N 종류의 소가 있다. 각각 1번 종, 2번 종, ..., N번 종이다. 만약 |a?b| ≤ 4라면 a번 종과 b번 종의 소는 친하지만, 그렇지 않으면 사이가 나쁘다.</p>

<p>존 도와주기 협회에 새로 가입한 사람들을 위해 농장의 구조를 다시 설명할 것이다. 농장에는 일자형 길이 있고, 양쪽에 목초지가 N개씩 있다. 왼쪽 목초지에는 각 종류의 소가 한 목초지씩 차지하고 있고, 오른쪽도 마찬가지이다. 교통사고를 막기 위해 존은 횡단보도를 설치하려고 한다. 각 횡단보도는 왼쪽과 오른쪽에 있는 목초지를 하나씩 이어야 하고, 길에 수직일 필요는 없다. 물론 사이가 좋은 소들끼리 연결해야 한다. 각 목초지에는 최대 한 개의 횡단보도만 있어야 한다. 그리고 횡단보도가 겹치면 안 된다.</p>

<p>그의 농장을 둘러보면서 가능한 한 많이 횡단보도를 설치해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 N (1 ≤ N ≤ 100,000)이 주어진다. 다음 N줄에는 길의 왼쪽에 있는 목초지별로 소의 종 번호가 차례대로 주어진다. 각 종은 한 번씩 나타난다. 그 다음 N줄에는 길의 오른쪽에 있는 목초지가 같은 방식으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>조건을 만족하도록 설치할 수 있는 횡단보도의 최대 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
1
2
3
4
5
6
6
5
4
3
2
1
','5
','DATA_STRUCTURE'),
                                                                                                                (7351,'BAEKJOON','https://www.acmicpc.net/problem/14460',14460,'소가 길을 건너간 이유 12','2초','512 MB',21,'<p>이번에는 우리가<a href="https://www.acmicpc.net/problem/14459"> 존의 농장</a>을 제대로 찾아가긴 했는데, 다른 이유로 계획이 실행되지 못했다. 그의 소 친밀도 이론에 오류가 발견되었기 때문이다.</p>

<p>존의 농장에는 N 종류의 소가 있다. 각각 1번 종, 2번 종, ..., N번 종이다. 만약 |a?b| ≤ K라면 a번 종과 b번 종의 소는 친하지만, 그렇지 않으면 사이가 나쁘다. 종별로 목초지 구조가 너무 달라서 한 목초지에는 정해진 종의 소만 방목할 수 있다. i번 목초지에는 i번 소만 방목할 수 있는 것이다. 소가 길을 건널 때는 자신의 종을 방목하는 반대편의 목초지로 이동하는 것이다.</p>

<p>존 도와주기 협회에 새로 가입한 사람들을 위해 농장의 구조를 다시 설명할 것이다. 농장에는 일자형 길이 있고, 양쪽에 목초지가 N개씩 있다. 왼쪽 목초지에는 각 종류의 소가 한 목초지씩 차지하고 있고, 오른쪽도 마찬가지이다. 목초지의 순서가 뒤죽박죽이어서, a종의 소와 b종의 소가 건너는 길이 겹칠 수도 있다. 존이 목초지 건설에 주의를 기울이지 않은 탓이다. 이때 (a,b)를 "가로지르는 쌍"이라고 하자.</p>

<p>이번에는 횡단보도를 설치하기 전에, 사이가 안 좋으면서 가로지르는 쌍이 몇 개인지 세고 싶다. 존 도와주기 협회장의 임기가 다 끝나가기 때문에 이것이 우리에게 주어진 마지막 임무이다. 마지막으로 존을 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 N&nbsp;(1 ≤ N ≤ 100,000)과 K&nbsp;(0 ≤ K < N)가 주어진다. 다음 N줄에는 길의 왼쪽에 있는 목초지 번호가 차례대로 주어진다. 각 종은 한 번씩 나타난다. 그 다음 N줄에는 길의 오른쪽에 있는 목초지가 같은 방식으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>사이가 안 좋으면서 가로지르는 쌍의 개수를 출력한다.<br></p>
					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>1과 4, 1과 3이 사이가 안 좋으면서 가로지르는 쌍이다.<br></p>
				</div>
				</div>','4 1
4
3
2
1
1
4
2
3
','2
','DATA_STRUCTURE'),
                                                                                                                (7353,'BAEKJOON','https://www.acmicpc.net/problem/14463',14463,'소가 길을 건너간 이유 9','2초','512 MB',17,'<p>이것은 <a href="https://www.acmicpc.net/problem/14466">존이 농장을 개편</a>하기 전의 이야기이다.</p>

<p>존의 농장에는 원형 목초지가 있고, 그 둘레에 길이 둘러져 있다. 존의 소는 매일 아침 이 길을 건너가 풀을 먹고 저녁에 다시 길을 건너가 헛간으로 돌아간다.</p>

<p>이 소들은 자신의 습관대로 매일 똑같은 방법으로 길을 건넌다. 각각의 소는 원형 길의 정해진 한 점을 지나 들어오고, 다른 점을 지나 나간다. 어떤 두 소도 길 위의 같은 점을 지나가지 않는다. 이걸 지켜본 존은 이 점들을 분석해 보기로 했다. 소는 총 N마리고, 1, 2, ..., N이라는 번호가 붙는다. (원래 <a href="https://www.acmicpc.net/problem/14468">A부터 Z까지</a> 이름이 있었는데, 소가 많아지면서 더 이상 그 방법을 사용할 수 없게 되었다.) 존은 2N개의 점을 시계방향으로 보면서 각 점을 어떤 소가 지나가는지 기록했다. 이렇게 만들어 낸 길이 2N의 수열에는 각 번호가 두 번씩 나타날 것이다.</p>

<p>어떤 두 소는 어떤 방법으로 걷든 그 경로가 어딘가에서 만나야 될 수도 있다. 그런 소가 총 몇 쌍인지 구해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 N (1 ≤ N ≤ 50,000)이 주어진다. 다음 2N줄에는 한 줄에 하나씩 길 위의 점을 지나간 소의 번호가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>경로가 무조건 만나는 소가 몇 쌍인지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3
2
4
4
1
3
2
1
','3
','DATA_STRUCTURE'),
                                                                                                                (7358,'BAEKJOON','https://www.acmicpc.net/problem/14464',14464,'소가 길을 건너간 이유 4','2초','512 MB',15,'<p>농부 존의 소들은 효율적으로 길을 건너는 방법을 터득하고 있다. 그들은 길 건너기의 달인인 닭의 도움을 받기로 했다.</p>

<p>안타깝게도 닭은 매우 바쁜 동물이라, 소를 도와줄 시간이 별로 없다. 농장에 C마리(1 ≤ C ≤ 20,000)의 닭이 있고, 1번부터 C번까지 번호가 붙어 있다. i번 닭은 정확히 T<sub>i</sub>초에만 소를 도와줄 수 있다. 하지만 닭은 길 건너기의 달인이므로 소를 데리고도 순식간에 길을 건널 수 있다. 소는 할 일이 없어서 여유롭게 길을 건널 수 있다. 소는 총 N마리(1 ≤ N ≤ 20,000)가 있고, 마찬가지로 1번부터 N번까지 번호가 붙어 있다. j번 소는 A<sub>j</sub>초부터 B<sub>j</sub>초까지 길을 건널 수 있다. j번 소가 i번 닭의 도움을 받아 길을 건너려면 &nbsp;A<sub>j </sub>≤ T<sub>i</sub> ≤ B<sub>j</sub>를 만족해야 한다.</p>

<p>소는 최대 한 마리의 닭에게만 도움을 받을 수 있고, 닭 역시 최대 한 마리의 소만 도와줄 수 있다. 도움을 받을 수 있는 소가 최대 몇 마리인지 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 C와 N이 주어진다. 다음 C줄에는 T<sub>1</sub>…T<sub>C</sub>가 주어지고, 그 다음 N줄에는 A<sub>j</sub>와 B<sub>j</sub>(A<sub>j&nbsp;</sub>≤ B<sub>j</sub>)가 주어진다. A, B, T는 모두 최대 1,000,000,000인 음이 아닌 정수이고, 같을 수도 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>도움을 받을 수 있는 소가 최대 몇 마리인지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 4
7
8
6
2
9
2 5
4 9
0 3
8 13
','3
','DATA_STRUCTURE'),
                                                                                                                (7344,'BAEKJOON','https://www.acmicpc.net/problem/14577',14577,'일기예보','2초','128 MB',18,'<p>눈꽃 나라엔 하루 종일 눈이 온다. 눈이 아주 많이 온다. 내린 눈은 계속해서 쌓이고 녹는다.</p>

<p>눈꽃 나라의 기상 캐스터 택희는 눈에 관해서만 일기예보를 한다. 지진이 나도, 태풍이 와도 택희는 항상 아래와 같은 예보만 한다.</p>

<blockquote>
<p>현재 적설량이 L<sub>i</sub>mm 이상 R<sub>i</sub>mm 이하인 지역은 A, B, C, ... , X 이상 K개의 지역입니다.</p>
</blockquote>

<p>택희는 항상 위와 같은 방식으로 예보를 했지만, 눈꽃 나라가 행정구역 개편을 하며 나뉜 지역 수가 무려 N개가 되는 바람에 K개의 지역을 일일히 언급하는 것은 너무 힘들게 되었다. 그래서 택희는 그냥 적설량이 L<sub>i</sub>mm 이상 R<sub>i</sub>mm 이하인 지역의 수 K만 세기로 마음먹었다. 하지만 이 방식으로는 각 지역에 대한 정보를 전혀 알 수 없었기 때문에, 현재 T번째로 눈이 많이 온 지역에 눈이 얼마나 쌓였는지도 언급하기로 하였다. 하지만 지역이 많이 늘어났다 보니 만만치 않은 작업이었다. 따라서 택희는 각 지역의 적설량을 체크하는 자동화 프로그램을 작성해보려 한다.</p>

<p>택희의 프로그램은 아래와 같은 네 가지 작업을 처리할 수 있어야 한다.</p>

<ol>
	<li>지역 i에 눈이 xmm쌓인다.</li>
	<li>지역 i의 눈이 ymm녹는다.</li>
	<li>현재 적설량이 L<sub>i</sub>mm이상 R<sub>i</sub>mm이하인 구역의 수를 센다.</li>
	<li>현재 적설량이 T번째로 많은 도시에 쌓인 눈이 몇 mm인지 센다.</li>
</ol>

<p>4번 작업을 좀 더 정확히 말하면, 만일 같은 값이 있다면 중복해서 모두 센다. 예를 들어 다섯 지역에 쌓인 눈이 (3, 1, 2, 1, 2) 일 때, 4번 작업에서 T가 각각 1, 2, 3, 4, 5일 때의 답은 3, 2, 2, 1, 1이 된다.</p>

<p>기상예보는 신속 정확이 생명이므로, 위와 같은 연산을 아주 빨리 할 수 있는 프로그램이 필요하다. 택희는 열심히 노력했지만, 어떤 프로그램도 위와 같은 연산을 빠르게 처리하지 못했다. 택희를 위해 여러분이 더 빠른 프로그램을 하나 만들어주도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 눈꽃 나라의 지역 수 N, 프로그램이 처리해야 할 명령의 수 M이 주어진다. (1 ≤ N, M ≤ 10<sup>5</sup>)</p>

<p>둘째 줄에 N개의 정수로 현재 각 지역에 쌓인 눈의 양 S<sub>i</sub>가 주어진다. (0 ≤ S<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄부터 M개의 줄에 걸쳐 다음 네 가지 형태 중 하나의 명령이 주어진다.</p>

<ul>
	<li>1 i x의 명령은 i번 지역에 xmm의 눈이 쌓임을 의미한다. (1 ≤ i ≤ N, 1 ≤ x ≤ 10<sup>9</sup>)</li>
	<li>2 i y의 명령은 i번 지역의 눈이 ymm만큼 녹았음을 의미한다. (1 ≤ i ≤ N, 1 ≤ y ≤ 10<sup>9</sup>)</li>
	<li>3 L<sub>i</sub> R<sub>i</sub>의 명령은 현재 시점에서 적설량이 L<sub>i</sub>mm이상 R<sub>i</sub>mm이하인 지역의 수를 세는 명령이다. (0 ≤ L<sub>i</sub> ≤ R<sub>i</sub> ≤ 10<sup>18</sup>)</li>
	<li>4 T의 명령은 현재 시점에서 T번째로 눈이 많이 쌓인 지역에 몇 mm의 눈이 쌓였는지 확인하는 명령이다. (1 ≤ T ≤ N)</li>
</ul>

<p>2번 명령으로 인해 어떤 지역의 적설량이 음수가 되는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3, 4번 명령이 주어질 때마다 하나의 정수로 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 7
0 0 1 0 0
1 2 2
3 1 2
1 5 5
3 2 5
4 3
2 5 5
3 2 5
','2
2
1
1
','DATA_STRUCTURE'),
                                                                                                                (7347,'BAEKJOON','https://www.acmicpc.net/problem/14587',14587,'도미노 (Large)','1초','512 MB',20,'<p>N개의 도미노가 일렬로 놓여있다. 각 도미노는 위치 X<sub>i</sub>에서 높이 H<sub>i</sub>로 세워져 있다. 같은 위치에 2개 이상의 도미노가 놓여있는 경우는 없다. 홍준이는 도미노를 밀어서 왼쪽 또는 오른쪽으로 넘어뜨릴 수 있다. 도미노가 넘어지는 동안 만나게 되는 모든 도미노들은 같은 방향으로 넘어진다.</p>

<p>높이가 h이고 위치 x에 있는 도미노를 왼쪽으로 넘어뜨린 경우를 생각해보자. (x-h)와 x 사이에 위치한 모든 도미노들은 왼쪽 방향으로 넘어진다. 마찬가지로 오른쪽으로 넘어뜨렸다면, x와 (x+h) 사이에 위치한 모든 도미노들이 오른쪽 방향으로 넘어질 것이다.</p>

<p>이제 홍준이는 최소 개수의 도미노만 넘어뜨려서 모든 도미노들을 넘어뜨리려고 한다. 홍준이를 도와 최소 몇 개의 도미노를 넘어뜨리면 되는지 그 개수를 계산하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. (1 ≤ N ≤ 500,000)</p>

<p>둘째 줄부터 N개의 줄에는 각 도미노의 위치와 높이를 나타내는 2개의 정수 X<sub>i</sub>와 H<sub>i</sub>가 주어진다.&nbsp;(1 ≤ X<sub>i</sub>, H<sub>i</sub> ≤ 2,000,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 모든 도미노를 넘어뜨리기 위해서 최소 몇 개의 도미노를 넘어뜨려야 하는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
3 1
6 2
7 1
9 2
','2
','DATA_STRUCTURE'),
                                                                                                                (7349,'BAEKJOON','https://www.acmicpc.net/problem/14595',14595,'동방 프로젝트 (Large)','1초','512 MB',13,'<p>동아리방이 가지고 싶었던 병찬이는 LINK 사업단에 문의하여 N개의 방 중의 하나를 얻을 기회를 얻었다. 일자로 되어있는 건물에 N개의 방은 일직선상에 존재하며, 각 방에는 번호가 매겨져 있다. 맨 왼쪽 방의 번호는 1번이며, 순서대로 증가하여 맨 오른쪽 방의 번호가 N번이다. 각 방 사이에는 방을 구분하는 벽이 존재한다.</p>

<p>물론 병찬이 외에도 많은 사람이 동아리방을 원한다. 다행히 방은 충분했기에 병찬이는 안심하고 있었지만…</p>

<p>그때였다.</p>

<p>빅-종빈빌런이 나타나 건물 벽을 허물기 시작한 것이다! 빅-종빈빌런은 다음과 같은 규칙으로 벽을 무너뜨린다.</p>

<ul>
	<li>x < y 를 만족하는 두 방에 대해서 x번 방부터 y번 방 사이에 있는 모든 벽을 허문다.</li>
	<li>두 방 사이의 벽이 허물어지면 두 방은 하나의 방으로 합쳐진다.</li>
	<li>이미 허물어진 벽이 존재한다면 무시하고 다음 벽을 허문다.</li>
	<li>빅-종빈빌런은 건물이 무너지는 걸 원치 않기 때문에, 1번 방의 왼쪽 벽과 N번 방의 오른쪽 벽(즉, 바깥과 연결된 벽)은 허물지 않는다.</li>
</ul>

<p>동아리 방의 개수가 점점 줄어들자 병찬이는 초조해졌다. 이에 병찬이는 동아리방을 얻을 수 있는지에 대한 확률을 계산하기 위해 남는 동아리방의 수를 구하고 싶어 한다. 병찬이를 위해 빅-종빈빌런의 행동 횟수 M과 동방의 개수 N이 주어졌을 때, 남은 동아리방의 수를 구해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 동아리방의 개수를 나타내는 양의 정수 N(2 ≤ N ≤ 1,000,000) 이 주어진다. 두 번째 줄에는 빅-종빈빌런의 행동 횟수를 나타내는 음이 아닌 정수 M(0 ≤ M ≤ 5,000) 이 주어진다. 세 번째 줄부터 M개의 줄에 걸쳐 빅-종빈빌런의 행동이 양의 정수 x, y(1 ≤ x < y ≤ N) 로 주어진다. 여기서 행동이란 x번 방부터 y번 방 사이의 벽을 무너뜨리는 것을 의미한다.</p>

<p>빅-종빈빌런은 매우 허당이기 때문에 동일한 행동을 여러 번 할 수 있음에 유의하라.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>빅-종빈빌런의 모든 행동이 끝난 후 남아있는 동방의 개수를 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 행동으로 1번과 2번 방이 합쳐져 (1, 2), (3), (4), (5) 상태가 된다. 이후 두 번째 행동으로 2, 3, 4번 방이 합쳐져 (1, 2, 3, 4), (5)의 상태가 된다. 따라서 남아있는 동방의 수는 2가 된다.</p>

				</div>
				</div>','5
2
1 2
2 4
','2
','DATA_STRUCTURE'),
                                                                                                                (7361,'BAEKJOON','https://www.acmicpc.net/problem/14603',14603,'소금과 후추 (Large)','1초','512 MB',20,'<p>갑과 을은 사귀는 사이입니다. 둘은 근사한 저녁을 먹기로 했습니다. 갑과 을은 저녁에 크림 치즈 스파게티를 먹으러 서*앤*이라는 식당에 들어갔습니다. 먹음직스러운 크림 치즈 스파게티를 보고 예쁘다는 생각이 든 갑은, 스마트폰을 들어 스파게티 사진을 찍었습니다. 그리고 갑은 SNS중 하나인 인*타*램에 사진을 올리려 하였는데, 그때 사진 속 스파게티 위에 뿌려진 소금과 후추가 갑의 눈에 띄었습니다.&nbsp;</p>

<p>갑은 소금과 후추가 마음에 들지 않았습니다. 사진 속에서 소금과 후추 부분을 제거하고 싶었던 갑은 을에게 사진 속 소금과 후추를 제거해줄 수 있냐고 물었습니다. 을은 바로 해줄 수 있다고 자신감 넘치게 대답하고는 가방에서 A4용지와 펜을 꺼냈습니다. 그리고 사진 속 소금과 후추를 제거해 줄 방법을 고민하기 시작했습니다. 을은 먼저 문제를 정의하여 A4용지에 다음과 같이 정리하였습니다.</p>

<ul>
	<li>입력으로 사진을 나타내는 MxN 행렬 A 가 주어진다. 행렬의 각 원소는 사진 속 한 픽셀의 밝기를 나타내는데, 0이면 가장 어두운 것을 의미하고, K 면 가장 밝은 것을 의미한다.</li>
	<li>또 다른 입력으로 정수 W 가 주어진다. W 를 이용해 행렬 B 를 아래와 같이 정의한다.
	<ul>
		<li>B[i][j] = median(A[i+x][j+y]),&nbsp;</li>
		<li>where 1 ≤ i ≤ M-W+1, 1 ≤ j ≤ N-W+1, 0 ≤ x, y < W</li>
		<li>(A[i+x][j+y] &nbsp;는 행렬 A 의 i+x 행 j+y열에 위치한 원소, median 은 중앙값*)</li>
	</ul>
	</li>
	<li>주어진 행렬 A와 정수 W를 이용하여 행렬 B를 구한다.</li>
</ul>

<p style="text-align:center"><img alt="" src="http://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14602/1.png" style="height:222px; width:391px"></p>

<p style="text-align:center"><행렬 A와 W로 행렬 B가 만들어지는 과정></p>

<p>을은 위의 문제를 컴퓨터 프로그램으로 해결하기 위해 가방에서 노트북을 꺼내 식탁 위에 펼쳤습니다. 을은 프로그램을 작성하기 시작했습니다. 하지만 잘 되지 않았고 스파게티는 불기 시작했습니다. 스파게티가 모두 불어 버리기 전에, 을을 위해 위의 문제를 해결하는 프로그램을 작성해주세요!</p>

<p>(중앙값*: 중앙값은 어떤 주어진 값들을 크기의 순서대로 정렬했을 때 가장 중앙에 위치하는 값을 의미합니다. 예를 들어, 1, 2, 3, 3, 100의 다섯 값이 있을 때, 3이 가장 중앙에 있기 때문에 3이 중앙값입니다.)</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 행렬의 크기를 나타내는 정수 M 과 N(1 ≤ M, N ≤ 300), 최고 밝기 K(1 ≤ K ≤ 100,000), 정수 W(1 ≤ W ≤ min(M, N))가 공백으로 구분되어 차례로 주어진다. (단, W는 홀수) 두 번째 줄부터 1+M 번째 줄까지, 각 줄마다 N 개의 0이상 K 이하 정수가 주어진다. 입력의 1+i번째 줄의 j번째 정수는 행렬 A 의 i번째 행, j번째 열에 위치한 원소를 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>M-W+1줄에 걸쳐 정답 행렬 B를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제1에서, w = 1, median(1) = 1, median(2) = 2, …, median(9) = 9 이므로 입력된 행렬과 동일한 행렬이 답입니다.</p>

<p>예제2에서 w = 3 이므로 median(1, 2, 3, 4, 5, 6, 7, 8, 9) = 5가 답입니다.</p>

<p>예제3 정답 행렬의 1행 1열에 위치한 8은 median(5, 1, 2, 12, 10, 3, 8, 12, 19) = 8 연산 과정을 통해 얻어졌습니다.</p>

				</div>
				</div>','3 3 10 1
1 2 3
4 5 6
7 8 9
','1 2 3
4 5 6
7 8 9
','DATA_STRUCTURE'),
                                                                                                                (7362,'BAEKJOON','https://www.acmicpc.net/problem/14632',14632,'고급 작품','4초','512 MB',17,'<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14632/1.png" style="height:146px; width:146px"></p>

<p>준하는 세계적인 화가이다. 한때 수학의 길을 걷고자 했으나 꿈을 접고 미술계에 몸을 담게 되었다. 준하의 작품은 도장을 이용하여 만드는 것으로 유명하다.</p>

<p>준하는 크기와 모양이 각각 다른 도장을 여러 개 준비한 다음, 도화지 여기저기에 도장을 찍는 방법으로 작품을 만든다. 이런 독특한 방식으로 만든 작품이 수억을 호가하다 보니 모조품을 만들려는 세력이 존재하기 마련이다.</p>

<p>바로 강민이가 그러하다. 강민이는 준하의 작품을 모방하고 양산해서 거액을 벌어들이려는 야망을 품고 있다. 강민이를 도와 도장의 종류와 도장을 찍는 좌표가 주어졌을 때, 좌표대로 도장을 찍어 그림을 완성하는 프로그램을 만들어주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 도화지의 세로 크기 N과 가로 크기 M이 주어진다. (1≤N,M≤1,000)</p>

<p>둘째 줄에 도장의 수 K가 주어진다. (1≤K≤500) 그다음 줄부터 도장의 크기와 모양이 K개 주어진다. 한 도장마다 도장의 크기 H, W가 주어지고, 다음 줄부터 H 줄에 걸쳐 도장의 모양이 주어진다. (1≤H,W≤500) 도장은 1번부터 K 번까지 번호가 매겨져 있다.</p>

<p>그 다음 도장을 찍는 좌표의 개수 Q 가 주어진다. (1≤Q≤10,000) 그 다음 줄 부터 Q줄에 걸쳐 도장의 번호 T와 도장을 찍을 좌표 Y,X가 순서대로 주어진다. (1≤T≤K) (0≤Y,X≤1,000)</p>

<p>Y, X는 도장을 찍을 좌표의 가장 왼쪽 위 좌표를 의미한다. 도화지를 벗어나는 입력은 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>도화지에 그려진 그림을 출력한다. 출력된 그림의 크기는 도화지의 크기와 같아야 한다. 아무것도 그려지지 않은 좌표는 ‘.’으로 출력한다. 도장을 찍은 순서에 맞게 그림이 출력되어야 함에 유의하자.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
2
3 3
ooo
ooo
ooo
3 3
xxx
xxx
xxx
3
1 0 0
2 1 1
1 2 2
','ooo..
oxxx.
oxooo
.xooo
..ooo

','DATA_STRUCTURE'),
                                                                                                                (7363,'BAEKJOON','https://www.acmicpc.net/problem/14670',14670,'병약한 영정','1초','512 MB',7,'<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14670/1.png" style="height: 200px; width: 391.667px;"></p>

<p>영정이는 병약하다. 본인도 병약한 것을 알고 있기 때문에 언제든 먹을 수 있는 약을 상비해서 들고 다닌다. 각 약들은 약의 이름과 필요한 증상이 적혀져 있으며 하나의 약은 하나의 증상만을 해결 할 수 있다. 각각의 약은 모두 다른 이름을 가지고 있으며 서로 다른 증상을 해결함이 보장된다. 영정이가 아픈 증상을 호소 할 때, 어떤 약들을 먹어야 하는지 출력 해 주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>프로그램의 입력은 표준 입력으로 받는다. 입력의 첫 줄에는 약의 종류의 개수 N이 입력된다. (1 ≤ N ≤ 100) 그 다음 N개의 줄에는 각각 약의 효능과 약의 이름이 숫자로 주어진다. (0 ≤ M<sub>e</sub>, M<sub>n</sub> ≤ 100) 각 약의 이름과 효능은 다른 어떤 약의 이름, 효능과 중복되지 않음을 보장한다. 다음 줄에는 영정이가 겪는 증상의 개수 R이 입력된다. (1 ≤ R ≤ 100) 다음 R 줄에는 증상의 개수 L<sub>i</sub> 와 증상들 (S<sub>1</sub>, S<sub>2</sub>, … S<sub>L</sub>)이 주어진다 (1 ≤ L<sub>i</sub> ≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>프로그램의 출력은 표준 출력으로 한다. R 개의 증상에 따라 먹어야 하는 약을 순서대로 출력한다. 각각은 개행으로 구분한다. 증상을 하나 이상 해결할 수 없을 경우 ‘YOU DIED’ 를 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 3
4 2
99 1
4
1 1
2 4 99
3 4 1 99
1 5
','3
2 1
2 3 1
YOU DIED
','DATA_STRUCTURE'),
                                                                                                                (7366,'BAEKJOON','https://www.acmicpc.net/problem/14698',14698,'전생했더니 슬라임 연구자였던 건에 대하여 (Hard)','1초','512 MB',12,'<p>안녕? 내 이름은 ntopia!</p>

<p>나는 원래 지구에 살고 있던 평범한 20대 청년이었어. 어느 날 길을 걷다가 괴한의 칼에 찔려 죽어버렸어. 그런데 이게 무슨 일이람! 정신을 차려보니 이세계에 떨어져 버렸지 뭐야. 여기에서 나는 슬라임을 전문으로 연구하는 슬라임 연구자가 되어버린 것 같아. 나는 지금 아주 중요한 연구를 진행하고 있어. 이 연구가 성공하면 나는 내가 살던 세계로 돌아갈 수 있게 될 거야. 이 연구를 도와주지 않겠니?</p>

<p>이곳의 슬라임은 모두 슬라임 에너지라는 것을 갖고 있고 그 양은 2 이상의 자연수로 표현돼. 나는 슬라임을 합성했을 때 슬라임 에너지가 어떻게 변화하는지에 대해 연구하고 있어.</p>

<p>슬라임 합성 과정은 2마리를 합성해서 1마리를 만들어내는 식으로 이루어져. A만큼의 슬라임 에너지를 가진 슬라임과 B만큼의 슬라임 에너지를 갖고 있는 슬라임이 있었다고 해보자. 이 슬라임 2마리를 합성하면 슬라임 에너지가 A × B 인 슬라임을 만들 수 있어.</p>

<p>그리고 슬라임 합성 기술이 아직 완벽하지 않아서 슬라임을 합성할 때마다 크나큰 전기 에너지가 필요해. 구체적으로, A만큼의 슬라임 에너지를 가진 슬라임과 B만큼의 슬라임 에너지를 가진 슬라임을 합성하려면 A × B 만큼의 전기 에너지가 필요해.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14698/1.png" style="height: 261.667px; width: 391.667px;"></p>

<p style="text-align: center;">에너지가 4인 슬라임과 에너지가 6인 슬라임을 합성한 모습. 4 × 6의 전기 에너지를 사용해 슬라임 에너지가 24인 슬라임이 합성되었다.</p>

<p>나에겐 지금 N마리의 슬라임이 있어. 이 슬라임들을 모두 적절히 합성해서 1마리의 슬라임으로 만들려고 해. 그런데 내가 소속된 연구소에서 각 합성 단계마다 필요한 전기 에너지들을 모두 곱한 값을 나에게 비용으로 청구하겠다고 했지 뭐야. 그래서 이 값이 최소가 되도록 합성을 적절히 수행하는 것이 내 연구의 목표야.</p>

<p>내 연구를 도와줘! 부탁이야!!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 테스트 케이스의 수 T 가 주어지고, 이어서 T 개의 테스트 케이스가 주어진다.</p>

<p>각 테스트 케이스의 첫 번째 줄에는 슬라임의 수 N (1 ≤ N ≤ 60)이 주어지고, 두 번째 줄에는 N 개의 자연수가 주어진다. i번째 자연수 C<sub>i</sub> (2 ≤ C<sub>i</sub> ≤ 2 × 10<sup>18</sup>) 는 i번째 슬라임의 슬라임 에너지를 나타낸다. 끝까지 합성하고 난 후에 생기는 슬라임의 에너지의 양이 2 × 10<sup>18</sup> 이하라는 것이 보장된다.</p>

<p>모든 테스트 케이스에 대한 N 의 총합이 1, 000, 000을 넘지 않음이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 슬라임을 끝까지 합성했을 때 청구될 비용의 최솟값을 1, 000, 000, 007로 나눈 나머지를 출력한다. 전기 에너지가 전혀 필요하지 않은 경우엔 1 을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
5
3 10 2 8 14
1
13
','270950400
1
','DATA_STRUCTURE'),
                                                                                                                (7367,'BAEKJOON','https://www.acmicpc.net/problem/14701',14701,'셔틀버스','1.5초','512 MB',18,'<p>서울대학교 내부를 운행하는 셔틀버스에는 한쪽 벽면에 N개의 좌석이 일렬로 놓여 있다. 각 좌석은 가장 왼쪽 좌석부터 시작하여 1번부터 N번까지의 번호가 붙어 있다. 이 버스는 학교 입구에서 N명의 학생들을 태운 뒤 출발하고, 학생들은 각자 하나의 좌석을 골라 앉는다. 편의상 출발할 때 i번 좌석에 앉은 학생을 i번 학생으로 부르기로 한다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14701/1.png" style="height:115px; width:352px"></p>

<p>학생들은 칸막이에 기대서 조는 것을 좋아하기 때문에 되도록 양쪽 끝자리에 앉고 싶어 한다. 그래서 바로 옆에 앉아 있던 학생이 내리거나 다른 자리로 옮겨 가서 좌석이 비었을 때 그 좌석으로 옮겨 앉는 게 양쪽 끝 자리에 더 가까워질 경우, 즉 1번 좌석과 N번 좌석 중 더 가까운 좌석까지의 거리가 줄어들 경우 그 좌석으로 옮겨 앉는다. 한 학생이 버스에서 내리는 즉시 모든 학생이 이 규칙에 따라 이동한다.</p>

<p>셔틀버스 기사 찬수는 버스에서 내리는 학생들을 보면서 지금 어떤 좌석에 어떤 학생이 앉아 있는지 궁금해 졌다. 찬수를 위해 아래의 두 가지 연산을 입력되는 순서대로 수행하는 프로그램을 작성해 주자.</p>

<ol>
	<li><code>1 x</code> : x번 학생이 버스에서 내린다. 이 학생은 버스에 타고 있던 학생임이 보장된다.</li>
	<li><code>2 x</code> : x번 좌석에 앉아 있는 학생의 번호를 출력한다. 좌석이 비어 있을 경우는 0을 출력한다</li>
</ol>

<p>찬수가 운전하는 버스는 차고지로 들어가는 버스이기 때문에 새로운 학생을 태우지는 않는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 셔틀버스에 있는 좌석의 수 N(1 ≤ N ≤ 200, 000), 처리해야 하는 연산의 수 M(1 ≤ M ≤ 400, 000)이 주어진다.</p>

<p>두 번째 줄부터 M개의 줄에 걸쳐 각 쿼리의 종류(1 또는 2)와 x(1 ≤ x ≤ N) 값이 공백을 사이에 두고 주어진다. 2번 쿼리가 하나 이상 존재함이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 2번 쿼리의 결과를 입력되는 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14701/2.png" style="height:110px; width:347px"></p>

<p>1번 학생이 내리면 2번 학생과 3번 학생이 순서대로 이동한다. 4번 학생은 3번 좌석으로 옮겨 앉더라도 양 끝 좌석까지의 거리가 변하지 않기 때문에 이동하지 않는다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14701/3.png" style="height:107px; width:347px"></p>

<p>3번 학생이 내리면 4번 학생은 2번 좌석으로 이동하는 것이 이득이지만, 바로 옆자리가 아니므로 이동하지 않는다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14701/4.png" style="height:111px; width:345px"></p>

<p>5번 학생이 내리면 4번 학생이 이동한다.</p>

				</div>
				</div>','6 9
2 2
1 1
2 1
2 6
1 3
2 4
1 5
2 5
2 3
','2
2
6
4
4
0
','DATA_STRUCTURE'),
                                                                                                                (7368,'BAEKJOON','https://www.acmicpc.net/problem/14727',14727,'퍼즐 자르기','2초','256 MB',16,'<p>상렬이에게는 히스토그램 모양의 플라스틱 퍼즐 조각이 많이 있다. 상렬이는 이 퍼즐 조각들이 필요가 없어져 버릴 계획이다. 하지만 갑자기 플라스틱 판이 많이 필요해져 퍼즐에서 직사각형 모양을 잘라내 재활용하려고 한다.</p>

<p>퍼즐의 모양이 주어질 때 자를 수 있는 가장 큰 직사각형의 넓이를 구하는 프로그램을 작성하라.</p>

<p>히스토그램의 정보는 히스토그램을 구성하는 직사각형들의 높이로 주어진다. 각 직사각형의 너비는 1로 모두 같다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>히스토그램을 구성하는 직사각형의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 이어 N개의 줄에 걸쳐 각 직사각형의 높이인 정수 H<sub>i</sub>(1 ≤ H<sub>i</sub> ≤ 1,000,000)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>잘라낼 수 있는 직사각형의 최대 넓이를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
7
3
4
','9
','DATA_STRUCTURE'),
                                                                                                                (7385,'BAEKJOON','https://www.acmicpc.net/problem/14845',14845,'컵과 구슬','4초','256 MB',21,'<p>홍준이와 명우는 놀기 좋아한다. 심심하던 홍준이는 다음과 같은 놀이를 생각해냈다.</p>

<p>1번부터 n번까지 서로 다른 번호를 가지는, 컵 n개와 구슬 n개가 있다. 홍준이는 각 컵마다 구슬을 하나씩 넣고, 컵의 번호 순서대로 일렬로 놓았다. 즉, 초기에 i번 컵에는 a<sub>i</sub>번 구슬이 있다.<br>
홍준이는 총 m번의 마법을 사용한다. 마법이 한 번 수행되면, l<sub>i</sub>번 컵과 r<sub>i</sub>번 컵 사이에 있는 모든 컵 안의 구슬들을 번호 오름차순 혹은 내림차순으로 정렬하여, 작은 번호의 컵부터 차례로 구슬을 1개씩 할당한다.</p>

<p>마법이 모두 끝나면, 홍준이는 명우에게 (n+1)/2번 컵에 몇 번 구슬이 있는지 묻는다. n은 홀수임이 보장된다.</p>

<p>예를 들어, n=5,m=2이고 a=[5,1,4,2,3]인 경우를 살펴보자. 첫 번째 마법이 1번 컵부터 4번 컵에 있는 구슬을 오름차순 정렬하는 것이라면, a=[1,2,4,5,3]로 바뀐다. 두 번째 마법이 2번 컵부터 5번 컵에 있는 구슬을 내림차순 정렬하는 것이라면, a=[1,5,4,3,2]로 바뀐다. 최종적으로 3번 컵에는 4번 구슬이 있게 된다.</p>

<p>여러분은 명우를 도와 홍준이의 질문에 대신 답을 해주는 프로그램을 작성하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 정수 n과 m (1 ≤ n ≤ 99,999, 0 ≤ m ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에 n개 정수 a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ n)이 주어진다. a는 1,2,…,n의 순열이다.</p>

<p>셋째 줄부터 m개의 줄에 걸쳐서 홍준이가 수행하는 마법이 순서대로 주어진다.</p>

<p>각 마법은 l<sub>i</sub>와 r<sub>i</sub> &nbsp;(1 ≤ l<sub>i</sub>, r<sub>i</sub>&nbsp;≤ n)로 구성되며, l<sub>i</sub> < r<sub>i</sub>이면 구슬을 번호 오름차순으로 정렬하고 l<sub>i</sub> ≥ r<sub>i</sub>이면 구슬을 번호 내림차순으로 정렬하는 것이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>홍준이가 m번의 마법을 수행한 이후에 (n+1)/2번째 컵에 몇 번 구슬이 있는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
5 1 4 2 3
1 4
5 2
','4
','DATA_STRUCTURE'),
                                                                                                                (7391,'BAEKJOON','https://www.acmicpc.net/problem/14865',14865,'곡선 자르기','2초','512 MB',16,'<p>컴퓨터 그래픽 캔버스는 컴퓨터 화면에서 그림을 그릴 수 있는 직사각형 영역을 말한다. 캔버스는 2차원 좌표 평면처럼 각 점의 위치를 좌표로 표시한다. 캔버스의 정중앙 점이 원점 (0,0)이고, 오른쪽으로 갈수록 x좌표 값이 커지고, 위쪽으로 갈수록 y좌표 값이 커진다.</p>

<p>창수는 마우스를 이용하여 캔버스에 그림을 그리고 있다. 지금은 캔버스에 곡선을 그리는데, 시작점과 끝점이 붙어있는 것 외에는 중간에 선이 교차하거나 붙는 경우가 없다. 곡선을 다 그린 다음, 캔버스에서 x축의 아래쪽 영역을 깨끗이 지우면 아래 그림처럼 경계선이 서로 만나지 않는 봉우리들의 패턴이 나타난다. 여기서 봉우리는 시작점과 끝점이 x축 상에 있는 곡선 부분과 x축으로 둘러싸인 영역을 말한다. 아래 그림의 예에서는 5개의 봉우리가 나타난다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14865/1.png" style="height:292px; width:187px"></p>

<p>마우스로 그린 곡선은 컴퓨터에 의해 수직 선분과 수평 선분들로 구성된 경로의 형태로 메모리에 저장된다. 따라서 창수가 그린 곡선의 경우는 수평 선분과 수직 선분이 한 번씩 번갈아가며 이어진 경계선을 가진 직교다각형의 형태로 저장된다. 이 직교다각형의 모든 꼭짓점은 서로 다르며, 연속한 두 변 이외에는 어떤 두 변도 만나지 않는다. 직교 다각형의 형태로 변환된 예를 아래 그림에서 볼 수 있다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14865/2.png" style="height:145px; width:188px"></p>

<p>창수는 이 직교다각형을 입력으로 받아 x축의 위쪽 영역에 나타나는 봉우리들 중에서, 다른 봉우리에 의해 포함되지 않는 봉우리 개수와 다른 봉우리를 포함하지 않는 봉우리 개수를 구하는 프로그램을 작성하려고 한다. 위 그림에서는 다른 봉우리에 의해 포함되지 않는 봉우리 개수는 3이고 다른 봉우리를 포함하지 않는 봉우리 개수는 4이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 곡선을 표현하는 직교다각형의 꼭짓점의 개수 N(4 ≤ N ≤ 10<sup>6</sup>)이 주어진다. 다음 N개의 각 줄에는 직교다각형의 경계선을 따라갈 때 만나는 꼭짓점 순서대로 각 꼭짓점의 좌표가 주어진다. 이 순서의 방향은 가장 왼쪽에 있는 수직 선분인 변을 볼 때 아래에서 위로 올라가는 방향이다. 각 좌표는 x좌표와 y좌표가 공백을 사이에 두고 주어지며, x좌표와 y좌표 모두 -10<sup>9</sup> 보다 크거나 같고 10<sup>9</sup>보다 작거나 같다. 또한 y좌표가 0인 경우는 없으며 x축과 교차하는 변이 반드시 하나 이상 존재한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로, 입력으로 주어진 직교다각형에 의해서 나타나는 봉우리 패턴에서 다른 봉우리에 의해 포함되지 않는 봉우리 개수와 다른 봉우리를 포함하지 않는 봉우리 개수를 공백을 사이에 두고 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>※ 입력(1)의 직교다각형을 그림으로 나타내면 아래와 같다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14865/3.png" style="height:118px; width:158px"></p>

				</div>
				</div>','14
-4 -4
-4 3
3 3
3 -2
1 -2
1 1
-1 1
-1 -1
-2 -1
-2 2
-3 2
-3 -2
0 -2
0 -4
','1 2
','DATA_STRUCTURE'),
                                                                                                                (7386,'BAEKJOON','https://www.acmicpc.net/problem/14867',14867,'물통','2초','512 MB',14,'<p>용량이 다른 두 개의 빈 물통 A, B가 있다. 이 물통들에 물을 채우고 비우는 일을 반복하여 두 물통을 원하는 상태(목표하는 양의 물을 담은 상태)가 되도록 만들고자 한다. 물통 이외에는 물의 양을 정확히 잴 수 있는 방법이 없으며, 가능한 작업은 다음과 같은 세 종류가 전부이다.</p>

<ul>
	<li>[F(x): Fill x]: 물통 x에 물을 가득 채운다. (물을 채우기 전에 물통 x가 비어있는지 여부는 관계없음. 다른 물통은 그대로 둠)</li>
	<li>[E(x): Empty x]: 물통 x의 물을 모두 버린다. (다른 물통은 그대로 둠)</li>
	<li>[M(x,y): Move water from x to y)]: 물통 x의 물을 물통 y에 붓는다. 이때 만약 물통 x에 남아 있는 물의 양이 물통 y에 남아 있는 빈 공간보다 적거나 같다면 물통 x의 물을 물통 y에 모두 붓는다. 만약 물통 x에 남아 있는 물의 양이 물통 y에 남아 있는 빈 공간보다 많다면 부을 수 있는 만큼 최대로 부어 물통 y를 꽉 채우고 나머지는 물통 x에 남긴다.</li>
</ul>

<p>예를 들어, 물통 A와 B의 용량이 각각 2리터와 5리터라고 하자. 두 물통 모두 빈 상태에서 시작하여 최종적으로 물통 A에는 2리터, 물통 B에는 4리터 물을 남기길 원할 경우, 다음과 같은 순서로 작업을 수행하면 총 8회의 작업으로 원하는 상태에 도달할 수 있다.</p>

<p>(0,0)→[F(B)]→(0,5)→[M(B,A)]→(2,3)→[E(A)]→(0,3)→[M(B,A)]→(2,1)→[E(A)]→(0,1)→[M(B,A)]→(1,0)→[F(B)]→(1,5)→[M(B,A)]→(2,4)</p>

<p>하지만, 작업 순서를 아래와 같이 한다면 필요한 작업 총 수가 5회가 된다.</p>

<p>(0,0)→[F(A)]→(2,0)→[M(A,B)]→(0,2)→[F(A)]→(2,2)→[M(A,B)]→(0,4)→[F(A)]→(2,4)</p>

<p>두 물통의 용량과 원하는 최종 상태를 입력으로 받은 후, 두 물통이 비어 있는 상태에서 시작하여 최종 상태에 도달하기 위한 최소 작업 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 물통 A의 용량을 나타내는 정수 a(1 ≤ a < 100,000), 물통 B의 용량을 나타내는 정수 b(a < b ≤ 100,000), 최종 상태에서 물통 A에 남겨야 하는 물의 용량을 나타내는 정수 c(0 ≤ c ≤ a), 최종 상태에서 물통 B에 남겨야 하는 물의 용량을 나타내는 정수 d(0 ≤ d ≤ b)가 공백으로 분리되어 한 줄에 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>목표 상태에 도달하는 최소 작업 수를 나타내는 정수를 표준 출력으로 출력한다. 만약 목표 상태에 도달하는 방법이 없다면 ?1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 7 3 2
','9
','DATA_STRUCTURE'),
                                                                                                                (7395,'BAEKJOON','https://www.acmicpc.net/problem/14868',14868,'문명','2초','512 MB',17,'<p>인류의 역사를 돌이켜보면, 문명의 발전은 독자적으로 진행되기도 하지만 서로 다른 문명이 만나 결합되기도 한다. 여러분은 이 가설을 바탕으로, 세계 문명의 발전 과정을 시뮬레이션 해보려고 한다.</p>

<p>세계를 N × N의 2차원 공간으로 생각할 수 있다. 즉, 1×1 크기의 정사각형이 가로, 세로로 각각 N개씩 쌓여있는 형태로 생각할 수 있다. 가장 왼쪽 아래 정사각형은 (1,1), 가장 오른쪽 위 정사각형은 (N,N) 위치에 있다. 두 정사각형 (a, b)와 (a′, b′)은 다음 두 조건 중 하나만 만족할 때 서로 인접해 있다고 하자.</p>

<ul>
	<li>|a - a′| = 1 이고 b = b′.</li>
	<li>|b - b′| = 1 이고 a = a′.</li>
</ul>

<p>문명의 최초 발상지는 모두 서로 다른 K곳에 있다. 각 정사각형에 해당하는 공간은 문명 지역이거나, 미개 지역이다. 문명의 최초 발상지는 문명 지역이며, 만약 문명 최초 발상지끼리 인접해 있다면, 이들은 처음부터 하나로 결합된다. 한 해가 지날 때마다, 문명 지역은 자신과 인접한 지역에 문명을 전파한다. 정사각형 (a, b)가 문명 지역이면, 다음 해에는 세계의 경계를 넘지 않는 한 이 정사각형과 인접한 네 정사각형 (a+1, b), (a-1, b), (a, b+1), (a, b-1)에 문명이 전파된다. 만약 두 인접하는 지역에 다른 문명이 전파되었거나, 한 지역에 둘 이상의 다른 문명이 전파된다면 이 문명들은 결합된다.</p>

<p>예를 들어, 다음과 같이 5 × 5 크기의 세계에 4곳의 정사각형 (1, 1), (2, 1), (2, 5), (5, 2)가 문명의 발상지라고 하자. 정사각형 (1, 1), (2, 1)의 문명은 인접해 있으므로 처음부터 결합되어 있다. 1년후 문명이 전파된 지역은 오른쪽 그림과 같고, 2년 후에 문명이 전파된 지역은 아래 그림과 같다. 이때 모든 문명은 서로 결합되어 하나의 문명이 된다. (2, 5)에서 발상한 문명과 (5, 2)에서 발상한 문명은 직접적으로 결합되지는 않았지만, (1, 1),(2, 1)에서 발상한 문명을 통하여 결합됨에 주의하라.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14868/1.png" style="height:235px; width:264px"></p>

<p>세계의 크기, 문명 발상지의 수 및 위치를 입력으로 받아 모든 문명이 하나로 결합될 때까지 걸리는 최소 햇수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 세계의 크기를 나타내는 정수 N(2 ≤ N ≤ 2,000)과 문명 발상지의 수 K(2 ≤ K ≤ 100,000)가 주어진다. 다음 K줄에는 한 줄에 하나씩 문명 발상지에 해당하는 정사각형의 위치 (x, y)를 나타내는 두 자연수 x와 y가 주어진다. (1 ≤ x, y ≤N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 모든 문명이 하나로 결합되는데 걸리는 최소 햇수를 정수로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 4
1 1
2 1
2 5
5 2
','2
','DATA_STRUCTURE'),
                                                                                                                (7388,'BAEKJOON','https://www.acmicpc.net/problem/14869',14869,'요리 강좌','2초','512 MB',22,'<p>여러분은 요리에 관심이 많아 요리 자격증을 취득하려고 한다. 요리 자격증을 취득하기 위해서는 총 M개의 강좌를 순서대로 한 번씩만 수강해야 한다. 이 요리 강좌는 N개의 학원에서 수강할 수 있는데, 학원마다 강좌별 수강비용은 다를 수 있다.</p>

<p>아래 표는 M = 5, N = 4인 경우, 학원별, 강좌별 수강비용의 예를 보여준다.</p>

<table class="table table-bordered table-center-30 td-center th-center">
	<thead>
		<tr>
			<th>&nbsp;</th>
			<th>강좌1</th>
			<th>강좌2</th>
			<th>강좌3</th>
			<th>강좌4</th>
			<th>강좌5</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>학원1</th>
			<td>1</td>
			<td>2</td>
			<td>1</td>
			<td>3</td>
			<td>8</td>
		</tr>
		<tr>
			<th>학원2</th>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>7</td>
			<td>2</td>
		</tr>
		<tr>
			<th>학원3</th>
			<td>1</td>
			<td>8</td>
			<td>8</td>
			<td>1</td>
			<td>2</td>
		</tr>
		<tr>
			<th>학원4</th>
			<td>10</td>
			<td>1</td>
			<td>1</td>
			<td>8</td>
			<td>8</td>
		</tr>
	</tbody>
</table>

<p>여러분은 비용을 줄이기 위해 중간에 학원을 변경할 수 있는데, 학원을 변경할 때마다 T의 추가 비용이 든다. 단, 학원 변경은 다음 규칙을 지켜야 한다.</p>

<ol style="list-style-type:lower-alpha">
	<li>하나의 학원에서 연속으로 수강할 수 있는 강좌의 수는 최소 S개, 최대 E 개다. 단, 마지막 강좌를 수강하는 학원에서는 강좌 S개 이상을 연속해서 들을 필요가 없다.</li>
</ol>

<p>S = 2이고 E = 3이라고 가정하자. 강좌1을 학원1에서 수강했다면, 강좌2는 무조건 학원1에서 수강해야 하고, 강좌 3은 학원1에서 수강할 수도 있고 다른 학원에서 수강할 수도 있다. 만약 강좌1부터 강좌3을 학원1에서 수강했다면, 강좌4는 무조건 다른 학원에서 수강해야 한다.<br>
또한, S = 1이고 E = 2인 경우, 강좌1과 강좌2를 학원3에서 수강하고, 강좌3과 강좌4를 학원1에서 수강하고, 강좌5를 다시 학원3에서 수강하는 것도 가능하다.</p>

<ol start="2" style="list-style-type:lower-alpha">
	<li>학원마다 직전 강좌를 특정한 학원에서 수강한 학생은 받지 않는데, 이를 ‘불허용 학원’이라고 하자. 각 학원마다 불허용 학원은 하나씩 존재한다.</li>
</ol>

<p>예를 들어, 아래 표의 학원1에 대한 정보는 학원2→학원1로 변경하는 것은 불가능하다는 것을 의미한다. 단, 학원2→학원4→학원1처럼 학원4 수강을 거쳐 변경하는 것은 가능하다.</p>

<table class="table table-bordered table-center-30 td-center th-center">
	<thead>
		<tr>
			<th>&nbsp;</th>
			<th>불허용 학원</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>학원1</th>
			<td>학원2</td>
		</tr>
		<tr>
			<th>학원2</th>
			<td>학원3</td>
		</tr>
		<tr>
			<th>학원3</th>
			<td>학원4</td>
		</tr>
		<tr>
			<th>학원4</th>
			<td>학원3</td>
		</tr>
	</tbody>
</table>

<p>예를 들어, S = 2, E = 3, T = 2이고, 위 수강비용 표와 불허용 학원 표가 주어졌을 때, 강좌 순서대로 수강하는 학원의 번호가</p>

<ul>
	<li>예1) 1 → 1 → 1 → 1 → 3 인 경우, 규칙 (a)에 위배되어 수강이 가능하지 않다.</li>
	<li>예2) 2 → 2 → 1 → 1 → 1 인 경우, 규칙 (b)에 위배되어 수강이 가능하지 않다.</li>
	<li>예3) 3 → 3 → 1 → 1 → 3 인 경우는 가능한 수강 방법이고, 전체 비용은 1+8+T+1+3+T+2 = 19이다.</li>
	<li>예4) 1 → 1 → 1 → 3 → 3 인 경우는 가능한 수강 방법이고, 전체 비용은 1+2+1+T+1+2 = 9이다.</li>
</ul>

<p>강좌 비용, 강좌 선택에 필요한 규칙 정보가 주어졌을 때, 모든 강좌를 순서대로 수강하기 위해 필요한 최소 비용을 구하시오.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 학원의 개수 N과 강좌 개수 M(3 ≤ N ≤ 3,000, 1 ≤ M ≤ 3,000, N × M ≤ 3,000,000), 학원 한 곳에서 연속 수강 가능한 최소 강좌 개수 S와 최대 강좌 개수 E(1 ≤ S ≤ E ≤ M), 그리고 학원 변경 비용 T(0 ≤ T ≤ 35,000)가 주어진다. 다음 N개의 줄에는 각 학원의 강좌별 수강비용이 주어진다. (수강비용은 1 이상 35,000 이하이다.) 처음 줄에는 학원1의 M개의 수강비용이 강좌 순서대로 공백을 사이에 두고 주어지고, 그 다음 줄부터 학원2, 학원3, ... , 학원N의 정보가 한 줄에 하나씩 순서대로 주어진다. 그 다음 N개의 줄에는 학원마다 불허용 학원 번호가 순서대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 최소 비용을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5 2 3 2
1 2 1 3 8
1 2 3 7 2
1 8 8 1 2
10 1 1 8 8
2
3
4
3
','9
','DATA_STRUCTURE'),
                                                                                                                (7402,'BAEKJOON','https://www.acmicpc.net/problem/14870',14870,'조개 줍기','2초','512 MB',22,'<p>바닷가에 있는 정올시에는 여러 지역들이 정방형 격자 형태로 나뉘어져 있다. 각 지역에는 한 가구만 살고 있으며 가장 왼쪽 위에 있는 지역에는 수산시장이 있다. (수산시장이 있는 지역에도 한 가구가 산다.)</p>

<p>각 지역에서 수산시장으로 이동하려면 다음의 두 가지 방법만을 이용하여 이동한다.</p>

<ol>
	<li>바로 위에 붙어있는 지역으로 이동</li>
	<li>바로 왼쪽에 붙어있는 지역으로 이동</li>
</ol>

<p>각 지역에 사는 사람들은 매일 수산시장으로 출근하면서 지나가는 지역에서 조개를 주워 수산시장에서 판다. (출발하는 지역과 수산물 시장이 있는 지역에서도 조개를 주울 수 있다.)</p>

<p>각 지역에는 자연보호를 위해 그 지역을 지나가는 한 가구가 주울 수 있는 조개 개수의 최댓값이 있다. (여러 가구가 지나가면 가구마다 최댓값만큼 조개를 주울 수 있을 정도로 조개는 충분하다.)</p>

<p>예를 들어, 격자의 크기가 3 (행) × 3 (열) 이고 지역마다 한 가구가 주울 수 있는 조개 개수의 최댓값이 다음의 왼쪽 표와 같다고 하자.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14870/1.png" style="height:95px; width:235px"></p>

<p>각 지역에서 하루에 수산시장에 팔 수 있는 조개 개수의 최댓값은 오른쪽 표와 같다. 예를 들면, 맨 오른쪽 아래 격자에서 출발해서 최대로 조개를 줍는 방법은 위쪽으로 2번 이동하고 왼쪽으로 두 번 이동하는 방법이며 총 8+6+7+2+3=26개의 조개를 주울 수 있다. 그리고 이 도시의 아홉 지역에서 수산시장에 팔 수 있는 조개 개수의 최댓값을 모두 합하면 3+5+12+7+9+18+12+15+26=107 개이다.</p>

<p>정올시의 성실한 공무원들은 주기적으로 각 지역의 조개 숫자를 조사하여 한 가구가 주울 수 있는 조개 개수의 최댓값을 수정한다. 하지만 급격한 변화는 위험하므로 최댓값을 +1이나 ?1만큼만 조정하는 것이 가능하다. 조정하지 않은 지역의 조개 개수의 최댓값은 그대로 유지된다. 예를 들면, 위의 왼쪽 표에서 격자의 1행, 2열의 2가 3으로 바뀐다면 각 지역에서 주울 수 있는 조개 개수의 최댓값과 각 지역에서 하루에 수산시장에 팔 수 있는 조개 개수의 최댓값이 다음과 같이 바뀐다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14870/2.png" style="height:94px; width:236px"></p>

<p>격자 칸마다 주울 수 있는 조개 개수의 최댓값의 초기 값이 주어지고, 격자 칸에서 주울 수 있는 조개 개수의 최댓값의 변화를 입력으로 받아, 각 지역에서 하루에 수산시장에 팔 수 있는 조개 개수의 최댓값을 계산해서 그 합을 출력하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 격자의 행(열)의 개수를 나타내는 정수 N(2 ≤ N ≤ 1,500)이 주어진다. 다음 N줄에는 각 격자 칸에서 주울 수 있는 조개의 개수가 제일 윗 행부터 순서대로 한 줄에 한 행씩 주어진다. 한 행의 값은 가장 왼쪽 열의 값부터 하나씩 나열된다. 주어지는 값들은 0이상 1,000이하이다. 다음 N개의 줄에는 각 줄에 변화 명령이 하나씩 주어진다. 변화 명령의 첫 글자는 U 혹은 D이다. 이어서 빈칸을 하나 두고 두 자연수가 주어지는데, 첫 번째는 행 번호, 두 번째는 열 번호이다. 첫 글자가 U인 경우 행 번호, 열 번호에 해당하는 격자 칸에서 주울 수 있는 조개의 개수가 1 증가한다. D인 경우 해당 격자 칸에서 주울 수 있는 조개의 개수가 1 감소한다. 감소한 결과가 음수가 되는 경우는 없다. 각 변화에 대해서 아래에 지정한 값을 출력해야 한다. 주어진 각 변화 명령은 이전 변화들이 모두 적용된 결과에 적용된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로, 초기에 각 격자 칸의 입력을 기준으로 모든 지역에서 팔 수 있는 조개 개수의 최댓값의 합을 출력한다. 그 다음, 각 변화 명령에 대해 그 변화 명령을 적용한 후, 모든 지역에서 팔 수 있는 조개 개수의 최댓값의 합을 출력한다. 전체 출력은 N+1줄임에 주의하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
3 2 7
4 2 6
5 3 8
U 1 2
D 3 2
U 1 2
','107
111
110
114
','DATA_STRUCTURE'),
                                                                                                                (7406,'BAEKJOON','https://www.acmicpc.net/problem/14894',14894,'퀵 소트 cnt++','2초','1024 MB',21,'<p>구사과는 N개의 서로 다른 양의 정수를 정렬하기 위해 아래와 같은 C++ 코드를 작성했다.</p>

<pre class="brush:c++; toolbar:false;">long long cnt = 0;
vector<int> sort(vector<int> &amp;a) {
    vector<int> less, greater;
    if (a.size() <= 1) return a;
    int pivot = a[(a.size()-1)/2];
    int n = a.size();
    for (int i=0; i<n; i++) {
        cnt += 1;
&nbsp;       if (a[i] < pivot) {
&nbsp;           less.push_back(a[i]);
&nbsp;       } else if (a[i] > pivot) {
            greater.push_back(a[i]);
        }
    }
    sort(less); sort(greater);
    vector<int> ans;
    ans.insert(ans.end(), less.begin(), less.end());
    ans.push_back(pivot);
    ans.insert(ans.end(), greater.begin(), greater.end());
    return ans;
}</pre>

<p>서로 다른 자연수 N개로 이루어진 배열 <code>A</code>가 주어졌을 때, 이를 <code>sort</code>&nbsp;함수를 이용해서 정렬했을 때, <code>cnt</code>에 들어있는 값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 배열 A에 들어있는 수가 공백으로 구분해 주어진다. 주어지는 수는 1부터 N까지의 수로 이루어진 순열이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력으로 주어진 수를 <code>sort</code> 함수를 이용해 정렬했을 때,&nbsp;<code>cnt</code>에 들어있는 값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4 3 5 1 2
','11
','DATA_STRUCTURE'),
                                                                                                                (7399,'BAEKJOON','https://www.acmicpc.net/problem/14895',14895,'모여라','5초','512 MB',20,'<p>N명의 사람들이 2차원 평면 위에 서있다. 사람의 번호는 1번부터 N번까지 번호가 매겨져 있다. 이때, 다음 쿼리의 정답을 구하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>l r</code>: l번 사람부터 r번 사람까지 한 점 P에 모일 때, 각 사람과 점 P사이의 거리의 합의 최솟값을 출력한다.</li>
</ul>

<p>두 점 (x<sub>1</sub>, y<sub>1</sub>), (x<sub>2</sub>, y<sub>2</sub>) 사이의 거리는 max(|x<sub>1</sub>-x<sub>2</sub>|, |y<sub>1</sub>-y<sub>2</sub>|)로 구한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 사람의 수 N과 쿼리의 수 Q (1 ≤ N, Q ≤&nbsp;100,000)</p>

<p>둘째 줄부터 N개의 줄에 사람의 좌표 X<sub>i</sub>, Y<sub>i</sub>가 공백으로 구분해서 주어진다. (-1,000,000,000 ≤ X<sub>i</sub>, Y<sub>i</sub> ≤&nbsp;1,000,000,000)</p>

<p>다음 Q개의 줄에는 쿼리 L<sub>i</sub>, R<sub>i</sub>가 공백으로 구분해서 주어진다. (1 ≤ L<sub>i</sub> ≤ R<sub>i</sub> ≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 정답을 출력한다. 정답과의 절대/상대 오차는&nbsp;10<sup>-3</sup>까지 허용한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 쿼리의 경우에는 (1.5, 2.5)에 모이는 것이 최소이고, 두 번째 쿼리의 경우에는 (1, 1)에 모이는 것이 최소이다.&nbsp;</p>

				</div>
				</div>','4 2
1 4
2 3
0 1
1 1
1 4
3 4
','5.0000000
1.0000000
','DATA_STRUCTURE'),
                                                                                                                (7400,'BAEKJOON','https://www.acmicpc.net/problem/14897',14897,'서로 다른 수와 쿼리 1','5초','1024 MB',19,'<p>총 N개의 정수로 이루어진 배열 A가 주어진다. 이때, 다음 쿼리를 총 Q번 반복 수행하는 프로그램을 작성하시오. 배열은 1번부터 시작한다.</p>

<ul>
	<li><code>l r</code>: l번째 수부터 r번째 수 중에서 서로 다른 수의 개수를 세고 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 배열의 크기 N(1 ≤ N ≤&nbsp;1,000,000)이 주어진다. 둘째 줄에는 배열에 포함된 수가 1번째 수부터 주어진다. 수는 공백으로 구분되어져 있다. 배열에 포함된 수는 1,000,000,000보다 작거나 같은 자연수이다.</p>

<p>셋째 줄에는 쿼리의 개수 Q(1 ≤ Q ≤ 1,000,000)가 주어진다. 넷째 줄부터 Q개의 줄에는 쿼리 l<sub>i</sub>, r<sub>i</sub>가 주어진다. (1 ≤ l<sub>i</sub> ≤ r<sub>i</sub> ≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 Q개의 줄에 쿼리의 답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 3 2 1 3 1 3 2 1 3
10
8 9
4 7
6 8
4 6
3 7
2 10
3 8
1 10
4 7
1 7
','2
2
3
2
3
3
3
3
2
3
','DATA_STRUCTURE'),
                                                                                                                (7401,'BAEKJOON','https://www.acmicpc.net/problem/14898',14898,'서로 다른 수와 쿼리 2','5초','1024 MB',22,'<p>총 N개의 정수로 이루어진 배열 A가 주어진다. 이때, 다음 쿼리를 총 Q번 반복 수행하는 프로그램을 작성하시오. 배열은 1번부터 시작한다.</p>

<ul>
	<li><code>l r</code>: l번째 수부터 r번째 수 중에서 서로 다른 수의 개수를 세고 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 배열의 크기 N(1 ≤ N ≤&nbsp;1,000,000)이 주어진다. 둘째 줄에는 배열에 포함된 수가 1번째 수부터 주어진다. 수는 공백으로 구분되어져 있다. 배열에 포함된 수는 1,000,000,000보다 작거나 같은 자연수이다.</p>

<p>셋째 줄에는 쿼리의 개수 Q(1 ≤ Q ≤ 1,000,000)가 주어진다. 넷째 줄부터 Q개의 줄에는 쿼리를 나타내는 두 정수 x<sub>i</sub>, r<sub>i</sub>가 주어진다. 이때, l<sub>i</sub> = x<sub>i</sub> + Q<sub>i-1</sub>로 구한다.&nbsp;(1 ≤ l<sub>i</sub>&nbsp;≤ r<sub>i</sub>&nbsp;≤ N, -(N-1) ≤ x<sub>i</sub> ≤ (N-1)) Q<sub>i</sub>는 i번 쿼리의 정답이고, 첫 쿼리의 번호는 1번이다. 마지막으로, Q<sub>0</sub> = 0이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 Q개의 줄에 쿼리의 답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 3 2 1 3 1 3 2 1 3
10
8 9
2 7
4 8
1 6
1 7
-1 10
0 8
-2 10
1 7
-1 7
','2
2
3
2
3
3
3
3
2
3
','DATA_STRUCTURE'),
                                                                                                                (7396,'BAEKJOON','https://www.acmicpc.net/problem/14899',14899,'수열과 쿼리 19','2초','512 MB',25,'<p>길이가 n인 수열 A<sub>0</sub>, A<sub>1</sub>, ..., A<sub>n-1</sub>이 있다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 l r c</code>: l ≤ i ≤ r에 속하는 모든 A<sub>i</sub>에 c를 더한다.</li>
	<li><code>2 l r d</code>: l ≤ i ≤ r에 속하는 모든 A<sub>i</sub>를 ?A<sub>i</sub>/d?로 바꾼다.</li>
	<li><code>3 l r</code>: l ≤&nbsp;i ≤ r에 속하는 모든 A<sub>i</sub>중에서 가장 작은 값을 출력한다.</li>
	<li><code>4 l r</code>: l ≤ i ≤ r에 속하는 모든 A<sub>i</sub>의 합을 출력한다.</li>
</ul>

<p>?x?는 y ≤&nbsp;x를 만족하는 가장 큰 정수 y이다. (?-2.5? = -3, ?-7? = -7)</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 n과 쿼리의 개수 q (1 ≤ n, q ≤ 100,000)가 주어진다.</p>

<p>둘째 줄에는 A<sub>0</sub>, A<sub>1</sub>, ..., A<sub>n-1</sub>가 주어진다. (-10<sup>9</sup> ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>다음 q개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (0 ≤ l ≤ r ≤ n-1, -10<sup>4</sup> ≤&nbsp;c ≤ 10<sup>4</sup>, 2 ≤ d ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 4번 쿼리가 주어질 때 마다 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 10
-5 -4 -3 -2 -1 0 1 2 3 4
1 0 4 1
1 5 9 1
2 0 9 3
3 0 9
4 0 9
3 0 1
4 2 3
3 4 5
4 6 7
3 8 9
','-2
-2
-2
-2
0
1
1
','DATA_STRUCTURE'),
                                                                                                                (7397,'BAEKJOON','https://www.acmicpc.net/problem/14911',14911,'궁합 쌍 찾기','2초','512 MB',7,'<p>첫째 줄에 주어진 여러 개의 정수 중에서 합이 둘째 줄에 주어진 수와 같은 서로 다른 위치에 있는 두 수의 쌍을 모두 출력하고 맨 아래에 이 쌍의 개수를 이어서 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 빈 칸으로 구분된 정수가 2개 이상, 10개 이하 주어진다. 둘째 줄에는 정수가 하나 주어진다. 주어지는 정수는 100,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>찾은 수의 쌍을 한 줄에 하나씩 출력하고 맨 아랫 줄에 그러한 쌍의 개수를 출력한다.</p>

<p>구성은 같지만, 순서가 다른 쌍 (a, b)와 (b, a)는 쌍 하나로 하며, a ≤ b인 쌍을 출력한다.</p>

<p>쌍이 여러 개인 경우에는 사전 순으로 출력한다. (a, b)가&nbsp;(c, d)보다 사전 순으로 앞서는 기준은&nbsp;a < c이거나, a == c 이면서, b < d 인 것이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1 2
3
','1 2
1
','DATA_STRUCTURE'),
                                                                                                                (7404,'BAEKJOON','https://www.acmicpc.net/problem/14932',14932,'금고 (SAFE)','2초','512 MB',17,'<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14932/1.png" style="float:right; height:129px; width:146px">제연이는 멘사 회원이 되고 싶어 멘사 수학 퀴즈를 살펴보던 중 흥미로운 사실을 발견하게 된다. 바로 멘사 회원들은 평범한 금고를 쓰지 않고 오른쪽 그림과 같은 금고를 사용한다는 점이다! 이 금고의 작동원리는 다음과 같다:</p>

<ol>
	<li>한 버튼을 선택한 후 그 버튼에 쓰인 글씨를 읽는다.</li>
	<li>U(위), D(아래), L(왼쪽), R(오른쪽)의 규칙으로 앞에 적힌 수만큼 이동한다.</li>
	<li>모든 버튼을 한 번씩 다 누를 때까지 1~2 과정을 반복한다.</li>
	<li>버튼을 누르던 도중 이미 누른 버튼을 다시 누르게 되면 금고를 여는 데에 실패하며, 모든 버튼을 다 누르는 순간 금고는 열린다.</li>
</ol>

<p>따라서 오른쪽 그림과 같은 경우에는 2행 2열의 “3D”를 누르게 되면 2행 5열의 “2D”를 누름과 동시에 금고가 열리게 된다. 하지만 다른 버튼으로 시작한 경우 금고는 열리지 않게 된다.</p>

<p>금고의 원리를 흥미롭게 느낀 제연이는 멘사 회원이 되기 위해 직접 “멘사 금고”를 제작하기로 마음먹고 N*N 크기의 격자판에 마음대로 수와 알파벳을 써넣었다. 아차! 무작정 글씨를 쓰다보니 어느 버튼을 눌러야 금고가 열리는지 알 수 없었다. 제연이를 도와 금고를 여는 버튼을 알려주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N(2 ≤ N ≤ 1,000)이 주어진다.</p>

<p>둘째 줄부터 N개의 줄에 수,&nbsp;알파벳 쌍이 N개 주어진다. 모든 알파벳은 U,D,L,R 중 하나이며 그 버튼을 눌러 따라갔을 때 금고 밖으로 벗어나는 일은 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>금고가 열리는 버튼이 단 하나 존재할 경우 그 버튼의 행과 열을 공백을 사이에 두고 출력한다.</p>

<p>만약 금고가 열리는 버튼이 두 개 이상 존재할 경우 “THIEF LOVE IT!”을 출력한다. (따옴표 제외)</p>

<p>어떤 버튼을 눌러도 금고가 열리지 않을 경우 “TOO SAFE”를 출력한다. (따옴표 제외)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
2D 3R 1D 1L 4D
1U 3D 2L 1R 2D
1D 2U 1D 2L 1L
4R 2R 1L 2U 1U
2R 2R 2U 4U 4L
','2 2
','DATA_STRUCTURE'),
                                                                                                                (7403,'BAEKJOON','https://www.acmicpc.net/problem/14942',14942,'개미','2초','256 MB',16,'<p>개미집은 n개의 방으로 구성되어 있으며 n개의 방은 1번부터 n번 까지 번호가 부여되어 있다. 그 중에서 1번 방은 지면에 바로 연결되어 있는 방이다. 각 방들은 서로 굴을 통해 연결되어 있다. 각 굴을 이동하기 위해서는 굴의 길이만큼 에너지가 소모된다.</p>

<p>개미는 집짓기의 달인이기 때문에 불필요한 굴은 짓지 않는다. 그래서 굴을 타고 한 방에서 다른 방으로 갈 수 있는 경로는 항상 존재하며 유일하다. 임의의 두 방 사이의 거리는 두 개의 방을 연결하는 경로를 구성하는 굴의 길이의 합이다.</p>

<p>겨울잠을 자던 개미들은 겨울잠에서 깨어나 지면으로 올라가 햇살을 보고 싶어한다. 그렇기 때문에 지면과 연결된 1번 방으로 이동을 하려고 한다. 하지만 불행하게도 개미는 긴 겨울잠을 자느라 축적해 놓은 에너지가 적다. 그래서 개미는 에너지를 1번 방에 도달하기 전에 모두 소모 할 수도 있다. 이렇게 에너지가 0이 된 개미는 더 이상 움직일 수 없다. 또한 1번 방에 도착한 개미는 더 이상 움직이지 않는다.</p>

<p>현재 모든 방에는 개미가 한 마리씩 있고 각각의 개미는 각자 축적된 에너지를 가지고 있다. 잠에서 깨어난 모든 개미는 1번 방을 향해서 이동한다. 이때 각각의 개미에 대해 도달할 수 있는 방 중에서 가장 1번 방에 가까운 방의 번호를 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>자연수 n이 주어진다. n은 방의 개수이다. (1 ≤ n ≤ 10<sup>5</sup>) 다음 n개의 줄에는 차례대로 현재 각각의 개미가 보유하고 있는 에너지 값이 주어진다. i+1번째 줄에는 i번째 방에 있는 개미가 가진 에너지를 나타내는 100,000이하의 자연수 값이 주어진다. 이후 n-1개의 줄에는 두 개의 방을 연결하는 굴의 정보가 3개의 정수 a b c 으로 주어진다. a, b는 연결된 방을 의미하고 c는 이 굴의 길이를 의미한다. 굴의 길이는 10,000 이하의 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>n개의 줄을 출력한다. i번째 줄에는 i번 방에 있던 개미가 도달할 수 있는 방 중에 1번 방과 가장 가까운 방의 번호를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
10
8
22
18
1 2 10
2 3 10
2 4 10
','1
2
1
2
','DATA_STRUCTURE'),
                                                                                                                (7423,'BAEKJOON','https://www.acmicpc.net/problem/15307',15307,'민돌 투어','1초','512 MB',18,'<p><em>민돌(mindol)</em>의 이름을 들어 본 적이 있는가? 세계 최고의 래퍼인 민돌은 100개국 투어로 번 돈으로 얼마 전 놀이공원 <em>민돌 파크</em>를 세웠다.</p>

<p>민돌 파크의 명물은 트램펄린 놀이기구로, $0$번, $1$번, ..., $N$번까지 총 $N+1$개의 트램펄린이 순서대로 놓여 있어 트램펄린 사이를 뛰어다니면서 즐기는 놀이기구이다. $0$번 트램펄린은 시작 지점으로, 다른 모든 트램펄린으로 한 번에 뛰어갈 수 있다. $i$번 트램펄린 ($1 \le i \le N$) 에서는, 번호 차이가 $A_i$ 이하인 트램펄린까지만 한 번에 뛰어갈 수 있다. 안전을 위해, 모든 트램펄린에서 $0$번 트램펄린까지 한 번에 뛰어갈 수 있도록 되어 있다. 즉, $A_i \ge i$이다.</p>

<p>민돌의 열렬한 팬이었던 민솔이는 이 소식을 듣고 곧바로 민돌 파크에 놀러 갔다. 민솔이는 트램펄린 놀이기구를 뭔가 특별한 방법으로 타고 싶었는데, &nbsp;해밀턴이 민돌과 라임이 맞는다고 생각한 민솔이는 해밀턴 투어를 본딴 <strong>민돌 투어</strong>를 해 보기로 했다. 민돌 투어란, $0$번 트램펄린에서 시작해 다른 모든 트램펄린을 정확히 한 번씩 방문하고 다시 $0$번 트램펄린으로 돌아오는 것을 말한다.</p>

<p>민솔이는 가능한 모든 민돌 투어를 한 뒤 집으로 돌아가려 한다. 민솔이는 놀이기구를 몇 번 이용해야 할까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 $0$번 트램펄린을 제외한 트램펄린의 개수 $N$ ($1 \le N \le 200\, 000$) 이 주어진다.</p>

<p>두 번째 줄에는 $N$개의 정수 $A_i$ ($i \le A_i \le N$) 들이 공백을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 모든 가능한 민돌 투어의 수를 $10^9+7$로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 예제의 경우 $0 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 0$ / $0 \rightarrow 2 \rightarrow 3 \rightarrow 1 \rightarrow 0$ / $0 \rightarrow 3 \rightarrow 1 \rightarrow 2 \rightarrow 0$ / $0 \rightarrow 3 \rightarrow 2 \rightarrow 1 \rightarrow 0$의 4가지 투어가 가능하다.</p>

				</div>
				</div>','3
1 3 3
','4
','DATA_STRUCTURE'),
                                                                                                                (7427,'BAEKJOON','https://www.acmicpc.net/problem/15313',15313,'정과프 해적단','1초','512 MB',21,'<p><em>정과프 해적단</em>이 나타났다! 정보과학프로젝트 수강생들로 이루어진 정과프 해적단은 가차없기로 악명이 높다. 그 두목의 정체를 아는 사람은 극히 일부밖에 없으며, <em>킹-갓</em>이라는 별명만이 떠돌아다닐 뿐이다. 세계 각국의 고귀한 보물들을 휩쓸고 다니던 정과프 해적단은 어느덧 우리나라의 아름다운 다도해, 서해만을 남겨두고 있었으니..</p>

<p>두목의 충실한 오른팔인 동건이는 서해에 있는 $N$개의 섬들에 숨겨져 있는 보물들을 가지고 오라는 명을 받았다. 동건이의 출발 위치는 ($0$, $0$)이며, 해적단의 아지트인 SRC 123호는 ($10^9$, $10^9$)에 위치해 있다. 남서풍이 심하게 불고 있어서, 동건이는 $x$좌표나 $y$좌표가 감소하는 방향으로 움직일 수 없다.</p>

<p>각 섬에는 보물이 숨겨진 금고가 하나씩 있고, 이 금고는 특수 제작된 해체기로 열 수 있다. 금고는 담긴 보물의 가치 $v_i$와 강도 $h_i$를 가지는데, 금고가 너무 단단하면 해체기가 망가지고, 너무 약하면 보물이 같이 부서지기 때문에 해체기를 미리 적절히 설정해야 한다. 해체기는 ($0$, $0$)에서 출발할 때 딱 한 번 설정할 수 있는데, 강도가 [$x$, $y$] 범위에 있는 금고를 열 수 있도록 설정하려면 ($y-x$)원의 비용이 든다.</p>

<p>동건이는 해체기 설정 비용 정도는 해적단에서 지원해 주리라 생각했지만, 두목은 자신의 부하에게도 가차없었다. 우리의 불쌍한 동건이가 두목과 연락하는 모습을 지켜보자.</p>

<p><em>"저... 두목님... 그 해체기 설정 비용은 지원해 주시는 거..."</em></p>

<p><em>"안 줘. 니 돈 써. 아 맞다, 보물 $M$원어치 안 모아오면 너 짜를거야. (뚝! 뚜... 뚜... 뚜... 뚜... 뚜...)"</em></p>

<p>동건이는 눈 앞에서 계약서를 불태워버리는 무자비한 두목의 모습을 상상하면서 두려움에 떨고 있다. 동건이가 해적단에서 쫓겨나지 않기 위해서는 사비를 최소 얼마나 써야 할까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 서해에 있는 섬의 개수 $N$ ($ 1 \le N \le 2\, 000$) 과 동건이가 최소로 모아 가야 하는 보물의 가치 $M$ ($1 \le M \le 10^{12}$) 이 주어진다.</p>

<p>다음 $N$개의 줄에는 각 섬의 $x$좌표, $y$좌표, 보물 가치, 금고 강도를 나타내는 4개의 정수 $x_i$, $y_i$, $v_i$, $h_i$ 가 공백을 사이에 두고 주어진다. (모두 $1$ 이상 $10^{9}$ 이하)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>동건이가 해적단에서 쫓겨나지 않기 위해 써야 하는 최소의 사비를 출력한다. 만약 동건이가 어떻게 해도 해적단에서 쫓겨나야 한다면 "-1"을&nbsp;출력한다. (따옴표 제외)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5
1 1 2 5
2 2 3 3
3 3 4 9
','2
','DATA_STRUCTURE'),
                                                                                                                (7432,'BAEKJOON','https://www.acmicpc.net/problem/15316',15316,'현수시티','1초','512 MB',21,'<p>여러분도 모두 알다시피, 경기과학고는 수원시 장안구 송죽동에 세워져 있다. 하지만, 사실 여러분이 아는 송죽동이 전부가 아니었으니... 여러분이 잠든 사이, 송죽동은 음침하고 위험한 도시 <em>현수시티</em>의 일부가 된다.</p>

<p>현수시티는 어둠에 잠긴 무서운 곳이지만, 사실 현수시티의 시장 현수는 무서운 사람이 아니다. 그는 단지 어두운 게 좋아 현수시티를 세웠을 뿐인데, 어둡다는 이유로 사람들이 모두 기피하고 범죄의 온상이 되어 버린 것이다.</p>

<p>현수시티는 $1$에서 $N$까지 번호가 붙은 $N$개의 교차로가 $M$개의 도로들로 연결되어 있는 형태인데, 임의의 교차로 사이를 도로들을 통해 오갈 수 있도록 되어 있다. 착한 현수는 모든 도로에 가로등을 하나씩 설치하고, 사람들이 길을 잃지 않도록 모든 도로가 최대 한 개의 사이클에 속하도록 도시를 설계했다.</p>

<p>현수에게는 요즘 새로운 고민이 생겼는데, 도로에 있는 가로등이 자꾸 고장난다는 것이다. 고장나는 대로 고치고는 있지만 역부족이었다. 가로등이 꺼진 도로를 지나다니는 것은 정말 위험하므로, 현수는 시민들이 가로등이 켜진 길로만 다닐 수 있었으면 한다. 이를 위해, 현수는 사람들이 어떤 두 교차로 사이를 가로등이 켜진 길로만 오갈 수 있는지 실시간으로 알려주는 앱을 만들려고 한다.</p>

<p>현수는 바쁘기 때문에 앱을 만드는 일을 당신에게 맡겼다. 현수를 도와주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 교차로의 개수 $N$ ($1 \le N \le 200\, 000$) 과 도로의 개수 $M$ ($N-1 \le M \le 200\, 000$) 이 주어진다.</p>

<p>다음 $M$개의 줄에는 각 도로가 잇는 두 교차로의 번호 $u_i$, $v_i$가 주어진다. ($1 \le u_i, v_i \le N$)</p>

<p>중복 간선이나 셀프 루프는 들어오지 않으며, 모든 간선이 최대 한 개의 사이클에 속함이 보장된다.</p>

<p>그 다음 줄에는 입력에서 $i$번째로 들어온 도로의 가로등이 작동하는지의 여부가 공백을 사이에 두고 순서대로 주어진다. 작동하면 $1$, 고장났으면 $0$이다.</p>

<p>그 다음 줄에는 앱에 들어오는 갱신 / 질의의 수 $Q$ ($1 \le Q \le 200\, 000$) 가 주어진다.</p>

<p>다음 $Q$개의 줄에는 각 갱신 / 질의의 정보가 순서대로 주어진다. 각 줄에는 $2$개 또는 $3$개의 숫자가 주어지고, 의미는 다음과 같다 :</p>

<p>$1$ $i$ : 입력에서 $i$번째로 들어온 도로에 있는 가로등의 상태가 바뀐다. (고장났다면 고쳐지고, 작동 중이었다면 고장난다)</p>

<p>$2$ $a$ $b$ : 현재 도로 상태에서 $a$번 교차로에서 $b$번 교차로 사이를 가로등이 켜진 길만 이용해서 오갈 수 있는지 물어보는 질의이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 질의($t=2$인 입력)에 대해, 해당하는 두 교차로를 가로등이 켜진 길만 이용해 오갈 수 있다면 "<code>YES</code>", 아니면 "<code>NO</code>"를 출력한다. (따옴표 제외)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 4
1 2
2 3
3 1
1 4
1 1 0 1
5
2 3 4
1 2
2 3 4
1 2
2 1 3
','YES
NO
YES
','DATA_STRUCTURE'),
                                                                                                                (7420,'BAEKJOON','https://www.acmicpc.net/problem/15352',15352,'욱제와 그의 팬들','2.5초','256 MB',18,'<p>욱제에게는 K개의 팬클럽이 있습니다. 욱제가 성인이 된 것을 기념하여 개최하는 욱제의 팬미팅에 N명의 팬이 모였습니다. N명의 팬들은 각각 순서대로 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub> 번 팬클럽에 소속되어 있으며, 등록번호 1, 2, ..., N을 가집니다. 팬들은 1, 2, ..., N번 순서로 서 있습니다.</p>

<p>할 일이 없었던 욱제는 Q번 어떠한 행동을 하기로 합니다. 행동에는 두가지 종류가 있습니다 :</p>

<ul>
	<li>행동 1 : 욱제는 팬을 한 명 골라 진정한 팬이 아니라는 이유로 팬미팅에서 퇴출시킵니다.</li>
	<li>행동 2 : 욱제는 팬을 한 명 골라 그 팬을 포함해&nbsp;양 옆으로 연속적으로 같은 팬클럽인 사람들에게 헌신적인 팬이 되어준 보상으로써 선물을 줍니다.</li>
</ul>

<p>욱제는 Q번의 행동을 수행한 후 너무 질린 나머지 "나보다 알고리즘 못하는 사람들 다 나가"를 시전해 팬미팅을 종료시켰습니다. 욱제는 팬미팅이 끝난 후 팬들에게 준 선물의 수를 알고 싶어합니다. 욱제를 도와주세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 K와 N이 입력됩니다. (1 ≤ K, N ≤ 10<sup>6</sup>)</p>

<p>두 번째 줄에 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 입력됩니다. (1 ≤ A<sub>i</sub> ≤ K)</p>

<p>세 번째 줄에 Q가 입력됩니다. (0 ≤ Q ≤ 3 × 10<sup>6</sup>)</p>

<p>Q개의 줄 동안 숫자 a와 b가 입력됩니다. (1&nbsp;≤ a ≤ 2, 1 ≤ b ≤ N)</p>

<p>a가 1일 경우엔 등록번호 b번 사람을 대상으로 행동 1을 시행하며. 이는 같은 팬에게 중복으로&nbsp;발생하지 않음이 보장됩니다.</p>

<p>a가 2일 경우엔 등록번호 b번 사람을 기준으로 행동 2를 시행합니다. 퇴출된 사람은 대상이 되지 않습니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q번의 행동을 시행한 후 욱제가 팬들에게 준 총 선물의 수를 출력합니다. 욱제는 선물을 무한히 많이 가지고 있기 때문에, 선물이 부족해 선물을 줄 수 없는 경우는 없습니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 행동 2에서 욱제는 등록번호 1, 2번에게 선물을 줍니다. ( 1-1-2-3-1 )</p>

<p>두 번째 행동 2에서 욱제는 등록번호 1, 2, 5번에게 선물을 줍니다. ( 1-1-1 )</p>

<p>마지막 행동 2에서 욱제는 등록번호 1, 5번에게 선물을 줍니다. ( 1-1 )</p>

				</div>
				</div>','10 5
1 1 2 3 1
6
2 2
1 3
1 4
2 5
1 2
2 5
','7
','DATA_STRUCTURE'),
                                                                                                                (7446,'BAEKJOON','https://www.acmicpc.net/problem/15481',15481,'그래프와 MST','2초','512 MB',20,'<p>총 N개의 정점과 M개의 간선으로 이루어져 있는 무방향 가중치 연결 그래프 G가 있다. 그래프 G는 루프가 없고, 두 정점을 연결하는 간선은 최대 1개이다.</p>

<p>각각의 간선 (u, v)에 대해서, 그 간선을 포함하는 최소 스패닝 트리의 가중치 합을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 N과 간선의 개수 M (2&nbsp;≤&nbsp;N ≤ 200,000, N-1 ≤ M ≤ 200,000)</p>

<p>둘째 줄부터 M개의 줄에 간선의 정보 u, v, w가 주어진다. u와 v를 연결하는 간선의 가중치가 w라는 뜻이다. (1 ≤ u, v ≤ n, u ≠ v, 1 ≤&nbsp;w ≤ 10<sup>9</sup>)&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 간선마다 그 간선을 포함하는 최소 스패닝 트리의 가중치 합을 출력한다. 간선은 입력받은 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 8
1 2 5
2 3 4
1 3 2
3 4 8
4 5 3
3 5 6
1 4 9
2 5 1
','11
10
10
14
10
12
15
10
','DATA_STRUCTURE'),
                                                                                                                (7447,'BAEKJOON','https://www.acmicpc.net/problem/15491',15491,'도시 정비','2초','512 MB',18,'<p>알고리즘 나라는 N개의 도시로 구성되어 있다. 모든 도시들은 고속도로를 통해 직간접적으로 연결되어 있다. 고속도로는 N-1개만 존재한다.</p>

<p>알고리즘 나라는 도시를 하나 없애려고 한다. 이때 그 도시와 직접 연결된 고속도로도 함께 제거된다.</p>

<p>알고리즘 나라의 도시들은 가끔 정비가 필요하다. 정비에는 정비 기기가 필요하고, 도시마다 필요한 정비 기기의 최소 가격이 있다. 즉 한 도시에 필요한 정비 기기의 최소 가격이 x이면, 가격이 x 이상인 정비 기기를 사용해야 그 도시를 정비할 수 있다.</p>

<p>정비 기기는 고속도로를 통해서만 이동할 수 있다. 도시 정비는 긴급하지 않기 때문에, 고속도로로 연결된 도시들의 집합에는 한 대의 정비 기기만 사용된다.</p>

<p>당신은 정비 기기를 만드는 회사의 사장이다. 당신은 어떤 도시가 없어졌을 때 가장 매출이 높아지는지 분석하고 싶다. 매출은 알고리즘 나라의 모든 도시를 정비하는 데 필요한 최소 비용이다. 도시를 없앴을 때 가능한 가장 높은 매출을 출력하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 양의 정수 N(2 ≤ N ≤ 1,000,000)이 하나 주어진다. 각 도시는 1 ~ N으로 번호가 하나씩 붙여져 있다. 그 다음 줄에는 1번 도시부터 N번 도시까지 필요한 정비 기기의 최소 가격이 차례대로 공백을 사이에 두고 N개의 양의 정수로 주어진다. 모든 가격의 합은 2<sup>31</sup> 미만이다. 그 다음 줄부터 N-1개의 줄에는 고속도로가 연결하고 있는 두 도시의 번호를 의미하는 두 개의 정수가 한 줄에 공백을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 도시를 제거했을 때 가능한 가장 높은 매출을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 3 7 4
1 3
2 3
3 4
','8
','DATA_STRUCTURE'),
                                                                                                                (7448,'BAEKJOON','https://www.acmicpc.net/problem/15493',15493,'수 고르기','1초','512 MB',22,'<p>kcm1700은 심심한 나머지 ntopia에게 다음과 같은 과제를 제시했다. 원형으로 N개의 수가 놓여 있는데, 인접하게 고르는 것이 없게 하면서 K개의 수를 골랐을 때 최대한 K개의 수의 합을 크게 하여라. 인접하게 고른다는 것은 선택한 것 중에 <strong>연속되게 놓여있는 두 개의 수를 고른 것이 있다</strong>는 뜻이다.</p>

<p>당신은 kcm1700을 무너뜨리고 ntopia를 돕기 위해 원형으로 놓인 N개의 수를 인접하지 않게 K개를 골랐을 때의 최대 합을 구하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 양의 정수 N(3 ≤ N ≤ 1,000,000)과 정수 K(1 ≤ K ≤ N/2) 주어진다. 둘째 줄에는 원을 이루는 N개의 자연수(2<sup>31</sup> 미만)가 시계방향 순서대로 빈 칸을 사이에 두고 차례대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최대 합을 구하여라. 답은 2<sup>31</sup> 보다 작다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 4
2 1 3 1 2 1 3 1 3 1
','11
','DATA_STRUCTURE'),
                                                                                                                (7452,'BAEKJOON','https://www.acmicpc.net/problem/15500',15500,'이상한 하노이 탑','2초','512 MB',9,'<p>승민이는 <a href="https://www.acmicpc.net/problem/11729">기존 하노이 탑 문제</a>를 약간 변형한 이상한 하노이 탑 문제를 만들었다.</p>

<p>이상한 하노이 탑 문제와 기존 하노이 탑 문제와 다른 점이 2가지가 있는데 하나는 "쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.(중간 과정 역시 그래야함)" 라는 조건이 삭제되었다는 점이고 또 다른 하나는 첫 번째 장대에 원판들이 반경 상관없이 무작위로 배치되어 있다는 점이다.</p>

<p>승민이는 이 문제를 진수에게 주었고 원판을 옮긴 횟수가 12345보다 같거나 작으면 피자를 사주기로 하였다. 진수를 도와 피자를 먹게 해주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 원판의 개수 N (1 ≤ N ≤ 123) 이 주어진다.</p>

<p>두 번째 줄에는 첫 번째 장대에 있는 원판들의 반경 나타내는 정수 a<sub>i</sub> (1 ≤ a<sub>i</sub>&nbsp;≤ N) 들이 공백을 두고 주어진다. (제일 아래에 있는 원판의 반경부터 주어진다.)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 원판을 옮긴 횟수&nbsp;K (0 ≤ K ≤ 12345) 를 출력한다.</p>

<p>다음 K 개 줄에 걸쳐 A&nbsp;B (1 ≤ A, B ≤ 3) 를 출력하는데 A 번째 장대 맨위에 있는 원판 하나를 B 번째 장대 맨위로 옮긴다는 뜻이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>아래는 예제를 푸는 과정을 나타낸다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15500/example.png" style="height:564px; width:221px"></p>

				</div>
				</div>','3
2 3 1
','4
1 2
1 3
1 3
2 3
','DATA_STRUCTURE'),
                                                                                                                (7449,'BAEKJOON','https://www.acmicpc.net/problem/15502',15502,'K-균등 문자열','1초','256 MB',14,'<p>0과 1로 이루어진 문자열에서 길이가 K인 연속된 부분문자열을 뽑았을 때, 항상 그 부분문자열에 포함된 1의 개수가 같다면 이 문자열을 K-균등하다고 하자.</p>

<p>예를 들어, “100110”이라는 문자열이 있을 때, 이 문자열은 4-균등하다고 말할 수 있다. 길이가 4인 연속된 부분문자열은 {“1001”, “0011”, “0110”} 이 있고, 모두 1이 2개씩 포함되어 있기 때문이다.</p>

<p>온조는 0과 1로 이루어진 길이 N의 문자열을 만들려고 한다. 또한 온조는 M개의 좋아하는 구간과, M개의 좋아하는 수가 있다. 이때 i번째 구간은 L<sub>i</sub>번째 문자부터 R<sub>i</sub>번째 문자까지의 부분문자열을 의미하며, i번째 수는 K<sub>i</sub>이다. 온조는 i번째 구간에 해당되는 부분문자열이 ‘K<sub>i</sub>-균등’하기를 원한다. (K<sub>i</sub>는 i번째 구간의 길이보다 크지 않다.) 이때, 온조가 만들 수 있는 문자열의 수를 구하시오. 수가 커질 수 있으니 1,000,000,007로 나눈 나머지를 출력하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 1000, 0 ≤ M ≤ 1000) i+1번째 줄에는 L<sub>i</sub>, R<sub>i</sub>, K<sub>i</sub>가 주어진다. (1 ≤ L<sub>i</sub> ≤ R<sub>i</sub> ≤ N, 1 ≤ K<sub>i</sub> ≤ R<sub>i</sub> - L<sub>i</sub> + 1)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 만들 수 있는 문자열의 수를 1,000,000,007로 나눈 나머지를 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 예제에서는, 다음의 8가지로 문자열을 만들 수 있다. {“00000”, “00001”, “01010”, “01011”, “10100”, “10101”, “11110”, “11111”}</p>

<p>두 번째 예제에서는 온조가 좋아하는 구간과 수가 없으므로 길이 N의 아무런 문자열이나 만들어도 된다. 즉, 2<sup>1000</sup>개의 문자열을 만들 수 있다.</p>

				</div>
				</div>','5 2
1 4 2
3 5 3
','8
','DATA_STRUCTURE'),
                                                                                                                (7450,'BAEKJOON','https://www.acmicpc.net/problem/15506',15506,'정원사','3초','128 MB',21,'<p>온조는 N개의 정원을 가꾸는 정원사이다. 모든 정원에는 아직 아무런 식물도 심어져 있지 않고, 각각의 정원에는 식물을 무한정 심을 수 있다. 모든 식물은 하루에 k만큼 자란다. 즉, 높이 h의 어떤 식물이 심어진 날이 x번째 날이라면, y번째 날에는 높이가 h + k(y-x)가 된다. 온조는 M개의 작업을 수행해 N개의 정원을 예쁘게 가꾸려고 한다.</p>

<p>다음은 작업의 종류 세 가지이다:&nbsp;</p>

<ul>
	<li><code>1 t x h</code> : t번째 날에 x번째 정원에 높이가 h인 식물을 하나 추가한다.</li>
	<li><code>2 t l r h</code> : t번째 날에 l번째 정원부터 r번째 정원까지에 심어져 있는 모든 식물들 중에서 높이가 h를 초과한 식물들을 모두 뽑아 버린다.</li>
	<li><code>3 t l r</code> : t번째 날에 l번째 정원부터 r번째 정원까지에 심어져 있는 모든 식물들의 수를 출력한다.</li>
</ul>

<p>온조는 뛰어난 정원사였기 때문에 첫 번째 작업과 두 번째 작업은 손쉽게 할 수 있었지만, 세 번째 작업은 수학에 약한 온조로서는 수행하기 어려웠다. 세 번째 작업에 대한 답을 우리가 대신 해 주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정원의 수 N (1 ≤ N ≤ 10<sup>5</sup>)과&nbsp;온조와 당신이 수행할 작업의 수 M (1 ≤ M ≤ 10<sup>6</sup>), 모든 식물이 하루에 자라는 높이 k (1 ≤ k ≤ 10<sup>9</sup>)가&nbsp;주어진다. 그 다음 줄부터 M개의 줄에는 작업의 정보가 주어진다. 작업의 정보는 날짜가 증가하는 순으로 주어지고, l과 r, x는 1 이상 N 이하이며, 그 외의 모든 수는 1 이상 10<sup>9</sup>&nbsp;이하의 자연수이다. 참고로 온조는 같은 날에 두 개의 작업을 하는 것을 원치 않기 때문에, 하루에는 최대 하나의 작업만 수행한다는 것이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>세 번째 작업에 대한 답을 각각의 줄에 출력한다. M개의 작업 중 세 번째 작업이 적어도 하나가 있다는 것이 보장된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5 1
1 1 2 3
1 2 2 3
1 3 3 6
2 4 2 3 6
3 100 1 3
','2
','DATA_STRUCTURE'),
                                                                                                                (7460,'BAEKJOON','https://www.acmicpc.net/problem/15559',15559,'내 선물을 받아줘','2초','512 MB',14,'<p>욱제는 구사과의 열렬한 팬이다. 오늘 욱제는 구사과에게 선물(<img alt="" class="no-responsive" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15559/1.png" style="height:20px; width:20px">)을 전달해주려고 한다. 지난 며칠간의 관찰 끝에 욱제는 구사과의 이동 패턴을 모두 파악했다.</p>

<p>구사과가 있는 곳은 N×M 크기의 직사각형 지도로 나타낼 수 있으며, 1×1크기의 정사각형으로 나누어져 있다. 구사과의 위치는 (i, j)로 나타낼 수 있으며, (i, j)는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸을 의미한다.</p>

<p>지도의 각 칸에는 N, W, E, S 중의 한 문자가 쓰여져 있는데, 구사과는 이 문자를 이용해서 이동한다. 구사과의 위치가 (i, j)인 경우에 N이 쓰여져 있는 칸에 서 있었다면, (i-1, j)로, S의 경우에는 (i+1, j)로, W의 경우에는 (i, j-1), E의 경우에는 (i, j+1)로 순간이동한다.&nbsp;구사과는 지치지 않기 때문에, 계속해서 이동한다.</p>

<p>욱제는 구사과의 위치를 모르기 때문에, 구사과가 이동을 시작하는 위치와 관계없이 선물을 주는 방법을 알아내려고 한다. 최소 몇 개의 칸 위에 선물을 놓으면, 구사과가 항상 선물을 가져가는지 구하는 프로그램을 작성하시오. 선물이 놓여진 칸에&nbsp;구사과가 이동하면, 구사과는 항상 선물을 가져간다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (1&nbsp;≤ N, M ≤ 1,000, 1 < N×M ≤ 1,000,000)</p>

<p>둘째 줄부터 N개의 줄에는 구사과가 있는 곳의 지도가 주어진다.&nbsp;</p>

<p>지도에 쓰여 있는대로 이동했을 때, 지도를 벗어나는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소 몇 개의 칸에 선물을 놓아야 하는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
SWWW
SEWN
EEEN
','2
','DATA_STRUCTURE'),
                                                                                                                (7459,'BAEKJOON','https://www.acmicpc.net/problem/15561',15561,'구간 합 최대? 2','1초','256 MB',20,'<p>길이&nbsp;<em>N</em>의 정수 수열&nbsp;<em>K</em><sub>1</sub>,?<em>K</em><sub>2</sub>,?...,?<em>K</em><sub><em>N</em></sub>과 상수&nbsp;<em>U</em>,&nbsp;<em>V</em>가 주어진다.</p>

<p><em>Q</em>개의 쿼리가 주어지며, 그 종류는 두 가지가 있다.</p>

<ol>
	<li><em>A</em>,&nbsp;<em>B</em>가 주어지면,&nbsp;<em>max</em>(<em>U</em>?×?(<em>K</em><sub><em>i</em></sub>?+?<em>K</em><sub><em>i</em>?+?1</sub>?+?...?+?<em>K</em><sub><em>j</em></sub>)?+?<em>V</em>?×?(<em>j</em>?-?<em>i</em>))&nbsp;(<em>A</em>?≤?<em>i</em>?≤?<em>j</em>?≤?<em>B</em>)&nbsp;의 값을 구한다.</li>
	<li><em>A</em>,&nbsp;<em>B</em>가 주어지면,&nbsp;<em>K</em><sub><em>A</em></sub>의 값을&nbsp;<em>B</em>으로 바꾼다.</li>
</ol>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정수&nbsp;<em>N</em>과&nbsp;<em>Q</em>,&nbsp;<em>U</em>,&nbsp;<em>V</em>가 입력된다.&nbsp;(1?≤?<em>N</em>,?<em>Q</em>?≤?10<sup>5</sup>,??-?5?≤?<em>U</em>,?<em>V</em>?≤?5)</p>

<p>두 번째 줄에 정수&nbsp;<em>K</em><sub>1</sub>,?<em>K</em><sub>2</sub>,?...,?<em>K</em><sub><em>N</em></sub>이 주어진다.&nbsp;(-10<sup>2</sup>?≤?<em>K</em><sub><em>i</em></sub>?≤?10<sup>2</sup>)</p>

<p>세 번째 줄부터 쿼리가 주어진다. 세 정수&nbsp;<em>C</em>,&nbsp;<em>A</em>,&nbsp;<em>B</em>가 주어진다.&nbsp;(0?≤?<em>C</em>?≤?1, A, B, C는 정수)</p>

<p><em>C</em>가 0이면 첫 번째 쿼리를, 아니면 두 번째 쿼리를 수행한다. 첫 번째 쿼리일 경우&nbsp;1?≤?<em>A</em>?≤?<em>B</em>?≤?<em>N</em>&nbsp;이다. 두 번째 쿼리일 경우&nbsp;1?≤?<em>A</em>?≤?<em>N</em>, -10<sup>2</sup>?≤?<em>B</em>?≤?10<sup>2</sup>이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄마다 첫 번째 쿼리의 결과값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3 2 4
1 1 1 1 1
0 1 5
1 3 -2
0 1 5
','26
20
','DATA_STRUCTURE'),
                                                                                                                (7465,'BAEKJOON','https://www.acmicpc.net/problem/15646',15646,'농부 후안은 바리스타입니다','2초','512 MB',17,'<p>농부 후안은 바리스타입니다. 후안은&nbsp;<i>N</i>?×?<i>M</i>&nbsp;크기의 커피 농장을 소유하고 있습니다. 후안은 <em>Q</em>번 농장에 씨앗을 심거나 심은 씨앗의 영양의 합을 확인할 것입니다. 후안은 자신의 농장을 관리해줄 자동화 시스템이 필요합니다. 후안을 도와줍시다. 프로그램은 다음과 같은 두 동작을 수행해야 합니다.</p>

<ul>
	<li>씨앗 심기 : x 좌표가 [<em>x<sub>1</sub></em>,<em>x<sub>2</sub></em>]에 포함되고 y 좌표가 [<em>y<sub>1</sub></em>,<em>y<sub>2</sub></em>]에 포함되는 모든 위치에 영양이 <em>d</em>인 씨앗을 1개 심습니다.</li>
	<li>씨앗 개수 확인하기 : (<em>x</em>,<em>y</em>) 위치에 심은 씨앗의 영양의 합을 확인합니다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p><em>N</em>, <em>M</em>, <em>Q</em>가 첫 줄에 주어집니다. (1?≤?<i>N</i>,?<i>M</i>?≤?5000,?0?≤?<i>Q</i>?≤?2?×?10<sup>5</sup>)</p>

<p><em>Q</em>개의 줄 동안 수행해야 하는 동작이 주어집니다.</p>

<p>첫 번째로 주어지는 숫자가 1이면 이는 씨앗을 심는 동작임을 뜻하며, 5개의 수 x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, d가 주어집니다. (1?≤?<i>x</i><sub>1</sub>?≤?<i>x</i><sub>2</sub>?≤?<i>N</i>,?1?≤?<i>y</i><sub>1</sub>?≤?<i>y</i><sub>2</sub>?≤?<i>M</i>,??-?10<sup>9</sup>?≤?<i>d</i>?≤?10<sup>9</sup>)</p>

<p>첫 번째로 주어지는 숫자가 2이면 이는 씨앗의 영양의 합을 확인하는 동작임을 뜻하며, 2개의 수 <em>x</em>와 <em>y</em>가 주어집니다. (1?≤?<i>x</i>?≤?<i>N</i>,?1?≤?<i>y</i>?≤?<i>M</i>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 씨앗 개수를 확인하는 동작에 대해, 각각의 결과를 한 줄마다 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5 2
1 1 1 3 5 2
2 3 3
','2
','DATA_STRUCTURE'),
                                                                                                                (7463,'BAEKJOON','https://www.acmicpc.net/problem/15648',15648,'추출하는 폴도 바리스타입니다','1.5초','64 MB',17,'<p>추출하는 폴은 바리스타입니다. 폴에게는 커피콩 <em>N</em>개가 순서대로 주어집니다. 폴은 이 중 몇 개를 골라서 추출할 예정입니다. 이때, 최종 결과물의 질이 좋아야 할 것입니다. 결과물의 질이 좋기 위해서는, 커피콩들의 종류(정수로 표현됩니다.)로 이루어진 수열의 부분수열을 <em>A</em>라고 하면, 2 이상의 모든 i 에 대해&nbsp;<em>A</em><sub><em>i</em>?-?1</sub>?≡?<em>A</em><sub><em>i</em></sub>&nbsp;(<em>mod</em>&nbsp;<em>k</em>)&nbsp;나&nbsp;<em>A</em><sub><em>i</em>?-?1</sub>?-?<em>d</em>?≤?<em>A</em><sub><em>i</em></sub>?≤?<em>A</em><sub><em>i</em>?-?1</sub>?+?<em>d</em>를 만족함을 뜻합니다.</p>

<p>폴을 위해서 질이 좋은 커피 추출물 중 가장 많은 커피콩을 고를 때 그 개수를 구해주세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 <em>N</em>, <em>k</em> 와 <em>d</em>가 주어집니다.&nbsp;(1?≤?<em>N</em>?≤?5?×?10<sup>5</sup>,?1?≤?<em>k</em>,?<em>d</em>?≤?5?×?10<sup>5</sup>)</p>

<p><em>N</em>개의 커피콩의 순서와 각각의 번호를 나타내는 길이 <em>N</em>의 배열 <em>S</em>가 다음 줄에 주어집니다.&nbsp;(1?≤?<em>S</em><sub><em>i</em></sub>?≤?5?×?10<sup>5</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>질이 좋은 커피 추출물 중 가장 많은 커피콩을 고를 때 그 개수를 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9 7 2
1 5 12 10 8 6 4 4 3
','8
','DATA_STRUCTURE'),
                                                                                                                (7464,'BAEKJOON','https://www.acmicpc.net/problem/15659',15659,'연산자 끼워넣기 (3)','2초','512 MB',12,'<p>N개의 수로 이루어진 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.</p>

<p>우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.</p>

<p>예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 60가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다.</p>

<ul>
	<li>1+2+3-4×5÷6</li>
	<li>1÷2+3+4-5×6</li>
	<li>1+2÷3×4-5+6</li>
	<li>1÷2×3-4+5+6</li>
</ul>

<p>식의 계산은 연산자 우선 순위를 이용해 계산해야 한다. 연산자 우선 순위는 ×와 ÷가 +와 -보다 앞선다. 우선 순위가 같은 경우에는 앞에 있는 식을 먼저 계산한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와&nbsp;같다.</p>

<ul>
	<li>1+2+3-4×5÷6 = 3</li>
	<li>1÷2+3+4-5×6 = -23</li>
	<li>1+2÷3×4-5+6 = 2</li>
	<li>1÷2×3-4+5+6 = 7</li>
</ul>

<p>N개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> ≤ 100) 셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수,&nbsp;곱셈(×)의 개수, 나눗셈(÷)의 개수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다. 최댓값과 최솟값이 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 또한, 식을 어떤 순서로 계산해도&nbsp;중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>세 번째 예제의 경우에 다음과 같은 식이 최댓값/최솟값이 나온다.</p>

<ul>
	<li>최댓값: 1-2÷3+4+5×6</li>
	<li>최솟값: 1+2+3÷4-5×6</li>
</ul>

				</div>
				</div>','2
5 6
0 0 1 0
','30
30
','DATA_STRUCTURE'),
                                                                                                                (7467,'BAEKJOON','https://www.acmicpc.net/problem/15674',15674,'가로수','2초','256 MB',19,'<p>연세대학교에서는 이번에 대대적인 가로수 심기 작업을 한다. 원활한 작업을 위해 학교에서는 어느 정도의 예산이 필요할지 알아보려 한다.</p>

<p>연세대학교에는 총 N개의 건물이 있으며, 각 건물 앞에는 정확히 한 그루씩의 나무를 심을 것이다. 따라서, 총 N그루의 나무를 심을 것이다. 심을 나무는 항상 두 종류 중 하나로, 하나는 은행나무이며(해충이 꼬이지 않지만, 가을에 악취가 심하다), 다른 하나는 플라타너스이다(여름에 그늘을 만들어주지만, 봄에 일부 사람에게 호흡기 알레르기를 유발할 수 있다).</p>

<p>학교 측에서는 미리 각 건물 앞에 은행나무를 심을 때의 비용과 플라타너스를 심을 때의 비용을 각각 모두 조사해 두었다. 각 건물이 있는 장소의 지형이나 환경이 다르기 때문에, 같은 나무를 심더라도 다른 건물 앞이라면 비용이 다를 수 있다.</p>

<p>학교 측에서는 최소 비용으로 가로수를 모든 건물 앞에 심을 계획을 작성했다. 하지만, 늦게 프로젝트에 합류한 디자이너는 이대로 가로수를 심을 경우 미관상 좋지 않다는 이야기를 하며, 계획을 꽤 많이 수정해야 한다고 했다. 디자이너의 요청은 두 가지 종류 중 하나였다.</p>

<ol>
	<li>건물 i와 건물 j에는 반드시 같은 나무를 심어야 한다.</li>
	<li>건물 i와 건물 j에는 반드시 다른 나무를 심어야 한다.</li>
</ol>

<p>설상가상으로, 디자이너의 요청을 받아 계획을 수정하는 일이 오래 걸리자, 미리 조사해 둔 비용들마저 변하기 시작했다. 각 비용은 아래와 같이 두 가지 종류 중 하나로 변한다.</p>

<ol>
	<li>건물 i에 은행나무를 심는 비용이 변한다.</li>
	<li>건물 i에 플라타너스를 심는 비용이 변한다.</li>
</ol>

<p>학교 측에서는 더이상 손수 계획을 수정하는 것은 무리라고 판단했으며, 이에 컴퓨터과학과 측에 지속적으로 변동하는 계획과 가격을 실시간으로 반영해 최적의 계획을 찾아 주는 프로그램 작성을 요청했다.</p>

<p>학교 측에서 요청한 프로그램을 작성해보도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 연세대학교 건물의 수 N, 현재까지 디자이너가 요청한 계획의 수 D가 주어진다. (1 ≤ N ≤ 200,000, 0 ≤ D ≤ 200,000)</p>

<p>건물의 번호는 1번부터 시작한다.</p>

<p>이어 N줄에 걸쳐, 각 건물에 은행나무를 심을 때의 비용 G<sub>i</sub>와 플라타너스를 심을 때의 비용 P<sub>i</sub>가 1번 건물부터 순서대로 주어진다. (1 ≤ G<sub>i</sub>, P<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>이어 D줄에 걸쳐, 디자이너의 요청 D개가 C i j의 형태로 주어진다. (C = 0 또는 1, 1 ≤ i ≤ N, 1 ≤ j ≤ N, i ≠ j)</p>

<p>C가 0일 경우, 건물 i와 건물 j에는 반드시 같은 나무를 심어야 함을 의미하며, C가 1일 경우엔 건물 i와 건물 j에는 다른 나무를 심어야 함을 의미한다.</p>

<p>다음 줄엔 추가적인 디자이너의 요청과 비용이 변동되는 횟수의 합 Q가 주어진다. (1 ≤ Q ≤ 200,000 )</p>

<p>이어 Q줄에 걸쳐, 각 요청/변동 사항이 C A B의 형태로 주어진다.</p>

<p>각 요청/변동 사항은 아래와 같이 분류된다.</p>

<ul>
	<li>C=0일 경우, 1 ≤ A, B ≤ N, A ≠ B. 건물 A와 B에는 동일한 나무를 심어야 한다는 요청이다.</li>
	<li>C=1일 경우, 1 ≤ A, B ≤ N, A ≠ B. 건물 A와 B에는 다른 나무를 심어야 한다는 요청이다.</li>
	<li>C=2일 경우, 1 ≤ A ≤ N, 1 ≤ B ≤ 10<sup>9</sup>. 건물 A에 은행나무를 심는 비용이 B로 변했다는 의미이다.</li>
	<li>C=3일 경우, 1 ≤ A ≤ N, 1 ≤ B ≤ 10<sup>9</sup>. 건물 A에 플라타너스를 심는 비용이 B로 변했다는 의미이다.</li>
</ul>

<p>모든 디자이너의 서로 다른 두 요청 i와 j에 대해, (A<sub>i</sub>, B<sub>i</sub>)와 (A<sub>j</sub>, B<sub>j</sub>), 또는 (A<sub>i</sub>, B<sub>i</sub>)와 (B<sub>j</sub>, A<sub>j</sub>)가 일치하는 경우는 없다.</p>

<p>모든 요청/변동은 누적된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 총 Q+1개의 줄로 이루어진다.</p>

<p>첫 줄에는 추가적인 요청과 비용 변동이 일어나기 전, 앞서 주어진 D개의 요청 사항만을 반영했을 때, 나무를 모든 건물 앞에 하나씩 심는 최소 비용을 출력한다.</p>

<p>이어 Q줄에 걸쳐, 각 요청/변동 직후에 나무를 모든 건물 앞에 하나씩 심는 최소 비용을 출력한다.</p>

<p>주어진 D개의 요청 및 이어지는 요청들을 모두 처리하는 과정에서 모든 건물 앞에 나무를 하나씩 심는 것이 불가능해지는 경우는 없다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>연세대학교에는 4개의 건물이 있으며, 디자이너는 우선 1번과 3번 건물 앞에는 같은 나무를 심을 것을 요청했다.</p>

<p>최적은 1번 건물부터 순서대로 (은행, 플라타너스, 은행, 은행) 을 심는 것이며, 이때의 비용은 17이다.</p>

<p>이어 추가적인 세 가지의 변동 사항에 대한 설명은 아래와 같다.</p>

<p>1번과 2번 건물 앞에 같은 나무를 심을 것을 요청받은 후에는 모든 건물 앞에 은행나무를 심는 것이 최적이 되며 (비용 18),</p>

<p>1번과 4번 건물 앞에 다른 나무를 심어야 함을 요청받은 후에는 (플라타너스, 플라타너스, 플라타너스, 은행)을 심는 것이 최적이다. (비용 30)</p>

<p>마지막으로, 4번 건물 앞에 플라타너스를 심는 비용이 100에서 1로 변화하면서, 최적의 계획은 (은행, 은행, 은행, 플라타너스) 를 심는 것이 된다. (비용 18)</p>

				</div>
				</div>','4 1
2 10
10 9
5 10
1 100
0 1 3
3
0 1 2
1 1 4
3 4 1
','17
18
30
18
','DATA_STRUCTURE'),
                                                                                                                (7469,'BAEKJOON','https://www.acmicpc.net/problem/15678',15678,'연세워터파크','1초','128 MB',16,'<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15678/1.png" style="width: 351.667px; height: 232.5px;"></p>

<p style="text-align: center;">(연세대학교 도서관, 2016년 7월)</p>

<p>연세대학교에서는 매년 여름 깜짝 워터파크를 개장한다. 이 워터파크가 발생할 장소는 알 수 없지만, 보통 도서관이나 서문 쪽에 주로 개장한다는 사실만이 알려져 있다.</p>

<p>워터파크 개장을 막는 것이 힘들다고 판단한 학교에서는 차라리 학생들이 워터파크를 더 즐길 수 있도록 정수 K<sub>i</sub> (-10<sup>9</sup> ≤ K<sub>i</sub> ≤ 10<sup>9</sup>)가 쓰여진 징검다리 N개를 놓아 두었다. 수업이 끝나고 친구들과 집에 가던 준호는 문득 이 징검다리를 이용해 여러 명이 즐길 수 있는 재미있는 게임을 하나 생각해냈다.</p>

<ul>
	<li>각 사람은 시작점으로 쓸 징검다리 하나를 아무 것이나 하나 고른다.</li>
	<li>시작점에서 출발한 뒤 계속 점프하여 징검다리를 몇 개든 마음대로 밟은 뒤, 나오고 싶을 때 나온다. 시작점에서 바로 나오는 것도 가능하다.</li>
	<li>시작점을 포함해, 밟은 모든 징검다리에 쓰여진 정수의 합이 가장 큰 사람이 이긴다.</li>
</ul>

<p>이 규칙에 따라 게임을 하던 준호는, 제자리 점프를 이용해 10억점을 만드는 친구를 본 뒤 규칙을 좀 더 추가하기로 하였다. 추가된 규칙은 아래와 같다.</p>

<ul>
	<li>N개의 모든 징검다리에 순서대로 1 ~ N의 번호를 붙인다. U번 징검다리에서 V번 징검다리로 점프하기 위해서는, U와 V의 차이가 미리 정해진 값 D 이하여야 한다.</li>
	<li>어떤 징검다리도 두 번 이상(한 번을 넘게) 밟을 수는 없다.</li>
</ul>

<p>이제 다시 게임을 진행하려 한다. 이 게임에서 준호는 최대 몇 점을 얻을 수 있을까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 징검다리의 수 N과 문제에서 설명한 D가 주어진다. (2 ≤ N ≤ 10<sup>5</sup>, 1 ≤ D ≤ N-1)</p>

<p>이어 N개의 정수로, 각 징검다리에 쓰인 수 K<sub>i</sub>가 1번 징검다리부터 N번 징검다리까지 순서대로 주어진다. (-10<sup>9</sup> ≤ K<sub>i</sub> ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가능한 최대 점수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 2
2 7 -5 -4 10 -5 -5 -5 30 -10
','40
','DATA_STRUCTURE'),
                                                                                                                (7470,'BAEKJOON','https://www.acmicpc.net/problem/15703',15703,'주사위 쌓기','2초(하단참고)','512 MB',12,'<p>아름이는 주사위 N개를 가지고 있다. 주사위는 정육면체 모양이고, 크기는 N개 모두 동일하다. 일반적인 주사위와 다르게, 여섯 개의 면에는 정수가 하나씩 쓰여 있다. 한 주사위에는 모두 같은 정수가 쓰여 있다.</p>

<p>주사위 탑이란 주사위를 위로 쌓은 모양을 의미한다. 주사위를 쌓을 때는 주사위의 변이&nbsp;일치하게 쌓아야 한다.&nbsp;주사위 N개를 쌓아서, 주사위 탑의 개수를 최소로 하려고 한다.</p>

<p>주사위에 쓰여 있는 수를 s라고 했을 때, 그 주사위의 위에는 최대 s개의 주사위를 올려놓을 수 있다.</p>

<p>예를 들어, 주사위가 총 4개 있고, 각 주사위에 쓰여 있는 수가 1, 2, 4, 5인 경우를 생각해보자. 주사위를 쌓은 결과가 위에서부터 2, 1, 4, 5인 경우는 가능하다. 2가 적힌 주사위 위에 0개, 1이 적힌 주사위 위에 1개, 4가 적힌 주사위 위에 2개, 5가 적힌 주사위 위에 3개가 있기 때문이다. 하지만, 4, 1, 5, 2의 순서로 쌓는 것은 불가능하다. 2가 적힌 주사위의 위에 주사위가 총 3개 있기 때문이다.</p>

<p>주사위의 개수 N과 각 주사위에 쓰여 있는 수가 주어졌을 때, 만들 수 있는 주사위 탑의 최소 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 주사위의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 주사위에 쓰여 있는 수가&nbsp;주어진다. 주사위에 쓰여 있는 수는 1,000보다 작거나 같은 양의 정수 또는 0이며,&nbsp;공백으로 구분되어져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 만들 수 있는 주사위 탑의 최소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>아래 설명에서 k개의 주사위가 쌓여져 있고, 위에서부터 적혀있는 정수가 s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>인 주사위 탑을 (s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>)로 표현했다.</p>

<p>예제 1의 경우에는 주사위 탑 1개를 만들 수 있다. (1, 2, 4, 5) 또는 (2, 1, 4, 5)와 같이 주사위 탑 1개를 만들 수 있으며, 다른 방법도 존재한다.</p>

<p>예제 2의 경우에는 2개보다 작은 주사위 탑을 만들 수 없다. (1, 2), (1, 2)로 2개를 만들 수 있다. (1, 1, 2), (2)와 같은 방법도 가능하다.</p>

<p>예제 3의 모든 주사위에 적혀있는 정수는&nbsp;0이다. 따라서, 한 주사위 위에 다른 주사위를 쌓을 수 없다. 따라서, 모든 주사위 탑은&nbsp;주사위 1개로 이루어져 있다.</p>

				</div>
				</div>','4
1 2 4 5
','1
','DATA_STRUCTURE'),
                                                                                                                (7456,'BAEKJOON','https://www.acmicpc.net/problem/15706',15706,'블록 게임','2초(하단참고)','512 MB',18,'<p>총 N개의 블록이 일렬로 놓여져 있다. 가장 왼쪽에 있는 블록의 번호는 1번이고, 그 오른쪽에 있는 블록은 2번이다. 이런식으로 가장 오른쪽에 있는 블록의 번호는 N번이다. i번 블록의 높이는 H<sub>i</sub>이다.</p>

<p>블록 게임을 하려면 블록의 앞에 작은 기계를 하나 놓아야 한다. 가장 처음에 이 기계는 1번 블록의 앞에 있다. 블록 게임의 목표는 기계를 이용해 블록을 <strong>모두</strong> 제거하는 것이다. 이때, 제거한 순서대로 블록의 높이를 나열한 수열은 비내림차순(non-descreasing order)을 만족해야 한다.</p>

<p>기계가 수행할 수 있는 명령은 다음과 같은 세 가지이다.</p>

<ul>
	<li>오른쪽 블록으로 이동한다. i번 블록 앞에 있었으면, i+1번 블록 앞으로 이동한다. 만약, 오른쪽에 블록이 없으면 이 명령을 내릴 수 없다.</li>
	<li>왼쪽 블록으로 이동한다. i번 블록 앞에 있었으면, i-1번 블록 앞으로 이동한다. 만약, 왼쪽에 블록이 없으면 이 명령을 내릴 수 없다.</li>
	<li>기계의 앞에 있는 블록을 제거하고, 왼쪽 또는 오른쪽 블록으로 이동한다. 제거한 후에 이동하는 방향도 정해서 이 명령을 내려야 한다. 블록을 모두 제거해 양쪽에 블록이 없는 경우에는 이동하지 않아도 된다.</li>
</ul>

<p>제거하는 명령을 내렸을 때, 블록의 번호가 변하게 된다. 예를 들어, 블록의 높이가 (2, 3, 4, 5, 6)이고, 기계가 현재 높이가 4인 블록 앞에 있는 경우가 있다. 높이가 4인 블록은 왼쪽에서부터 3번째에 있기 때문에, 3번이다. 이 블록을 제거하고 왼쪽으로 이동하면, 블록의 높이는 (2, 3, 5, 6)이 되고 블록은 높이가 3인 블록(2번 블록) 앞에 있게 된다. 만약, 오른쪽으로 이동하면, 블록의 높이는 (2, 3, 5, 6)이 되고 블록은 높이가 5인 블록(3번 블록) 앞에 있게 된다.</p>

<p>게임의 목표를 달성하기 위해 필요한 명령의 최소 횟수를 구하는 프로그램을 작성하시오.&nbsp;</p>

<p>길이가 K인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>K</sub>가&nbsp;A<sub>1</sub> ≤ A<sub>2</sub> ≤ ... ≤ A<sub>K</sub>를 만족하면,&nbsp;비내림차순(non-decreasing order)이라고 한다.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 블록의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄에는 블록의 높이 H<sub>i</sub>가 순서대로 주어진다. (1 ≤ H<sub>i</sub> ≤ 100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 게임의 목표를 달성하기 위해 필요한 명령의 최소 횟수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 1의 경우에는 기계에 명령을 다음과 같이 내리면 된다. 밑 줄이 쳐있는 블록의&nbsp;앞에 기계가 있다.</p>

<ul>
	<li>처음 상태: <u>1</u> 2 3</li>
	<li>블록을 제거하고, 오른쪽으로 이동: <u>2</u> 3</li>
	<li>블록을 제거하고, 오른쪽으로 이동: <u>3</u></li>
	<li>블록을 제거</li>
</ul>

<p>예제 2의 경우에는 다음과 같이 명령을 내려야 한다.</p>

<ul>
	<li>처음 상태:&nbsp;<u>4</u> 2 1 3</li>
	<li>오른쪽으로 이동: 4 <u>2</u> 1 3</li>
	<li>오른쪽으로 이동: 4 2 <u>1</u> 3</li>
	<li>블록을 제거하고 왼쪽으로 이동: 4 <u>2</u>&nbsp;3</li>
	<li>블록을 제거하고 오른쪽으로 이동: 4 <u>3</u></li>
	<li>블록을 제거하고 왼쪽으로 이동: <u>4</u></li>
	<li>블록을 제거</li>
</ul>

<p>&nbsp;</p>

				</div>
				</div>','3
1 2 3
','3
','DATA_STRUCTURE'),
                                                                                                                (7439,'BAEKJOON','https://www.acmicpc.net/problem/15708',15708,'미네크래프트','1초','128 MB',16,'<p>미네크래프트에 있는 디디는 집을 짓기 위해 돌을 채취하려고 한다. N개의 바위들이 일렬로 놓여져 있고, 디디는 현재 첫 번째 바위에 위치해 있다. 각 바위 i는 서로 같거나 다른 강도를 가지고 있어서, 바위에서 돌을 채취하기 위해 해야 하는 곡괭이질의 수 Ki 또한 서로 같거나 다르다. 디디는 돌을 채취하기 위해 다음과 같은 행동을 할 수 있다.</p>

<ol>
	<li>시간 1을 소비하여, 디디가 위치해 있는 바위에 곡괭이질을 1번 한다.</li>
	<li>시간 P를 소비하여, 이웃한 바위로 이동한다.</li>
</ol>

<p>디디에게 T만큼의 시간이 주어졌을 때, 채취할 수 있는 돌의 최대 개수를 출력하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 N(1 ≤ N ≤ 10<sup>5</sup>), T(1 ≤ T ≤ 10<sup>9</sup>), P(1 ≤ P ≤ 10<sup>5</sup>)가 공백으로 구분되어 주어진다.</p>

<p>둘째 줄에 바위 i(i = 1, 2, ..., N)를 채취하기 위해 필요한 곡괭이질의 수 K<sub>i</sub>(1 ≤ K<sub>i</sub> ≤ 10<sup>5</sup>)가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>문제의 정답을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 17 1
3 5 2 6 9 1
','4
','DATA_STRUCTURE'),
                                                                                                                (7474,'BAEKJOON','https://www.acmicpc.net/problem/15714',15714,'열려라 참깨','1초','256 MB',18,'<p>디디와 chogahui05는 우연히 주운 보물지도를 따라 목적지에 도착했다. 그런데 그 보물들은 퍼즐을 풀어야만 열리는 금고에 보관되어 있었다. 퍼즐의 내용은 다음과 같다.</p>

<p>가로 N, 세로 2<sup>31</sup> 크기의 격자로 이루어진 판이 있다.</p>

<p>N개의 세로줄에는, 매 줄마다 자갈과 그 자갈을 위치시켜야 하는 홈이 각각 하나씩 있다.</p>

<p>1초에 한번씩 연속된 세로줄에 있는 자갈 X개를 선택하여, 전부 위로 1칸 올리거나, 아래로 1칸 내릴 수 있다. 또한 홈에 위치한 자갈도 움직일 수 있다. 모든 자갈을 홈 안에 넣으면 퍼즐이 풀리며 금고의 문이 열리게 된다.</p>

<p>편의상 자갈과 홈의 크기는 1×1이며, 자갈이 홈의 딱 정중앙에 위치해야 한다. 또한 자갈이 격자판을 벗어나게 해선 안 된다.</p>

<p>디디는 chogahui05가 자리를 비운 사이 퍼즐을 최대한 빨리 풀어 보물을 가지고 도망치려고 한다. 디디가 이 퍼즐을 풀 수 있는 가장 빠른 시간(초)을 구하는 프로그램을 작성해야 한다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15714/1.png" style="width: 166px; height: 275px;"></p>

<p style="text-align: center;">위는 가로3 세로5 격자판의 예시이다. (●는 자갈, ?는 홈)</p>

<p>가장 최적의 정답 중 하나는 세로줄 기준으로 1~3번째 줄에 있는 돌을 전부 한 칸 올리고, 2번째 줄에 있는 돌을 연속으로 두 칸 내리는 것이다. 위 경우 3초가 소요된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. (1 ≤ N ≤&nbsp;1,000,000)</p>

<p>둘째 줄에 자갈의 위치(i, Y<sub>i</sub>)를 나타내는 정수 Y<sub>i</sub>가 공백으로 구분되어 주어진다. (i = 1, 2, ..., N, 0 ≤ Y<sub>i</sub> < 2<sup>31</sup>)</p>

<p>셋째 줄에 홈의 위치(i, Y<sub>i</sub>)를 나타내는 정수 Y<sub>i</sub>가 공백으로 구분되어 주어진다. (i = 1, 2, ..., N, 0 ≤ Y<sub>i</sub> < 2<sup>31</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>문제의 정답을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
4 6 4
5 5 5
','3
','DATA_STRUCTURE'),
                                                                                                                (7486,'BAEKJOON','https://www.acmicpc.net/problem/15789',15789,'CTP 왕국은 한솔 왕국을 이길 수 있을까?','1초','512 MB',12,'<p>CTP 왕국은 정말 깊은 역사를 가지고 있다. 선대 김진서 왕부터 시작하여 전현용 왕을 거쳐 … 마침내 김세진이 CTP 왕국의 왕이되었다. 세진이는 재미없는 개그를 정말 싫어했기 때문에 왕이 되자마자 CTP 왕국에서 가장 재미없는 이한솔을 쫓아냈다.&nbsp;</p>

<p>화가난 한솔이는 자기의 개그에 유일하게 웃어주던 박정률과 함께 한솔 왕국을 세웠다.</p>

<p>그 이후 33년이 지났다 ………….&nbsp;</p>

<p>어느새 한솔 왕국은 번창하여 CTP 왕국보다 힘이 쎄졌다. 세진이는 다른 왕국과 동맹을 맺어 CTP 왕국의 힘을 길러 한솔 왕국보다 부흥시키려고 한다.&nbsp; 왕국의 힘이란 동맹국의 수를 의미한다.&nbsp; (예를 들어 동맹이 없는 나라의 힘은 1이다)</p>

<p>왕국간의 동맹의 법칙은 조금 특별해서 만약에 A왕국과 B왕국이 동맹이고 B왕국과 C왕국이 동맹이라면 A왕국과 C왕국도 동맹이 된다.&nbsp;</p>

<p>CTP 왕국의 왕 세진이는 최대 K번 다른 왕국과 동맹을 맺을 기회를 갖으며, 현재 동맹관계는 CTP 왕국과 한솔 왕국은 동맹이 아니다. 또한 한솔 왕국과 동맹인 왕국과는 동맹을 맺을 수 없으며 K번의 동맹 맺을 기회를 모두 사용하지 않아도 된다.</p>

<p>각 왕국들의 동맹관계와 CTP 왕국의 번호, 한솔 왕국의 번호가 주어질 때 세진이를 도와 CTP 왕국의 힘의 최댓값을 구하여라. 각 왕국의 번호는 1부터 N까지의 자연수로 나타내어지며, 서로 다른 두 왕국이 같은 번호를 갖는 경우는 없다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫째 줄에 왕국의 수 N(3 ≤ N ≤ 100,000)과 동맹 관계의 수 M(1 ≤ M ≤ 200,000)이 주어진다. 이 후 M개의 줄에 X,Y가 주어진다. 이는 X 왕국과 Y 왕국이 동맹이라는 뜻이다.</p>

<p>입력의 마지막 줄에 CTP 왕국의 번호 C와 한솔 왕국의 번호 H와 추가 동맹의 기회 K(0 ≤ K ≤ 100)가 공백으로 구분되어 주어진다.&nbsp;</p>

<p>주어지는 입력에서 CTP 왕국과 한솔 왕국은 절대로 동맹이 되지 않게 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>CTP 왕국의 힘의 최댓값을 출력하라.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 7
1 2
1 3
2 3
1 4
5 6
8 10
7 9
5 9 1
','6
','DATA_STRUCTURE'),
                                                                                                                (7490,'BAEKJOON','https://www.acmicpc.net/problem/15809',15809,'전국시대','1초','128 MB',12,'<p>전국시대엔 N개의 국가가 존재한다. 각 국가는 1부터 N까지의 번호를 가지고 있다.</p>

<p>또한, 모든 국가는 각자 자신의 국가의 힘을 상징하는 병력을 가지고 있다. 이때 M개의 기록이 주어진다. 각각의 기록은 다음과 같다.</p>

<ol>
	<li>동맹 - 두 나라가 서로 동맹을 맺는다. 두 나라의 병력이 하나로 합쳐진다.</li>
	<li>전쟁 - 두 나라가 서로 전쟁을 벌인다. 병력이 더 많은 나라가 승리하며 패배한 나라는 속국이 된다. 이때 남은 병력은 승리한 나라의 병력에서 패배한 나라의 병력을 뺀 수치가 된다. 두 나라의 병력이 같을 경우 두 나라 모두 멸망한다.</li>
</ol>

<p>모든 나라는 정직하기 때문에 내 동맹의 동맹도 나의 동맹이고, 내 동맹이 적과 전쟁을 시작하면 같이 참전한다. 속국인 경우도 동맹의 경우와 마찬가지이다.</p>

<p>따라서, 전쟁에서 진 국가와 동맹인 다른 국가 또한 전쟁에서 이긴 국가의 속국이 된다.</p>

<p>모든 기록이 끝났을 때 남아있는 국가의 수를 출력하고, 그 국가들의 남은 병력의 수를 오름차순으로 출력하는 프로그램을 작성하시오.</p>

<p>단, 여러 국가가 서로 동맹이거나 속국 관계인 경우는 한 국가로 취급한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 국가의 수를 나타내는 N과 기록의 수 M이 주어진다. (1 ≤ N, M ≤ 100,000)</p>

<p>두 번째 줄 부터 N개의 줄에 걸쳐 i번째 국가의 병력 A<sub>i</sub> (1 ≤ i ≤ N)가 자연수로 주어진다. (1 ≤ A<sub>i</sub> ≤ 10,000)</p>

<p>다음 M개의 줄에는 기록이 3개의 정수 O, P, Q로 주어진다. O가 1인 경우 P, Q가 서로 동맹을 맺었음을 의미하고, O가 2인 경우 P, Q가 서로 전쟁을 벌였음을 의미한다.</p>

<p>동맹끼리 다시 동맹을 맺거나 전쟁하는 입력은 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 남아있는 국가의 수를 출력한다.</p>

<p>다음 줄에 각 국가의 남은 병력의 수를 띄어쓰기를 간격으로 오름차순으로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
10
20
30
40
50
1 1 2
1 3 4
2 1 3
','2
40 50
','DATA_STRUCTURE'),
                                                                                                                (7489,'BAEKJOON','https://www.acmicpc.net/problem/15815',15815,'천재 수학자 성필','1초','128 MB',8,'<p>평행 세계의 성필은 숫자와 연산자를 만든 당대 최고의 수학자이다. 그리고 놀랍게도 이 숫자와 연산자는 현재 우리가 사용하는 것과 같다. 하지만 수식은 연산자가 피연산자 가운데 위치하는 우리와는 다르게 연산자가 피연산자 뒤에 위치한다고 한다.</p>

<p>우리 세계의 식을 성필의 식으로 바꾸는 방법을 간단히 설명하자면 이렇다. 우선 주어진 식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.</p>

<p>예를 들어 a+b*c는 (a+(b*c))의 식과 같게 된다. 그다음에 안에 있는 괄호의 연산자 *를 괄호 밖으로 꺼내게 되면 a+bc*가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다.</p>

<p>천재 수학자 성필은 자신이 만든 이런 간단한 식조차 1초 안에 계산하지 못하는 사람들을 위하여 답을 구해주는 프로그램을 개발하려고 했지만 아쉽게도 성필의 세계에는 프로그래밍 언어가 없다. 프로그래밍을 할 수 있는 우리가 성필을 위해 평행세계의 식을 계산하는 프로그램을 만들어주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>길이가 100이 넘지 않는 수식이 예제 입력과 같이 공백 없이 입력된다. 수식은 0부터 9까지의 숫자와 연산자 +, -, *, / 로만 이루어져 있다.</p>

<p>또한, 수식의 계산 중간 과정의 모든 결과는 항상 2,147,483,647을 넘지 않는 정수이고 0으로 나누는 경우는 없습니다.</p>

<p>잘못된 수식이 입력되는 경우도 없습니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력으로 주어진 성필의 수식의 답을 첫째&nbsp;줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','123*+
','7
','DATA_STRUCTURE'),
                                                                                                                (7491,'BAEKJOON','https://www.acmicpc.net/problem/15816',15816,'퀘스트 중인 모험가','3초','256 MB',17,'<p>모험가 x|최강영훈|x 은 온라인 RPG 게임 월드 아트 위그드라실(WAY)에서 활동중인 랭커이다.</p>

<p>x|최강영훈|x 은 매일 WAY의 퀘스트를 달성하는것에 재미를 느끼고 있다.</p>

<p>WAY에는 -10억부터 10억까지의 모든 정수 번호에 대해 퀘스트가 하나씩 부여되어 있다. 또한 특정 범위의 퀘스트를 모두 달성하면 업적을 받을 수 있다.</p>

<p>x|최강영훈|x 은 퀘스트를 달성하는 김에 업적도 얻고 싶었다. 하지만 WAY에는 항상 퀘스트를 순서대로 달성할 수 없는 경우가 존재해서 업적마다 몇 개의 퀘스트를 더 달성해야하는지 매번 계산해야 하는 불편함이 존재했다.</p>

<p>이를 안타깝게 여긴 모험가 사투-는 특정 범위의 퀘스트 중 모험가가 달성하지 못한 퀘스트의 개수를 출력하는 애드온을 개발하기로 했다.</p>

<p>물론 언제나 그렇듯, 구현은 당신이 해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 지금까지 달성한 퀘스트의 개수 N이 주어진다. (1 ≤ N ≤ 1,000,000)</p>

<p>둘째 줄에 지금까지 달성한 퀘스트들의 번호 Q<sub>1</sub> ... Q<sub>N</sub> 까지의 N개의 수가 주어진다. (?1,000,000,000 ≤ Q[i] ≤ 1,000,000,000, Q[i] < Q[i+1])</p>

<p>셋째 줄에 애드온 요청의 개수 M이 주어진다. (1 ≤ M ≤ 1,000,000)</p>

<p>넷째 줄부터 M개의 줄에 걸쳐서 애드온에 요청할 명령이 주어진다.</p>

<ol>
	<li>1 X:&nbsp; 퀘스트 번호 X를 달성했다. 애드온에 이를 반영해야 한다. (?1,000,000,000 ≤ X ≤ 1,000,000,000)</li>
	<li>2 L R: 퀘스트 번호 L 이상 R 이하인 퀘스트 중, 모험가가 달성하지 못한 퀘스트의 개수를 출력한다. (?1,000,000,000 ≤ L ≤ R ≤ 1,000,000,000)</li>
</ol>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>애드온 기능2에 해당하는 출력을 요청당 한 줄씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 10 20
4
2 1 20
1 5
2 1 20
2 1 1
','17
16
0
','DATA_STRUCTURE'),
                                                                                                                (7493,'BAEKJOON','https://www.acmicpc.net/problem/15823',15823,'카드 팩 구매하기','1초','512 MB',14,'<p>주띵이는 오프라인 카드 게임 하프 스톤을 좋아하는 평범한 대학생이다. 주띵이가 자주 방문하는 게임용품 전문점인 카드 몬스터에서는 개점 3주년을 기념해 카드 팩 이벤트를 진행하고 있다. 이벤트에 참여한 사람은 사장이 만든 규칙을 만족하면 한 번에 많은 카드를 저렴하게 구매할 수 있다.</p>

<ol>
	<li>N개의 카드가 한 줄로 진열되어 있으며, 카드의 자리는 바꿀 수 없다.</li>
	<li>좌/우로 연속한 카드들을 묶어 하나의 카드 팩을 구성할 수 있다.</li>
	<li>주띵이는 정확히 M개의 카드 팩을 구매해야 한다.</li>
	<li>각 카드 팩을 구성하는 카드의 수는 일치해야 한다.</li>
	<li>한 카드 팩안에 같은 종류의 카드가 두 장 이상 존재해서는 안 된다.</li>
	<li>하나의 카드가 여러 카드팩에 속할 수 는 없다.</li>
</ol>

<p>예를 들어서 N=10이고 M=3인 경우를 가정해보자. 각 카드의 식별 번호가 차례로 10, 9, 7, 7, 9, 8, 8, 8, 2, 1 이라고 한다면, 아래와 같은 방법들로 구매할 수도 있다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15823/1.png" style="width: 388px; height: 52px;"></p>

<p style="text-align: center;">그림1. 카드 팩을 한 장으로 구성한 경우의 예시</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15823/2.png" style="width: 388px; height: 52px;"></p>

<p style="text-align: center;">그림 2. 카드 팩을 두 장으로 구성한 경우의 예시</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15823/3.png" style="width: 393px; height: 60px;"></p>

<p style="text-align: center;">그림 3. 구매할 수 없는 경우의 예시</p>

<p>개점 이벤트로 인해 각 카드 팩을 구성하는 카드 수에 상관없이 항상 가격이 일정하므로, 주띵이는 최대한 많은 카드를 카드 팩으로 구성하려고 한다. 하지만 한 번 카드 팩을 구성한 이후에 수정하는 것은 가게 주인이 좋아하지 않으므로, 미리 가장 이득이 되는 방법을 설계한 후 구성하려고 한다. 주띵이를 도와주자. 주띵이가 각 카드 팩에 구성할 수 있는 최대의 카드 수는 몇 장인가?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 두 개의 자연수 N과 M이 공백으로 구분되어 주어진다. N은 상점에 진열된 카드의 수이며 M은 주띵이가 구매해야 할 카드 팩의 수다. 이후 두 번째 줄에는 총 N개의 나열된 카드에 대한 자연수 식별 번호가 입력으로 주어진다. 가장 왼쪽에 나열된 카드부터 오른쪽에 나열된 카드까지 실제 위치와 같은 순서로 식별 번호가 주어지며, 각 식별 번호는 공백으로 구분되어 있다.</p>

<p>각 카드의 식별번호는 1 이상 50만 이하의 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>이벤트의 규칙을 모두 만족하면서 주띵이가 하나의 카드 팩에 구성할 수 있는 카드의 최대 수량을 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>3번 예제는 Small 에서는 나오지 않는다.</p>

				</div>
				</div>','10 1
5 2 5 3 4 1 3 1 2 1
','5
','DATA_STRUCTURE'),
                                                                                                                (7502,'BAEKJOON','https://www.acmicpc.net/problem/15899',15899,'트리와 색깔','2초(추가시간없음)','512 MB',19,'<p>1부터 N까지의 번호가 부여된 N개의 정점과 N-1개의 간선으로 구성된 트리가 있다. 이 트리의 루트는 1번 정점이며, 임의의 한 정점과 다른 정점 사이의 경로가 반드시 한 개 존재한다.</p>

<p>트리의 각 정점은 특정 색깔을 가지고 있다. 편의상 색깔은 1 이상 C 이하의 자연수로 표현된다. 이때, 질의 f(v,c)를 다음과 같이 정의하자.</p>

<p>f(v, c) : 정점 v가 루트인 부트리(sub-tree)에서 색깔이 c 이하인 정점의 개수</p>

<p>M개의 질의 f(v<sub>i</sub>, c<sub>i</sub>)가 주어질 때, 각 질의에 대한 답을 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정점의 수를 나타내는 N(1 ≤ N ≤ 2×10<sup>5</sup>), 질의의 개수를 나타내는 M(1 ≤ M ≤ 2×10<sup>5</sup>), 정점의 색깔 종류를 나타내는 C(1 ≤ C ≤ N)가 공백 하나를 사이에 두고 차례로 주어진다.</p>

<p>두 번째 줄에는 각 정점의 색깔을 나타내는 N개의 정수가 공백으로 구분되어 순서대로 주어진다. 첫 번째 수는 1번 정점의 색깔이며, ..., N 번째 수는 N번 정점의 색깔이다.</p>

<p>세 번째 줄부터 N-1개의 줄에 걸쳐서 트리를 이루는 각 간선의 정보가 주어진다. 각 간선의 정보는 해당 간선을 이루는 서로 다른 두 정점의 번호로 구성된다. 각 정점의 번호는 1 이상 N 이하의 자연수이다.</p>

<p>이후, 이어서 M개의 줄에 걸쳐서 i번째 줄에 i번째 질의의 정보&nbsp;v<sub>i</sub>, c<sub>i</sub>가 공백으로 구분되어&nbsp;주어진다.&nbsp;v<sub>i</sub>는 1 이상 N 이하의 정점 번호를 나타낸다. c<sub>i</sub>는 1 이상 C 이하의 색깔 정보를 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>M개의 질의에 대한 정답을 모두 더한 뒤, 1,000,000,007로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5 3
1 2 1 3 3
1 2
2 3
3 4
4 5
1 1
1 3
3 2
4 3
5 3','11','DATA_STRUCTURE'),
                                                                                                                (7505,'BAEKJOON','https://www.acmicpc.net/problem/15901',15901,'소각로','2초(추가시간없음)','512 MB',20,'<p>종영이는 여러 가지 쓰레기들을 소각하려고 한다. 쓰레기들은 그 안에서도 여러 종류가 있다. 그 종류는 총 K개가 있는데&nbsp;이를 순서대로 1, 2, ..., K의 자연수로 표현하자.</p>

<p>대기열에 순서대로 있는 총 N개의 쓰레기를&nbsp;순서대로 소각해야 하는데, 그 쓰레기의 종류를 순서대로 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub> 으로 나타낼 수 있다. 이후에 소각해야 하는 쓰레기들이 대기열 뒤에 더 추가될 수도 있다.</p>

<p>소각로는 M개의 칸이 일렬로 나열되어있는 구조이며 각 칸은 맨 왼쪽부터 오른쪽으로 1번부터 M번까지 번호가&nbsp;붙어있다. 맨 처음에는 대기열의 앞에서부터 순서대로 min(N, M)개의 쓰레기를 가져와 소각로의 1번 칸부터&nbsp;min(N, M)번 칸까지 순서대로&nbsp;놓아둔다. N < M 이면 오른쪽에 빈 칸들이 있을 수 있음에 유의하자.</p>

<p>소각 작업은 L번 칸부터 R번 칸까지(L ≤ R) 연속된 칸에 있는 쓰레기&nbsp;모두를 한 번에 태우는 식으로 이루어진다. 이렇게 한 번 태우고 나면 L번 칸부터 R번 칸까지는 비게 되는데, 그때 대기열의 앞에서부터 순서대로 쓰레기를 가져와 L번 칸부터 R번 칸까지 채운다. 쓰레기를 가져와 채우다가 더 이상 대기열 상에 쓰레기가 남지 않았으면 그 뒤로는 아무것도 놓지 않는다.</p>

<p>이러한 소각 시스템을 자동화하자. 다음과 같은 4가지 명령을 총 Q번 수행하는 코드를 작성하여라.</p>

<ul>
	<li>소각로 상의 [L, R] 구간에 소각 작업을 진행한다.</li>
	<li>i번째 소각로 칸에 놓여있는 쓰레기의 종류를 출력한다.</li>
	<li>p번 종류의 쓰레기&nbsp;q개를&nbsp;현재 대기열 뒤에 넣는다.</li>
	<li>재활용을 위해 현재 대기열 맨 앞의 쓰레기 t개를 제거한다.</li>
</ul>

<p>또한, 명령을 모두 수행한 뒤 마지막에는 현재 소각로의 상태를 출력해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 N, M, K, Q의 값들이 순서대로 입력된다. (1 ≤ N, M, K, Q ≤ 5×10<sup>5</sup>)</p>

<p>두 번째&nbsp;줄에 N개의 A<sub>i</sub> 값들이 주어진다. (1 ≤ A<sub>i</sub> ≤ K)</p>

<p>Q개 줄에 명령들이 주어진다. 명령의 의미를 나타내는 수 o가 먼저 주어진다. (1 ≤ o ≤ 4)</p>

<ul>
	<li>o=1 이면 첫 번째 명령을 뜻하며, L과 R이 주어진다. (1 ≤ L ≤ R ≤ M)</li>
	<li>o=2 이면 두 번째 명령을 뜻하며, i가 주어진다. (1 ≤ i ≤ M)</li>
	<li>o=3 이면 세 번째 명령을 뜻하며, p와 q가 주어진다. (1 ≤ p ≤ K, 1 ≤ q ≤ 10<sup>6</sup>)</li>
	<li>o=4 이면 네 번째 명령을 뜻하며, t가 주어진다. (1 ≤ t ≤ 현재 대기열 상 쓰레기의 개수)</li>
</ul>

<p>두 번째 명령은 한 번 이상 주어짐이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 모든 두 번째 명령에 대한 출력값을 공백으로 구분해 출력한다. 두 번째 줄에 모든 명령을 수행한 후 소각로 상에 남은 쓰레기들의 종류를 왼쪽부터 순서대로 M개의 수로 구분해 출력한다. 소각로 칸이 비어있는 경우에는 그 칸을 나타내는 수로 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 3 100 7
1 2 3 4 5 7 7 8 9 10
1 1 3
4 4
3 100 1000000
4 999999
2 2
1 1 3
2 2','5 0
100 0 0','DATA_STRUCTURE'),
                                                                                                                (7507,'BAEKJOON','https://www.acmicpc.net/problem/15903',15903,'카드 합체 놀이','1초(추가시간없음)','512 MB',10,'<p>석환이는 아기다. 아기 석환이는 자연수가 쓰여져있는 카드를 갖고 다양한 놀이를 하며 노는 것을 좋아한다. 오늘 아기 석환이는 무슨 놀이를 하고 있을까? 바로 카드 합체 놀이이다!</p>

<p>아기 석환이는 자연수가 쓰여진 카드를 n장 갖고 있다. 처음에 i번 카드엔 a<sub>i</sub>가 쓰여있다. 카드 합체 놀이는 이&nbsp;카드들을 합체하며 노는 놀이이다. 카드 합체는 다음과 같은 과정으로 이루어진다.</p>

<ol>
	<li>x번 카드와 y번 카드를 골라 그 두 장에 쓰여진 수를 더한 값을 계산한다. (x ≠ y)</li>
	<li>계산한 값을 x번 카드와 y번 카드 두 장 모두에 덮어 쓴다.</li>
</ol>

<p>이 카드 합체를 총 m번 하면 놀이가 끝난다. m번의 합체를 모두 끝낸 뒤, n장의 카드에 쓰여있는 수를 모두 더한 값이 이 놀이의 점수가 된다. 이 점수를 가장 작게 만드는 것이 놀이의 목표이다.</p>

<p>아기 석환이는 수학을 좋아하긴 하지만, 아직 아기이기 때문에 점수를 얼마나 작게 만들 수 있는지를 알 수는 없었다(어른 석환이는 당연히 쉽게 알 수 있다). 그래서 문제 해결 능력이 뛰어난 여러분에게 도움을 요청했다. 만들 수 있는 가장 작은 점수를 계산하는 프로그램을 만들어보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 카드의 개수를 나타내는 수 n(2 ≤ n ≤ 1,000)과 카드 합체를 몇 번 하는지를 나타내는 수 m(0 ≤ m ≤ 15×n)이 주어진다.</p>

<p>두 번째 줄에 맨 처음 카드의 상태를 나타내는 n개의 자연수 a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub>이 공백으로 구분되어 주어진다. (1 ≤ a<sub>i</sub> ≤ 1,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 만들 수 있는 가장 작은 점수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 1
3 2 6
','16
','DATA_STRUCTURE'),
                                                                                                                (7508,'BAEKJOON','https://www.acmicpc.net/problem/15926',15926,'현욱은 괄호왕이야!!','2초','512 MB',13,'<p>여는 괄호 ‘(’와 닫는 괄호 ‘)’로 구성된 문자열에서 아래의 조건을 만족하는 문자열을 올바른 괄호 문자열이라고 부른다.</p>

<ol>
	<li>() 는 올바른 괄호 문자열이다</li>
	<li>어떤 문자열 x가 올바른 괄호 문자열이라면, (x)도 올바른 괄호 문자열이다.</li>
	<li>어떤 문자열 x와 y가 올바른 괄호 문자열이라면, xy도 올바른 괄호 문자열이다.</li>
</ol>

<p>현욱은 친구로부터 생일 선물로 굉장히 긴 괄호 문자열을 받았다(도대체 왜 이런 걸 선물하는걸까?). 하지만 현욱은 올바른 괄호 문자열이 아니면 굉장히 싫어하기 때문에, 받은 괄호 문자열에서 연속한 일부분을 잘라서 올바른 괄호 문자열을 만들려고 한다. 그리고 이왕이면 긴 문자열이 좋으니 현욱은 부분 구간을 최대한 길게 잘라내려고 한다. 현욱을 도와 주어진 괄호 문자열에서 위의 조건을 만족하는 가장 긴 부분 문자열의 길이를 계산하는 프로그램을 작성해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 문자열의 길이 n (1 ≤ n ≤ 200,000)이 주어진다.</p>

<p>둘째 줄에 괄호로만 구성된 길이 n짜리 문자열이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>주어진 문자열에서 길이가 가장 길면서 올바른 괄호 문자열인 부분 문자열의 길이를 출력한다. 올바른 괄호 문자열인 부분 문자열을 찾을 수 없는 경우 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 입출력에서, 맨 처음 위치부터 4개를 잘라낸 (())가 가장 긴 올바른 괄호 문자열이다.</p>

<p>두 번째 입출력에서, 6번째 위치부터 8개를 잘라낸 ()((()))가 가장 긴 올바른 괄호 문자열이다.</p>

				</div>
				</div>','5
(())(
','4
','DATA_STRUCTURE'),
                                                                                                                (7506,'BAEKJOON','https://www.acmicpc.net/problem/15946',15946,'피아의 아틀리에 ~신비한 생명의 연금술사~','2초(추가시간없음)','512 MB',24,'<p>피아는 “새로운 생명을 창조하는 연금술"에 대해 연구하는 유명한 연금술사이다. 피아는 이 연금술로 수많은 생명을 창조하여 인류의 발전에 기여하고 있다. 하지만 피아는 빛의 속도로 달린다는 전설속의 동물 “달토끼"만큼은 만들 수 없었다.</p>

<p>연금술은 미생물이 서식하고 있는 가마를 이용해 이루어진다. 이 미생물들은 특정한 규칙을 만족해야만 “신비한 생명의 힘”이 발현되어 새로운 생명을 창조할 수 있다(만족하지 않는다면 가마의 뜨거운 온도 때문에 미생물의 기분이 나빠져 연금술을 할 수 없다). 그 규칙은 다음과 같다.</p>

<ul>
	<li>가마는 가로, 세로 모두 n칸인 격자 모양이다.</li>
	<li>가마의 각 칸은 미생물 서식지이거나, 미생물 서식지가 아니다.</li>
	<li>(i, j), (i+1, j), (i, j+1), (i+1, j+1) 4개의 칸에 있는 미생물 서식지 수의 총합을 2로 나눈 나머지는 c<sub>i,j</sub>와 같아야 한다. (1 ≤ i, j ≤ n-1; 0 ≤ c<sub>i,j</sub> ≤ 1)</li>
</ul>

<p>특별한 생명을 창조하기 위해서는 특별한 조건을 만족해야 하며, 이를 “레시피"라고 한다. 레시피를 만족하지 않는다면 좀비같은 괴생명체가 만들어질 수 있기 때문에 매우 조심해야 한다. 피아가 만든 “달토끼 레시피"는 아래와 같은 m개의 조건을 만족해야 한다.</p>

<ul>
	<li>달토끼 레시피의 i번째 조건은 다음과 같다: "s<sub>i</sub>일부터 e<sub>i</sub>일까지 가마의 (x<sub>i</sub>, y<sub>i</sub>)칸은, 항상 서식지이거나, 항상 서식지가 아니어야 한다." (1 ≤ i ≤ m)</li>
</ul>

<p>피아는 자신이 만든 레시피대로 연금술을 시도했지만, 특정 시간에는 위의 조건을 모두 만족하는 서식지 배치가 존재하지 않아 실패하고 말았다. 피아는 레시피를 수정하기 전에 여러분에게 다음과 같은 내용을 의뢰했다: “연금술이 이루어지는 T일 각각에 대해, 달토끼 레시피를 포함한 모든 조건을 만족하는 미생물 서식지가 존재하는지 여부를 알려주세요.”</p>

<p>피아의 달토끼 레시피가 성공적으로 완성될 수 있도록 피아를 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 가마의 크기 n과 조건의 수 m, 일 수 T가 주어진다. (2 ≤ n ≤ 3,000, 1 ≤ m ≤ 10<sup>5</sup>, 1 ≤ T ≤ 10<sup>5</sup>)</p>

<p>두 번째 줄부터 n-1개의 줄에 n-1개의 정수 c<sub>i,j</sub>가 공백 없이 주어진다. (0 ≤ c<sub>i,j</sub> ≤ 1)</p>

<p>n번째 줄부터 m개의 줄에 걸쳐 조건의 정보가 5개의 수 s<sub>i</sub>, e<sub>i</sub>, x<sub>i</sub>, y<sub>i</sub>, p<sub>i</sub> 로 주어진다(1 ≤ s<sub>i</sub> ≤ e<sub>i</sub> ≤ T; 1 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ n; 0 ≤ p<sub>i</sub> ≤ 1). 이는 x<sub>i</sub>번째 행 y<sub>i</sub>번째 열에 위치한 칸이, s<sub>i</sub>일부터 e<sub>i</sub>일까지, p<sub>i</sub>가 0인 경우 미생물 서식지가 될 수 없는 경우를, p<sub>i</sub>가 1인 경우 미생물 서식지가 되어야 하는 경우를 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 T개의 글자를 출력한다. k번째 글자로 k번째 날에 미생물이 열기를 이겨낼 수 있는 배치가 존재한다면 1, 아니면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5 9
01
10
1 5 1 1 1
2 6 1 3 0
3 7 2 2 1
4 8 3 1 0
5 9 3 3 0
','111101111
','DATA_STRUCTURE'),
                                                                                                                (7516,'BAEKJOON','https://www.acmicpc.net/problem/15955',15955,'부스터','8초(추가시간없음)','512 MB',19,'<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/c2bada33-0a9b-4fe1-b28b-c6bb2ca7f25f/-/preview/" style="width: 347.5px; height: 290px;"></p>

<p>최근 새로 출시되어 인기를 끌고 있는 카카오게임이 있다. 이 게임에서는 2차원 좌표 평면상에 <em>N</em>개의 체크포인트가 존재하며, 플레이어는 체크포인트를 오가면서 원하는 곳에 도달해야 하는 목표를 가진다.</p>

<p>플레이어가 조종하는 캐릭터는 최대 HP 제한 <em>X</em>를 가지며, 또한 부스터를 장착하고 있다. 이 캐릭터는 다음과 같은 두 가지 방법으로 이동할 수 있다.</p>

<ul>
	<li>걷기: 단순한 걷기 동작이다. 원하는 방향으로 걸어갈 수 있다. <em>d</em>만큼의 거리를 걸어갔을 때, 캐릭터의 HP는 <em>d</em>만큼 감소한다. HP가 0 미만이 될 경우 캐릭터는 죽게 된다.</li>
	<li>부스터 사용: 플레이어는 동 / 서 / 남 / 북 4가지 방향으로 부스터를 사용할 수 있다. (동: <em>x</em>좌표 증가, 서: <em>x</em>좌표 감소, 남: <em>y</em>좌표 감소, 북: <em>y</em>좌표 증가) 부스터를 활성화하면, 캐릭터는 HP를 소모하지 않고 원하는 방향으로 날아가게 된다. 이후 플레이어가 원하는 위치에서 부스터를 종료하면, 움직임이 멈추고 캐릭터가 그 자리에 서게 된다.</li>
</ul>

<p>부스터는 "방전"과 "충전"의 두 가지 상태를 가지며, 충전 상태에만 사용될 수 있다. 부스터를 종료하면, 부스터는 이동 거리에 상관없이 방전된다.</p>

<p>초기에, 플레이어의 HP는 <em>X</em>이며, 플레이어의 부스터는 방전되어 있다. 각각의 체크포인트에서 플레이어는 HP를 최대 한번 재충전할 수 있으며 (즉, 최대 HP인 <em>X</em>로 바꿀 수 있으며), 방전된 부스터를 최대 한번 재충전할 수 있다.</p>

<p>동현이는 이 게임의 개발자이며, 현재 게임의 세부 사항을 조정하고 있다. 다양한 스테이지의 개발을 위해서, 동현이는&nbsp;다음과 같은 질의를 빠르게 처리해야 한다.</p>

<ul>
	<li>플레이어의 최대 HP 제한이 X일 때, 체크포인트 A에서 시작하여서 체크포인트 B로 이동할 수 있는 방법이 있는가?</li>
</ul>

<p>동현이를&nbsp;도와, 각각의 질의를 처리하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 체크포인트의 수 <em>N</em>, 질의의 수 <em>Q</em>가 주어진다. (1 ≤ <em>N</em>, <em>Q</em>&nbsp;≤ 250,000)</p>

<p>이후 <em>N</em>개의 줄에 체크포인트의 좌표를 나타내는 두 정수 <em>X<sub>i</sub></em>, <em>Y<sub>i</sub></em>가 주어진다. (<em>X<sub>i</sub></em>, <em>Y<sub>i</sub></em>) 위치에 <em>i</em>번 체크포인트가 있음을 뜻한다. 모든 체크포인트의 위치는 서로 다르다. (-10<sup>9</sup> ≤ <em>X<sub>i</sub></em>, <em>Y<sub>i</sub></em> ≤ 10<sup>9</sup>)</p>

<p>이후 <em>Q</em>개의 줄에 각각의 질의를 나타내는 세 정수 <em>A<sub>i</sub></em>, <em>B<sub>i</sub></em>, <em>X<sub>i</sub></em>가 주어진다. <em>A<sub>i</sub></em>번 체크포인트에서 <em>B<sub>i</sub></em>번 체크포인트로 최대 HP 제한 <em>X<sub>i</sub></em>&nbsp;상태에서 움직일 수 있는지를 묻는 질의이다. (1 ≤ <em>A<sub>i</sub></em>, <em>B<sub>i</sub></em> ≤ <em>N</em>, 0 ≤ <em>X<sub>i</sub></em> ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em>개의 줄에 각각의 질의의 결과를 <code>YES</code> 또는 <code>NO</code>로 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
1 2
3 2
4 4
6 2
3 9
1 5 0
3 4 0
3 4 2','YES
NO
YES','DATA_STRUCTURE'),
                                                                                                                (7522,'BAEKJOON','https://www.acmicpc.net/problem/15957',15957,'음악 추천','2초(추가시간없음)','512 MB',22,'<p>멜론은 국내 최다 고객과 음원을 보유한 디지털 뮤직 플랫폼이다. 멜론의 특징 중 하나는 사용자 개인별 맞춤 큐레이션 서비스로, 사용자의 취향 및 콘텐츠의 특성을 분석하여 좋아할 만한 음악을 추천함으로써 사용자가 계속해서&nbsp;쓸 수 있는 서비스를 만드는 것이다. 사용자가 만족할 만한 서비스를 제공하기 위해서는 추천 알고리즘의 성능을 우수하게 유지하는 것이 중요하기 때문에, 사용자의 피드백에 따라 추천 알고리즘을 개선하거나, 좋은 성능을 보일 수 있는 새로운 추천 알고리즘을 고안하는 과정이 필요하다.</p>

<p>프로도는 사용자가 좋아할 만한 음악을 추천하기 위한 새로운 추천 알고리즘을 고안했다. 이 알고리즘은 음악 간 유사도를 트리의 형태로 만든 뒤 사용자의 입력에 따라 추천할 음악을 결정하는 방식이다. 예를 들어, 음악 간 유사도를 표현한 다음 트리를 살펴보자. 여기에서 각각의 노드가 곡을 나타내며, 노드의 색깔은 가수를 의미한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/25393cc3-1622-4ad8-a58a-ef05d12ee2a8/-/preview/" style="width: 347.5px; height: 290px;"></p>

<p>추천이 이루어지는 과정은 다음과 같다. 사용 패턴 분석을 통해 트리에 있는 노드 중 하나와 가중치가 결정되는데, 선택된 노드가 루트가 되는 서브트리의 모든 노드가 추천 대상이 된다. 이 서브트리에 속한 노드에 가중치에 따른 점수가 고르게 부여된다. 가중치가 노드의 수로 나누어떨어지지 않는 경우 몫만이 분배된다.&nbsp;예를 들어, 아래 그림에서처럼 노드가 하나 선택되고 여기에 가중치 23을 부여한다고 가정해보자. 이 서브트리에 속한 노드는 총 다섯 개이고, 23을&nbsp;5로 나누면 몫이&nbsp;4가 되고 나머지가 3이 되기 때문에 각각의 노드에 점수 4가 부여된다. 이 점수가 높을수록 추천에서 선택될 확률이 높아진다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/087e9adf-674d-4fc1-b41c-04316246bfaa/-/preview/" style="width: 347.5px; height: 290px;"></p>

<p>이때, 특정한 가수의 곡만 추천되는 상황을 방지하기 위해 가수 별로 평균 점수를 관리하려고 한다. 위 트리에서 빨간색 벽돌 무늬로 표시된 노드가 아이유의 곡이라고 가정하자. 위의 그림과 같이 서브트리가 선택된 상황의 경우, 빨간색 노드가 총 두 개이므로 노드 하나당 4점씩 부여되어 아이유의 곡의 점수의 합은 8이 된다. 트리에서 빨간색으로 표시된 노드가 총 세 개이므로, 아이유의 곡은 평균 8/3점이 된다.</p>

<p>위와 같이 트리의 노드와 가중치가 선택되는 과정이 반복된다고 할 때, 가수 별 평균 점수가 주어진 목표 점수를 언제 초과하게 되는지 계산하려고 한다. 트리의 형태와 추천 알고리즘의 결과 데이터가 입력으로 주어질 때, 노드 별로 가수의 평균 점수가 목표 점수를 초과하는 시점을 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫째 줄에는 세 정수로, 곡의 수 <em>N</em>(2 ≤ <em>N</em> ≤ 100,000), 추천 알고리즘의 결과 데이터의 수 <em>K</em>(1 ≤ <em>K</em> ≤ 100,000), 목표 점수 <em>J</em>(10 ≤ <em>J</em> ≤ 10<sup>8</sup>)가 주어진다. 각각의 곡은 1번부터 <em>N</em>번까지 번호가 붙어 있다. 다음 줄에 <em>N</em>-1개의 곡 번호가 주어지는데, 이는 2번 곡부터 해당 곡의 부모 노드가 되는 곡의 번호이다. 1번 곡은 부모 노드가 없다. 다음 줄에 <em>N</em>개의 수가 주어지는데, 이는 1번 곡부터 해당 곡을 부른 가수의 번호이다. 가수의 번호는 1 이상 <em>N</em> 이하의 자연수이다. 다음 <em>K</em>개의 줄에 추천 알고리즘의 결과 데이터가 하나씩 주어진다. 결과 데이터는 <em>T</em>, <em>P</em>, <em>S</em>의 세 값으로 주어진다. <em>T</em>는 데이터가 계산된 시간으로, 1 이상 10<sup>9</sup> 이하의 자연수이다. <em>P</em>는 점수가 부여되는 서브트리의 루트가 되는 곡의 번호이다. <em>S</em>는 서브트리에 부여할 가중치로, 1 이상 10<sup>9</sup> 이하의 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 <em>N</em>개의 줄로 이루어진다. 1번 곡부터 해당 곡을 부른 가수의 평균 점수가 <em>J</em>를 넘게 되는 시간을 출력한다. 점수가 <em>J</em>를 넘는 일이 없는 경우 -1을 출력한다. 같은 가수가 부른 곡은 같은 값을 가지게 될 것이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3 52
1 1
1 1 3
1 1 90
2 2 100
3 1 30','2
2
-1','DATA_STRUCTURE'),
                                                                                                                (7514,'BAEKJOON','https://www.acmicpc.net/problem/15967',15967,'에바쿰','1.5초(추가시간없음)','256 MB',17,'<p>재성이는 현실 세계에서 짱 쎈 친구이다! 너무 쎄서 학교의 학생 모두가 그를 보면 오금이 지릴 정도였는데, 그가 쎄지게 된 계기는 다음과 같다.</p>

<p>원래 재성이는 마법에 천부적인 재능이 있어서 순간적으로 공기의 압력을 증가시키는 에어 프레셔와 바쿰프레스라는 공격기술을, 그리고 이전으로 돌아갈 수 있는 타임머신 기술을 사용할 수 있는 마력을 가지고 있었다. 하지만 그걸 모르고 재혁이한테 뚜까맞던 재성이는 어느 순간 너무 화나서 각성을 했다.</p>

<p>각성 후에, 이때까지 쌓인 한을 풀기 위해 재성이는 재혁이를 i일엔 ai의 충격을 주면서 때렸다. 언제는 한번 변덕이 돋아서 j일부터 m일까지로 돌아가서 각각 l의 충격을 더해서 때리곤 했는데, 타임머신 기술을 활용하는 건 매우 힘든 일이므로 충격이 음수가 되면서 자기가 도리어 역으로 퍼맞을 수도 있다.</p>

<p>재혁이는 계속 뚜까맞다보니 자신이 n일부터 m일까지 얼마나 퍼맞았는지 궁금했다.</p>

<p>처절한 재혁이를 위해 재성이가 n일부터 m일까지 얼마나 때렸는지를 알려주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>재성이가 재혁이를 때린 날수 N과 재성이가 변덕을 부린 날의 개수 Q1, 재혁이가 얼마나 맞았는지 궁금한 구간의 개수 Q2가 주어진다. (1 ≤ N ≤ 1,000,000, 0 ≤ Q1, Q2 ≤ 10,000)</p>

<p>그 다음줄엔 재혁이가 i번째 날에 맞았던 충격&nbsp;a<sub>i</sub>가 주어진다.(1 ≤ a<sub>i</sub> ≤ 1,500,000)</p>

<p>그 다음 Q1+Q2 줄에는 다음과 같은 쿼리가 주어진다.</p>

<ol>
	<li>1 n m : 재혁이가 n일부터 m일까지 맞은 양을 출력한다. 이 1번 쿼리는 Q2개 주어진다.(1 ≤ n, m ≤ N)</li>
	<li>2 s e l&nbsp;: 재성이가 s일에서 e일까지로 돌아가서 l의 충격을&nbsp;더해서 때릴 수 있다. 이 2번 쿼리는 Q1개 주어진다.(-1,000 ≤ l ≤ 1,000, 1 ≤ s, e ≤ N)</li>
</ol>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1번 쿼리에 대한 답을 Q2줄에 걸쳐 차례대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 0 2
1 2 3
1 1 2
1 1 3
','3
6
','DATA_STRUCTURE'),
                                                                                                                (7523,'BAEKJOON','https://www.acmicpc.net/problem/15977',15977,'조화로운 행렬','5초','768 MB',22,'<p>서로 다른 양의 정수로 구성된 2×<em>N</em> 또는 3×<em>N</em>&nbsp;행렬(이차원 배열)을 고려 하자. 어떤 행렬 <em>Q</em>가 주어졌을 때, 1개 이상의 열을 선택하여 순서대로 붙여 만든 행렬을 <em>Q</em>의 열-부분행렬이라 한다. (<em>Q</em>도 자신의 열-부분행렬이다.)</p>

<p>예를 들어, 행렬 <em>Q</em>가 다음과 같이 주어졌을 때,</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/e9d26371-63c3-4ebf-bd18-f3d76de06948/-/preview/" style="width: 296px; height: 98px;"></p>

<p>다음 행렬 <em>X</em>는 <em>Q</em>에서 2열, 3열, 5열, 6열, 8열을 선택하여 만든 열-부분행렬 이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/fd94564e-52d0-4dc4-b614-4206c7031f39/-/preview/" style="width: 182px; height: 78px;"></p>

<p>행렬 <em>X</em>의 <strong>등수행렬</strong>&nbsp;<em>R<sub>X</sub></em>를 다음과 같이 정의하자. 행렬 <em>R<sub>X</sub></em>의 <em>i</em>행 <em>j</em>열 원소 <em>R<sub>X</sub></em>[<em>i</em>,&nbsp;<em>j</em>]는 행렬 <em>X</em>의 <em>i</em>행 <em>j</em>열의 원소 <em>X</em>[<em>i</em>, <em>j</em>]가 <em>X</em>의 <em>i</em>번째 행에서 몇 등(가장 큰 수가 1등)인지 나타낸다. <em>X</em>의 등수 행렬 <em>R<sub>X</sub></em>는 다음과 같다. (원본 행렬 <em>Q</em>의 원소는 모두 다르므로, <em>R<sub>X</sub></em>의 각 행에서 같은 등수는 존재하지 않는다.)</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/6d780baa-9c74-403d-98aa-57e7fd901e89/-/preview/" style="width: 183px; height: 75px;"></p>

<p><em>X</em>[1,1]에 저장된 74는 <em>X</em>의 1행 원소들 74, 41, 89, 52, 63 중에서 두 번째로 크므로 <em>R<sub>X</sub></em>[1, 1]에 2가 저장된다. 다른 원소 값도 비슷하게 계산된다.</p>

<p>어떤 열-부분행렬의 등수행렬에서 모든 행이 일치하면, 그 열-부분행렬을 <strong>조화로운</strong> 행렬이라고 한다. <em>R<sub>X</sub></em>의 경우, 1행과 3행은 일치하나, 2행은 다른 행과 일치하지 않으므로 조화로운 행렬이 아니다.</p>

<p>다음은 행렬 <em>Q</em>에서 2열, 3열, 6열, 8열을 선택하여 만든 열-부분행렬 <em>Y</em>와 이의 등수행렬 <em>R<sub>Y</sub></em>이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/70b6236b-deb5-4c11-bc82-8ca402ac4e6b/-/preview/" style="width: 299px; height: 77px;"></p>

<p>등수행렬 <em>R<sub>Y</sub></em>의 모든 행이 일치하므로 열-부분행렬 <em>Y</em>는 조화로운 행렬이다. 행렬 <em>Q</em>의 조화로운 열-부분행렬 중 가장 큰 행렬의 크기는 3×4이다.</p>

<p>2×<em>N</em> 또는 3×<em>N</em>&nbsp;행렬 <em>Q</em>가 주어졌을 때, <em>Q</em>의 조화로운 열-부분행렬 중 가장 큰 행렬의 열 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 행의 개수 <em>M</em>과 열의 개수 <em>N</em>이 첫 줄에 입력된다. 다음 <em>M</em>개의 줄에 각 행의 정보가 한 줄에 하나씩 입력된다. 한 줄에는 한 행의 원소를 나타내는 <em>N</em>개의 양의 정수가 열&nbsp;순서대로 공백을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>조화로운 열-부분행렬 중 가장 큰 행렬의 열 개수를 나타내는 정수를 표준 출력으로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 9
10 74 41 15 89 52 16 63 75
30 53 22 33 46 45 25 47 21
29 49 13 26 59 17 62 34 19
','4
','DATA_STRUCTURE'),
                                                                                                                (7526,'BAEKJOON','https://www.acmicpc.net/problem/15978',15978,'족보','2초','512 MB',24,'<p>김 박사는 고대 아마존 왕국 유적지를 탐험하다가 여왕 족보 두 개를 발견하 였다. 각 족보에는 최초의 여왕 1명과그 여왕의 여자 후손들 간의 부모-자식 관계가 아래와 같이 나무 형태로 기록 되어 있다. 예를 들면, 그림 1에서 C는 최초의 여왕이며 F와 D는 C의 자식이 다. 한 사람의 자식들 사이에는 순서를 구별하지 않는다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/325a7483-5796-4b50-b51b-ae995f94377c/-/preview/" style="width: 286px; height: 191px;"></p>

<p style="text-align: center;"><strong>그림 1</strong></p>

<p>두 족보가 발견되었을 때 다음과 같이 정의되는 단위훼손이 0번 이상 발생했다는 것을 알았다.</p>

<p>단위훼손: 부모 P와 P의 자식 Q가 한사람으로 합쳐진다. 두 사람의 모든 자식들(Q 제외)은 합쳐진 한 사람의 자식이 된다.</p>

<p>예를 들면, 다음 그림 2에서 A와 F가 합쳐지는 단위훼손이 일어나면 그림 3과 같이 변화된다. 또한, 그림 3에서 추가적으로 B와 D가 합쳐지는 단위훼손 (그림 4)이 일어나면 그림 5와 같이 변화된다.</p>

<div class="table-responsive">
<table class="table table table-bordered" style="width: 100%;">
	<tbody>
		<tr>
			<td style="width: 25%; text-align: center;"><img alt="" src="https://upload.acmicpc.net/a8b5ff08-f7c6-45b1-86ca-f758c25ee8e5/-/preview/" style="width: 286px; height: 189px;"></td>
			<td style="width: 25%; text-align: center;"><br>
			<img alt="" src="https://upload.acmicpc.net/017e007a-eed9-46a0-aa60-459f21a06792/-/preview/" style="width: 293px; height: 195px;"></td>
			<td style="width: 25%; text-align: center;"><img alt="" src="https://upload.acmicpc.net/a62827d3-92c7-4aaa-8b42-4d8bc719eb10/-/preview/" style="width: 293px; height: 189px;"></td>
			<td style="width: 25%; text-align: center;"><br>
			<img alt="" src="https://upload.acmicpc.net/38eb5ac8-eae7-4907-830a-4ccdfb3313df/-/preview/" style="width: 285px; height: 184px;"></td>
		</tr>
	</tbody>
	<tfoot>
		<tr>
			<th style="width: 25%; text-align: center;">그림 2</th>
			<th style="width: 25%; text-align: center;">그림 3</th>
			<th style="width: 25%; text-align: center;">그림 4</th>
			<th style="width: 25%; text-align: center;">그림 5</th>
		</tr>
	</tfoot>
</table>
</div>

<p>그림 5에서 E와 G가 합쳐지는 단위훼손(그림 6)이 일어나면 그림 7과 같이 된다.</p>

<div class="table-responsive">
<table class="table table table-bordered" style="width: 100%;">
	<tbody>
		<tr>
			<td style="width: 50%; text-align: center;"><img alt="" src="https://upload.acmicpc.net/18562872-9749-4c02-a34b-b87ccc83600d/-/preview/" style="width: 291px; height: 188px;"></td>
			<td style="width: 50%; text-align: center;"><br>
			<img alt="" src="https://upload.acmicpc.net/999ba21c-0267-4566-a551-99d7200dba52/-/preview/" style="width: 296px; height: 191px;"></td>
		</tr>
	</tbody>
	<tfoot>
		<tr>
			<th style="width: 50%; text-align: center;">그림 6</th>
			<th style="width: 50%; text-align: center;">그림 7</th>
		</tr>
	</tfoot>
</table>
</div>

<p>다행히도 족보에서 자식이 없는 사람 (그림에서 숫자 이름에 해당)이 포함된 단위훼손은 발생하지 않았다. 또한, 자식이 없는 사람들은 모두 이름이 족보에 적혀있었고 이름은 서로 다르다. 하지만 자식이 있는 사람들(그림에서 알파벳 이름에 해당)은 이름이 하나도 남아 있지 않다. 따라서 발견된 족보의 형태는 그림 8과 같다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/4b4ff52b-95c2-4fb9-be4c-714fc7bfebe7/-/preview/" style="width: 288px; height: 198px;"></p>

<p style="text-align: center;"><strong>그림 8</strong></p>

<p>동일한 원본에서 단위 훼손이 일어나는 방법에 따라 여러 가지 결과가 나올 수 있다는 것을 짐작할 수 있다. 하지만, 그림 9의 두 족보는 동일한 원본에서 만들 수 없는 예이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/099a890d-ae9f-4a89-a7a0-0819559cba22/-/preview/" style="width: 295px; height: 117px;"><br>
<strong>그림 9</strong></p>

<p>입력으로 주어진 두 족보가 같은 원본 에서 0번 이상의 단위훼손을 통해 만들어질 수 있는지를 판단하는 프로그램을 작성하라. 입력으로 주어진 두 족보 S와 T에서 자식이 없는 사람들의 이름의 집합이 동일하다. 즉, 족보 S에서 자식이 없는 사람들의 이름으로 집합을 만들고 족보 T에서 자식이 없는 사람들의 이름으로 집합을 만들면 두 집합은 동일하다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 첫 번째 족보의 사람 수 <em>N</em><sub>1</sub>, 두 번째 족보의 사람 수 <em>N</em><sub>2</sub>,&nbsp;각 족보에서 자식이 없는 사람들의 수 <em>K</em>가 주어진다. 첫 번째 족보의 사람 들은 1부터 <em>N</em><sub>1</sub>까지 번호가 붙어 있고 두 번째 족보의 사람들은 1부터 <em>N</em><sub>2</sub>까지 번호가 붙어 있다. 두 족보 모두, 1번부터 <em>K</em>번까지의 사람들은 자식이 없다. 또한, 1번부터 <em>K</em>번까지의 사람들은 각각 같은 번호인 사람끼리 이름이 같다.</p>

<p>다음 줄에는 첫 번째 족보에서 각 사람의 부모의 번호가 사람의 번호 순서대로 주어진다. 부모가 없는 경우는 0이 주어진다. 다음 줄에는 두 번째 족보에서 각 사람의 부모의 번호가 사람의 번호 순서대로 주어진다. 부모가 없는 경우는 0이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로, 두 족보가 같은 원본에서 만들어질 수 있는 것들인 경우 YES를, 그것이 불가능한 경우 NO를 영어 대문자로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3 2
3 3 0
3 3 0
','YES
','DATA_STRUCTURE'),
                                                                                                                (7517,'BAEKJOON','https://www.acmicpc.net/problem/15982',15982,'국제 소 줄서기 사진 콘테스트','2초','512 MB',18,'<p>현욱은 보물 상자 속에서 국제 소 줄서기 사진 콘테스트의 본선 초대권을 발견했다. 전 세계 낙농인이 주목하는 이 대회의 우승자는 첫 대회부터 한 번도 거르지 않고 무려 20년 연속으로 USACO Farm의 존이라는 농부가 차지했는데, 한국인 최초로 우승자가 되고 싶은 현욱은 이참에 키우고 있는 소들로 멋진 사진을 찍어 참가해보기로 했다.</p>

<p>이 대회의 심사 기준은 정확히 알려져 있진 않지만, 소문에 의하면 사진에 찍힌 암소와 수소의 수가 반드시 같아야 하고, 사진에 찍힌 소의 수가 많을수록 높은 점수를 받는다고 한다. 현욱은 키우고 있는 소 중 몇 마리를 골라 심사 기준에 맞게 사진을 찍으려고 했지만, 그러면 사진에 찍히지 못한 소들이 실망하기 때문에 모든 소를 찍은 다음 적당히 사진의 좌우를 세로로 잘라서 대회에 응모하려고 한다.</p>

<p>현욱은 사진을 찍는 것만으로도 바빠서, 찍은 사진을 자르는 작업을 당신에게 부탁했다. 즉, 당신은 심사 기준에 맞춰 주어진 사진을 적당히 잘라 암소와 수소의 수가 동일하면서 소의 수가 최대한 많게 만들어야 한다.</p>

<p>소들이 계속 가만히 서 있다면 사진을 찍는 작업이 비교적 쉽겠지만, 소들은 참을성이 부족하기 때문에 줄을 선 채로 가만히 서 있지 않고 가끔씩 서로 인접한 소끼리 위치를 바꾼다. 하지만 동시에 여러 쌍의 소가 위치를 바꾸지는 않는다. 현욱은 소들이 서로 위치를 바꿀 때마다 새로운 사진을 찍는다.</p>

<p>현욱을 도와 처음 소들이 줄을 선 상태와 사진을 찍는 사이 소들이 어떻게 움직였는지 정보가 주어졌을 때, 각각의 사진에 대해 암소와 수소의 수가 동일하면서 소의 수가 가장 많은 연속한 부분 구간의 길이를 계산하는 프로그램을 작성해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 소의 숫자 <em>N</em>,&nbsp;찍은 사진의 숫자 <em>M</em>이 주어진다.</p>

<p>둘째 줄에 <em>N</em>개의 숫자가 주어진다. 각 수는 모두 <em>0</em> 또는 <em>1</em>이며, <em>0</em>은 암소, <em>1</em>은 수소를 뜻한다.</p>

<p>셋째 줄에 <em>M</em>개의 숫자 <em>P<sub>1</sub></em>,<em> P<sub>2</sub></em>, ..., <em>P<sub>m</sub></em>이 주어진다. 각각의<em> P<sub>i</sub></em> 값은 <em>P<sub>i</sub></em>번째 소와 <em>P<sub>i</sub></em> + 1 번째 소가 서로 위치를 바꿨다는 의미이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 처음 주어진 소의 상태에서 암소와 수소의 수가 같은 가장 긴 연속 부분 구간의 길이를 출력한다.</p>

<p>둘째 줄부터 <em>M</em>&nbsp;줄에 걸쳐, 각각 소들이 위치를 바꾸고 난 후 암소와 수소의 수가 같은 가장 긴 연속 부분 구간의 길이를 출력한다. 어떻게 구간을 잘라도 암소와 수소의 수를 같게 만들 수 없는 사진의 경우<em> 0</em>을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
0 1 1 1 0
4 3 2','2
4
4
4','DATA_STRUCTURE'),
                                                                                                                (7519,'BAEKJOON','https://www.acmicpc.net/problem/15986',15986,'마법 목걸이','2초','512 MB',21,'<p>현욱은 여행 중에 어느 유적지에서 유물을 훔쳐 왔는데, 그 때 훔친 유물들 중에는 마법 구슬을 꿰어서 만든 특별한 목걸이가 있었다. 이 목걸이를 이루고 있는 마법 구슬에는 각각 정수가 하나씩 적혀 있다.</p>

<p>&nbsp;마법 구슬은 구슬에 적힌 수가 뭐냐에 따라 구슬의 소유자에게 특별한 능력을 부여한다. 이때 적힌 수가 1인 경우 착용자의 머리를 좋게 만들어 주는데, 내일 당장 소프트콘 대회에 참가해야 하는 현욱은 대회에서 최대한 좋은 성적을 얻기 위해 자신이 가진 마법 목걸이의 구슬을 적절히 융합시켜서 모든 마법 구슬에 적힌 수가 1이면서, 구슬의 개수가 최대한 많게 만들려고 한다.</p>

<p>마법 목걸이는 끈으로 묶여 있을 때는 안정적인 상태라 구슬에 적힌 숫자에 변화를 줄 수 없다. 하지만 목걸이의 어느 한 부분을 끊어서 일자로 만들 경우 서로 인접한 마법 구슬들은 새로운 마법 구슬 하나로 융합시킬 수 있는데, 이때 새롭게 만들어진 마법 구슬에 적힌 정수는 융합에 사용된 마법 구슬들의 최대 공약수가 된다.</p>

<p>현욱은 목걸이를 어떻게 자르느냐에 따라 얻을 수 있는 1이 적힌 마법 구슬의 최대 개수가 어떻게 변화하는지가 궁금해졌다. 현욱을 도와 이를 구하는 프로그램을 작성해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 구슬의 개수 <em>N</em>이 주어진다.&nbsp;</p>

<p>둘째 줄에는 각각의 마법 구슬에 적힌 수 <em>a<sub>1</sub></em>, <em>a<sub>2</sub></em>, ... ,<em>a<sub>N</sub></em>(1 ≤<em>&nbsp;a<sub>i</sub></em>&nbsp;≤ 10<sup>18</sup>)이 공백을 사이에 두고 주어진다. <em>a<sub>1</sub></em>과 <em>a<sub>N</sub></em>은 서로 인접해 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>N</em>줄에 걸쳐, 주어진 목걸이를 각각의 위치에서 잘랐을 때 모든 마법 구슬에 적힌 수가 1이면서 그 개수가 가장 많게 했을 때 가능한 개수를 출력한다. 그런 경우를 만들 수 없다면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4 6 2 7 3','1
2
2
1
2
','DATA_STRUCTURE'),
                                                                                                                (7515,'BAEKJOON','https://www.acmicpc.net/problem/15987',15987,'팀 빌딩','1초','512 MB',19,'<p>소프트콘 대회에 참가한 현욱은 파죽지세로 8개의 문제를 풀고 마지막 한 문제만을 남겨두게 되었다. 하지만 이상하게 현욱은 이 문제가 잘 풀리질 않았고, 한참 고민하는 사이 다른 사람들이 서서히 현욱의 점수를 따라오기 시작했다. 빨리 대회 우승을 확정짓고 게임하러 가고 싶다는 조바심에 현욱은 결국 부정 행위를 마음 먹고 말았다.</p>

<p>그리고 현욱은 언제나 자신을 도와주는 좋은 친구인 당신에게 마지막 문제를 대신 풀어달라고 부탁했다. 현욱이 보내온 마지막 문제의 요약은 다음과 같다. 현욱을 도와 대신 문제를 풀어주자!</p>

<p>&nbsp;</p>

<p style="text-align: center;">*</p>

<p>&nbsp;</p>

<p>어떤 회사에 총 N명의 사람이 있다. 각 사원에게는 입사한 순서대로 1~<em>N</em>번까지 번호가 붙어있다. 이때 이 사원들을 적절하게 팀에 배치하기 위해 다음 세 가지 명령을 사용한다.</p>

<p>- <em>1&nbsp;X&nbsp;Y</em>&nbsp;: <em>X</em>가 속한 팀과 <em>Y</em>가 속한 팀을 한 팀으로 합친다. (<em>1</em> ≤ <em>X</em>, <em>Y</em> ≤ <em>N</em>)</p>

<p>- <em>2&nbsp;X&nbsp;K</em>&nbsp;: <em>X</em>가 속한 팀을 사원 번호를 <em>P</em>로 나눈 나머지가 <em>K</em>인 팀과 그렇지 않은 팀으로 나눈다. (<em>1</em> ≤ <em>X</em> ≤ <em>N</em>, <em>0</em> ≤ <em>K</em> < <em>P</em>)</p>

<p>- <em>3&nbsp;X</em>&nbsp;: <em>X</em>가 속한 팀의 총 인원수를 출력한다.(<em>1</em> ≤ <em>X</em> ≤ <em>N</em>)</p>

<p><em>Q</em>개의 명령이 주어졌을 때 주어진 명령의 수행 결과를 출력하는 프로그램을 작성해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 <em>N</em>,<em>P</em>,<em>Q</em>가 주어진다.</p>

<p>둘째 줄부터 <em>Q</em>줄에 걸쳐 명령이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 3번 명령에 대해 그 결과를 한 줄에 하나씩 명령이 주어진 순서대로 출력한다. 3번 명령은 반드시 한 번 이상 주어진다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3 8
1 2 3
1 3 4
3 3
2 3 0
3 3
3 2
1 1 5
3 1
','3
1
2
2
','DATA_STRUCTURE'),
                                                                                                                (7500,'BAEKJOON','https://www.acmicpc.net/problem/16002',16002,'조용한 생활관 만들기','4초(추가시간없음)','768 MB',26,'<p>카카오 마법 학교는 건물들의 독특한 구조로 유명한데, 그중에서도 특이한 것은 학생 생활관이다. 카카오 마법 학교의 생활관은 N 개의 건물로 이루어져 있으며, N-1 개의 도로가 건물 사이를 잇고 있다. 특이한 것은 이 도로들이 모두 일방통행이라는 것이다. 자세한 구조를 설명하자면, 생활관은 입구와 출구가 있으며, 입구에는 1번 건물이 있다. 1번 건물을 제외한 각 건물에는 그 건물로 들어오는 도로가 정확히 하나 존재하며, 1번 건물로부터 각 건물까지 일방통행 도로만을 이용해서 갈 수 있다. 그리고 모든 건물에서 출구로 가는 길이 존재하는데, 생활관 규칙이 엄격하여 밤에는 출구가 폐쇄된다.</p>

<p>라이언은 카카오 마법 학교에서 코딩마법을 가르치는 교수이다. 요즘 그의 가장 큰 고민거리는 교수아파트 바로 옆에 있는 학생 생활관에서 발생하는 소음 때문에 잠을 이루지 못한다는 것이다. 생활관이 이렇게 시끄러운 이유는 많은 학생이 한 건물로 모여들기 때문이다. 라이언 교수는 두 도로를 이어서 한 도로로 만드는 ‘Union’ 마법을 이용해서 원래 서로 오고 갈 수 있던 건물들을 그렇지 못하게 만들어 학생들이 모이는 것을 방지하고자 한다. ‘Union’ 마법을 자세히 설명하면, 한 도로의 끝점과 다른 도로의 시작점이 같을 때 두 도로를 이어 붙이는 마법이다. 즉, 한 도로가 건물 x 에서 건물 y 로, 다른 도로가 건물 y 에서 건물 z 로 가는 도로일 때 ‘Union’ 마법을 사용하면 원래 있던 두 도로는 사라지고 건물 x 에서 z 로 가는 하나의 도로가 생긴다. 이때, 새 도로는 건물 y 를 지나지 않는다.</p>

<p><img alt="" src="https://upload.acmicpc.net/af18f5a9-22b3-46b7-a2b0-addc4a748893/-/preview/" style="width: 378.333px; height: 140px;"></p>

<p>라이언의 목표는 생활관의 “시끄러운 정도”를 최소화하는 것이다. 생활관의 “시끄러운 정도”는 서로 다른 건물에 사는 학생 a 와 학생 b 에 대해, 학생 a 가 사는 건물에서 학생 b 가 거주하는 건물로 가는 경로가 존재하는 (a, b) 쌍의 개수이다. 앞서 말했다시피 밤에는 출구가 폐쇄되기 때문에 출구로 나갔다가 입구로 다시 들어오는 것은 불가능하다.</p>

<p>라이언은 오랜 기간 마법을 수련해 무제한으로 ‘Union’ 마법을 사용할 수 있다. 이때, 생활관의 “시끄러운 정도”의 가능한 최솟값을 구해 라이언을 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫째 줄에는 생활관의 건물 개수 <em>N</em>(2 ≤ <em>N</em> ≤ 200,000)이 주어진다. 다음 줄에는 <em>N</em>-1 개의 수가 공백을 사이에 두고 주어진다.</p>

<p><em>N</em>-1 개의 수 중 <em>i </em>번째 수는 <em>i</em>+1 번째 건물로 가는 일방통행 도로의 시작점에 있는 건물의 번호이다.</p>

<p>다음 줄에는 각 건물에 사는 학생의 수를 나타내는 <em>N </em>개의 수가 공백을 사이에 두고 주어진다. 한 건물에 사는 학생의 수는 1 이상 10<sup>6</sup> 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 생활관의 “시끄러운 정도”의 가능한 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 1 2
2 1 3 2
','10
','DATA_STRUCTURE'),
                                                                                                                (7530,'BAEKJOON','https://www.acmicpc.net/problem/16124',16124,'나는 행복합니다','3초(추가시간없음)','512 MB',23,'<p>한국 프로야구단 이글스의 열렬한 팬인 아인따는 올해는 분명 이글스의 가을 야구를 볼 수 있을 거라는 희망에 부풀어 있다. 그의 바람대로 올해 이글스가 포스트시즌에 진출한다면 드디어 10자리의 비밀번호를 끊을 수 있게 된다!</p>

<p>한국 프로야구에서 비밀번호란 어떤 팀의 연도별 순위를 나열한 문자열을 말하는데, 오랜 기간 동안 포스트시즌에 진출하지 못한 팀들의 비밀번호는 놀림감이 되곤 한다. 아인따가 응원하는 이글스의 비밀번호는 5886899678이고, 그 외에도 트윈스의 6668587667, 자이언츠의 8888577 등이 유명하다. 한국 프로야구 리그는 10개의 팀으로 구성되어 있기 때문에 1위부터 10위까지 순위가 매겨진다. 이때 10위를 기록한 해는 비밀번호에 0으로 표기한다.</p>

<p>현실 세계의 이글스는 고작 10자리의 비밀번호를 찍고 있지만, 이글스가 100만 자리의 비밀번호를 찍고 있는 미래를 상상하는 것은 그다지 어렵지 않다. 미래의 아인따는 모든 것에서 해탈해서 특별한 능력을 쓸 수 있게 되었다. 아인따는 어떤 기간 동안 이글스가 <em>A</em>등을 기록한 모든 해의 경기 내용을 조작해서 이글스를 <em>B</em>등으로 바꿀 수 있다. 이때 순위가 너무 부자연스러우면 다른 팀의 팬들에게 의심을 살 수 있기 때문에, 능력을 쓰는 중간중간에 어떤 기간의 비밀번호가 얼마나 자연스러운지를 자신만의 방법으로 확인한다.</p>

<p>미래의 이글스의 비밀번호와 아인따가 비밀번호를 조작하는 과정이 주어질 때, 이에 따라 비밀번호를 조작하는 프로그램을 작성해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 이글스의 비밀번호를 의미하는 문자열 <em>S</em>가 주어진다. 문자열은 숫자로만 이루어져 있으며, 문자열의 길이는 1 이상 10<sup>6</sup> 이하이다.</p>

<p>두 번째 줄에 아인따가 비밀번호를 조작하면서 취한 행동의 수를 의미하는 정수 <em>Q</em>(1 ≤ <em>Q</em> ≤ 100,000)가 주어진다.</p>

<p>세 번째 줄부터 <em>Q</em>개의 줄에 걸쳐 각 줄에 아인따의 행동이 한 줄에 하나씩 순서대로 주어진다. 아인따의 행동은 다음과 같은 두 가지 형식이 있다.</p>

<ul>
	<li><code>1</code> <em>i</em> <em>j</em> <em>from</em> <em>to</em> (1 ≤ <em>i</em> ≤ <em>j</em> ≤ |<em>S</em>|, <em>from</em>, <em>to</em>는 숫자): 비밀번호의 <em>i</em>번째 위치부터 <em>j</em>번째 위치까지의 범위에 있는 숫자 <em>from</em>을 전부 <em>to</em>로 바꾼다.</li>
	<li><code>2</code> <em>i</em> <em>j</em> (1 ≤ <em>i</em> ≤ <em>j</em> ≤ |<em>S</em>|): 비밀번호의 <em>i</em>번째 위치부터 <em>j</em>번째 위치까지의 숫자를 이어 붙여 하나의 정수로 볼 때, 이 정수를 998,244,353으로 나눈 나머지를 구한다.</li>
</ul>

<p>두 번째 행동이 한 번 이상 주어짐이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 두 번째 행동에 대한 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<ul>
	<li>쿼리 1: 입력된 수 중 [6, 9] 범위의 정수는 9,967이므로 이를 출력한다.</li>
	<li>쿼리 2: [2, 9] 범위에 있는 8을 5로 바꾸므로 5556599678이 된다.</li>
	<li>쿼리 3: [1, 3] 범위에 있는 5를 0으로 바꾸므로 0006599678이 된다.</li>
	<li>쿼리 4: [1, 6] 범위의 정수인 659를 출력한다.</li>
	<li>쿼리 5: [1, 10] 범위에 있는 0을 2로 바꾸므로 2226599678이 된다.</li>
	<li>쿼리 6: [5, 8] 범위에 있는 8을 1로 바꾸는데, 이 범위에는 8이 없으므로 아무 일도 일어나지 않는다.</li>
	<li>쿼리 7: [1, 10] 범위의 정수는 2,226,599,678이므로 이를 998,244,353으로 나눈 나머지인 230,110,972를 출력한다.</li>
</ul>

				</div>
				</div>','5886899678
7
2 6 9
1 2 9 8 5
1 1 3 5 0
2 1 6
1 1 10 0 2
1 5 8 8 1
2 1 10','9967
659
230110972','DATA_STRUCTURE'),
                                                                                                                (7532,'BAEKJOON','https://www.acmicpc.net/problem/16133',16133,'공학용 계산기 (Calculator)','1초(추가시간없음)','256 MB',19,'<p>현석이는 기말고사 대비를 위해 화학 문제를 풀고 있다. 화학 문제를 풀던 도중 공학용 계산기를 홈베에 두고 온 것이 기억났다. 홈베에 너무 내려가기 귀찮은 현석이는 그냥 코딩을 해서 계산기를 만들기로 했다.</p>

<p>현석이의 계산기는 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>(</code>, <code>)</code>, <code>#</code> 연산자를 지원한다. 각각 덧셈, 뺄셈, 곱셈, 나눗셈, 거듭제곱, 여는 괄호와 닫는 괄호, 제곱근을 의미하며, 제곱근 연산자는 <code>#5</code> 또는 <code>#(1+2)</code> 와 같이 제곱근을 구하고자 하는 식의 앞에 붙는다. 그리고 식을 계산하기 위해서는 식을 전부 입력하고 난 뒤 마지막에 <code>=</code> 버튼을 눌러야 한다. 계산기가 처리할 수 있는 입력을 엄밀하게 표현하면 다음과 같다.</p>

<pre><input>    ::= <expr> "="
<expr>     ::= <term> | <term> ("+" | "-") <expr>
<term>     ::= <factor> | <factor> ("*" | "/") <term>
<factor>   ::= <power> | <power> "^" <factor>
<power>    ::= "#" <power> | <root>
<root>     ::= <num> | "(" <expr> ")"
<num>      ::= "0" | <non-zero> <digit>*
<digit>    ::= "0" | <non-zero>
<non-zero> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
</pre>

<p>연산자의 우선순위는 괄호 > 제곱근 > 거듭제곱 > 곱셈과 나눗셈 > 덧셈과 뺄셈 순이며, 우선순위가 같은 연산자가 여럿 있는 경우 제곱근과 거듭제곱을 제외한 연산자는 왼쪽부터 오른쪽으로, 제곱근과 거듭제곱은 오른쪽부터 왼쪽으로 계산된다. 즉 <code>2^3^2</code>은 <code>2^(3^2)</code>로 계산되고, <code>##32</code>는 <code>#(#32)</code>로 계산된다.</p>

<p>현석이의 계산기는 정수 연산밖에 하지 못한다. 제곱근이나 나눗셈 연산의 결과가 정수로 맞아떨어지지 않는 경우는 대신 0 방향으로 가장 가까운 정수를 결괏값으로 취한다. 예를 들어 <code>#17</code>의 결과는 <code>4</code>이고, <code>(2-9)/3</code>의 결과는 <code>-2</code>이다.</p>

<p>현석이는 잠깐 코딩을 해 보다가 차라리 손으로 계산하는 게 더 빠르겠다는 생각이 들었다. 코딩을 못하는 현석이를 위해 계산기를 만들어 주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>계산해야 할 식이 주어진다. 식의 길이는 100을 넘지 않으며, 문제에 주어진 문법을 만족한다. 또한 다음과 같은 조건을 만족하는 수식만 입력으로 주어짐이 보장된다.</p>

<ul>
	<li>계산 과정에서 등장하는 모든 수는 부호 있는 64비트 정수형으로 나타낼 수 있다.</li>
	<li>계산 과정에서 음수의 제곱근을 구하거나 어떤 수를 음수 번 거듭제곱하는 연산은 등장하지 않는다.</li>
	<li>계산 과정에서 0을 0번 거듭제곱하거나 어떤 수를 0으로 나누는 연산은 등장하지 않는다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>계산 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','#9+2*3+1=
','10
','DATA_STRUCTURE'),
                                                                                                                (7538,'BAEKJOON','https://www.acmicpc.net/problem/16151',16151,'별자리','1.5초','512 MB',19,'<p dir="ltr" style="margin-top:0pt; margin-bottom:0pt">별의 신 디디는 자신이 만들었던 별자리를 사람들이 알아보지 못해 속상했다. 그래서 이번에는 좌표평면 상에 존재하는 별들로&nbsp;알아보기 쉬운&nbsp;별자리를 하나&nbsp;만들려고 한다. 별자리에 속한 별들의 집합을 <em>S</em>라고 하자. 디디는 집합 <em>S</em>에 속해 있는&nbsp;임의의&nbsp;별을&nbsp;원점으로 생각했을 때,&nbsp;그 별을 제외한&nbsp;<em>S</em>의 모든 별들이&nbsp;1사분면 혹은 3사분면에 있다면, 그&nbsp;별자리를 알아보기 쉽다고 생각한다. 사분면의 정의는 다음 링크를 따른다. (<strong><a href="https://ko.wikipedia.org/wiki/%EC%82%AC%EB%B6%84%EB%A9%B4">링크</a>.</strong>&nbsp;단, 좌표축은 사분면에 포함되지 않는다.)</p>

<p dir="ltr" style="margin-top:0pt; margin-bottom:0pt">&nbsp;</p>

<p dir="ltr" style="text-align: center"><img alt="" src="https://upload.acmicpc.net/87dec6e9-cda9-46df-a5d9-d988e592bfdd/" style="width: 150px; height: 150px;"></p>

<p dir="ltr" style="text-align: center">올바른 예시</p>

<p dir="ltr" style="margin-top: 0pt; margin-bottom: 0pt; text-align: center;"><img alt="" src="https://upload.acmicpc.net/e36b590f-3705-4b98-bab3-ab7e072c15b9/" style="width: 150px; height: 150px;">&nbsp;&nbsp;&nbsp;<img alt="" src="https://upload.acmicpc.net/766ae188-5a76-4071-b3c5-b0ae7699092b/" style="width: 150px; height: 150px;"></p>

<p dir="ltr" style="margin-top: 0pt; margin-bottom: 0pt; text-align: center;">올바르지 않은 예시</p>

<p dir="ltr" style="margin-top: 0pt; margin-bottom: 0pt; text-align: center;">&nbsp;</p>

<p dir="ltr" style="margin-top: 0pt; margin-bottom: 0pt;">또한, 알아보기 쉬운 별자리는 집합&nbsp;<em>S</em>에 속해 있는&nbsp;임의의&nbsp;별을&nbsp;원점으로 생각했을 때, 어떤 사분면에 <em>S</em>의 별이 존재하는 경우, 그러한 각각의&nbsp;사분면에서 |<em>X</em><sub><em>i</em>&nbsp;</sub>- <em>X<sub>j</sub></em>| +&nbsp;|<em>Y<sub>i</sub></em><sub> </sub>- <em>Y<sub>j</sub></em>|가&nbsp;가장 작은&nbsp;별들과 아래 조건을 만족해야 한다.</p>

<p dir="ltr" style="margin-top: 0pt; margin-bottom: 0pt; text-align: center;">|<em>X</em><sub><em>i</em>&nbsp;</sub>- <em>X<sub>j</sub></em>| ≤&nbsp;<em>L </em><code>그리고</code>&nbsp;|<em>Y<sub>i</sub></em><sub> </sub>- <em>Y<sub>j</sub></em>| ≤&nbsp;<em>L</em></p>

<p dir="ltr" style="margin-top: 0pt; margin-bottom: 0pt; text-align: center;">(단, <em>i</em>는 원점으로 생각한 별, <em>j</em>는 그 사분면에서 |<em>X</em><sub><em>i</em>&nbsp;</sub>- <em>X<sub>j</sub></em>| +&nbsp;|<em>Y<sub>i</sub></em><sub> </sub>- <em>Y<sub>j</sub></em>|가&nbsp;가장 작은&nbsp;별을 의미한다.)</p>

<p dir="ltr" style="margin-top: 0pt; margin-bottom: 0pt; text-align: center;">&nbsp;</p>

<p dir="ltr" style="margin-top: 0pt; margin-bottom: 0pt;">디디는 알아보기 쉬운&nbsp;별자리 중 구성하는 별들의 밝기의 합이 가장 큰 별자리를 만들려고 한다. 디디를 도와 밝기의 합의 최댓값을&nbsp;구하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 좌표평면 상에 존재하는 별의 개수 <em>N&nbsp;</em>(1 ≤&nbsp;<em>N</em>&nbsp;≤ 2&nbsp;x 10<sup>5</sup>), 문제에서 주어진 정수&nbsp;<em>L&nbsp;</em>(1 ≤&nbsp;<em>L</em>&nbsp;≤&nbsp;10<sup>9</sup>)이 공백으로 구분되어 주어진다.</p>

<p>둘째 줄부터 <em>N</em>개의 줄에는 각각 별의 위치 <em>X<sub>i</sub></em><sub>,</sub> <em>Y<sub>i&nbsp;</sub></em>(1 ≤&nbsp;<em>X<sub>i</sub></em>, <em>Y<sub>i&nbsp;</sub></em>≤&nbsp;10<sup>9</sup>) 별의 밝기 <em>B<sub>i </sub></em>(1 ≤&nbsp;<em>B<sub>i</sub></em>&nbsp;≤ 10<sup>4</sup>)가 공백으로 구분되어 주어진다. 주어지는 입력은 모두 정수이며, 같은 위치를 가지는 별들도 입력으로 주어질 수 있음에 유의하라.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>구성하는 별들의 밝기의 합이 가장 큰 알아보기 쉬운&nbsp;별자리의 밝기의 합을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 4
12 14 7
2 2 3
6 4 7
5 3 2
7 9 10
11 10 3
','20
','DATA_STRUCTURE'),
                                                                                                                (7533,'BAEKJOON','https://www.acmicpc.net/problem/16152',16152,'트리와 가희','1.5초','512 MB',20,'<p>노드의 개수가 <em>N</em>개이며 루트 노드의 번호가 1인&nbsp;완전 이진 트리가 있다. 루트 노드를 제외한 각 노드 <em>i</em>(<em>i</em> = 2, 3, 4, ..., <em>N</em>)는&nbsp;?<em>i</em> / 2?번 노드를 부모로 갖는다. 이때 다음 2가지 종류의 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li>1 <em>a</em> : <em>a</em>를 루트로 하는 서브트리의 노드 개수를 출력한다. 만약,&nbsp;노드<i> a</i>가 존재하지 않는다면 0을 출력한다.</li>
	<li>2 <em>a</em> : <em>a</em>를 루트로 하는 서브트리를 제거한다. 만약, 노드<i> a</i>가 존재하지 않는다면 무시한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 완전 이진 트리의 노드 개수 <em>N</em>(1 ≤ <em>N</em> ≤ 1012111225)과 쿼리의 개수 <em>Q</em>(1 ≤ <em>Q</em> ≤ 361936)가 공백으로 구분되어 주어진다.</p>

<p>둘째 줄부터 <em>Q</em>개의 각 줄에는 문제에서 주어진 쿼리가 하나씩&nbsp;주어진다. <em>a</em>는 1이상 <em>N</em>이하인 정수이며, 1번 쿼리는 최소한 하나 이상 주어지는 것이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1번째 쿼리에 대한 답을 한 줄에 하나씩 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12 8
1 2
1 3
2 5
2 6
1 1
1 2
2 9
1 4
','7
4
7
4
2
','DATA_STRUCTURE'),
                                                                                                                (7534,'BAEKJOON','https://www.acmicpc.net/problem/16165',16165,'걸그룹 마스터 준석이','2초(추가시간없음)','128 MB',8,'<p>정우는 소문난 걸그룹 덕후이다. 정우의 친구 준석이도 걸그룹을 좋아하지만 이름을 잘 외우지 못한다는 문제가 있었다. 정우는 친구를 위해 걸그룹 개인과 팀의 이름을 검색하여 외우게 하는 퀴즈 프로그램을 만들고자 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 총 입력 받을 걸그룹의 수 N(0 < N < 100)과 맞혀야 할 문제의 수 M(0 < M < 100)을 입력받는다.</p>

<p>두 번째 줄부터는 각 걸그룹마다 팀의 이름, 걸그룹의 인원 수, 멤버의 이름을 한 줄씩 차례대로 입력받는다. 팀과 멤버의 이름은 최대 100글자이며, 모든 글자는 알파벳 소문자이다. 하나의 걸그룹이나 서로 다른 두 걸그룹에 이름이 같은 두 멤버가 있는 경우는 없다.</p>

<p>그 다음 줄부터는 M개의 퀴즈를 입력받는다. 각각의 퀴즈는 두 줄로 이루어져 있으며, 팀의 이름이나 멤버의 이름이 첫 줄에 주어지고 퀴즈의 종류를 나타내는 0 또는 1이 두 번째 줄에 주어진다. 퀴즈의 종류가 0일 경우 팀의 이름이 주어지며, 1일 경우 멤버의 이름이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄부터 차례대로 퀴즈에 대한 답을 출력한다. 퀴즈의 종류가 0일 경우 해당 팀에 속한 멤버의 이름을 사전순으로 한 줄에 한 명씩 출력한다. 퀴즈의 종류가 1일 경우 해당 멤버가 속한 팀의 이름을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
twice
9
jihyo
dahyeon
mina
momo
chaeyoung
jeongyeon
tzuyu
sana
nayeon
blackpink
4
jisu
lisa
rose
jenny
redvelvet
5
wendy
irene
seulgi
yeri
joy
sana
1
wendy
1
twice
0
rose
1
','twice
redvelvet
chaeyoung
dahyeon
jeongyeon
jihyo
mina
momo
nayeon
sana
tzuyu
blackpink
','DATA_STRUCTURE'),
                                                                                                                (7537,'BAEKJOON','https://www.acmicpc.net/problem/16166',16166,'서울의 지하철','2초(추가시간없음)','128 MB',11,'<p>한국에 처음 도착한 미국인 Mr.Goofcode는 한국의 수도 서울을 여행할 생각에 들떠 있었다. 하지만, 공항 철도를 타고 서울역에 도착한 Mr.Goofcode는 복잡한 서울의 지하철 노선도를 보고 경악을 금치 못했다. 왜냐하면, 서울역을 포함한 서울의 모든 역은 이름이 아닌 숫자로 구분해야 했으며, 운영되는 지하철의 종류(호선)가 너무 많아 최적의 이동 경로를 계산하기 어려웠기 때문이다.</p>

<p>Mr.Goofcode는 패닉에 빠져 평소 메일로 편지를 주고 받던 당신에게 도움을 요청했다. 평소 Mr.Goofcode에게 도움을 받았던 당신은 그를 위해 지하철 노선도 어플리케이션을 만들어 주려고 한다. 그러나, 까다로운 Mr.Goofcode는 걷는 것을 매우 싫어한다. 따라서, 그를 위해 가능하면 어플리케이션이 제시하는 지하철 환승 횟수를 최소로 줄이고 싶어 한다.</p>

<p>Mr.Goofcode를 위해 주어진 지하철 노선도를 보고 Mr.Goofcode가 목적지에 도달하기 위해 최소 몇 번의 환승이 필요한지 구해주자. 단, Mr.Goofcode의 출발역인 서울역의 역 번호는 항상 0번이다.</p>

<p>지하철의 호선이란&nbsp;한 종류의 지하철에서, 다른 지하철로 환승하지 않고 이동할 수 있는 역의 집합을 의미한다. 지하철의 역이란&nbsp;지하철의 호선의 원소로 지하철이 방문할 수 있는 정점을 의미한다. 각 역은 간선으로 연결 관계를 나타낼 수 있으며, 이 간선을 통해서만 지하철이 이동할 수 있다. 지하철은 양 방향으로 이동할 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 서울의 지하철 호선의 개수 N(1 ≤ N&nbsp;≤ 10)이 주어진다.</p>

<p>둘째 줄부터, 순서대로 1호선부터 N호선까지, 각 호선의 역 개수 K(1 ≤ K ≤ 10)와 각 지하철 호선이 포함하는 역의 번호a<sub>N1</sub>, a<sub>N2</sub>, a<sub>N3</sub>, ... a<sub>NK</sub>가 한 줄에 주어진다. 각 역의 번호는 모두 다르며 0이상 2<sup>32</sup>-1&nbsp;이하의 정수임이 보장되어 있다.</p>

<p>입력의 마지막 줄에는, 도착역의 번호가 주어진다.</p>

<p>각 지하철 호선 중, 순환선이 있을 수 있음에 주의하자, 순환선의 입력은 호선이 포함하는 역의 번호가 a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ... a<sub>K-1</sub>, a<sub>1</sub>&nbsp;의 꼴로 주어진다. (예제 2번)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출발 역(서울 역)에서 도착 역까지 최소 환승 횟수를 한 줄에 출력한다. 단, 도달할 수 없는 경우 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
3 0 2 3
4 2 5 7 10
2 10 8
8
','2
','DATA_STRUCTURE'),
                                                                                                                (7535,'BAEKJOON','https://www.acmicpc.net/problem/16168',16168,'퍼레이드','2초(추가시간없음)','128 MB',12,'<p>종우는 18학번을 대표하여 중앙대학교 개교 100주년 기념 퍼레이드의 경로 선정 위원으로 선정되었다. 퍼레이드의&nbsp;경로는 일정한 지점들과 두 지점을 연결하는 연결&nbsp;구간으로 이루어져 있다. 종우는 모든 지점을 지나면서 모든 연결 구간들을 지나고 싶어한다.</p>

<p>하지만 같은 연결 구간을 두 번 이상 지날 경우 그 구간의 주민들이 민원을 제기하게 된다. 단, 같은 지점은 두 번 이상 지나도 된다.</p>

<p>민원을 받지 않으면서 모든 구간을 지나도록 퍼레이드를 만들고 싶은 종우를 위한 프로그램을 작성해보도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 지점의 개수 V, 연결 구간의 개수 E가&nbsp;주어진다. (1 <span style="font-size:10.0pt"><span style="font-family:나눔고딕"><span style="color:black"><span style="language:en-US">≤&nbsp;</span></span></span></span>V <span style="font-size:10.0pt"><span style="font-family:나눔고딕"><span style="color:black"><span style="language:en-US">≤&nbsp;</span></span></span></span>E <span style="font-size:10.0pt"><span style="font-family:나눔고딕"><span style="color:black"><span style="language:en-US">≤&nbsp;</span></span></span></span>3000) 이후 E개의 줄에 걸쳐 각 연결 구간이 연결하는 두 지점의 번호 V<sub>a</sub>, V<sub>b</sub>가 공백을 사이에 두고 주어진다. (1 <span style="font-size:10.0pt"><span style="font-family:나눔고딕"><span style="color:black"><span style="language:en-US">≤&nbsp;</span></span></span></span>V<sub>a</sub>, V<sub>b</sub> <span style="font-size:10.0pt"><span style="font-family:나눔고딕"><span style="color:black"><span style="language:en-US">≤&nbsp;</span></span></span></span>V, V<sub>a</sub>&nbsp;<span style="font-size:10pt"><span style="line-height:115%"><span style="font-family:&quot;맑은 고딕&quot;">≠</span></span></span>&nbsp;V<sub>b</sub>)</p>

<p>서로 다른 두 연결 구간 (V<sub>a1</sub>, V<sub>b1</sub>), (V<sub>a2</sub>, V<sub>b2</sub>) 에서 V<sub>a1</sub>&nbsp;=&nbsp;V<sub>a2</sub> &amp;&nbsp;V<sub>b1</sub>&nbsp;= V<sub>b2</sub>&nbsp;인 경우는 존재하지 않으며, 임의의 지점에 적어도 하나의 연결 구간이 연결되어 있음이&nbsp;보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>종우가 원하는 노선을 만들 수 있다면 YES, 아니면 NO를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5
1 2
1 3
1 4
2 3
2 4
','YES
','DATA_STRUCTURE'),
                                                                                                                (7540,'BAEKJOON','https://www.acmicpc.net/problem/16209',16209,'수열 섞기','1초','512 MB',13,'<p>준원이는 이 문제를 각색하려고 했는데 너무 귀찮다. 그냥 풀어보도록 하자.</p>

<p>당신은 길이 N인 정수열 a<sub>1</sub>, …, a<sub>N</sub>을 가지고 있다. 당신은 이 수열을 재배열하여, 수열에서 인접한 원소의 곱들의 합, 즉 a<sub>1</sub>a<sub>2</sub>&nbsp;+ a<sub>2</sub>a<sub>3</sub>&nbsp;+ … + a<sub>N-1</sub>a<sub>N</sub>을 최대화하려고 한다. 이렇게 재배열한 수열을 하나 출력해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 수열의 길이 N이 주어진다. (2 ≤ N ≤ 500,000)</p>

<p>둘째 줄에는 수열의 각 원소가 공백을 사이에 두고 주어진다. 각 원소의 절댓값은 100만 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>인접한 원소의 곱들을 최대화한 본 수열의 재배열을 하나 출력하자. 만약 최대화할 수 있는 재배열이 여러 가지&nbsp;있다면 아무거나 하나 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
7 7 12 14','7 14 12 7','DATA_STRUCTURE'),
                                                                                                                (7542,'BAEKJOON','https://www.acmicpc.net/problem/16220',16220,'회의','1초(추가시간없음)','1024 MB',15,'<p>사람 N명이 회의를 하려고 한다. i번째 사람은 회의실에 S<sub>i</sub>시간부터 E<sub>i</sub>시간까지 머무른다. 두 사람이 동시에 회의실에 머무르는 순간이 존재한다면, 두 사람이&nbsp;같이 회의를 하게 할 수 있다. 한 사람은 최대 한 회의에만 포함될 수 있다. 최대한 많은 회의를 열어 작업 효율성을 높이려 한다. 이 때 열 수 있는 회의의 개수를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 N이 주어진다. (1&nbsp;≤ N ≤ 5 × 10<sup>5</sup>)</p>

<p>N개의 줄 동안 S<sub>i</sub>와 E<sub>i</sub>가 공백으로 구분되어 주어진다. (모든 i에 대해서, 1&nbsp;≤ S<sub>i</sub>&nbsp;≤ E<sub>i</sub>&nbsp;≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>최대로 열 수 있는 회의의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 5
2 4
3 3
5 6
999999999 1000000000
','2
','DATA_STRUCTURE'),
                                                                                                                (7543,'BAEKJOON','https://www.acmicpc.net/problem/16221',16221,'모독','3초(추가시간없음)','1024 MB',17,'<p>준원이가 좋아하는 하스스톤의 주문 카드 “모독”은 다음과 같은 효과를 지닌다:&nbsp;“모든 하수인에게 피해를 1 줍니다. 하나라도 죽으면, 이 주문을 다시 시전합니다.”</p>

<p>다른 말로 설명하면 다음과 같다. 현재 전장에 있는 하수인들의 생명력들을 길이 r인 양의 정수열 a<sub>1</sub>, …, a<sub>r</sub>로 나타내자. “모독” 카드를 쓰면&nbsp;수열 a에 아래와 같은 연산을 하게 된다.</p>

<ol>
	<li>a<sub>1</sub>, …, a<sub>r</sub>을 모두 1씩 감소시킨다.</li>
	<li>a<sub>i</sub>&nbsp;= 0이 되는 수열의 원소 a<sub>i</sub>가 하나라도 존재한다면, 해당하는 a<sub>i</sub>들을 모두 수열에서 제거하고, 다시 1.로 돌아간다.&nbsp;제거된 원소의 개수만큼 “죽은 하수인 수” 카운트를&nbsp;증가시킨다. 	그러한&nbsp;a<sub>i</sub>가 하나도 없다면, 과정을 중단한다.
	</li>
</ol>

<p>현재 전장에는 하수인이 하나도 없다. 하스스톤에는 수많은 변수가 있지만, 다음 두 가지의 변화만이 발생한다고 가정하자.</p>

<ol>
	<li>생명력이 k인 하수인 하나가 전장에 추가된다.</li>
	<li>생명력인 k인 하수인 하나가 전장에서 제거된다.</li>
</ol>

<p>각 변화가&nbsp;발생한 후에, 당신은 “모독” 카드를 한 번 사용했을 때에&nbsp;죽는&nbsp;하수인 수를 구해야 한다.</p>

<p>모든 변화는 누적된다. 또한,&nbsp;실제로 “모독” 카드를 사용하지 않고 카드를 사용했을 때의 상황을 가정하는 것일 뿐임에 유의하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 전장에 발생하는 변화의 수인 Q가 주어진다. (1 ≤ Q ≤ 1,000,000)</p>

<p>그 뒤 Q개의 줄에는 전장에 발생하는 각 변화를 나타내는&nbsp;두 개의 정수 T, K가&nbsp;주어진다. (T = 1 또는 T = 2, 1 ≤ K ≤ 1,000,000)</p>

<p>T = 1일 때에는, 생명력이 K인 하수인 하나가 전장에 추가된다.</p>

<p>T = 2일 때에는, 생명력이 K인 하수인 하나가 전장에서 제거된다.&nbsp;전장에 생명력이 K인 하수인이 이 때 하나 이상 존재함이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력에 주어진 각 변화가&nbsp;발생한 뒤, “모독” 카드를&nbsp;사용한다면 죽게 되는 하수인의 수를 구하여, 한 줄에 하나씩 출력한다.</p>

<p>입출력의 크기가 매우 크므로, 빠른 입출력 방식을 사용하는 것을 권장한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 1
1 2
1 3
1 4
2 2
1 3
1 2
1 5
2 1
1 1
','1
2
3
4
1
1
5
6
0
6
','DATA_STRUCTURE'),
                                                                                                                (7544,'BAEKJOON','https://www.acmicpc.net/problem/16223',16223,'클러스터','3초(추가시간없음)','1024 MB',23,'<p>어느 도시든 회사들이 많이 있기 마련이다. 1번부터 N번까지, N개의 회사들이 1번부터 순서대로 선형으로 배열되어 있으며, i번째 회사에는 A<sub>i</sub>명의 직원이 있다. 당신은 도시의 회사들을 관리하는 공무원으로, 산업 활성화를 위해서 회사들을 연속하게 클러스터로 묶어 각 클러스터 내의 소통을 활발히 하게 하려고 한다. 이때&nbsp;모든 회사가 하나의 클러스터에 포함되어야 한다.</p>

<p>각각의 클러스터 내외의 소통을 위해&nbsp;리더 역할을 하는 회사가 필요할 것이다. 이 회사를 "리더 회사"라고 하자. 관리를 쉽게 하기 위해&nbsp;클러스터 상에서 가장 왼쪽 또는 가장 오른쪽 회사만 리더 회사로 지정할 수 있다. i번째 회사는 최대 L<sub>i</sub>개의 회사들을 관리할 수 있기 때문에, i번째 회사를 리더 회사로 삼으면 클러스터의 크기는 L<sub>i&nbsp;</sub>이하여야 한다. 또한&nbsp;각 리더 회사는 클러스터의 발전에 사용될 돈을 요구하는데, i번째 회사가 리더 회사이고, 클러스터에 포함된 회사들의 직원들의 수를 모두 합친 값을 S라 한다면, 요구하는 금액은 C<sub>i&nbsp;</sub>×&nbsp;S + T<sub>i</sub> 이다. 이 돈은 단순한 예산이 아닌&nbsp;다양한 용도로 사용되어, C<sub>i</sub>와 T<sub>i</sub>의 값이 음수일 수도 있다.</p>

<p>공무원인 당신은 요구될 돈의 총합을 최소화하려고 한다. 이때 그 값을 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 N이 주어진다. (1&nbsp;≤ N&nbsp;≤ 2 × 10<sup>5</sup>)</p>

<p>둘째 줄에 N개의 A<sub>i</sub>가 공백으로 구분되어 주어진다. (1&nbsp;≤ A<sub>i</sub>&nbsp;≤ 10<sup>2</sup>)</p>

<p>셋째 줄에 N개의 C<sub>i</sub>가 공백으로 구분되어 주어진다. (-50&nbsp;≤ C<sub>i</sub>&nbsp;≤ 50)</p>

<p>넷째 줄에 N개의 T<sub>i</sub>가 공백으로 구분되어 주어진다. (-100&nbsp;≤ T<sub>i</sub>&nbsp;≤ 100)</p>

<p>다섯째 줄에 N개의 L<sub>i</sub>가 공백으로 구분되어 주어진다. (1&nbsp;≤ L<sub>i</sub>&nbsp;≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>필요한 돈의 총합의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','11
1 1 1 1 1 1 1 1 1 1 1
-1 1 1 1 1 -1 1 1 1 -1 1
-1 1 1 1 1 -1 1 1 1 -1 1
11 11 11 11 11 11 11 11 11 11 11','-14','DATA_STRUCTURE'),
                                                                                                                (7545,'BAEKJOON','https://www.acmicpc.net/problem/16225',16225,'제271회 웰노운컵','1초(추가시간없음)','1024 MB',21,'<p>2250년, 드디어 전세계의 사람들이 기다리는 웰노운컵의 271회 대회가 열린다. 2018년에 1회가 열렸을 당시에는 “웰노운 알고리즘으로 풀 수 있는 문제들”이라는 취지로 웰노운컵이라는 이름이 붙었는데, 지금은 출제/검수하는 사람만 약 1만 명에 달해서 “알고리즘계에서 잘 알려진 사람들은 전부 이 대회의 출제/검수에 참여한다”라는 의미를 가지고 있다.</p>

<p><meta charset="utf-8"></p>

<p>수많은 경쟁자들을 꺾고 마침내 Etacoder Plus와의 결승전이 열렸다. 참, 나와 Etacoder Plus는 인공지능이다. 내 이름은 SolvingCore KX이다. 하긴 요즘 세상에 인간이 본선에 진출하는 것도 이상하지만. 그럼 인간 부문과 인공지능 부문을 따로 열면 되지 않느냐 싶겠지만, 누구나 튜링 테스트를 통과하는 요즘 인간과 인공지능을 구별하는 것이 극도로 힘들기 때문에 현실적이지 못한 방안이다.</p>

<p>결승전의 진행 방식은 조금 특이하다. Etacoder Plus는 작년 대회의 우승자이기 때문에 그에게 약간의 제약이 들어간다. 구체적으로, 결승전에는 짝수 개의 문제가 준비되어 있다. 먼저 도전자가 두 개의 문제를 고르고, 우승자가 그 둘 중 하나를 고른다. 도전자는 남은 하나를 가져간다. 모든 문제가 배정될 때까지 이것을 반복한 다음 배정된 모든 문제를 먼저 푸는 사람이 승리한다. (2250년에는 인공지능도 사람이라고 부른다.)</p>

<p>나는 먼저 각 문제에 대해 두 사람이 얼마나 자신이 있는지를 각각 자연수로 수치화하였다. 즉 내가 문제 i를 푸는 데에는 A[i]만큼 자신이 있고, Etacoder Plus가 푸는 데에는 B[i]만큼 자신이 있다. 내가 두 문제를 고르면 Etacoder Plus는 당연히 더 높은 B값을 가지는 문제를 가져갈 것이다. 이 전략을 가정했을 때, 내가 가져가는 문제에 대해 A값의 합을 최대화하고 싶다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 짝수 N(2 ≤ N ≤ 200,000)이 주어진다. 다음 줄에 A[1], ..., A[N], 그 다음 줄에 B[1], ..., B[N]이 (1 ≤ A[i], B[i] ≤ 10<sup>9</sup>) 주어진다. 모든 A[i]는 서로 다르고, 모든 B[i]도 서로 다르다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>내가 가져가는 문제의 A[i]값의 최대 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
4 2 8 6
6 5 7 8
','10
','DATA_STRUCTURE'),
                                                                                                                (7551,'BAEKJOON','https://www.acmicpc.net/problem/16226',16226,'거울냥이는 죽어서 거울을 남긴다','1초(추가시간없음)','1024 MB',14,'<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/7481b1cf-7952-4099-ae73-d8dbfc677c4f/-/preview/" style="height: 150px; width: 143px; margin-left: 50px; margin-right: 50px;"><img alt="" src="https://upload.acmicpc.net/f36b5d00-6698-4980-a87d-e9ad3aa12ffa/-/preview/" style="height: 150px; width: 314px; margin-left: 50px; margin-right: 50px;"></p>

<p>격자판으로 이루어진 디디몬 어드벤쳐의 어느 섬. 그 곳에는 거울냥이들이 모여 살고 있다. 거울냥이들의 생태계를 조사하던 디디는 충격적인 사실을 알게 되었다. 거울냥이들은 닿는 생명체를 전부 녹여버리는 빔을 상하좌우 네 방향으로 발사한다. 그 빔은 다른 거울냥이들을 관통하며, 어디서 발사하든 격자판의 끝에 도달한다. 거울냥이들은 동료로부터 자신의 몸을 보호하기 위해 꼬리에 거울을 달고 있도록 진화했는데, 그 거울은 항상 거울냥이의 하단 칸에 위치한다. 거울은 빔이 통과하지 않게 막으며 빔에 의해 녹지 않는다. 그리고 요즘은 무광이 대세이므로, 거울은 빔을 반사하지 않는다. 거울냥이는 죽어서 거울을 남기기 때문에 거울냥이가 녹아 없어져도 거울은 있던 자리에 그대로 남는다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/4eb7b47f-4cf1-415b-948e-ee3cd12a1640/-/preview/" style="height: 242px; width: 200px; margin-left: 100px; margin-right: 100px;"><img alt="" src="https://upload.acmicpc.net/3d2aa64e-c678-4ee7-a8e6-5745e7acb61e/-/preview/" style="height: 247px; width: 200px; margin-left: 100px; margin-right: 100px;"></p>

<p>디디는 거울냥이들이 빔을 쏘는 순서가 정해져 있다는 것을 알아냈다. 하지만 이미 누군가의 빔에 의해 사라진 거울냥이는 자신의 차례가 오더라도 빔을 쏘지 못한다. 살아 있는 거울냥이들이 모두 빔을 한 번씩 순서대로 쐈을 때, 마지막까지 살아남은 거울냥이의 마릿수를 구하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 거울냥이의 마릿수를 나타내는 정수 <em>N</em>(1 ≤ <em>N</em> ≤ 2 x 10<sup>5</sup>)이 주어진다.</p>

<p>둘째 줄부터 <em>N</em>개의 줄에는 빔을 쏘는 순서대로 거울냥이의 격자상의 위치 <em>R<sub>i</sub></em>, <em>C<sub>i</sub></em>(1 ≤ <em>R<sub>i</sub></em>, <em>C<sub>i</sub></em> ≤ 10<sup>5</sup>)가 공백으로 구분되어 주어진다. 거울냥이와 거울냥이, 거울냥이와 거울의 위치는 중복되지 않게 주어지는 것이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>마지막까지 살아남은 거울냥이의 마릿수를 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 1
1 4
1 3
','1
','DATA_STRUCTURE'),
                                                                                                                (7546,'BAEKJOON','https://www.acmicpc.net/problem/16228',16228,'GCC의 유산','1초(추가시간없음)','1024 MB',13,'<p><meta charset="utf-8">옛날 GCC에는 비표준 확장으로 각각 최솟값과 최댓값을 구해주는 이항 연산자 <?와 >?가 있었다. (현재는 지원되지 않는다.) 이 두 연산자를 포함하는 식을 계산해보자. 식을 계산할 때에는 괄호 안부터 먼저 계산하고 덧셈과 뺄셈은 <?와 >?보다 우선순위가 낮다. 우선순위가 같은 연산자(덧셈과 뺄셈, <?와 >?)끼리는 왼쪽부터 계산해야 한다. 계산 과정에서 등장하는 모든 수는 부호 있는 32비트 정수형으로 나타낼 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>계산해야 할 식이 주어진다. 주어지는 식은 숫자, 괄호, 이항 연산자 +, -, <?, >?만을 포함하며(+, -는 단항 연산자로 쓰이지 않음) 띄어쓰기는 없다. 식의 길이는 100보다 작거나 같고 최소 하나의 숫자를 포함하며 문법 오류가 있는 식은 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>계산 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','35<?40','35','DATA_STRUCTURE'),
                                                                                                                (7547,'BAEKJOON','https://www.acmicpc.net/problem/16231',16231,'내가 그린 라이언 그림','3초(추가시간없음)','1024 MB',25,'<p>나는 라이언 그림들을 그려, 트리 형태의 구조를 띄고 있는 미술관에 전시해 두었다. 미술관은 여러 방으로 이어져 있으며 각 방에 하나의 그림이 있다. 그 방을 오갈 수 있는 여러 길이의 통로들이 있는데, 방을 정점으로, 통로를 간선으로 한다면 그 그래프가 트리라는 것이다. 트리에서의 루트는 입장 및 퇴장을 할 수 있는 문이 있는 1번 방이다.&nbsp;</p>

<p>그런데 슬프게도 누군가가 침입해 모든 라이언 그림이 곰처럼 보이게 해버렸다. 나는 정확히 N개의 라이언 그림을 그렸는데, 그 종류는 총 K개가 있다. i번째 종류의 그림을 수정할 때 C<sub>i</sub>만큼의 시간이&nbsp;소모된다. 그리고 물감의 양은 한정되어 있기에 i번째 종류의 그림은 P<sub>i</sub>개만 수정할 수 있다.&nbsp;</p>

<p>또한, 1번 방을 루트로 하였을 때 한 방을 “작업 방”으로 정한다. 나는 작업 방을 루트로 하는 서브트리 내의 그림들만을 수정할 수 있다. 그리고&nbsp;작업을 끝낼 때마다 작업 방으로&nbsp;되돌아가야 하므로, 작업 방에서 그림이 원래 있던 곳까지의 거리가 d라고 할 때, d만큼의 시간이 추가로 필요하다. 나는 M시간 동안 작업을 할 수 있다. 각각의 방을 작업 방으로 삼을 때, 작업 시간의 합이&nbsp;M을 초과하지 않게 수정할 수 있는 그림의 최대 개수는 무엇인지 알려주길 바란다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는&nbsp;N, K, M이 주어진다. (1&nbsp;≤ K ≤ N ≤ 2 × 10<sup>5</sup>,&nbsp;1&nbsp;≤ M ≤ 10<sup>15</sup>)</p>

<p>N-1개의 줄에 걸쳐, i번째 정보로&nbsp;i+1번 방의 부모 방의 번호와 부모 방까지의 거리가 공백으로 구분되어 주어진다. (1&nbsp;≤&nbsp;통로의 길이&nbsp;≤&nbsp;10<sup>5</sup>)</p>

<p>다음 줄에 N개의 수가 주어지며, i번째 수는 i번째 방에 있는 그림의 종류를 의미한다. (1&nbsp;≤ 그림의 종류<span style="font-size: 10.8333px;">&nbsp;</span>≤ K)</p>

<p>다음 줄에 K개의 수가 주어지며, i번째 수는 C<sub>i</sub>를 의미한다. (1&nbsp;≤&nbsp;C<sub>i</sub>&nbsp;≤ M)</p>

<p>다음 줄에 K개의 수가 주어지며, i번째 수는 P<sub>i</sub>를 의미한다. (1&nbsp;≤&nbsp;P<sub>i</sub>&nbsp;≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>i번째 줄에 i번 방을 작업 방으로 했을 때, 수정 가능한 최대 그림의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12 4 10
1 1
1 1
1 2
2 3
5 7
2 4
5 1
3 10
4 2
4 3
9 5
1 2 1 3 1 4 2 4 3 2 1 2
1 1 1 1
1 1 1 1','3
3
1
3
2
1
1
1
2
1
1
1','DATA_STRUCTURE'),
                                                                                                                (7549,'BAEKJOON','https://www.acmicpc.net/problem/16232',16232,'없던 일처럼','2초(추가시간없음)','1024 MB',23,'<blockquote>
<p><em>흐려진 얼굴 위로 기억을 더듬어, 두 손을 덥혀주던 따뜻했던 체온과, 잊을 틈 없도록 매일 내게 들려주던 목소리까지도, 잊혀지지 않는데 사라져가, 없던 일처럼.</em></p>

<p><em>- <없던 일처럼>, 윤하</em></p>
</blockquote>

<p>윤하는 자신의 삶의 변곡점이 된 사건 N개를 생각하였다. 그리고&nbsp;그녀의 “멘탈 상태”를 나타내는 변수를&nbsp;생각한다.</p>

<p>이 변수는 모든 사건이 일어나기 전의&nbsp;처음 상태에는 0이었다. 각 사건이 발생한 다음에는 윤하의 멘탈이 증가하거나 감소한다.</p>

<p>i번째 사건 직전에 윤하의 멘탈 상태가 k<sub>i</sub>&nbsp;이상이었다면, 그녀의 멘탈 상태는&nbsp;b<sub>i</sub>만큼 증가하고, k<sub>i</sub>&nbsp;미만이었다면 a<sub>i</sub>만큼 증가했을 것이다. 물론, a<sub>i</sub>, b<sub>i</sub>가 음수라면 그&nbsp;절댓값만큼 감소한다는 뜻이다.&nbsp;<strong>a<sub>i</sub>는 항상 b<sub>i</sub> 이하이다.</strong></p>

<p>그녀는 이들 사건 중 하나라도&nbsp;없었다면, 자신의 인생이 얼마만큼 바뀌었을지, 즉 현재의 멘탈 상태가 어떻게 되었을지&nbsp;상상한다. 여러분이 각 사건에 대해, 각&nbsp;사건이 없었을 때에&nbsp;윤하의 현재 멘탈 상태를 계산해 주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 사건의 수 N이 주어진다. (1 ≤ N ≤ 200,000)</p>

<p>둘째 줄부터 N개의 줄에 윤하에게 일어난 각 사건의 a<sub>i</sub>,&nbsp;b<sub>i</sub>와&nbsp;k<sub>i</sub>를 나타내는 세 개의 정수가 일어난&nbsp;시간 순서대로 주어진다. (-10<sup>3</sup>&nbsp;≤ a<sub>i</sub>&nbsp;≤ b<sub>i</sub>&nbsp;≤ 10<sup>3</sup>, k<sub>i</sub>&nbsp;≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>사건 1부터 N까지의 각 사건이 일어나지 않았을&nbsp;때에, 윤하의 최종 멘탈 상태를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
-1 1 1
-2 -1 -1
-3 2 1','-4
-4
-2
','DATA_STRUCTURE'),
                                                                                                                (7553,'BAEKJOON','https://www.acmicpc.net/problem/16235',16235,'나무 재테크','0.3초(하단참고)','512 MB',13,'<p>부동산 투자로 억대의 돈을 번 상도는 최근 N×N 크기의 땅을 구매했다. 상도는 손쉬운 땅 관리를 위해 땅을 1×1 크기의 칸으로 나누어 놓았다. 각각의 칸은 (r, c)로 나타내며, r은 가장 위에서부터 떨어진 칸의 개수, c는 가장 왼쪽으로부터 떨어진 칸의 개수이다. r과 c는 1부터 시작한다.</p>

<p>상도는 전자통신공학과 출신답게 땅의 양분을 조사하는 로봇 S2D2를 만들었다. S2D2는 1×1 크기의 칸에 들어있는 양분을 조사해 상도에게 전송하고, 모든 칸에 대해서 조사를 한다. 가장 처음에 양분은 모든&nbsp;칸에 5만큼 들어있다.</p>

<p>매일 매일 넓은 땅을 보면서 뿌듯한 하루를 보내고 있던 어느 날&nbsp;이런 생각이 들었다.</p>

<blockquote>
<p><strong>나무 재테크를 하자!</strong></p>
</blockquote>

<p>나무 재테크란 작은 묘목을 구매해 어느정도 키운 후 팔아서 수익을 얻는 재테크이다. 상도는 나무 재테크로 더 큰 돈을 벌기 위해 M개의 나무를 구매해 땅에 심었다. 같은 1×1 크기의&nbsp;칸에 여러 개의 나무가 심어져 있을 수도 있다.</p>

<p>이 나무는 사계절을 보내며, 아래와 같은 과정을 반복한다.</p>

<p>봄에는 나무가 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다. 각각의 나무는 나무가 있는 1×1 크기의 칸에 있는 양분만 먹을 수 있다. 하나의 칸에 여러 개의 나무가 있다면, 나이가 어린 나무부터 양분을 먹는다. 만약, 땅에 양분이 부족해 자신의 나이만큼 양분을 먹을 수 없는 나무는 양분을 먹지 못하고 즉시 죽는다.</p>

<p>여름에는 봄에 죽은 나무가 양분으로 변하게 된다. 각각의 죽은 나무마다&nbsp;나이를 2로 나눈 값이 나무가 있던 칸에 양분으로 추가된다. 소수점 아래는 버린다.</p>

<p>가을에는 나무가 번식한다. 번식하는 나무는 나이가 5의 배수이어야 하며, 인접한 8개의 칸에 나이가 1인 나무가 생긴다. 어떤 칸 (r, c)와 인접한 칸은 (r-1, c-1), (r-1, c), (r-1, c+1), (r, c-1), (r, c+1), (r+1, c-1), (r+1, c), (r+1, c+1) 이다. 상도의 땅을 벗어나는 칸에는 나무가 생기지 않는다.</p>

<p>겨울에는 S2D2가 땅을 돌아다니면서 땅에 양분을 추가한다. 각 칸에 추가되는 양분의 양은 A[r][c]이고, 입력으로 주어진다.</p>

<p>K년이 지난 후 상도의 땅에 살아있는 나무의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N, M, K가 주어진다.</p>

<p>둘째 줄부터 N개의 줄에 A배열의 값이 주어진다. r번째 줄의 c번째 값은 A[r][c]이다.</p>

<p>다음 M개의 줄에는 상도가 심은 나무의 정보를 나타내는 세 정수 x, y, z가 주어진다. 처음 두 개의 정수는&nbsp;나무의 위치 (x, y)를 의미하고, 마지막 정수는 그 나무의 나이를 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 K년이 지난 후 살아남은 나무의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>나무 재테크와 관련된 내용은 <a href="http://www.samsungfundblog.com/archives/29818">이 링크</a>를 참고했다.</p>

				</div>
				</div>','1 1 1
1
1 1 1
','1
','DATA_STRUCTURE'),
                                                                                                                (7570,'BAEKJOON','https://www.acmicpc.net/problem/16402',16402,'제국','1초','256 MB',14,'<p>배성일력 73년, 대륙을 주름잡던 성일 제국은 무리한 정복 전쟁 끝에 멸망하게 되었다. 기회를 노리던 반란군들은 혼란을 틈타 제각각 왕국을 선포했고, 왕국들은 제국의 자리를 차지하기 위해 수많은 전쟁을 치르게 되었다.</p>

<p>전쟁은 다음과 같은 방식으로 진행된다.</p>

<p>다른 왕국의 속국이 아닌 왕국은 자신의 속국이 아닌 다른 왕국을 공격하여 전쟁을 벌일 수 있다. 만약 전쟁에서 승리한다면 그 왕국과 그 왕국의 속국들을 전부 자신의 속국으로 삼게 된다. 때로는 다른 왕국의 속국을 공격하는 경우도 있는데, 이 경우 그 왕국의 종주국(그 왕국을 거느린 왕국)은 그 왕국을 지키기 위해 지원을 아끼지 않는다. 따라서 여기서 승리한다면 빈털터리가 된 종주국과 그 속국들까지도 전부 자신의 속국으로 삼을 수 있다. 그러나 전쟁에서 패배한다면 자신과 자신의 속국들이 전부 상대 왕국(만약 다른 왕국의 속국이라면 그 종주국)의 속국으로 넘어가게 된다.</p>

<p>속국은 기본적으로 다른 왕국을 공격할 수 없지만, 한 가지 예외가 있다. 바로 자신의 종주국을 공격하는 것이다. 만약 이 전쟁에서 속국이 승리한다면 속국 신세에서 벗어나 종주국이었던 왕국과 그 속국들을 속국으로 삼게 된다. 그러나 종주국이 승리한다면 아쉽게도 아무 일도 일어나지 않는다.</p>

<p>왕국들의 이름과 두 왕국의 전쟁 결과들이 주어질 때, 모든 전쟁이 끝난 후 속국이 아닌 왕국들의 수와 속국이 아닌 각 왕국의 이름을 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 왕국들의 수 N(2&nbsp;≤ N ≤ 500), 전쟁 결과의 수 M(1 ≤ M ≤ 2,000) 이 주어진다.</p>

<p>둘째 줄부터 N개의 줄에 걸쳐 각 왕국의 이름이 주어진다.</p>

<p>왕국의 이름은 항상 “Kingdom of ”로 시작하며, 그 뒤로 공백 없는 하나의 단어로 이루어진다. 왕국 이름은 알파벳 대소문자와 공백으로만 이루어지고, 이름의 총 길이는 공백을 포함해 20을 넘지 않는다. 또한 왕국의 이름은 중복되지 않는다.</p>

<p>그다음 줄부터 M개의 줄에 걸쳐 전쟁의 결과가 주어진다.</p>

<p>전쟁의 결과로 왕국1의 이름, 왕국2의 이름, w(w = 1 or 2)가 <strong>공백 없이</strong> 쉼표(,)를 사이에 둔 형식으로 주어지며, w가 1인 경우 왕국1이, 2인 경우 왕국2가 승리했다는 것을 뜻한다. 왕국 이름의 입력 순서는 어느 쪽이 먼저 공격했는지와는 관계가 없으며, 문제 조건에 따라 성립할 수 있는 전쟁만이 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 속국이 아닌 왕국의 수를 출력한다.</p>

<p>둘째 줄부터 속국이 아닌 왕국의 이름을 ASCII 사전 순으로 정렬하여 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
Kingdom of A
Kingdom of B
Kingdom of C
Kingdom of D
Kingdom of E
Kingdom of A,Kingdom of B,1
Kingdom of C,Kingdom of D,2
','3
Kingdom of A
Kingdom of D
Kingdom of E
','DATA_STRUCTURE'),
                                                                                                                (7571,'BAEKJOON','https://www.acmicpc.net/problem/16404',16404,'주식회사 승범이네','1초','256 MB',18,'<p>승범이는 평소 래퍼 도끼를 흠모해왔지만, 도끼만큼 랩을 잘할 수 없다는 것을 깨닫고 도끼만큼 돈이라도 벌자는 결심을 한다. 그래서 휴학 후 <strong>㈜승범이네</strong>를 창업했다.</p>

<p><strong>㈜승범이네</strong>는 판매원들로만 이루어진 다단계 회사이다.</p>

<p>승범이를 제외한 모든 판매원은 사수가 배정되는데, 사수는 한 회원당 단 한 명씩만 배정된다. 만약 판매원 A가 B의 사수라면, B를 A의 부사수라고 부른다.</p>

<p><strong>㈜승범이네</strong>의 수익구조는 기형적이다.</p>

<p>판매원들은 제품을 자비로 사서 판매한다. 이때 제품을 구매가격보다 저렴하게 판매하게 되면 손해를 보게 되는데, 어떤 회원 A가 손해를 보면 그 회원의 모든 부사수도 같은 만큼의 손해를 보게 된다. 그러면 부사수들의 부사수들도 손해를 보게 되고, 그들의 부사수들도 손해를 보게 되고, … ,결국 A와 A 밑의 모든 판매원이 A가 잃은 만큼의 손해를 보게 된다.</p>

<p>반대로 판매원 A가 제품을 비싸게 팔아 이익이 생길 경우, A와 A밑의 모든 판매원이 같은 이익을 얻을 수 있다.</p>

<p>승범이는 직원들이 현재 얼마만큼 돈을 벌었는지 감시하기&nbsp;위해 다음 두 종류의 명령을 처리하려고 한다.</p>

<ul>
	<li>1 i w : 직원 i가 w만큼 이익/손해를 본다. (이익은 양수로, 손해는 음수로 주어진다)</li>
	<li>2 i : 직원 i의 현재 통장 잔액을 출력한다.</li>
</ul>

<p>직원들은 빈 통장을 갖고 일을 시작하며, 이익과 손해가 실시간으로 통장에 기록된다. 물론 통장 잔액은 음수일 수도 있다.</p>

<p>일을 시작하기 직전에&nbsp;플래티넘 승급전을 남겨두고 온 것을 떠올린 승범이는 우리에게 일을 맡기고 집으로 달려가버렸다.</p>

<p>만년 골드 승범이를 위해 문제를 대신 해결해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 승범이를 포함한 판매원들의 수 N(1 ≤ N ≤ 100,000), 명령의 수 M(1 ≤ M ≤ 100,000)이 주어진다. 판매원들은 1번부터 N번까지 번호가 매겨지며, 승범이는 항상 1번이다.</p>

<p>두 번째 줄에 판매원 1번부터 N번까지의 사수가 순서대로 공백으로 구분되어 주어진다. 승범이는 사수가 없으므로 -1이 주어진다.</p>

<p>세 번째 줄부터 M개의 줄에 걸쳐 위에서 설명한 명령(i, w는 정수, 1 ≤ i ≤ N, -10,000 ≤ w ≤ 10,000) 이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p class="MsoNoSpacing" style="margin:0cm 0cm 0.0001pt; text-align:justify">2번 명령이 주어질 때마다 한 줄에 하나씩 해당하는 직원 i의 잔고 상황을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 7
-1 4 1 1 1
1 3 10
2 3
1 1 -7
2 2
1 4 10
2 2
2 1
','10
-7
3
-7
','DATA_STRUCTURE'),
                                                                                                                (7578,'BAEKJOON','https://www.acmicpc.net/problem/16499',16499,'동일한 단어 그룹화하기','2초','512 MB',7,'<p>소문자로 이루어진 단어 N개가 주어졌을 때, 단어가 총 최소 몇 개의 그룹으로 이루어져 있는지 구하는 프로그램을 작성하시오.</p>

<p>그룹에 속한 단어는 모두 같은 알파벳으로 이루어져 있어야 하고, 개수도 같아야 한다. 즉, 단어를 구성하는 알파벳의 순서만 달라야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 단어의 개수 N이 주어진다. (2 ≤ N ≤ 100) 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 소문자로만 이루어져 있고, 길이는 10을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 그룹의 최소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
cat
dog
god
tca
','2
','DATA_STRUCTURE'),
                                                                                                                (7583,'BAEKJOON','https://www.acmicpc.net/problem/16562',16562,'친구비','2초','512 MB',12,'<p>19학번 이준석은 학생이 N명인 학교에 입학을 했다. 준석이는 입학을 맞아 모든 학생과 친구가 되고 싶어한다. 하지만 준석이는 평생 컴퓨터랑만 대화를 하며 살아왔기 때문에 사람과 말을 하는 법을 모른다. 그런 준석이에게도 희망이 있다. 바로 친구비다!</p>

<p>학생 i에게 <em>A<sub>i</sub></em>만큼의 돈을 주면 그 학생은 1달간 친구가 되어준다! 준석이에게는 총 k원의 돈이 있고 그 돈을 이용해서 친구를 사귀기로 했다. 막상 친구를 사귀다 보면 돈이 부족해질 것 같다는 생각을 하게 되었다. 그래서 준석이는 “친구의 친구는 친구다”를 이용하기로 했다.</p>

<p>준석이는 이제 모든 친구에게 돈을 주지 않아도 된다!</p>

<p>위와 같은 논리를 사용했을 때, 가장 적은 비용으로 모든 사람과 친구가 되는 방법을 구하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 학생 수 N (1 ≤ N ≤ 10,000)과 친구관계 수 M (0 ≤ M ≤ 10,000), 가지고 있는 돈 k (1 ≤ k ≤ 10,000,000)가 주어진다.</p>

<p>두번째 줄에 N개의 각각의 학생이 원하는 친구비 <em>A<sub>i</sub></em>가 주어진다. (1 ≤ <em>A<sub>i</sub></em> ≤ 10,000, 1 ≤ i ≤ N)</p>

<p>다음 M개의 줄에는 숫자 v, w가 주어진다. 이것은 학생 v와 학생 w가 서로 친구라는 뜻이다. 자기 자신과 친구일 수도 있고, 같은 친구 관계가 여러 번 주어질 수도 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>준석이가 모든 학생을 친구로 만들 수 있다면, 친구로 만드는데 드는 최소비용을 출력한다. 만약 친구를 다 사귈 수 없다면, “<code>Oh no</code>”(따옴표 제거)를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3 20
10 10 20 20 30
1 3
2 4
5 4
','20
','DATA_STRUCTURE'),
                                                                                                                (7584,'BAEKJOON','https://www.acmicpc.net/problem/16566',16566,'카드 게임','1.2초','512 MB',16,'<p>철수와 민수는 카드 게임을 즐겨한다. 이 카드 게임의 규칙은 다음과 같다.</p>

<ol>
	<li>N개의 빨간색 카드가 있다. 각각의 카드는 순서대로 1부터 N까지 번호가 매겨져 있다. 이 중에서 M개의 카드를 고른다.</li>
	<li>N개의 파란색 카드가 있다. 각각의 카드는 순서대로 1부터 N까지 번호가 매겨져 있다. 이 중에서 빨간색에서 고른 번호와 같은 파란색 카드 M개를 고른다.</li>
	<li>철수는 빨간색 카드를 가지고 민수는 파란색 카드를 가진다.</li>
	<li>철수와 민수는 고른 카드 중에 1장을 뒤집어진 상태로 낸다. 그리고 카드를 다시 뒤집어서 번호가 큰 사람이 이긴다. 이 동작을 K번 해서 더 많이 이긴 사람이 최종적으로 승리한다. 한 번 낸 카드는 반드시 버려야 한다.</li>
</ol>

<p>철수는 뛰어난 마술사이기 때문에 본인이 낼 카드를 마음대로 조작할 수 있다. 즉, 카드를 버리고 민수 몰래 다시 들고 온다거나 민수한테 없는 카드를 내기도 한다.</p>

<p>민수는 뛰어난 심리학자이기 때문에 철수가 낼 카드를 알아낼 수 있다. 그래서 민수는 철수가 낼 카드보다 큰 카드가 있다면 그 카드들 중 가장 작은 카드를 내기로 했다.</p>

<p>K번 동안 철수가 낼 카드가 입력으로 주어진다. 그렇다면 민수가 어떤 카드를 낼지 출력하라. 단, 민수가 카드를 내지 못하는 경우는 없다고 가정한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 세 개의 자연수 N, M, K가 주어진다. (1 ≤ M ≤ N ≤ 4,000,000, 1 ≤ K ≤ min(M, 10,000))</p>

<p>다음 줄에 카드의 번호를 나타내는 M개의 자연수가 주어진다. 각각의 수들은 1 이상이고 N 이하이며 서로 다르다.</p>

<p>다음 줄에 K개의 자연수가 주어진다. i번째 수는 철수가 i번째로 내는 카드의 번호이다. 철수가 내는 카드 역시 1 이상 N 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>K줄에 걸쳐서 수를 출력한다. i번째 줄에는 민수가 i번째로 낼 카드의 번호가 출력되어야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 7 5
2 5 3 7 8 4 9
4 1 1 3 8
','5
2
3
4
9
','DATA_STRUCTURE'),
                                                                                                                (7611,'BAEKJOON','https://www.acmicpc.net/problem/16682',16682,'삼원색','3초','256 MB',21,'<p>x축, y축으로 이루어진 평면 상에 직사각형들이 있다. 민성이는 지금부터 엄청나게 거대한 프린터기를 사용하여 이 평면 상의 직사각형들을 색칠할 것이다.</p>

<p>민성이에게는 3가지 색상 - 시안, 노랑, 그리고 자홍색의 잉크가 있다. 어떤 직사각형 위에는 시안색을 칠하고, 어떤 직사각형 위에는 노랑색, 또 다른 어떤 직사각형 위에는 자홍색을 칠할 수 있다.</p>

<p>어떤 경우에는 서로 다른 2개 이상의 직사각형의 영역이 겹쳐있어, 민성이가 가지고 있는 3가지 잉크의 색깔이 아닌 다른 색깔의 영역이 나타날 수 있다. 다음 그림은 시안, 노랑, 자홍색을 섞었을 때 나타날 수 있는 색깔들이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/d70b979b-3d34-41b9-9ff1-ac9a883796df/-/preview/" style="height: 375px; width: 375px;"><br>
&nbsp;</p>

<p style="text-align: center;">그림 1: 감산혼합의 3원색 CMYK.</p>

<p style="text-align: center;">&nbsp;</p>

<p>즉 빨간색은 자홍색과 노란색이, 초록색은 노란색과 시안색이, 파란색은 자홍색과 시안색이, 검은색은 자홍색과 노란색과 시안색이 동일한 비율로 섞인 색이다.</p>

<p>단, 민성이는 잉크를 아끼기 위해 한번 어떤 색깔로 색칠한 곳은 이후에 동일한 색깔의 겹치는 직사각형 영역이 나타나더라도 한번만 칠하기로 했다. 예를 들어서, (0, 0)부터 (2, 2)까지의 영역에 민성이가 노란색을 칠한 후 다시 (1, 1)부터 (3, 3)까지 노란색을 칠해야 하는 상황이 왔다면, (1, 1)부터 (2, 2)까지는 이미 노란색이 색칠되어 있으므로 다시 노란색을 덧칠하지 않는다. 이렇게 되면 3원색이 섞이는 비율이 항상 동일하기 때문에, 민성이가 잉크를 아끼게 됨과 동시에 위 그림에 나오지 않은 색깔이 등장할 일도 없어지게 된다.</p>

<p>당신은 서로 다른 색깔로 칠할 직사각형들이 주어졌을 때, 민성이가 주어진 색깔대로 모두 칠한 후 각 색깔별 영역의 넓이를 민성이가 일일이 색칠하기 전에 미리 구하고자 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 입력받을 직사각형의 개수 <em>N</em>이 주어진다. (1 ≤ <em>N</em> ≤ 25,000)</p>

<p>두 번째 줄부터 <em>N</em>개의 줄에 걸쳐 각 직사각형의 정보를 나타내는 정수 <em>x1, y1, x2, y2</em>와<em> </em>문자<em> c</em>가 공백으로 구분되어 주어진다. (-10<sup>8</sup> ≤&nbsp;<em>x1</em>&nbsp;<&nbsp;<em>x2</em> ≤&nbsp;10<sup>8</sup>, -10<sup>8</sup> ≤&nbsp;<em>y1</em> <&nbsp;<em>y2</em> ≤&nbsp;10<sup>8</sup>)</p>

<p>이는 해당하는 직사각형이 (<em>x1, y1</em>), (<em>x1, y2</em>), (<em>x2, y2</em>), (<em>x2, y1</em>)를 꼭짓점으로 가지고 <em>c</em>에 해당하는 색깔로 영역을 칠함을 의미한다.</p>

<p>모든 <em>c</em>는&nbsp;1글자짜리 문자로, “<code>C</code>”(시안), “<code>M</code>”(자홍), “<code>Y</code>”(노랑) 중 하나이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 일곱 개의 정수 <em>S<sub>c</sub>, S<sub>m</sub>, S<sub>y,</sub> S<sub>r</sub>, S<sub>g</sub>, S<sub>b</sub>, S<sub>k</sub></em>을 공백으로 구분하여 출력한다. 각각 시안색 영역의 넓이, 자홍색 영역의 넓이, 노란색 영역의 넓이, 빨간색 영역의 넓이, 초록색 영역의 넓이, 파란색 영역의 넓이, 그리고 검정색 영역의 넓이를 의미한다. (CMY RGB K)</p>

<p>(0,0), (1,0), (1,1), (0,1)을 꼭짓점으로 가지는 직사각형의 넓이는 1이다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
0 0 3 3 C
1 1 4 4 M
2 -1 5 2 Y
5 4 6 5 C','5 4 6 1 1 3 1','DATA_STRUCTURE'),
                                                                                                                (7604,'BAEKJOON','https://www.acmicpc.net/problem/16686',16686,'실시간 내비게이션','2.5초','512 MB',23,'<p>우리는 dijkstra가 고안한 알고리즘 덕분에 길을 쉽게 찾을 수 있지만, 그러다 보니 사람들은 몇몇 도로만 드나들게 되어 교통체증이 심해졌습니다. 이에 따라 한국도로공사는 도로의 통행시간 정보를 수정하여 내비게이션이 다른 경로를 추천하도록 하였습니다. 그러자 다른 도로들이 새롭게 막히기 시작했습니다.</p>

<p>새로운 도로들이 계속 막히다 보니 한국도로공사는 도로 정보를 더욱 자주 바꾸기 시작했습니다. 허나, dijkstra의 알고리즘은 도로 정보를 바꿀 때마다&nbsp;<em>O(E logV)</em>&nbsp;만큼 연산을 수행하기에 내비게이션 서버가 다운이 되어버렸습니다.</p>

<p>큰 문제가 생기자 내비게이션 회사는 도로 정보가 바뀔 때 빨리 최단경로를 구해주는 소프트웨어를 새로 짜기 시작했습니다. 회사는 우선 수요가 많은 강변북로 및 올림픽대로 구간만 모델링하여 최단경로를 구하려고 합니다.</p>

<p>한강 북쪽에 강변북로, 남쪽에 올림픽대로가 있으며 강변북로와 올림픽대로에 각각 <em>N</em> 개의 나들목이 있습니다. 강변북로에 있는 나들목의 코드는 가장 서쪽에 있는 것부터 순서대로 N-<em>1, </em>N-<em>2</em>, ... ,&nbsp;N-<em>N</em><em> </em>이고, 올림픽대로에 있는 나들목의 코드는 서쪽부터 순서대로 S-<em>1</em>, S-<em>2</em> , ... , S-<em>N</em><em> </em>입니다. 강변북로 <em>i</em> 번째 도로는 N-<em>i</em><em> </em>번 나들목과 N-<em>i+1</em><em> </em>번 나들목을 이으며, 올림픽대로 <em>i</em> 번째 도로는 S-<em>i</em><em> </em>번 나들목과 S-<em>i+1</em><em> </em>번 나들목을 잇습니다. 한강에 있는 <em>i&nbsp;</em>번째 다리는 N-<em>i</em> 번&nbsp;나들목과 S-<em>i</em> 번 나들목을 잇습니다. 각 도로 및 다리는 드나드는데 일정한 시간이 걸립니다.</p>

<p>내비게이션 서버는 맨 처음에 <em>3N-2&nbsp;</em>개&nbsp;도로의 통행 시간 정보를 갖고 있습니다. 거기에 더해, 내비게이션 서버는 한국도로공사 서버로부터 특정 도로의 통행 시간이 바뀌었다라는 정보를 받습니다. 이 정보를 토대로 내비게이션 서버는 수시로 운전자가 여기에서 저기로 가는 가장 빠른 길을 알려주세요라고 물을 때마다 재빨리 답을 구하여 보내야 합니다. 빠르게 두 종류의 쿼리를 처리하는 프로그램을 작성하세요. 단, 다리를 여러 번 건너는 경로도 답이 될 수 있습니다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 다리의 수 <em>N</em> 이 주어집니다. (2 ≤&nbsp;N ≤ 300,000)</p>

<p>두 번째 줄에는 강변북로에 있는 <em>N-1&nbsp;</em>개의 길을 지나는데 걸리는 시간 <em>N<sub>i</sub>&nbsp;</em>가 서쪽 도로부터 순서대로 주어집니다. (1 ≤&nbsp;<em>N<sub>i</sub></em> ≤ 1,000,000,000)</p>

<p>세 번째 줄에는 올림픽대로에 있는 <em>N-1&nbsp;</em>개의 길을 지나는데 걸리는 시간 <em>S<sub>i&nbsp;</sub></em>가 서쪽 도로부터 순서대로 주어집니다. (1 ≤&nbsp;<em>S<sub>i</sub></em> ≤ 1,000,000,000)</p>

<p>네 번째 줄에는 한강에 있는 <em>N</em> 개의 다리를 지나는데 걸리는 시간<em> B<sub>i</sub>&nbsp;</em>가 서쪽 다리부터 순서대로 주어집니다. (1 ≤&nbsp;<em>B<sub>i</sub></em> ≤ 1,000,000,000)</p>

<p>다섯 번째 줄에는 쿼리의 수 <em>Q</em>가 주어집니다. (1 ≤&nbsp;<em>Q</em>&nbsp;≤ 300,000)</p>

<p>여섯 번째 줄부터 <em>Q</em> 개의 줄에는 아래와 같은 형식으로 쿼리가 주어집니다.</p>

<ul>
	<li><em>1</em> <em>a b</em>&nbsp;: <em>a</em> 번 나들목에서 <em>b</em> 번 나들목까지 가는데 걸리는 최소 시간을 구해라. <em>a</em> 와 <em>b</em> 는 서로 다르며, 강변북로 <em>x</em> 번째 나들목은 <em>Nx</em> 꼴로, 올림픽대로 <em>x</em> 번째 나들목은 <em>Sx</em> 꼴로 주어진다.</li>
	<li><em>2</em>&nbsp;<em>a&nbsp;N<sub>a</sub></em>&nbsp;: 강변북로 <em>a</em> 번째 도로를 지나는데 걸리는 시간이 <em>N<sub>a</sub></em> 로 바뀐다. (1 ≤&nbsp;<em>a</em> ≤ <em>N-1</em>, 1 ≤&nbsp;<em>N<sub>a</sub></em> ≤ 1,000,000,000)</li>
	<li><em>3</em> <em>b S<sub>b</sub></em>&nbsp;: 올림픽대로 <em>b</em> 번째 도로를 지나는데 걸리는 시간이 <em>S<sub>b</sub></em> 로 바뀐다. (1&nbsp;≤ <em>b</em> ≤ <em>N-1</em>, 1 ≤&nbsp;<em>S<sub>b</sub></em> ≤ 1,000,000,000)</li>
	<li><em>4</em> <em>c B<sub>c</sub></em>&nbsp;: 한강에 있는 <em>c</em> 번째 다리를 지나는데 걸리는 시간이 <em>B<sub>c</sub></em> 로 바뀐다. (1 ≤ <em>c</em> ≤ <em>N</em>, 1 ≤&nbsp;<em>B<sub>c</sub></em> ≤ 1,000,000,000)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1번 쿼리에 대하여, 쿼리의 답을 한 줄에 하나씩 출력합니다. 1번 쿼리가 적어도 한 번 나오는 것은 보장됩니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1 2 1 1 1 2
1 1 1 3 3 1
10 9 7 12 11 8 10
6
1 N2 S4
4 6 2
1 N3 S5
3 3 8
2 4 2
1 N2 S4','10
8
14','DATA_STRUCTURE'),
                                                                                                                (7618,'BAEKJOON','https://www.acmicpc.net/problem/16724',16724,'피리 부는 사나이','1초','256 MB',13,'<p>피리 부는 사나이 성우는 오늘도 피리를 분다.</p>

<p>성우가 피리를 불 때면 영과일 회원들은 자기도 모르게 성우가 정해놓은 방향대로 움직이기 시작한다. 성우가 정해놓은 방향은 총 4가지로 U, D, L, R이고 각각 위, 아래, 왼쪽, 오른쪽으로 이동하게 한다.</p>

<p>이를 지켜보던 재훈이는 더 이상 움직이기 힘들어하는&nbsp;영과일 회원들을 지키기 위해 특정 지점에 ‘SAFE ZONE’ 이라는 최첨단 방음 시설을 만들어 회원들이 성우의 피리 소리를 듣지 못하게 하려고 한다. 하지만 예산이 넉넉하지 않은 재훈이는 성우가 설정해 놓은 방향을 분석해서 최소 개수의 ‘SAFE ZONE’을 만들려 한다.&nbsp;</p>

<p>성우가 설정한 방향 지도가 주어졌을 때 재훈이를 도와서 영과일 회원들이 지도 어느 구역에 있더라도 성우가 피리를 불 때 ‘SAFE ZONE’에 들어갈 수 있게 하는 ‘SAFE ZONE’의 최소 개수를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 지도의 행의 수를 나타내는 N(1&nbsp;≤ N ≤ 1,000)과 지도의 열의 수를 나타내는 M(1&nbsp;≤ M ≤ 1,000)이 주어진다.</p>

<p>두 번째 줄부터 N개의 줄에 지도의 정보를 나타내는 길이가 M인 문자열이 주어진다.</p>

<p>지도 밖으로 나가는 방향의 입력은 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 ‘SAFE ZONE’의 최소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
DLLL
DRLU
RRRU
','2
','DATA_STRUCTURE'),
                                                                                                                (7607,'BAEKJOON','https://www.acmicpc.net/problem/16856',16856,'감성 테트리스','1초','512 MB',22,'<p>디디는 1 X&nbsp;4 ㅡ자, 4 X 1 ㅣ자 모양 블럭으로만 진행되는 테트리스를 하고 있다. 이 테트리스는 어떤 블럭의 떨어질 위치를 정하면 그 위치에서 수직방향으로&nbsp;떨어지며, 수평방향으로 움직이거나 블럭을 회전시킬 수 없다. 또한 떨어지는 블럭의 아랫면이, 다른 블럭의 윗면 혹은 바닥과 1칸이라도 맞닿는다면, 이 블럭은 떨어지는 것을 멈추고 맞닿는 면 위에 쌓이게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/66bdf674-ba61-4841-992a-986b536c36ef/-/preview/" style="width: 385.833px; height: 97.5px;"></p>

<p>이 블럭이 떨어지면 그 밑에 있는 블럭들은 많이 아프겠ㄷr... 테트리스를 감성으로 하는 디디는 어떤 블럭이 떨어질 때 하중을 받는 블럭의 개수를 구하려고 한다. 떨어지는 블럭의 아랫면과 면을 공유하는 블럭은 하중을 받으며, 하중을 받은 블럭들의 아랫면과 면을 공유하는 블럭들 또한 하중을 받게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/01552d51-5532-45aa-9dc0-45affd7a5bd7/-/preview/" style="height: 70.8333px; width: 347.5px;"></p>

<p style="text-align: center;"><빨간색&nbsp;블럭은 이번에 떨어뜨린 블럭이며, 노란색 블럭은 이때&nbsp;하중을 받는 블럭이다.></p>

<p>착한 leejseo는 감성이 풍부한 디디를 위해, 디디가 블럭을 떨어뜨릴 때마다 그 블럭의 하중을 받는 블럭의 개수를 구하는 프로그램을 작성하려고 한다. leejseo를 따라서 디디를 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 디디가 떨어뜨린 블럭의 개수 <em>Q</em>(1 ≤ <em>Q</em> ≤ 10<sup>5</sup>)가 주어진다.<br>
둘째 줄부터 <em>Q</em>개의 각 줄에는 디디가 떨어뜨린 블럭에 대한 정보가 주어진다.<br>
각 줄은 아래 2개 중 하나의 형식을 가지고 있다.</p>

<ul>
	<li>1 <em>a</em> : 블럭의 왼쪽 끝 칸이 위치 <em>a</em>에 위치하게 ㅡ자 모양의 블럭을&nbsp;떨어뜨린다.</li>
	<li>2 <em>a</em> : 위치 <em>a</em>에 ㅣ자 모양의 블럭을 떨어뜨린다.</li>
</ul>

<p>단, <em>a</em>는 항상 정수이며 블럭의 어떤 부분도 위치 1 ~ 400,000를 벗어나지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em>개의 각 줄에 디디가 블럭을 떨어뜨릴 때마다 그 블럭의 하중을 받는 블럭의 개수를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
1 5
2 5
2 6
2 7
2 8
1 5
','0
1
1
1
1
5
','DATA_STRUCTURE'),
                                                                                                                (7605,'BAEKJOON','https://www.acmicpc.net/problem/16858',16858,'고양이 소개팅','4초','1024 MB',20,'<p>류트나라에는 거대한 캣타워가 있다. 캣타워는 루트 있는 트리 구조를 이루고 있다. 따라서 캣타워에는 1번부터 n번까지 번호가 붙여진 총 n개의 보금자리가 있고, 보금자리에 연결된 n-1개의 통로가 있다. 캣타워의 맨 위에는 항상 1번 보금자리가 있다. 캣타워에 사는 고양이들은 아래쪽 통로를 통해서 살던 보금자리에서 다른 보금자리로 떨어질 수 있다. 단, 고양이들이 통로를 타고 올라갈 수는 없다.&nbsp;캣타워가 루트 있는 트리 구조이기 때문에, 맨 위 보금자리를 제외하면 임의의 보금자리로 곧바로 떨어질 수 있는 통로는 단 하나 존재한다. 또한 어떤 보금자리에서 다른 보금자리로 떨어질 수 있다면 그 경로는 유일하며, 모든 보금자리는 통로로 이어져 있다. &nbsp;i번 보금자리에는 암컷 또는 수컷 고양이가 c<sub>i</sub>마리 살고 있다. i번 보금자리로 곧바로 떨어질 수 있는 통로는 길이가 d<sub>i</sub>이다. 한 보금자리에서 다른 보금자리로 이동하는 경로의 길이는 한 통로를 두 번 이상 지나지 않으면서 이동할 때 지나게 되는 모든 통로의 길이의 합이 된다.</p>

<p>고양이들은 오늘 단체로 소개팅을 하려고 한다. 고양이들의 소개팅 한 쌍은 암컷 고양이 한 마리와 수컷 고양이 한 마리가 만나서 이뤄진다. 소개팅에 가기 위해서 수컷 고양이는 아래쪽 통로를 통해 이동할 수 있는 보금자리로 뛰어내릴 수 있다. 하지만 공중 곡예비행의 대가라고 불리는 고양이들도 너무 많이 떨어지면 다치기 때문에, i번 보금자리에 사는 고양이들은 원래 살던 보금자리로부터 경로의 길이가 v<sub>i</sub>를 초과하는 정점으로는 뛰어내리지 않기로 했다. 시장 leejseo는 가능한 많은 쌍의 소개팅이 이뤄지길 원한다. leejseo는 어떻게 하면 소개팅 횟수를 최대화 할 수 있을까 고민하다, 당신에게 그 작업을 맡기기로 했다. 캣타워의 구조와 고양이들의 정보가 주어질 때, 성사될 수 있는 소개팅 횟수의 최댓값을 구하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 캣타워 내 보금자리의 개수 n (1 ≤ n ≤ 200,000)이 주어진다.&nbsp;</p>

<p>두 번째 줄에 1번 보금자리부터 n번 보금자리에 사는 고양이의 수 c<sub>i</sub> (1 ≤ c<sub>i</sub>&nbsp;≤ 10<sup>8</sup>)가 차례대로 주어진다.</p>

<p>세 번째 줄에, 1번 보금자리부터 n번 보금자리에 사는 고양이가 떨어질 수 있는 최대 높이 v<sub>i</sub>&nbsp;(v<sub>i</sub>는 -1이거나 1&nbsp;≤ v<sub>i</sub>&nbsp;≤ 10<sup>8</sup>)가 차례대로 주어진다. 만약 v<sub>i</sub>가 1&nbsp;이상의 정수라면, i번 보금자리에는 c<sub>i</sub>마리의 수컷 고양이가 살고 있다. v<sub>i</sub>가 -1이라면, 그 보금자리에는 c<sub>i</sub>마리의 암컷 고양이가 살고 있다.</p>

<p>네 번째 줄에 2번 보금자리부터 n번 보금자리까지 그 보금자리로 곧바로 떨어질 수 있는 보금자리 a<sub>i</sub>&nbsp;(1&nbsp;≤ a<sub>i</sub>&nbsp;≤ n)가 차례대로 주어진다.</p>

<p>다섯 번째 줄에 2번 보금자리부터 n번 보금자리까지 그 보금자리로 곧바로 떨어질 수 있는 통로의 길이&nbsp;d<sub>i</sub>&nbsp;(1 ≤ d<sub>i</sub>&nbsp;≤ 10<sup>8</sup>)가 차례대로 주어진다.&nbsp;&nbsp; &nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 성사될 수 있는 소개팅 횟수의 최댓값을 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
5 4 3 6 2
-1 3 5 -1 5
3 1 2 1
4 1 3 2
','4
','DATA_STRUCTURE'),
                                                                                                                (7615,'BAEKJOON','https://www.acmicpc.net/problem/16903',16903,'수열과 쿼리 20','1초','512 MB',18,'<p>0이 하나 포함되어 있는 배열 A가 있다. 이때, 다음 쿼리를 수행해야 한다.</p>

<ul>
	<li><code>1 x</code>: A에 x를 추가한다.</li>
	<li><code>2 x</code>: A에서 x를 제거한다. A에 x가 두 개 이상 있는 경우에는 하나만 삭제한다. 항상 A에 x가 있는 쿼리만 주어진다.</li>
	<li><code>3 x</code>: A에 포함된 각각의 원소와 x를 XOR 연산을 한 다음, 가장 큰 값을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 쿼리의 개수 M(1 ≤ M ≤ 200,000)이 주어진다. 둘째 줄부터 M개의 줄에 쿼리가 주어진다. 입력으로 주어지는 x의 범위는 10<sup>9</sup>보다 작거나 같은 자연수이다.</p>

<p>3번 쿼리는 하나 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>쿼리를 수행한 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 8
1 9
1 11
1 6
1 1
3 3
2 8
3 3
3 8
3 11
','11
10
14
13
','DATA_STRUCTURE'),
                                                                                                                (7621,'BAEKJOON','https://www.acmicpc.net/problem/16905',16905,'XOR 부분 행렬','2초','512 MB',18,'<p>크기가 N인 배열 V와 크기가 M인 배열 V를 이용해서 크기가 N×M인 행렬 A를 만들 수 있다. 이때, A<sub>ij</sub> = V<sub>i</sub> xor U<sub>j</sub> 이다.</p>

<p>A의 부분 행렬 중에서, 부분 행렬에 포함된 원소를 모두 xor한 값이 가장 큰 것을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 배열의 크기 N과 M이 주어진다. 둘째 줄에는 V<sub>1</sub>, V<sub>2</sub>, ..., V<sub>N</sub>이, 셋째 줄에는 U<sub>1</sub>, U<sub>2</sub>, ..., U<sub>M</sub>이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>A의 부분 행렬 중에서, 부분 행렬에 포함된 원소를 모두 xor한 값이 가장 큰 것을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
5 3 1
2 1 2 4
','7
','DATA_STRUCTURE'),
                                                                                                                (7617,'BAEKJOON','https://www.acmicpc.net/problem/16906',16906,'욱제어','1초','512 MB',17,'<p>욱제어는 욱제가 사용하는 언어이고, 알파벳으로 0과 1만 사용한다. 욱제어에는 N개의 단어가 있는데, 각 단어의 길이는 L<sub>1</sub>, L<sub>2</sub>, ..., L<sub>N</sub>이다. 욱제어를 사용하는 사람들은 단어를 끝까지 말하지 않아도, 서로 어떤 단어인지 이해하는 경우가 많다. 그 이유는 한 단어가 다른 단어의 접두어(Prefix)가 되는 경우가 없기 때문이다.</p>

<p>욱제어를 공부하고 싶었던 동탄 주민 준오는 욱제어에 대한 정보를 몰래 입수했다. 하지만, 단어는 입수하지 못하고 단어의 길이만 입수하는데 성공했다. N개의 단어 길이 L<sub>1</sub>, L<sub>2</sub>, ..., L<sub>N</sub>이 주어졌을 때, 한 단어가 다른 단어의 접두어가 되지 않게 단어를 만들 수 있는지 알아보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 단어의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 L<sub>1</sub>, L<sub>2</sub>, ..., L<sub>N</sub>이 주어진다. 단어 길이의 총합은 1,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>욱제어 단어를 N개 만드는 것이 가능하면, 첫째 줄에 1을 출력하고, 둘째 줄부터 N개의 줄에 욱제어의 단어를 한 줄에 하나씩 출력한다. 단어는 입력으로 주어진 순서를 만족해야 한다. 즉, 길이가 L<sub>1</sub>인 단어, 길이가 L<sub>2</sub>인 단어, ..., 길이가 L<sub>N</sub>인 단어를 출력해야 한다.</p>

<p>욱제어 단어를 N개 만드는 것이 불가능하면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2 3
','1
0
10
110
','DATA_STRUCTURE'),
                                                                                                                (7628,'BAEKJOON','https://www.acmicpc.net/problem/16909',16909,'카드 구매하기 3','2초','512 MB',18,'<p>욱제는 민규네 동네에서 유행하는 <a href="/problem/11052">PS카드</a>를 구매하려고 한다. 욱제가 방문한 카드 가게에는 총 N개의 카드가 일렬로 놓여져 있고, i번째 카드의 능력치는 A<sub>i</sub>이다.</p>

<p>욱제는 진열된 카드를 연속해서 구매하는 것을 좋아한다. 즉, 욱제는 i번째 카드부터 j번째 카드를 구매하게 된다. 구매한 카드의 가격은 능력치에 영향을 받는다. 카드를 구매하는 비용은 구매하려고 하는 카드 능력치의 최댓값에서 최솟값을 뺀 값이다.</p>

<p>예를 들어, 카드의 능력치가 [2, 5, 3]인 경우, 욱제는 이 카드를 6가지 방법으로 구매할 수 있다.</p>

<ul>
	<li>i = 1, j = 1: [2], 가격: 2-2 = 0</li>
	<li>i = 1, j = 2: [2, 5], 가격: 5-2 = 3</li>
	<li>i = 1, j = 3: [2, 5, 3], 가격: 5-2 = 3</li>
	<li>i = 2, j = 2: [5], 가격: 5-5 = 0</li>
	<li>i = 2, j = 3: [5, 3], 가격: 5-3 = 2</li>
	<li>i = 3, j = 3: [3], 가격: 3-3 = 0</li>
</ul>

<p>욱제가 카드를 구매할 수 있는 방법을 모두 구하고, 그 때 가격의 합을 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 진열대에 놓인 카드의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다.</p>

<p>둘째 줄에는 카드의 능력치 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>(1 ≤ A<sub>i</sub> ≤ 1,000,000)이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 카드를 구매하는 모든 방법의 가격의 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
2 5 3
','8
','DATA_STRUCTURE'),
                                                                                                                (7629,'BAEKJOON','https://www.acmicpc.net/problem/16910',16910,'mex와 쿼리','2초','512 MB',21,'<p>mex는 어떤 수열에 포함되지 않은 수 중에서 가장 작은 자연수를&nbsp;찾는 함수이다. 예를 들어, mex([1,2,3]) = 4, mex([5,3,1,1,4]) = 2, mex([1,5,2,1,5,2,1,2]) = 3이다.</p>

<p>비어있는 배열 A와 쿼리 N개가 주어졌을 때, 쿼리를 수행해보자. 쿼리는 총 3가지가 있으며, 아래와 같다.</p>

<ul>
	<li><code>1 l r</code>: 구간 [l, r]에 속하는 모든 자연수를 배열 A에 추가한다. 배열에 이미 있는 자연수는 또 추가하지 않는다.</li>
	<li><code>2 l r</code>: 구간 [l, r]에 속하는 모든 자연수를 배열 A에서 제거한다.</li>
	<li><code>3 l r</code>: 구간 [l, r]에 속하는 모든 자연수 x에 대해서, 다음을 수행한다.
	<ul>
		<li>x가 배열 A에 있으면, 배열에서 제거한다.</li>
		<li>x가 배열 A에 없으면, 배열에 추가한다.</li>
	</ul>
	</li>
</ul>

<p>각 쿼리를 수행한 다음에 mex(A)를 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 쿼리의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 쿼리를 나타내는 q, l, r (1 ≤ q ≤ 3, 1 ≤ l ≤ r ≤ 10<sup>18</sup>)이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리를 수행한 후에 mex(A)를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 3 4
3 1 6
2 1 3
','1
3
1
','DATA_STRUCTURE'),
                                                                                                                (7631,'BAEKJOON','https://www.acmicpc.net/problem/16911',16911,'그래프와 쿼리','2초','512 MB',21,'<p>N개의 정점으로 이루어진 그래프 G가 있다. 가장 처음에 G에는 간선이 없다. 아래와 같은 쿼리를 수행해보자.</p>

<ul>
	<li>1 A B: 정점 A와 B를 연결하는 간선을 추가한다. 쿼리가 주어지기 전에 A와 B사이에는 간선이 없다.</li>
	<li>2 A B: 정점 A와 B를 연결하는 간선을 제거한다. 쿼리가 주어지기 전에 A와 B사이에는 간선이 있다.</li>
	<li>3 A B: 정점 A에서 B로 가는 경로가 있는지 없는지 조사한다. 있는 경우에는 1, 없는 경우에는 0을 출력한다.</li>
</ul>

<p>모든 A와 B는 1 ≤ A, B ≤ N, A ≠ B를 만족하고, 모든 간선은 방향이 없다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 N(2&nbsp;≤ N ≤ 100,000)과 쿼리의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 11
1 1 2
1 2 3
1 3 4
1 1 4
3 4 2
2 1 2
3 2 4
2 3 4
3 4 2
1 2 4
3 4 2
','1
1
0
1
','DATA_STRUCTURE'),
                                                                                                                (7634,'BAEKJOON','https://www.acmicpc.net/problem/16912',16912,'트리와 쿼리 12','2초','512 MB',21,'<p>N개의 정점으로 이루어진 루트없는 트리의 포레스트 F가 있다. 가장 처음에 F에 속하는 모든 트리는 정점 하나로만 이루어져 있는 트리이다.&nbsp;아래와 같은 쿼리를 수행해보자.</p>

<ul>
	<li>1 A B: 정점 A와 B를 연결하는 간선을 추가한다. 쿼리가 주어지기 전에 A와 B사이에는 간선이 없다.</li>
	<li>2 A B: 정점 A와 B를 연결하는 간선을 제거한다. 쿼리가 주어지기 전에 A와 B사이에는 간선이 있다.</li>
	<li>3 A B: 정점 A에서 B로 가는 경로가 있는지 없는지 조사한다. 있는 경우에는 1, 없는 경우에는 0을 출력한다.</li>
</ul>

<p>모든 A와 B는 1 ≤ A, B ≤ N, A ≠ B를 만족하고, 모든 간선은 방향이 없다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 N(2&nbsp;≤ N ≤ 100,000)과 쿼리의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에 쿼리가 한 줄에 하나씩 주어진다. 쿼리의 수행 결과가 포레스트인 입력만 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 11
3 1 5
1 1 2
1 1 3
1 3 4
1 5 4
3 1 5
2 4 5
3 1 5
2 3 4
1 3 5
3 1 5
','0
1
0
1
','DATA_STRUCTURE'),
                                                                                                                (7638,'BAEKJOON','https://www.acmicpc.net/problem/16950',16950,'레드 블루 스패닝 트리 2','1초','128 MB',19,'<p>무방향, 무가중치, 연결 그래프가 주어진다. 그래프의 각 간선은 빨간색 또는 파란색으로 색칠되어져 있다. 이 그래프의 스패닝 트리 중 파란색 간선이 정확히 k개인 것이 있는지 없는지 알아내고, 있으면 그 중 아무거나 하나를 출력하는&nbsp;프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 세 정수 n, m, k가 주어진다. n은 그래프의 정점의 개수 (2 ≤ n ≤ 1,000)이고, m은 간선의 개수, k는 문제에 설명되어 있는 파란색 간선의 개수 (0 ≤ k < n) 이다.</p>

<p>다음 m개 줄에는 간선의 정보가 주어지며, 각 정보는 세 정수 c, f, t로 이루어져 있다. c는 간선의 색상을 나타내며, 빨간색인 경우에는 R, 파란색인 경우에는 B이다. f와 t는 정수로 간선이 연결하는 두 정점을 나타낸다. (1 ≤ f, t ≤ n, f&nbsp;≠ t) 두 정점을 연결하는 간선은 최대 한 개이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>파란색 간선이 정확하게 k개인 스패닝 트리를 만들 수 있으면 총 n-1개의 줄을 출력한다. 각 줄에 하나씩 한 간선의 양 끝점의 번호를 차례대로 출력한다.</p>

<p>조건을 만족하는 스패닝 트리를 만들 수 없으면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3 2
B 1 2
B 2 3
R 3 1
','1 2
2 3
','DATA_STRUCTURE'),
                                                                                                                (7637,'BAEKJOON','https://www.acmicpc.net/problem/16957',16957,'체스판 위의 공','2초','512 MB',12,'<p>크기가 R×C인 체스판이 있고, 체스판의 각 칸에는 정수가 하나씩 적혀있다. 체스판에 적혀있는 정수는 모두 서로 다르다.</p>

<p>체스판의 각 칸 위에 공을 하나씩 놓는다. 이제 공은 다음과 같은 규칙에 의해서 자동으로 움직인다.</p>

<ul>
	<li>인접한 8방향 (가로, 세로, 대각선)에 적힌 모든 정수가&nbsp;현재 칸에 적힌 수보다 크면 이동을 멈춘다.</li>
	<li>그 외의 경우에는 가장 작은 정수가 있는 칸으로 공이 이동한다.</li>
</ul>

<p>공의 크기는 매우 작아서, 체스판의 한 칸 위에 여러 개의 공이 있을 수 있다. 체스판의 상태가 주어진다. 공이 더 이상 움직이지 않을 때, 각 칸에 공이 몇 개 있는지 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 체스판의 크기 R, C가 주어진다. 둘째 줄부터 R개의 줄에 체스판에 적혀있는 정수가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 R개의 줄에 걸쳐서 체스판에 적힌 정수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
1 3 4
5 6 7
8 9 2
','6 0 0
0 0 0
0 0 3
','DATA_STRUCTURE'),
                                                                                                                (7663,'BAEKJOON','https://www.acmicpc.net/problem/16964',16964,'DFS 스페셜 저지','2초','512 MB',13,'<p>BOJ에서 정답이 여러가지인 경우에는 스페셜 저지를 사용한다.&nbsp;스페셜 저지는 유저가 출력한 답을 검증하는 코드를 통해서 정답 유무를 결정하는 방식이다. 오늘은 스페셜 저지 코드를 하나 만들어보려고 한다.</p>

<p>정점의 개수가 N이고, 정점에 1부터 N까지 번호가 매겨져있는 양방향 그래프가 있을 때, DFS 알고리즘은 다음과 같은 형태로 이루어져 있다.</p>

<pre class="brush:c++; toolbar:false;">void dfs(int x) {
&nbsp;   if (check[x] == true) {
&nbsp;       return;
&nbsp;   }
    check[x] = true;
    // x를 방문
    for (int y : x와 인접한 정점) {
        if (check[y] == false) {
            dfs(y);
        }
    }
}
</pre>

<p>이 문제에서 시작 정점은 1이기 때문에 가장 처음에 호출하는 함수는 <code>dfs(1)</code>이다. DFS 방문 순서는 <code>dfs</code>함수에서&nbsp;<code>// x를 방문</code>&nbsp;이라고 적힌 곳에 도착한 정점 번호를 순서대로 나열한 것이다.</p>

<p>트리가 주어졌을 때, 올바른 DFS 방문 순서인지 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 수 N(2&nbsp;≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에는 트리의 간선 정보가 주어진다. 마지막 줄에는 DFS&nbsp;방문 순서가 주어진다. DFS 방문 순서는 항상 N개의 정수로 이루어져 있으며, 1부터 N까지 자연수가 한 번씩 등장한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력으로 주어진 DFS 방문 순서가 올바른 순서면 1, 아니면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2
1 3
2 4
1 2 3 4
','0
','DATA_STRUCTURE'),
                                                                                                                (7647,'BAEKJOON','https://www.acmicpc.net/problem/16975',16975,'수열과 쿼리 21','2초','512 MB',17,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i j k</code>: A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>에 k를 더한다.</li>
	<li><code>2 x</code>: A<sub>x</sub>&nbsp;를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub>&nbsp;≤ 1,000,000)</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. 1번 쿼리의 경우 1 ≤ i ≤ j ≤ N, -1,000,000&nbsp;≤ k ≤ 1,000,000 이고, 2번 쿼리의 경우 1 ≤ x ≤ N이다. 2번 쿼리는 하나 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리가 주어질 때마다 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 4 5
4
1 3 4 6
2 3
1 1 3 -2
2 3
','9
7
','DATA_STRUCTURE'),
                                                                                                                (7646,'BAEKJOON','https://www.acmicpc.net/problem/16976',16976,'민혁이의 게임 파티','2초','512 MB',19,'<p>민혁이와 N-1명의 친구들이 게임을 하나씩 구매했다. 구매할 수 있는 게임은 총 M가지이고, 1번부터 M번까지 번호가 매겨져 있다. 모든 게임은 멀티플레이어 게임이고, 인터넷에 연결할 필요 없이 로컬 네트워크로 즐길 수 있다.</p>

<p>게임은 모여서 다같이 하면 더욱 재밌다. 민혁이는 컴퓨터를 N대 구매해 지하실에 모두 설치했고, 아직 모든 컴퓨터는 네트워크와 연결되어 있지 않다.</p>

<p>친구들은 자신이 구매한 게임을 민혁이네&nbsp;지하실에서 하려고 한다. 민혁이는 바쁜 시간 쪼개서 모인 소중한 시간인데, 각자 알아서 게임을 하는 것은 그렇게 가치 있는 시간이라고 생각하지 않는다. 따라서, 같은 게임을 구매한 사람은 모두 같이 게임을 해야 한다.</p>

<p>현재 어떤 컴퓨터도 서로 연결되어 있지 않은 상태이다. 컴퓨터는 총 Q개의 랜선을 이용해서 연결하려고 한다. 랜선은 두 컴퓨터 u와 v를 연결할 수 있다. 민혁이는 랜선을 하나씩 순서대로 연결한다.</p>

<p>임의의 두 컴퓨터 x와 y가 같은 로컬 네트워크에 속한다는 의미는 컴퓨터 x에서 랜선을 이용해서 y로 갈 수 있을 때를 의미한다.</p>

<p>각 사람이 몇 번째 랜선이 연결되면 게임을 시작할 수 있는지 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 사람과 컴퓨터의 수 N, 게임 종류의 수 M, 랜선의 수 Q가 주어진다.</p>

<p>둘째 줄에는 각 사람이 구매한 게임의 번호가 주어진다.</p>

<p>셋째 줄부터 Q개의 줄에는 랜선이 연결하는 두 컴퓨터의 번호가 주어진다. 같은 컴퓨터를 여러 번 연결하는 경우도 존재한다.</p>

<p>컴퓨터와 사람의 번호는 1부터 N까지 하나씩 매겨져 있다. 각 게임을 고른 사람의 수는 최소 1명이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 M개의 줄에 i번 게임을 구매한 사람은 몇 번째 랜선이 연결되면 게임을 시작할 수 있는지 출력한다. 만약, 어떤 게임을 구매한 사람이 1명이라 랜선의 연결이 필요하지 않으면 0을 출력한다. 랜선을 모두 연결해도 게임을 시작할 수 없다면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2 4
1 2 2 2 1
1 2
2 3
1 5
4 5
','3
4
','DATA_STRUCTURE'),
                                                                                                                (7645,'BAEKJOON','https://www.acmicpc.net/problem/16977',16977,'히스토그램에서 가장 큰 직사각형과 쿼리','4초','512 MB',23,'<p>히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형이다. 각 직사각형은 같은 너비를 가지고 있지만, 높이는 서로 다를 수도 있다. 예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.</p>

<p style="text-align: center;"><img alt="" src=https://www.acmicpc.net/upload/images/histogram.png" style="height: 110.833px; width: 351.667px;"></p>

<p>히스토그램에서 아래와 같은 쿼리 Q개를 수행해보자.</p>

<ul>
	<li><code>l r w</code>: l번째 직사각형부터 r번째 직사각형까지만 있을 때, 너비가 w이면서 가장 넓이가 큰 직사각형의 높이를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 직사각형의 수 N이&nbsp;주어진다. 둘째 줄에는&nbsp;N개의 정수 h<sub>1</sub>, ..., h<sub>n</sub>&nbsp;가 주어진다. 이 숫자들은 히스토그램에 있는 직사각형의 높이이며, 왼쪽부터 오른쪽까지 순서대로 주어진다. 모든 직사각형의 너비는 1이다.</p>

<p>셋째 줄에는 쿼리의 수 Q가 주어진다. 넷째 줄부터 Q개의 줄에는 쿼리가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
2 1 4 5 1 3 3
8
3 4 2
4 7 2
2 5 1
2 5 2
2 5 3
2 5 4
1 3 2
6 7 2
','4
3
5
4
1
1
1
3
','DATA_STRUCTURE'),
                                                                                                                (7648,'BAEKJOON','https://www.acmicpc.net/problem/16978',16978,'수열과 쿼리 22','1초','512 MB',17,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i v</code>: A<sub>i</sub>&nbsp;= v로 변경한다.</li>
	<li><code>2 k i j</code>: k번째 1번 쿼리까지 적용되었을 때, A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>의 합을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub>&nbsp;≤ 1,000,000)</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. 1번 쿼리의 경우 1 ≤ i ≤ N, 1 ≤ v ≤ 1,000,000 이고, 2번 쿼리의 경우 1 ≤ i ≤ j ≤ N이고, 0 ≤ k ≤ (쿼리가 주어진 시점까지 있었던 1번 쿼리의 수)이다.</p>

<p>입력으로 주어지는 모든 수는 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 2번 쿼리마다 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 4 5
7
1 2 5
2 0 1 3
2 1 1 3
1 4 2
2 0 2 5
2 1 2 5
2 2 2 5
','6
9
14
17
15
','DATA_STRUCTURE'),
                                                                                                                (7649,'BAEKJOON','https://www.acmicpc.net/problem/16979',16979,'수열과 쿼리 23','5초','512 MB',20,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>s e</code>: s ≤ i < j ≤ e 이면서 A<sub>i</sub> > A<sub>j</sub>인 (i, j) 쌍의 개수를 출력한다. (1 ≤ s ≤ e ≤ N)</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000), 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub>&nbsp;≤ 1,000,000,000)</p>

<p>셋째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 쿼리마다 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
1 4 2 3 1
1 2
3 5
1 5
','0
2
5
','DATA_STRUCTURE'),
                                                                                                                (7654,'BAEKJOON','https://www.acmicpc.net/problem/16993',16993,'연속합과 쿼리','2초','512 MB',20,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>i j</code> : A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>에서 가장 큰 연속합을 출력한다. (1 ≤ i ≤ j ≤ N)</li>
</ul>

<p>수열의 인덱스는 1부터 시작한다.</p>

<p>연속합은 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합이며, 수는 한 개 이상 선택해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (-1,000 ≤ A<sub>i</sub> ≤ 1,000)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>쿼리의 정답을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
10 -4 3 1 5 6 -35 12 21 -1
10
1 1
3 4
1 6
2 6
6 6
7 7
8 9
8 10
1 10
5 8
','10
4
21
15
6
-35
33
33
33
12
','DATA_STRUCTURE'),
                                                                                                                (7674,'BAEKJOON','https://www.acmicpc.net/problem/17076',17076,'망가진 데이터','1초','512 MB',18,'<p>택희는 이번 대회에 사용하기 위해 그래프를 몇 개 만들었다.</p>

<p>택희의 그래프 데이터는 항상 아래의 형식을 따른다.</p>

<blockquote>
<p><em>N M U<sub>1</sub> V<sub>1</sub> U<sub>2</sub> V<sub>2</sub> U<sub>3</sub> V<sub>3</sub> ... U<sub>M</sub> V<sub>M</sub></em></p>
</blockquote>

<p>위는 정점이 <em>N</em>개, 간선이 <em>M</em>개인 그래프 데이터로, 모든 <em>U<sub>i</sub></em>, <em>V<sub>i</sub></em>에 대해 1 ≤ <em>U<sub>i</sub></em>, <em>V<sub>i</sub></em> ≤&nbsp;<em>N</em>을 만족하며, <em>N</em>과 <em>M</em> 뒤에 등장하는 간선 정보(<em>U</em>, <em>V</em> 페어)는 정확히 <em>M</em>개이다. 그 외의 다른 조건은 없다.</p>

<p>택희는 대회에 사용할 모든 그래프를 만들었고, 데이터를 업로드하려던 그 순간!&nbsp;갑자기 영훈이가 나타나 데이터의 여기저기에 임의의 정수를 몇 개 써 넣어 버렸고, 택희는 순간적인 상황 변화를 받아들이지 못하고 격한 욕설을 내뱉으며 영훈이에게 당장 원래 데이터로 고쳐&nbsp;두라고 말한 뒤 자리를 떠나 버렸다.</p>

<p>영훈이는 최대한 빠르게 그래프 데이터를 복원해야 한다. 하지만 자신이 어디에&nbsp;어떤 수를 썼는지&nbsp;전혀 기억하지 못하는 영훈이는 고민에 빠졌다.</p>

<p>영훈이는 자신이 데이터에 한 일은 수를 임의의 위치에 넣은 것뿐이라는 것을 알기에, 데이터에서 몇 개의 수를 지워 그래프 데이터를 만들려 한다. 즉, 수들의 원래 순서를 유지하면서 수 일부를 지워, 남은 수들이 올바른 데이터 가 되도록 하려는 것이다. 이때 올바른 데이터 란,</p>

<ul>
	<li>4개 이상의 정수로 이루어져 있고,</li>
	<li>택희가 처음 만든 데이터의 형식을 따르며,</li>
	<li>택희가 지키려 했던 모든 조건을 지키고 있는 데이터를 의미한다.</li>
</ul>

<p>영훈이는 그래프를 복원할 방법이 여러 가지라면 기왕이면 노드의 수(<em>N</em>)가&nbsp;가장 큰 것을, 그러한 것도 여러 가지라면 간선의 수(<em>M</em>)가 가장&nbsp;큰 것을 복원할 것이다.</p>

<p>현재 데이터의 상태가 주어졌을 때, 영훈이가 복원할 그래프의 노드의 수와 간선의 수를 알아내보도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 데이터에 기록되어 있는 정수의 개수 <em>K</em>가 주어진다. (4&nbsp;≤ <em>K</em>&nbsp;≤ 200,000)</p>

<p>이어 둘째 줄에 데이터에 기록된 수 <em>a<sub>1</sub></em>, <em>a<sub>2</sub></em>, ..., <em>a<sub>k</sub></em>가 순서대로 공백으로 구분되어 주어진다. (1&nbsp;≤ <em>a<sub>i</sub></em>&nbsp;≤ 200,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>영훈이가 복원할 그래프의 노드의 수 <em>N</em>과 간선의 수 <em>M</em>을 공백으로 구분하여 출력한다.</p>

<p>그러한 것이 여러 가지라면 <em>N</em>이 가장 큰 것을, 그런 것도 여러 가지라면 <em>M</em>이 가장 큰 것을 골라야 한다.</p>

<p>만약 수를 어떻게 지우더라도 올바른 데이터를 만들 수 없다면 첫째 줄에 -1 하나만을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2 1 1 1
','2 1
','DATA_STRUCTURE'),
                                                                                                                (7602,'BAEKJOON','https://www.acmicpc.net/problem/17082',17082,'쿼리와 쿼리','2초','512 MB',17,'<p>겨울이 가고 날이 풀리자, 택희는 겨울 옷을 세탁해 보관하고, 한참 동안 입지 않았던 후드를 하나 꺼냈다. 옷을 입던 택희는 후드의 주머니 안에 무언가 들어있음을 알아차렸다. 놀랍게도, 후드의 왼쪽 주머니와 오른쪽 주머니 안에는, 정확히 <em>M</em>개씩의 정수가 들어 있었다.</p>

<p>택희는 2018 연세대학교 교내 경진대회 문제에 사용했던 수열 하나를 꺼내 깨끗이 닦았다. 수열은 <em>N</em>개의 정수로 이루어져 있으며, 인덱스는 1, 2, …, <em>N</em>으로 매겨진다. 택희는 이 수열과 주머니에서 발견한 정수들을 이용해 ‘쿼리 놀이’를 하기로 했다.</p>

<p>쿼리 놀이는 아래와 같이 진행된다.</p>

<ul>
	<li>왼쪽 주머니에서 하나의 정수를 꺼낸다. 이 값을 <em>L</em>이라 한다.</li>
	<li>오른쪽 주머니에서 하나의 정수를 꺼낸다. 이 값을 <em>R</em>이라 한다.</li>
	<li><em>L</em> ≤ <em>R</em>이라면 수열의 [<em>L</em>, <em>R</em>] 구간 내에서 최댓값을 찾고, 그 값을 종이에 기록한다. <em>L</em> > <em>R</em> 이라면 종이에 10<sup>9</sup>을 기록한다. 그 후, 사용한 <em>L</em>과 <em>R</em>은 버린다.</li>
	<li>주머니가 빌 때까지 위의 작업을 반복한다.</li>
</ul>

<p>이 놀이가 끝나고 나면, 종이에는 <em>M</em>개의 정수가 쓰여 있을 것이다. 택희는 이 놀이를 반복하다가, 종이에 쓰인 정수 <em>M</em>개 중 최댓값을 최소화한다면 얼마가 될 지 궁금해졌다. 그리고 기왕 궁금해하는 김에, 수열의 두 원소의 위치를 바꾸는 쿼리 형태로 궁금해하기로 했다. 게다가 이런 궁금증이 무려 <em>Q</em>번 생겨났다!</p>

<p>택희의 쿼리 놀이에 대한 쿼리를 효율적으로 처리해 줄 프로그램을 작성해보도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 길이 <em>N</em>, 왼쪽 주머니와 오른쪽 주머니에 들어 있는 정수의 개수 <em>M</em>, 쿼리의 개수 <em>Q</em>가 주어진다. (1 ≤ <em>N</em>, <em>M</em>, <em>Q</em> ≤ 200,000)</p>

<p>둘째 줄에는 공백으로 구분된 수열의 원소 <em>a<sub>i</sub></em>가 <em>N</em>개 주어진다. (-10<sup>9</sup> ≤ <em>a<sub>i</sub></em> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 왼쪽 주머니에 들어 있는 정수 <em>l<sub>i</sub></em>가 <em>M</em>개 주어진다. (1 ≤ <em>l<sub>i</sub></em> ≤ <em>N</em>)</p>

<p>넷째 줄에는 오른쪽 주머니에 들어 있는 정수 <em>r<sub>i</sub></em>가 <em>M</em>개 주어진다. (1 ≤ <em>r<sub>i</sub></em> ≤ <em>N</em>)</p>

<p>다섯째 줄부터 <em>Q</em>+4번째 줄까지, 쿼리에 대한 정보 <em>i j</em> 가 주어진다. 이는 <em>a<sub>i</sub></em>와 <em>a<sub>j</sub></em>를 서로 바꾸겠다는 의미이다. (1 ≤ <em>i</em>, <em>j</em> ≤ <em>N</em>)</p>

<p>모든 쿼리는 누적된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em>줄에 걸쳐, 수열 변경 직후에 대해, 놀이의 결과 정수 <em>M</em>개 중 최댓값의 가능한 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2 3
-2 0 1 2 -1
1 2
4 2
2 3
4 5
1 5
','2
1
2
','DATA_STRUCTURE'),
                                                                                                                (7630,'BAEKJOON','https://www.acmicpc.net/problem/17092',17092,'색칠 공부','1초','512 MB',12,'<p>크기가 H×W인 모눈종이가 있고, 1×1 크기의 칸으로 나누어져 있다. 이 중 N개의 칸은 검정색이고, 나머지 칸은 흰색이다.</p>

<p>3×3 크기의 모든 부분 모눈종이에 대해서, 검정색 칸의 개수가 i개인 것이 몇 개 있는지 구해보자. (0 ≤ i ≤ 9)</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 모눈종이의 크기 H, W와 검정색 칸의 개수 N이 주어진다.</p>

<p>둘째 줄부터 N개의 줄에 검정칸의 위치 r, c가 한 줄에 하나씩 주어진다. 같은 칸이 여러 번 주어지는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 10개의 줄에 문제의 정답을 출력한다. i+1번째 줄에&nbsp;검정색 칸의 개수가 i개인 부분 모눈종이의 개수를 출력한다. (0&nbsp;≤ i ≤ 9)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5 8
1 1
1 4
1 5
2 3
3 1
3 2
3 4
4 4
','0
0
0
2
4
0
0
0
0
0
','DATA_STRUCTURE'),
                                                                                                                (7633,'BAEKJOON','https://www.acmicpc.net/problem/17126',17126,'연산','2초','512 MB',18,'<p>값이 0으로 초기화되어 있고 인덱스는 0으로 시작하는 정수 배열 A에 대해 다음 세 함수가 주어진다.</p>

<ul>
	<li>더하기 (key, value) : A[key]의 값을 value만큼 더한다. 리턴하는 값은 A[key]가 아니라, 배열 A 값 전체의 합이다.</li>
	<li>구간합 (key1, key2) : key1 ≤ i ≤ key2 인 모든 i에 대한 A[i]의 구간합을 리턴한다. (key1 ≤ key2)</li>
	<li>삭제 (key) : A[key]의 값을 0으로 만든다. 리턴하는 값은 역시 해당 연산 이후 배열 A 값 전체의 합이다.</li>
</ul>

<p>연산을 수행할 때마다, 리턴값을 출력하는 프로그램을 작성하시오.</p>

<p>예를 들어 아래와 같은 12개의 연산을 순서대로 적용한다고 해보자. 화살표 이후에 나타나는 값이 바로 당신의 프로그램이 출력해야하는 값이다.</p>

<ul>
	<li>더하기 (key=27, value=30) → 30</li>
	<li>더하기 (key=25, value= 40) → 70</li>
	<li>삭제 (key=17) → 70</li>
	<li>더하기 (key=17, value=20) → 90</li>
	<li>더하기 (key=5, value=50) → 140</li>
	<li>구간합 (key1=10, key2=20) → 20</li>
	<li>구간합 (key1=25, key2=30) → 70</li>
	<li>삭제 (key=25) → 100</li>
	<li>삭제 (key=17) → 80</li>
	<li>더하기 (key=27, value=20) → 100</li>
	<li>구간합 (key1=10, key2=20) → 0</li>
	<li>구간합 (key1=25, key2=30) → 50</li>
</ul>

<p>총 n개의 연산이 주어졌을 때, 각 연산을 적용한 이후 올바른 값을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 연산의 수 n이 주어진다.</p>

<p>각 연산은 종류에 따라 아래와 같은 형태로 한 줄에 하나씩 주어진다:</p>

<ul>
	<li>더하기: 줄의 첫 입력으로 1이 주어지고 이후에 key과 value가 공백으로 구분되어 주어진다.</li>
	<li>구간합: 줄의 첫 입력으로 2이 주어지고 이후에 두 개의 key가 공백으로 구분되어 주어진다.</li>
	<li>삭제: 줄의 첫 입력으로 3가 주어지고 이후에 key가 주어진다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄에 각 함수의 리턴값을 공백으로 구분해서 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다.</p>

<p>C++을 사용하고 있고 <code>cin</code>/<code>cout</code>을 사용하고자 한다면, <code>cin.tie(NULL)</code>과 <code>sync_with_stdio(false)</code>를 둘 다&nbsp;적용해 주고, <code>endl</code> 대신 개행문자(<code>\n</code>)를 쓰자.&nbsp;단, 이렇게 하면 더 이상 <code>scanf</code>/<code>printf</code>/<code>puts</code>/<code>getchar</code>/<code>putchar</code>&nbsp;등 C의 입출력 방식을 사용하면 안 된다.</p>

<p>Java를 사용하고 있다면, <code>Scanner</code>와 <code>System.out.println</code> 대신 <code>BufferedReader</code>와 <code>BufferedWriter</code>를 사용할 수 있다.&nbsp;<code>BufferedWriter.flush</code>는 맨 마지막에 한 번만 하면 된다.</p>

<p>Python을 사용하고 있다면, <code>input</code>&nbsp;대신 <code>sys.stdin.readline</code>을 사용할 수 있다. 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 <code>.rstrip()</code>을 추가로 해 주는 것이 좋다.</p>

				</div>
				</div>','12
1 27 30
1 25 40
3 17
1 17 20
1 5 50
2 10 20
2 25 30
3 25
3 17
1 27 20
2 10 20
2 25 30
','30 70 70 90 140 20 70 100 80 100 0 50
','DATA_STRUCTURE'),
                                                                                                                (7635,'BAEKJOON','https://www.acmicpc.net/problem/17131',17131,'여우가 정보섬에 올라온 이유','1초','256 MB',17,'<p>여우가 정보섬에 올라왔다!</p>

<p>오늘도&nbsp;하늘에는&nbsp;아름다운 별들이 빛나고 있다. 정보섬은 언덕 꼭대기에 위치해 있기 때문에 별이 잘 보이기로 유명하다. 그래서인지,&nbsp;여우 한 마리가&nbsp;정보섬에 올라와 밤하늘을 바라보며 별자리를 만들고 있다.&nbsp;여우는 세 개의 별을 연결하여 V형 별자리를&nbsp;만드는데, 그 이유는&nbsp;V가 자신의 얼굴과 닮았기 때문이라나 뭐라나.&nbsp;여우는 자신의 시점을 기준으로 생각하기 때문에,&nbsp;V가 회전한 모양(<, >, ㄴ, ㄱ, ^ 등)은&nbsp;V라고 생각하지 않는다.</p>

<p>여우는 만들 수 있는 V형 별자리의 총 개수가 궁금해졌다. 그러나 일일이 세보기에는&nbsp;별이 너무 많았기 때문에, 여우는&nbsp;뛰어난&nbsp;프로그래머인 당신에게 도움을 요청했다! 귀여운 여우를&nbsp;위해&nbsp;얼마나 많은 V형 별자리가&nbsp;만들어질 수 있는지 계산해 주자.</p>

<p>V형 별자리를&nbsp;명확하게&nbsp;정의하면&nbsp;다음과 같다.&nbsp;세 별 (s,t,u)가 <b>s.x < t.x < u.x</b>이고 <b>s.y > t.y < u.y</b>이면 V형 별자리이다. 예를 들어 아래의&nbsp;정보섬의 밤하늘&nbsp;참고도에서 (a,b,c)는 V형 별자리를 이루지만&nbsp;(d,b,c)는 d.x < b.x가 아니므로 V형 별자리가 아니다. V형 별자리의 개수를 셀&nbsp;때,&nbsp;한 별이 여러 별자리에 속할 수 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/dbf080bd-9e82-4a6b-af2e-4e3043244970/-/preview/" style="width: 384.167px; height: 129.167px;"></p>

<p>답이 매우 커질 수 있으므로&nbsp;(10<sup>9</sup>+7)로 나눈 나머지를 출력한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 별의 개수 N이 주어진다. 그 다음 줄부터 N개의 줄에 걸쳐 별의 좌표 x&nbsp;y가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>(만들 수 있는 V형 별자리의 개수) mod (10<sup>9</sup>+7)을&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
-1 1
0 0
1 1
0 1
','1
','DATA_STRUCTURE'),
                                                                                                                (7636,'BAEKJOON','https://www.acmicpc.net/problem/17132',17132,'두더지가 정보섬에 올라온 이유','2초','512 MB',16,'<p>두더지가 정보섬에 올라왔다!</p>

<p>두더지는 정보섬 지하에&nbsp;여러 채의 자택을 소유하고 있다. 두더지는&nbsp;집 사이를&nbsp;오가는 걸 좋아한다.&nbsp;정보섬에는 총 N개의 두더지 집이 있으며 이 집들은 N-1개의 길로 연결되어 있다. 임의의 집에서 또 다른 집으로 가는 경로는 항상 유일하게 하나만&nbsp;존재한다. 즉, 두더지 집들은 트리 형태로 모두 연결되어 있다.&nbsp;어떤 길을 지날 때, 두더지는 W만큼의 만족도를 얻는다.</p>

<p>어느 날, 아래의 그림과 같은 집을 가진&nbsp;두더지는 집1에서 집4로 이동했다. 이때&nbsp;거치게 되는&nbsp;집은&nbsp;(1 →&nbsp;2 →&nbsp;3 →&nbsp;4)이다.&nbsp;두더지는 한 번 이동할 때마다,&nbsp;이동경로에 포함되는 만족도들 중에서&nbsp;가장 최소인&nbsp;만족도를 얻는다. 즉, (1&nbsp;→&nbsp;4)의&nbsp;경우에는 만족도를 2만큼, (6&nbsp;→ 2)의 경우에는 만족도를 3만큼&nbsp;얻게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/9fde67aa-ce73-4809-9f6f-9d23ce0bb640/-/preview/" style="width: 370.833px; height: 217.5px;"><br>
&nbsp;</p>

<p>&nbsp;</p>

<p>두더지는 갑자기&nbsp;모든 집의 쌍 (a, b)에 대한 이동을 끝냈을 때 얻을 수 있는 만족도의 총합이 얼마인지 궁금해졌다. (a, b)와 (b, a)는 같은 경로로 친다.&nbsp;즉,&nbsp;위의 그림의 경우 (1-2, 1-3, 1-4, 1-5, 1-6, 2-3, 2-4, 2-5, 2-6, 3-4, 3-5, 3-6, 4-5, 4-6, 5-6)를 모두&nbsp;이동했을때&nbsp;얻는 만족도의 총합을 말한다.</p>

<p>하지만 두더지는 계산하다가&nbsp;지쳐 이내 잠에 들고 말았다!&nbsp;착한 여러분들이 잠든 두더지를 대신해 계산해 주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 집의 수 N이 주어진다.&nbsp;(1 ≤ N&nbsp;≤ 100,000)</p>

<p>이후 N-1개의 줄에 걸쳐&nbsp;X, Y, W가 주어진다. 이는 집&nbsp;X와&nbsp;Y가 연결되어 있고,&nbsp;이 길을 지날 때의 만족도가 W라는 뜻이다.&nbsp;(1 ≤ X,Y ≤ N, 1 ≤ W ≤ 200)&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>문제에 제시된 이동을 끝냈을 때,&nbsp;두더지가 느끼는 만족도의 총합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
3 4 2
5 6 4
2 3 2
1 5 5
1 2 3','40','DATA_STRUCTURE'),
                                                                                                                (7639,'BAEKJOON','https://www.acmicpc.net/problem/17138',17138,'습격자 초라기와 쿼리 (Easy)','1초','256 MB',19,'<p>초라기는 한국의 비밀 국방 기지 원타곤을 습격하는 임무를 받은 특급 요원이다. 원타곤은 도넛 형태이며, 아래와 같이 <em>N</em>개의 구역으로 나뉜다. (그림의 숫자는 각 구역의 번호이다.)</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/f6e3719a-5b74-4550-9703-6b0a45610bec/-/preview/" style="width: 292px; height: 292px;"></p>

<p>초라기는 특수 소대들을&nbsp;출동시켜 모든 구역을 점령하고 적들을 포로로 사로잡는 데 성공했다. 특수 소대는 아래 조건에 따라 원타곤의 각 구역에 배치되어&nbsp;포로들을&nbsp;관리한다.</p>

<ol>
	<li>한 특수 소대는 구역 하나 또는 서로 인접한 두 구역에 배치할 수 있다. (같은 경계를 공유하고 있으면 인접하다고 한다. 위 그림에서 구역 1은 구역 2, 구역&nbsp;<em>N</em>과 서로 인접한 상태이다.)</li>
	<li>한 특수 소대가 관리하는 포로의 수는&nbsp;<em>W</em>보다 작거나 같아야 한다.</li>
</ol>

<p>각 구역에 포로들이 몇 명씩 있는지는 초라기가 모두 파악하고 있다. 그런데 다른 곳으로 이송되는 포로도 있고 증원군으로 왔다 잡혀서 새로 포로가 되는 적들도 있다보니 계속 각 구역의 포로 수가 바뀌어 초라기가 더 이상 관리 불가능한 수준에 이르고 말았다.&nbsp;초라기가 가진 특수 소대는 많지 않기 때문에, 초라기는 특수 소대를 최소한으로 배치하고 싶다. <em>Q</em>번에 걸쳐 한 번에 한 구역의 포로 수가 바뀔 때, 초라기를 위해 필요한 특수 소대 수의 최솟값을 실시간으로 구해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 정수 <em>N</em>, <em>Q</em>, <em>W</em>가 공백으로 구분되어 주어진다. (2&nbsp;≤&nbsp;<em>N&nbsp;</em>≤ 250 000, 1 ≤&nbsp;<em>Q</em>&nbsp;≤ 250 000, 1 ≤&nbsp;<em>W</em> ≤ 100 000)</p>

<p>둘째 줄에는 점령 직후 구역 1 ?&nbsp;<em>N</em>에 존재하는 포로의 수가 공백으로 구분되어 주어진다. 각 구역의 포로의 수는 0보다 크거나 같고 <em>W</em>보다 작거나 같다.</p>

<p>그 다음 <em>Q</em>줄에는 각 줄마다&nbsp;정수 <em>a</em>, <em>b</em>가 공백으로 구분되어 주어진다. (1 ≤ <em>a</em> ≤ <em>N</em>, 0 ≤ <em>b </em>≤ <em>W</em>) 이는 구역 <em>a</em>에 존재하는 포로의 수가 <em>b</em>명으로 변경되었다는 것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에는 점령 직후 필요한 특수 소대 수의 최솟값을 출력한다.</p>

<p>그 다음 <em>Q</em>줄에는 각 줄마다 포로 수가 변경되고 나서 필요한 특수 소대 수의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3 1
0 0 0
1 1
2 1
3 1
','2
2
2
3','DATA_STRUCTURE'),
                                                                                                                (7641,'BAEKJOON','https://www.acmicpc.net/problem/17139',17139,'습격자 초라기와 쿼리 (Normal)','5초','512 MB',22,'<p>초라기는 한국의 비밀 국방 기지 원타곤을 습격하는 임무를 받은 특급 요원이다. 원타곤은 도넛 형태이며, 아래와 같이 2<em>N</em>개의 구역으로 나뉜다. (그림의 숫자는 각 구역의 번호이다.)</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/67f339bf-bcdd-439d-af66-aabae3e3d116/-/preview/" style="width: 335px; height: 331.667px;"></p>

<p>초라기는 특수 소대들을&nbsp;출동시켜 모든 구역을 점령하고 적들을 포로로 사로잡는 데 성공했다. 특수 소대는 아래 조건에 따라 원타곤의 각 구역에 배치되어&nbsp;포로들을&nbsp;관리한다.</p>

<ol>
	<li>한 특수 소대는 구역 하나 또는 서로 인접한 두 구역에 배치할 수 있다. (같은 경계를 공유하고 있으면 인접하다고 한다. 위 그림에서 구역 1은 구역 2, 구역&nbsp;<em>N</em>, 구역 <em>N</em>+1과 서로 인접한 상태이다.)</li>
	<li>한 특수 소대가 관리하는 포로의 수는&nbsp;<em>W</em>보다 작거나 같아야 한다.</li>
</ol>

<p>각 구역에 포로들이 몇 명씩 있는지는 초라기가 모두 파악하고 있다. 그런데 다른 곳으로 이송되는 포로도 있고 증원군으로 왔다 잡혀서 새로 포로가 되는 적들도 있다보니 계속 각 구역의 포로 수가 바뀌어 초라기가 더 이상 관리 불가능한 수준에 이르고 말았다.&nbsp;초라기가 가진 특수 소대는 많지 않기 때문에, 초라기는 특수 소대를 최소한으로 배치하고 싶다. <em>Q</em>번에 걸쳐 한 번에 한 구역의 포로 수가 바뀔 때, 초라기를 위해 필요한 특수 소대 수의 최솟값을 실시간으로 구해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 정수 <em>N</em>, <em>Q</em>, <em>W</em>가 공백으로 구분되어 주어진다. (2&nbsp;≤&nbsp;<em>N&nbsp;</em>≤ 250 000, 1 ≤&nbsp;<em>Q</em>&nbsp;≤ 250 000, 1 ≤&nbsp;<em>W</em> ≤ 100 000)</p>

<p>둘째 줄에는 점령 직후 구역 1 ?&nbsp;<em>N</em>에 존재하는 포로의 수가 공백으로 구분되어 주어진다.</p>

<p>셋째 줄에는 점령 직후 구역 <em>N</em>+1&nbsp;? 2<em>N</em>에 존재하는&nbsp;포로의 수가 공백으로 구분되어 주어진다.&nbsp;각 구역의 포로의 수는 0보다 크거나 같고 <em>W</em>보다 작거나 같다.</p>

<p>그 다음 <em>Q</em>줄에는 각 줄마다&nbsp;정수 <em>a</em>, <em>b</em>가 공백으로 구분되어 주어진다. (1 ≤ <em>a</em> ≤ 2<em>N</em>, 0 ≤ <em>b </em>≤ <em>W</em>) 이는 구역 <em>a</em>에 존재하는 포로의 수가 <em>b</em>명으로 변경되었다는 것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에는 점령 직후 필요한 특수 소대 수의 최솟값을 출력한다.</p>

<p>그 다음 <em>Q</em>줄에는 각 줄마다 포로 수가 변경되고 나서 필요한 특수 소대 수의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 6 1
0 0 0
0 0 0
1 1
2 1
3 1
4 1
5 1
6 1
','3
3
3
3
4
5
6
','DATA_STRUCTURE'),
                                                                                                                (7673,'BAEKJOON','https://www.acmicpc.net/problem/17178',17178,'줄서기','1초','512 MB',11,'<p>아이즈원의 팬인 시온이는 드디어 티켓팅에 성공하여 콘서트를 갔다. 콘서트장에 일찍 도착한 시온이는 기대하며 입장을 위해 줄을 섰다. 하지만 아이즈원의 인기대로 시온이를 포함한&nbsp;많은 팬이 줄을 서고 있다.&nbsp;콘서트의 입장이 시작되었고 입장은 티켓 번호 순서대로 이루어졌다. 하지만 입구에 너무 많은 팬이 몰려 아무도 이동할 수 없는 상황이 되었고, 결국 주최 측에서 인원을 정렬시켜 다음과 같이 간신히 사람 한 줄이 설 수 있는 대기 공간을 만들었다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/bc504cb9-71fa-4df1-8ad9-0575a0203262/-/preview/" style="width: 344.167px; height: 83.3333px;"></p>

<p>주최 측은 번호표 순서대로만 통과할 수 있는 입구를 만들어 두었지만, 줄에서는 마구잡이로 사람들이 기다리고 있다. 대기 공간을 이용하여 입장이 원활히 이루어지도록 하려고 한다. 콘서트장에 사람들이 제대로 들어갈 수 있는지 확인해보자.</p>

<p>사람들은 현재 5명씩 <em>N&nbsp;</em>줄을 서 있고,&nbsp;첫 번째 줄 맨 앞사람만 이동이 가능하다. 이 사람은 콘서트장으로 입장할 수도 있고 대기 공간에서 다시 기다릴 수도 있다. 한 줄의 사람이 다 이동했다면 그다음 줄의 사람들이 이동한다. 대기 공간에는 한 줄로만 설 수 있는 공간이 있으며, 마지막에 들어온 사람부터 나갈 수 있다. 나갈 경우 바로 입장해야 하고, 다시 줄로 돌아갈 수는 없다.&nbsp;티켓은 A-123과 같이 한 개의 대문자 알파벳과 -, 1000 미만의 자연수의 조합으로 이뤄어져 있다. 만약 수가 7이라면 A-7과 같이 주어진다. 티켓의 순서는 알파벳이 빠른 티켓이 빠르며, 동일하다면 더 적은&nbsp;수가 더 빠르다. 티켓 번호는 중복되게 주어지지 않는다.</p>

<p>위의 예시를 예로 들면 다음과 같이 모든 사람들이 입장할 수 있다. 그림과는 달리 대기 공간에는 무한히 많은 사람들이 들어올 수 있다는 것에 주의하여야 한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/9827f814-14b0-4334-8af0-10a89be7a623/-/preview/" style="width: 345.833px; height: 84.1667px;"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/d21ef9b6-6de8-4640-8822-b142f4cccf6c/-/preview/" style="width: 345px; height: 83.3333px;"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/8af4d04f-6fa2-40d4-ad4c-d21cd50f8389/-/preview/" style="width: 345.833px; height: 82.5px;"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/6ce1200a-d930-4d6a-9a45-f785857737b8/-/preview/"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/828c1fd8-a5d8-4728-980a-f7371db21328/-/preview/"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/aa24fa18-f5cb-4a1c-9fd7-e88c38bd1c31/-/preview/"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/4433b135-81c3-4b12-9431-e761c71dd6cd/-/preview/"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/052561a8-730e-43ab-b929-2ebe0d6ff31d/-/preview/"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 줄에서 기다리고 있는 사람들의 줄 수&nbsp;<em>N</em>이 주어진다.&nbsp;(1 ≤&nbsp;<em>N</em>&nbsp;≤ 100)</p>

<p>둘째 줄부터&nbsp;<em>N&nbsp;</em>개의 줄에는 한 줄에 서 있는 5명의 티켓 번호가 주어진다.</p>

<p>사람들이 서 있는 순서대로 입력이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 사람이 무사히 콘서트장에 입장할 수 있다면 “GOOD”을 출력하고 그렇지 않다면 “BAD”를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
G-555 B-203 A-102 A-504 C-719
','GOOD
','DATA_STRUCTURE'),
                                                                                                                (7676,'BAEKJOON','https://www.acmicpc.net/problem/17219',17219,'비밀번호 찾기','5초','256 MB',7,'<p>2019 HEPC - MAVEN League의 "<a href="/problem/17218">비밀번호 만들기</a>"와 같은 방식으로 비밀번호를 만든 경민이는 한 가지 문제점을 발견하였다. 비밀번호가 랜덤으로 만들어져서 기억을 못 한다는 것이었다! 그래서 경민이는 메모장에 사이트의 주소와 비밀번호를 저장해두기로 했다. 하지만 컴맹인 경민이는 메모장에서 찾기 기능을 활용하지 못하고&nbsp;직접 눈으로 사이트의 주소와 비밀번호를 찾았다. 메모장에 저장된 사이트의 수가 늘어나면서&nbsp;경민이는 비밀번호를 찾는 일에 시간을 너무 많이 쓰게 되었다. 이를 딱하게 여긴 문석이는 경민이를 위해 메모장에서 비밀번호를 찾는 프로그램을 만들기로 결심하였다! 문석이를 도와 경민이의 메모장에서 비밀번호를 찾아주는 프로그램을 만들어보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 저장된 사이트 주소의 수 N(1&nbsp;≤ N&nbsp;≤ 100,000)과 비밀번호를 찾으려는 사이트 주소의 수 M(1&nbsp;≤ M&nbsp;≤ 100,000)이 주어진다.</p>

<p>두번째 줄부터 N개의 줄에 걸쳐&nbsp;각 줄에 사이트 주소와 비밀번호가 공백으로 구분되어 주어진다. 사이트 주소는 알파벳 소문자,&nbsp;알파벳 대문자,&nbsp;대시(-), 마침표(.)로 이루어져 있고, 중복되지 않는다. 비밀번호는 알파벳 대문자로만 이루어져 있다. 모두 길이는 최대 20자이다.</p>

<p>N+2번째 줄부터 M개의 줄에 걸쳐 비밀번호를 찾으려는 사이트 주소가 한줄에 하나씩 입력된다. 이때,&nbsp;반드시 이미 저장된 사이트 주소가 입력된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄부터 M개의 줄에 걸쳐&nbsp;비밀번호를 찾으려는 사이트 주소의 비밀번호를 차례대로 각 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다.</p>

<p>C++을 사용하고 있고&nbsp;<code>cin</code>/<code>cout</code>을 사용하고자 한다면, main함수 안에&nbsp;<code>cin.tie(NULL)</code>과 <code>ios::sync_with_stdio(false)함수를</code>&nbsp;둘 다 호출해 주고,&nbsp;<code>endl</code>&nbsp;대신 개행문자(<code>\n</code>)를 쓰자.&nbsp;단, 이렇게 하면 더 이상&nbsp;<code>scanf</code>/<code>printf</code>/<code>puts</code>/<code>getchar</code>/<code>putchar</code>&nbsp;등 C의 입출력 방식을 사용하면 안 된다.</p>

<p>Java를 사용하고 있다면,&nbsp;<code>Scanner</code>와&nbsp;<code>System.out.println</code>&nbsp;대신&nbsp;<code>BufferedReader</code>와&nbsp;<code>BufferedWriter</code>를 사용할 수 있다.&nbsp;<code>BufferedWriter.flush</code>는 맨 마지막에 한 번만 하면 된다.</p>

				</div>
				</div>','16 4
noj.am IU
acmicpc.net UAENA
startlink.io THEKINGOD
google.com ZEZE
nate.com VOICEMAIL
naver.com REDQUEEN
daum.net MODERNTIMES
utube.com BLACKOUT
zum.com LASTFANTASY
dreamwiz.com RAINDROP
hanyang.ac.kr SOMEDAY
dhlottery.co.kr BOO
duksoo.hs.kr HAVANA
hanyang-u.ms.kr OBLIVIATE
yd.es.kr LOVEATTACK
mcc.hanyang.ac.kr ADREAMER
startlink.io
acmicpc.net
noj.am
mcc.hanyang.ac.kr
','THEKINGOD
UAENA
IU
ADREAMER
','DATA_STRUCTURE'),
                                                                                                                (7677,'BAEKJOON','https://www.acmicpc.net/problem/17230',17230,'문제집 만들기','2초','512 MB',18,'<p>민규는 요즘 알고리즘 과외를 받고 있다. 민규에게는 매우 무서운 과외 선생님 준표가 있는데, 준표는 민규에게 매일 문제집을 한 권씩 만들어주려고 한다. 준표가 생각하기에 몇몇 문제는 민규가 처음부터 풀기엔 너무 어렵기 때문에 문제 간의 관계를 정리하여 표로 남겨두고자 한다.</p>

<p>예를 들어, <em>a</em>번 문제를 풀기 위해 <em>b</em>번 문제를 먼저 풀어야 한다면 <em>a b</em>로 기술한다. 문제집을 만드는 중간에 생각이 바뀌면 준표는 표를 수정할 수 있으며, <em>a</em>번을 풀기 위해선 <em>b</em>번을 풀어야 하는 동시에 <em>b</em>번을 풀기 위해선 <em>a</em>번을 풀어야 하는 모순된 상황이 없도록 주의하며 작성한다.</p>

<p>준표는 <em>x</em>번부터 <em>y</em>번까지의 문제들로 문제집을 만들었을 때 민규가 처음부터 끝까지 문제집을 전부 풀 수 있는지 알고 싶다. 하지만 준표는 APC 준비 때문에 너무 바빠서 이 작업을 할 시간이 없다. 바쁜 준표를 위해 프로그램을 작성해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 문제의 수 <em>N</em>, 문제 간의 관계의 수 <em>M</em>, 작업 횟수 <em>Q </em>가 주어진다.</p>

<p>두 번째 줄부터 <i>M</i>+1번째 줄까지 두 정수 <em>a b</em>가 주어진다. 이는 <em>a</em>번 문제를 풀기 위해선 <em>b</em>번 문제를 먼저 풀어야 한다는 관계를 표에 추가한다는 의미이다. 동일한 관계는 중복해서 입력되지 않는다.</p>

<p><em>M</em>+2번째 줄부터 <i>Q </i>개의 줄에 걸쳐 아래 세 종류의 입력이 <em>w</em>, <em>x</em>, <em>y</em> 순으로 주어진다.</p>

<ul>
	<li>1 <em>x y</em> : <em>x</em>번부터 <em>y</em>번까지의 문제들로 구성된 문제집을 민규에게 준다. ( <em>x</em> ≤ <em>y</em> )</li>
	<li>2 <em>x y</em> : <em>x</em>번 문제를 풀기 위해선 <em>y</em>번 문제를 먼저 풀어야 한다는 관계를 표에서 지운다. 삭제되는 관계는 표에 존재하는 관계만 주어진다.</li>
	<li>3 <em>x y</em> : <em>x</em>번 문제를 풀기 위해선 <em>y</em>번 문제를 먼저 풀어야 한다는 관계를 표에 추가한다. 생성되는 관계는 표에 존재하지 않는 관계만 주어진다.</li>
</ul>

<p>모순된 상황이 발생하는 입력은 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1 <em>x y</em> 의 입력이 들어왔을 때, 민규가 현재 <em>x</em>번부터 <em>y</em>번까지의 문제들로 구성된 문제집을 전부 풀 수 있으면 <code>"YES"</code>, 그렇지 않다면 <code>"NO"</code>를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제2, 3은&nbsp;서브태스크1, 2에서는 나오지 않는다.</p>

				</div>
				</div>','5 3 6
2 4
3 2
5 4
1 1 1
1 2 4
1 3 4
1 4 4
1 4 5
1 5 5
','YES
YES
NO
YES
YES
NO
','DATA_STRUCTURE'),
                                                                                                                (7678,'BAEKJOON','https://www.acmicpc.net/problem/17250',17250,'은하철도','5초','512 MB',12,'<p>하나의 은하 안에는 여러 행성들이 존재한다. 문명의 기술 발전으로 은하 내의 모든 행성들은 서로 여행할 수 있게 되었다.</p>

<p>드디어 오늘, 80,000 광년 떨어진 다른 은하와 우리 은하를 연결하는 은하 철도가 개통된다.</p>

<p>은하 철도가 개통되면 더 많은 행성을 여행할 수 있다는 사실에 은하 내 모든 행성의 주민들은 들떠있는 분위기이다.</p>

<p>우주철도공사 G-Express는 앞으로의 은하 철도 계획을 발표하였다.</p>

<p>우주는 너무 넓기 때문에, G-Express사는 은하가 연결될 때마다 몇 개의 행성들이 서로 여행할 수 있게 되었는 지를 알려주고자 한다.</p>

<p>G-Express사 기술개발팀의 직원인 당신에게 이 프로그램의 업무 요청이 들어왔다. 각 은하들의 행성 수와 철도 계획이 주어지면 해당 철도를 이용할 수 있는 행성들의 수를 실시간으로 안내하는 프로그램을 만들자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 은하의 수&nbsp;N과 철도의 개수&nbsp;M이 주어진다.</p>

<p>두 번째 줄부터 N개의 줄에 N개의 각 은하 내에 존재하는 행성들의 수가 1번 은하부터 차례대로 주어진다. (행성을 세는 단위는 조(10<sup>12</sup>) 단위이다.)</p>

<p>그리고 N+2 번째 줄부터 M개의 줄에 걸쳐 은하와 은하 사이를 잇는 철도가 주어진다. 같은 은하 사이에 여러 개의 철도가 건설될 수 있다.</p>

<p>입력되는&nbsp;N은 2 ≤ N ≤ 100,000,&nbsp;M은&nbsp;1 ≤ M ≤ 100,000이고, 각 은하의 행성 수는 100(조)개를 넘지 않으며 아무 행성도 없는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>철도가 연결될 때마다 해당 철도를 이용할 수 있는 행성들의 수를 한 줄씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>입력 데이터가 큰 관계로, 빠른 입출력을 사용하는 것을 권장합니다.</p>

				</div>
				</div>','5 4
3
9
10
11
15
1 2
2 3
4 5
4 3
','12
22
26
48
','DATA_STRUCTURE'),
                                                                                                                (7679,'BAEKJOON','https://www.acmicpc.net/problem/17255',17255,'N으로 만들기','1초','256 MB',12,'<p>준하는 노트에 수를 적다가 수가 만들어지는 방식을 깨달았다.</p>

<p>처음에 어떤 숫자 하나를 적고 만들어진 수의 왼쪽이나 오른쪽에 숫자를 계속 붙이면 어떤 수&nbsp;N이든 만들 수 있다는 것이다.</p>

<p>다시 말해 어떤 수&nbsp;N을 만들기 위해서는, 처음에 어떤 숫자를 하나 적고 아래의 두 가지 행동을 반복한다.</p>

<ol>
	<li>수의 왼쪽에 숫자를 하나 적는다.</li>
	<li>수의 오른쪽에 숫자를 하나 적는다.</li>
</ol>

<p>준하는 어떤 수&nbsp;N을 만드는 방법의 수가 몇 가지인지 궁금해졌다. 이를 알아내는 프로그램을 작성해주자. 숫자를 적는 과정에서 나온 수가 순서대로 모두 같다면 같은 방법이다.</p>

<p>단, 숫자를 적는 과정에서 수는 0으로 시작할 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>음이 아닌 정수&nbsp;N이 주어진다. (0 ≤ N ≤ 10,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>N을 만드는 방법의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','521
','4
','DATA_STRUCTURE'),
                                                                                                                (7686,'BAEKJOON','https://www.acmicpc.net/problem/17274',17274,'카드 공장 (Large)','3초','256 MB',22,'<p>진서는 CTP 카드 공장의 노동자이다. 공장에는 <em>N</em>개의 카드가 있으며 각 카드에는 앞면과 뒷면에 숫자가 쓰여있다. 공장장 노진의 명령에 따라서 진서는 카드를 뒤집어야 한다. 명령은 <em>M</em>번 내려지게 되며, 명령은 다음과 같다.</p>

<p><strong>“공장장 노진이 <em>K</em>라는 수를 말하게 되면 진서는 <em>N</em>개의 카드 중 보이고 있는 면이 <em>K</em>이하인 카드를 모두&nbsp;뒤집어야 한다.”</strong></p>

<p>그리고 공장장의 명령이 끝났을 때, 카드의 보이는 면의 수들의 합을 공장장에게 보고해야 한다.</p>

<p>예를 들면 다음 그림과 같다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/5e980e9e-425c-451c-988c-7a1afe0ad8df/-/preview/" style="width: 376.667px; height: 201.667px;"></p>

<p><b>카드들은 처음에 모두 앞면이 보이도록 세팅되어 있고, 카드에 적힌 수는 10억 이하의 자연수이다.</b></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 <em>N</em>과 <em>M</em>이 주어진다. (<em>N, M</em>은 200,000 이하의 자연수)</p>

<p>그리고 다음 <em>N</em>개의 줄에 카드의 앞면 A<sub>i</sub>와 뒷면 B<sub>i</sub>가 주어진다. (A<sub>i</sub>와 B<sub>i</sub>는 10억 이하의 자연수)</p>

<p>그리고 다음 <em>M</em>개의 줄에 공장장이 말하는 수 <em>K</em>가 주어진다. (<em>K</em>는 10억 이하의 자연수)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>명령이 끝났을 때 보이고 있는 카드들의 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
4 6
9 1
8 8
4 2
3 7
8
2
9
','18
','DATA_STRUCTURE'),
                                                                                                                (7682,'BAEKJOON','https://www.acmicpc.net/problem/17277',17277,'주식','1초','512 MB',17,'<p>당신은 주식을 사고 팔아 이윤을 남기고 싶다. 주식 투자에 대한 법이 최근 바뀌어 아래와 같은 제한이 있다.</p>

<ul>
	<li>시장은 1일차부터 n일차까지, n일 동안만 개장된다.</li>
	<li>당신은 그 중에 연속된 k일 (k ≥ 1) 기간 동안에만 참가할 수 있다. 참가하는 날에는 무조건 매일 주식을 사야 한다.</li>
	<li>당신이 주식을 살 때의 가격은, 매일 y원으로, 언제나 일정하다.</li>
	<li>당신이 주식을 팔 때의 가격은, i일차에 산 경우 V[i]원으로, 산 날짜에 따라 다르다. V[i]는 음수일 수 있다.</li>
	<li>당신은 초기 자금 X원을 가지고 참가한다.</li>
	<li>당신은 시장 개장 기간인 n일차가 지나기 전까지는 산 주식을 팔 수 없다.</li>
	<li>당신은 최소 Z원 이상의 이윤을 남겨야 한다. (Z&nbsp;≥ 0)</li>
</ul>

<p>즉, 1 ≤ i ≤ j ≤ n을 만족하는 i일차부터 j일차까지 주식을 샀다면,</p>

<p>(V[i] + V[i+1] + … + V[j-1] + V[j]) - y × (j - i + 1) ≥ Z 및 y × (j - i + 1) ≤ X 을 만족해야 한다.</p>

<p>이 때, 당신의 목표는 Z원 이상의 이윤을 남길 수 있는 구매 방법 중에서 가장 짧은 기간을 찾는 것이다.</p>

<p>다시 말해서, 이윤은 Z원 이상만 남길 수 있다면 아무래도 상관없고, 최대한 짧은 기간 동안에 Z원 이상의 이윤을 남기는 방법을 찾고 싶다. 그러한 기간을 나타내는 시작일/종료일 i, j를 출력하는 프로그램을 만드시오.</p>

<p>동일한 최단 기간 구매법이 복수 존재한다면, 그 중 i가 가장 큰 (즉, 시장에 가장 늦게 진입하는) 기간을 출력하시오.</p>

<p>Z원 이상의 이윤을 남길 수 있는 방법이 존재하지 않는다면, -1을 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p dir="ltr">첫 줄에 테스트 케이스의 수 T가 주어진다 (1 ≤&nbsp;T ≤ 10).</p>

<p dir="ltr">각 테스트 케이스는 두 줄에 걸쳐서 주어진다.</p>

<p dir="ltr">첫째 줄에 n, X, y, Z가 공백으로 구분되어 주어진다. 0 ≤&nbsp;X, y, Z ≤&nbsp;10<sup>9</sup> 를 만족한다.</p>

<p dir="ltr">둘째 줄에 n개의 정수 V가 공백으로 구분되어 주어진다. 각 V[i] 는 |V[i]| ≤&nbsp;10<sup>6</sup> 를 만족한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해 한 줄에 답을 출력한다. 문제에서 언급된 조건들을 만족하는 i, j가 존재하지 않을 경우 -1을 출력하고, 아닌 경우 묘사된대로 (j - i + 1)을 최소화 하는 (i, j) 중 i값이 최대가 되는 i, j 를 &nbsp;공백으로 구분하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 0 0 1
1
2 0 0 4
1 2
3 0 0 3
2 -1 2
3 0 0 2
2 -1 2
3 0 0 1
2 -1 2
','1 1
-1
1 3
3 3
3 3
','DATA_STRUCTURE'),
                                                                                                                (7681,'BAEKJOON','https://www.acmicpc.net/problem/17280',17280,'카풀 매칭','3초','512 MB',15,'<p>당신은 친구를 도와 새로운 카풀 앱을 개발해야 한다. 그 중 운전자와 승객을 매칭 시켜주는 알고리즘을 당신이 개발해야 한다. 현재 이 앱은 베타 버전이기 때문에 동-서로 길게 늘어진 고속도로 위에 위치한 지역에서만 서비스를 하고 있으며 아래와 같은 제한이 있다.&nbsp;</p>

<ul>
	<li>모든 운전자와 승객은 가장 동쪽에 위치한 “출발지" 도시에서 출발한다.</li>
	<li>총 N명의 승객이 있으며, i번째 승객은 출발지에서 서쪽으로 x<sub>i</sub> 미터 떨어진 곳에 위치한 목적지에 가고 싶어한다 (0 < x<sub>i</sub>).</li>
	<li>총 M명의 운전자가 있으며, j번째 운전자는 출발지에서 서쪽으로 y<sub>j</sub> 미터 이상 z<sub>j</sub> 미터 이하 떨어진 곳 사이에 가고 싶어하는 승객을 최대 한 명 태워줄 의향이 있다 (0 < y<sub>j</sub>&nbsp;≤&nbsp;z<sub>j</sub>).&nbsp;</li>
</ul>

<p>당신은 이 조건들을 만족하면서 최대한 많은 승객-운전자를 매칭시키는 알고리즘을 작성해야 한다.</p>

<p>예를 들어, 3명의 승객과 3명의 운전자가 있을 때, x, y, z 값이 아래와 같다고 하자.</p>

<ul>
	<li>x = [10, 20, 30]</li>
	<li>y = [8, 2, 25]</li>
	<li>z = [8, 18, 35]</li>
</ul>

<p>이 경우 승객 1, 2, 3은 각각 정확 10미터, 20미터, 30미터 떨어진 곳으로 가고 싶어하며, 운전자 1은 정확히 8미터 떨어진 곳에 가려는 승객을 태울 의향이 있고,&nbsp; 운전자 2는 2미터 이상 18미터 이하 떨어진 곳에 가려는 승객을 태울 의향이 있고, 운전자 3은 25미터 이상 35미터 이하 떨어진 곳에 가려는 승객을 태울 의향이 있다.</p>

<p>이 경우, 승객1-운전자2, 승객3-운전자3을 매칭시켜주면 총 두 쌍을 매칭시킬 수 있고 이보다 많은 수의 승객-운전자를 매칭 시킬 수 있는 방법은 없다.</p>

<p>입력으로 N, M, 그리고 x, y, z 값들을 입력 받아 최대한 많은 승객-운전자 쌍을 매칭시키면 몇 쌍을 매칭 시킬 수 있는지 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T가 주어진다 (1 ≤&nbsp;T ≤ 10).</p>

<p>각 테스트 케이스의 첫 줄에는 N, M 이 주어진다.</p>

<p>그 다음 줄에 x<sub>i</sub> 가 공백으로 구분되어 주어진다 (1 ≤ x<sub>i</sub>&nbsp;≤&nbsp;1,000,000,000).</p>

<p>다음 M줄에 걸쳐 각 줄에 y<sub>j</sub> 와 z<sub>j</sub> 가 공백으로 구분되어 주어진다 (1 ≤ y<sub>j</sub> ≤ z<sub>j</sub> ≤ 1,000,000,000).</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해, 최대한 많은 승객-운전자를 매칭 시켰을 때 몇 쌍을 매칭시킬 수 있는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
3 3
10 20 30
8 8
2 18
25 35
4 4
2 3 4 5
1 4
2 4
3 5
3 4
3 3
1 2 3
10 20
30 40
50 60
','2
4
0
','DATA_STRUCTURE'),
                                                                                                                (7685,'BAEKJOON','https://www.acmicpc.net/problem/17298',17298,'오큰수','1초','512 MB',12,'<p>크기가 N인 수열 A = A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 있다. 수열의 각 원소 A<sub>i</sub>에 대해서 오큰수 NGE(i)를 구하려고 한다. A<sub>i</sub>의 오큰수는 오른쪽에 있으면서 A<sub>i</sub>보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.</p>

<p>예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3)&nbsp;= 8, NGE(4) = -1이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>&nbsp;(1 ≤ A<sub>i</sub> ≤ 1,000,000)이&nbsp;주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3 5 2 7
','5 7 7 -1
','DATA_STRUCTURE'),
                                                                                                                (7688,'BAEKJOON','https://www.acmicpc.net/problem/17299',17299,'오등큰수','1초','512 MB',13,'<p>크기가 N인 수열 A = A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 있다. 수열의 각 원소 A<sub>i</sub>에 대해서 오등큰수 NGF(i)를 구하려고 한다.</p>

<p>A<sub>i</sub>가 수열 A에서 등장한 횟수를 F(A<sub>i</sub>)라고 했을 때,&nbsp;A<sub>i</sub>의 오등큰수는 오른쪽에 있으면서 수열 A에서 등장한 횟수가 F(A<sub>i</sub>)보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오등큰수는 -1이다.</p>

<p>예를 들어, A = [1, 1,&nbsp;2, 3, 4, 2, 1]인 경우 F(1) = 3, F(2) = 2, F(3) = 1, F(4) = 1이다. A<sub>1</sub>의 오른쪽에 있으면서 등장한 횟수가 3보다 큰 수는 없기 때문에, NGF(1) = -1이다. A<sub>3</sub>의 경우에는 A<sub>7</sub>이 오른쪽에 있으면서&nbsp;F(A<sub>3</sub>=2) < F(A<sub>7</sub>=1) 이기 때문에, NGF(3) = 1이다. NGF(4) = 2, NGF(5) = 2, NGF(6) = 1 이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>&nbsp;(1 ≤ A<sub>i</sub> ≤ 1,000,000)이&nbsp;주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 N개의 수 NGF(1), NGF(2), ..., NGF(N)을 공백으로 구분해 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1 1 2 3 4 2 1
','-1 -1 1 2 2 1 -1
','DATA_STRUCTURE'),
                                                                                                                (7690,'BAEKJOON','https://www.acmicpc.net/problem/17303',17303,'슈퍼브 다트','1초','512 MB',20,'<p>주식회사 슈퍼브에이아이 구성원들은 커피값 내기를 하기 위하여 슈퍼브 다트라는 새로운 게임을 만들었다. 슈퍼브 다트의 규칙은 아래와 같다.</p>

<ul>
	<li>2차원 평면 위에 다트판을 그린다.</li>
</ul>

<ul>
	<li>다트판은 평면 위의 점들을 정점으로 하고 그 사이를 잇는 선분들을 간선으로 하여 만들어지는 그래프이다.
	<ul>
		<li>각 정점은 정수 좌표를 가지며, 좌표가 서로 같은 정점은 없다.</li>
		<li>만들어진 그래프는 중복되는 간선을 가지지 않는 단순 그래프이며 모든 임의의 두 정점 사이의 경로가 항상 존재하는 연결 그래프이다.</li>
		<li>만들어진 그래프는 서로 다른 선분끼리 교차하지 않으며, 두 선분이 정점을 공유하는 경우 그 점에서만 접할 수 있는 평면 그래프이다.</li>
	</ul>
	</li>
</ul>

<ul>
	<li>다트판 위에 다트를 던질 때, 한 번의 시행으로 얻는 점수는 다트가 꽂힌 점이 포함된 영역의 넓이에 반비례한다.
	<ul>
		<li>어떤 점을 포함하는 영역이란 그 점에서 다트판의 간선들과 교차하거나 접하지 않는 경로로 연결할 수 있는 점들의 집합이다. 여기서 경로란 그래프상의 경로가 아닌 평면상에서의 경로를 의미하며, 이는 곡선이 될 수도 있다.</li>
		<li>넓이가 무한한 곳이나 밖, 혹은 점이나 간선 바로 위에 꽂혔을 경우 이는 영역으로 치지 않으며 0점을 얻게 된다.</li>
	</ul>
	</li>
</ul>

<p>호기심이 많은 슈퍼브에이아이 구성원들은 이러한 다트판에서 나올 수 있는 점수들의 조합이 궁금해졌다. 이 궁금증을 해결하기 위해 우선 다트판이 주어졌을 때 다트판에 있는 영역들의 넓이를 계산해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 다트판의 정점 개수와 간선 개수 <em>N</em>, <em>M</em>(1 ≤ <em>N</em>, <em>M</em> ≤ 100,000)이 주어진다. 각 정점에는 1부터 <em>N</em>까지, 각 간선에는 1부터 <em>M</em>까지 순서대로 번호가 붙어 있다.</p>

<p>다음 <em>N</em>개의 줄에는 정점들의 좌표가 주어진다. 이 중 <em>i</em>번째 줄에는 <em>i</em>번 정점의 x좌표 <em>x<sub>i</sub></em>와 y좌표 <em>y<sub>i</sub></em>(-10<sup>6</sup> ≤ <em>x<sub>i</sub></em>, <em>y<sub>i</sub></em>&nbsp;≤ 10<sup>6</sup>)가 띄어쓰기로 구분되어 주어진다. 중복된 좌표는 주어지지 않는다.</p>

<p>다음 <em>M</em>개의 줄에는 다트판의 간선이 주어진다. 각 줄은 두 개의 정수 <em>s</em>, <em>e</em>(1 ≤ <em>s</em>, <em>e</em> ≤ <em>N</em>)로 이루어져 있으며, 이는 간선의 양 끝 정점 번호를 의미한다. 양 끝점은 서로 다르며, 중복된 간선은 없다. 서로 다른 두 간선은 최대 하나의 교차점을 가지며, 임의의 서로 다른 두 간선이 하나의 교차점을 가진다면 두 간선은 해당 교차점을 양 끝으로 공유한다.</p>

<p>주어진 다트판의 모든 정점은 간선으로 연결되어 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 다트판에 있는 넓이가 0보다 크고 유한한 영역의 개수 <em>S</em>를 출력한다.</p>

<p>다음 <em>S</em>개의 줄에 해당 영역들의 <strong>넓이를 오름차순으로 소수점 둘째 자리에서 반올림</strong>하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 6
0 0
0 1
0 3
1 1
1 3
1 2
2 3
1 4
2 4
4 5
3 5
','2
0.5
2.0
','DATA_STRUCTURE'),
                                                                                                                (7689,'BAEKJOON','https://www.acmicpc.net/problem/17306',17306,'전쟁 중의 삶','2초','512 MB',18,'<p>석환나라에 전쟁이 일어났다! 석환나라는 엄청나게 큰 이진 트리 모양의 국가로,&nbsp;1,2, ... ,10<sup>100</sup> 까지 번호가 붙여진 총&nbsp;10<sup>100</sup>&nbsp;개의 도시로 이루어져 있다. 석환나라에는&nbsp;10<sup>100</sup>-1개의 도로가 있는데, 이 중 <em>i</em>번째 도로는 (1 ≤ <em>i</em> <10<sup>100</sup>)&nbsp;$\lfloor \frac{i+1}{2} \rfloor$ 번 도시와 <em>i</em>+1 번 도시를 잇는데, 이를 그림으로 묘사하면 아래와 같다:</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/7d145311-fa1b-474e-9fdf-c2535cab046e/-/preview/"></p>

<p>총리 <em>윈스턴 아기서콴</em>(<em>Winston Agiseokhwan</em>)은 위기의 석환나라를 구하는 중대한 임무를 맡고 있다. 석환나라의 적국들은 석환나라의 중요 군 시설을 방해하는 데 혈안이 되어 있기 때문에, 석환나라의 국민들을 보호하기 위해서는 군대가 자주 오가는 도시를 우선 방어하는 것이 효과적이다. 석환나라에는&nbsp;<em>N</em>개의 군부대가 서로 다른 도시에 존재하고, 군부대들은 서로 물자나 정보를 주고받기 위해서 오간다.</p>

<p>이때, 어떠한 도시가&nbsp;<strong>위험하다</strong>는 것은, 해당 도시에 군부대가 있거나, 경로가 해당 도시를 지나는 서로 다른 두 군부대가 존재함을 뜻한다. 석환나라는 트리이고, 경로는 같은 도시를 두 번 방문하지 않아야 한다고 정의되기 때문에, 두 군부대를 지나는 경로는 언제나 유일하다는 사실을 유념하자.</p>

<p>아기서콴 총리를 위해, 석환나라에 있는 위험한 도시의 개수를 계산해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 군부대의 수 <em>N</em>이 주어진다. (2 ≤<em> </em><em>N</em> ≤ 250,000)</p>

<p>이후 <em>N</em>개의 줄에 군부대가 있는 도시의 번호를 나타내는 수열 <em>A<sub>1</sub></em>, ..., <em>A<sub>N</sub></em>이 주어진다. 주어지는 도시들은 서로 다르다. (1 ≤ <em>A<sub>i</sub></em>&nbsp;< 2<sup>50</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>석환나라에 있는 위험한 도시의 개수를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
4 5 6 7
','7
','DATA_STRUCTURE'),
                                                                                                                (7693,'BAEKJOON','https://www.acmicpc.net/problem/17348',17348,'국제 옥토끼 기구','4초','1024 MB',25,'<p>달에 사는 곰인 옥토끼2는 국제 옥토끼 기구(IMO, International moonrabbit organization)&nbsp;회의 장소 예약부의 과장이다.&nbsp;지금까지 N개 국가가 달에 진출하여 기지를 하나씩 만들었다고 한다. 국가들은 1번부터 N번까지의 번호가 붙어있다.&nbsp;곰들은 달에서&nbsp;무역하기 위해서 두 기지 사이를&nbsp;연결하는 양방향 도로를&nbsp;만들었다. 양방향 도로는 비용 절감을 위해 N-1개만을 만들었고, 이 도로들만 이용해도 임의의 두 기지 사이를 이동할 수 있다고 한다. 도로는 1번부터 N-1번까지 번호가 붙어있다.&nbsp;i번 도로는 S<sub>i</sub>번 국가의 기지와 E<sub>i</sub>번 국가의 기지를 연결하며, 걸어서 이동하는데 D<sub>i</sub>초가 걸린다.</p>

<p>2020년 1월 1일, 국제 옥토끼 기구 탄생 100주년을 기념하여 1년간 매일 회의를 열기로 하였다. 2020년은 총 Q일이며, i번째 날의 회의는 V<sub>i</sub>번 국가의 기지에서 열리고, L<sub>i</sub> ~ R<sub>i</sub>번 국가의 기지들에서 각각 한 마리씩 참여한다.&nbsp;옥토끼2는 회의 장소를 예약하기 위해 i번째 날의 회의에 곰들이 도착하는 시간이 날이&nbsp;시작되고 몇 초 후인지를&nbsp;알아야&nbsp;한다. 모든 곰은 부지런하여 날이&nbsp;시작되는 즉시 출발하여 회의 장소까지 최단 시간으로 걸어오고, 회의가 끝나면 즉시 원래 있던 기지로 돌아간다. 회의가 열리는 날마다&nbsp;옥토끼2에게&nbsp;회의 장소에 가장 일찍&nbsp;도착하는 곰이 도착하는 시간, 가장 늦게 도착하는 곰이 도착하는 시간, 모든 곰이 도착하는 시간의 평균을 알려주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N, Q가&nbsp;주어진다. (1 ≤ N, Q ≤ 10<sup>5</sup>)</p>

<p>다음 N-1줄 중 i번째 줄에는 i번 도로의 정보&nbsp;S<sub>i</sub>, E<sub>i</sub>, D<sub>i</sub>가 주어진다. (1 ≤ S<sub>i</sub>, E<sub>i</sub> ≤ N, 1 ≤ D<sub>i</sub> ≤ 10<sup>8</sup>)</p>

<p>주어진 도로들만 이용해서 임의의 두 기지 사이를 이동할 수 있음이 보장된다.</p>

<p>다음 Q줄 중 i번째 줄에는 i번째 날의 회의에 대한 정보 L<sub>i</sub>, R<sub>i</sub>, V<sub>i</sub>가 주어진다. (1&nbsp;≤ L<sub>i</sub>&nbsp;≤ R<sub>i</sub>&nbsp;≤ N, 1&nbsp;≤ V<sub>i</sub>&nbsp;≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>i번째 날의 회의에서 가장 일찍 도착하는 곰이&nbsp;도착하는 시간을 min<sub>i</sub>초, 가장 늦게 도착하는 곰이 도착하는 시간을 max<sub>i</sub>초, 회의에 참석하는 모든 곰이 도착하는 시간의 합을 sum<sub>i</sub>초라고 할 때, i번째 줄에 min<sub>i</sub>, max<sub>i</sub>, sum<sub>i</sub>을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5
4 3 34
1 2 13
2 4 56
1 4 1
1 3 3
1 4 4
1 2 3
3 4 1
','0 103 185
0 103 193
0 69 159
90 103 193
69 103 172
','DATA_STRUCTURE'),
                                                                                                                (7692,'BAEKJOON','https://www.acmicpc.net/problem/17352',17352,'여러분의 다리가 되어 드리겠습니다!','1초','512 MB',11,'<p>선린월드에는 <em>N</em>개의 섬이 있다. 섬에는 1, 2, ..., <em>N</em>의 번호가 하나씩 붙어 있다.&nbsp;그 섬들을 <em>N&nbsp;</em>- 1개의 다리가 잇고 있으며, 어떤 두 섬 사이든 다리로 왕복할 수 있다.</p>

<p><strong>어제까지는 그랬다.</strong></p>

<p>"왜 다리가 <em>N&nbsp;</em>- 1개밖에 없냐, 통행하기 불편하다"며 선린월드에 불만을 갖던 욱제가 다리 하나를 무너뜨렸다! 안 그래도 불편한 통행이 더 불편해졌다. 서로 왕복할 수 없는 섬들이 생겼기 때문이다. 일단 급한 대로 정부는 선린월드의 건축가를 고용해, 서로 다른 두 섬을 다리로 이어서 다시 어떤 두 섬 사이든 왕복할 수 있게 하라는 지시를 내렸다.</p>

<p>그런데 그 건축가가 당신이다! 안 그래도 천하제일 코딩대회에 참가하느라 바쁜데...</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 정수 <em>N</em>이 주어진다. (2&nbsp;≤ <em>N</em>&nbsp;≤ 300,000)</p>

<p>그 다음 <em>N</em> - 2개의 줄에는 욱제가 무너뜨리지 않은 다리들이 잇는 두 섬의 번호가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>다리로 이을 두 섬의 번호를 출력한다. 여러 가지 방법이 있을 경우 그 중 아무거나&nbsp;한 방법만 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2
1 3
','1 4
','DATA_STRUCTURE'),
                                                                                                                (7696,'BAEKJOON','https://www.acmicpc.net/problem/17353',17353,'하늘에서 떨어지는 1, 2, ..., R-L+1개의 별','1초','512 MB',19,'<p>욱제의 은밀한 취미 중 하나는&nbsp;매일 밤하늘을 감상하는 것이다.&nbsp;?? 욱제는 하늘의 별들이 다음과 같은 규칙들을 따르며 떨어지는 걸 관찰했다.</p>

<ol>
	<li>별이 떨어지는 위치는&nbsp;N개의 점이다. 점은&nbsp;순서대로&nbsp;<em>1, 2, ..., N</em>의&nbsp;번호를 갖는다.</li>
	<li>매일 밤 별들은 <em>1, 2, ..., N</em>의 연속한 부분 구간 [L, R]에 떨어진다.</li>
	<li>[L, R]에 별이 떨어지면, 각 점에는 순서대로 <em>1, 2, ..., R-L+1</em>개의 별이 떨어진다.&nbsp;다시 말해,&nbsp;L에는 1개, L+1에는 2개, ..., R에는 R-L+1개의 별이 떨어진다.</li>
</ol>

<p>욱제는 하늘에서 떨어지는 별들을 기록하다가&nbsp;잠이 들어버렸다!!&nbsp;혹시나 했지만 역시나, 여러분은 욱제를 대신해 아래의 쿼리를 수행해야 한다. (ㅎㅎ;; ㅈㅅ.. ㅋㅋ!!)</p>

<ul>
	<li><strong>1 L R</strong>: [L, R]에 별이 떨어진다. (1 ≤ L&nbsp;≤&nbsp;R ≤ N)</li>
	<li><strong>2 X</strong>: 점 X에 떨어진 별의 개수의 합을&nbsp;출력한다.&nbsp;(1 ≤ X ≤ N)</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 별이 떨어지는 점의 개수 N이 주어진다. (1 ≤ N ≤ 10<sup>5</sup>)</p>

<p>둘째 줄에 욱제가 잠들기 전까지 세어 놓은, 이미 떨어진 별들의 개수 A<sub>1</sub>, ..., A<sub>N</sub>이 공백을 사이에 두고 주어진다.&nbsp;(0&nbsp;≤ A<sub>1</sub>, ..., A<sub>N</sub>&nbsp;≤ 10<sup>6</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 Q가 주어진다. (1 ≤ Q&nbsp;≤ 10<sup>5</sup>)</p>

<p>넷째 줄부터 Q개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리에 대한 답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 1 2 1
4
1 1 5
2 5
1 2 5
2 5
','6
10
','DATA_STRUCTURE'),
                                                                                                                (7695,'BAEKJOON','https://www.acmicpc.net/problem/17364',17364,'대회','1.5초(추가시간없음)','1024 MB',21,'<p>형섭이는 세계에서 고작 <em>K</em>번째로 프로그래밍을 잘하지만, 최대한 많은 프로그래밍 대회에서 우승하여 자신의 이름을 알리고 싶어한다. 형섭이가 프로그래밍 대회에 참가하면 자기보다 잘하는 사람에게는 항상 지고 자기보다 못하는 사람은 항상 이긴다. 즉, 형섭이가 프로그래밍 대회에서 우승하려면 형섭이보다 잘하는 사람이 대회에 참가하지 않아야 하며 그런 대회에서는 형섭이가 항상 우승한다.</p>

<p>전세계에서는 총 <em>N</em>개의 프로그래밍 대회가 개최되며 각 대회는 <em>S<sub>i</sub></em>일차부터 <em>E<sub>i</sub></em>일차까지 열린다. 대회가 열리는 장소가 다르므로 어느 누구라도 기간이 겹치는 대회는 동시에 참가할 수 없다. 형섭이는 자기보다 잘하는 <em>K</em>-1명의 사람들이 어떤 대회에 참가하는지 미리 알 수 있다. 형섭이는 <em>K</em>-1명이 참가하지 않는 대회들을 골라 최대한 많이 우승할 수 있도록 대회에 참가할 것이다.</p>

<p>만약 <em>K</em>-1명의 사람들이 적절하게 대회에 참가한다면 형섭이가 우승할 수 있는 대회가 얼마 없을 것이다. 형섭이는 그런 경우에 자신이 최대 몇 개의 대회에서 우승할 수 있는지 살펴보고자 한다. 대회의 정보가 주어질 때 형섭이가 우승할 수 있는 대회의 수를 구하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 대회의 수 <em>N</em> (1 ≤ <em>N</em> ≤ 100,000), 형섭이의 등수 <em>K</em> (1 ≤ <em>K</em> ≤ 100,000)가 주어진다.</p>

<p>두 번째 줄부터 <em>N</em>개의 줄에는 대회의 시작 날짜 <em>S<sub>i</sub></em>, 종료 날짜 <em>E<sub>i</sub></em>가 주어진다. (1 ≤ <em>S<sub>i</sub></em>, <em>E<sub>i</sub></em> ≤ 1,000,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>형섭이가 우승할 수 있는 최대 대회 수가 가장 적어지도록 <em>K</em>-1명이 대회에 적절히 참가할 때, 형섭이가 우승할 수 있는 대회 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 2
1 2
2 3
3 4
4 5
5 6
6 7
7 8
','2
','DATA_STRUCTURE'),
                                                                                                                (7697,'BAEKJOON','https://www.acmicpc.net/problem/17373',17373,'녜힁','1초(추가시간없음)','1024 MB',20,'<p>해조는 2019년 8월 3일에 오픈베타가 열리는 대작 MMORPG 패스 오브 여로에서 사전예약을 하려고 한다. 해조는 예쁜 두 글자 닉네임을 갖고 싶었지만 발 빠른 다른 유저들이 선점하여 가질 수 없었다.</p>

<p>해조가 선점된 닉네임의 규칙을 살펴본 결과 특정 소설에서 순서대로 두 글자를 따온 닉네임들은 전부 등록되어 있었고 그 외의 두 글자 닉네임은 모두 만들 수 있었다. 예를 들어 소설의 내용이 나랏말싸미듕귁에달아이라고 해보자. 해조가 발견한 규칙에 따르면 나미는 이미 있는 닉네임이고, 아싸는 언급된 글에서 아보다 싸가 앞에 있어서 소설에서 만들 수 없는 단어이므로 생성할 수 있는 닉네임이다.</p>

<p>해조는 만들 수 있는 두 글자 닉네임 중에서 사전 순으로 <em>K</em>번째로 앞서는 것을 닉네임으로 정하려고 한다. 해조는 <em>Q</em>개의 <em>K</em>를 정하여 닉네임을 구한 다음 그중에서 가장 예쁜 것을 선택할 예정이다. 해조를 도와 소설의 내용이 주어졌을 때 만들 수 있는 닉네임 중에서 사전 순으로 <em>K</em>번째로 앞선 것을 구하는 프로그램을 작성하여라.</p>

<p>편의상 모든 글자는 1 이상 <em>M</em> 이하의 정수로 표현하며, 닉네임 <em>AB</em>가 닉네임 <em>CD</em>보다 사전 순으로 앞선다는 것은 <em>A</em> < <em>C</em>이거나, <em>A</em> = <em>C</em>이고 <em>B</em> < <em>D</em>임을 의미한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 소설의 길이 <em>N</em>(1 ≤ <em>N</em> ≤ 100,000), 글자의 종류 수 <em>M</em>(1 ≤ <em>M</em> ≤ 1,000,000), 쿼리의 수 <em>Q</em>(1 ≤ <em>Q</em> ≤ 100,000)가 주어진다.</p>

<p>두 번째 줄에는 소설의 내용에 해당하는 <em>N</em>개의 1 이상 <em>M</em> 이하의 정수가 주어진다.</p>

<p>세 번째 줄부터 <em>Q</em>개의 줄에는 가지려는 닉네임의 사전 순 번호 <em>K</em>(1 ≤ <em>K</em> ≤ <em>M</em><sup>2</sup>)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em>개의 줄에 걸쳐 만들 수 있는 두 글자 닉네임 중 사전 순으로 <em>K</em>번째로 앞선 것을 출력한다. 앞글자와 뒷글자 사이는 공백으로 구분한다.</p>

<p>만약 만들 수 있는 닉네임의 개수가 <em>K</em>개보다 적다면 <code>-1 -1</code>을 출력한다.</p>

<p>앞선 쿼리는 이후의 쿼리에 영향을 주지 않는다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5 3
1 2 3 4 5
6
12
18
','3 3
5 2
-1 -1
','DATA_STRUCTURE'),
                                                                                                                (7702,'BAEKJOON','https://www.acmicpc.net/problem/17398',17398,'통신망 분할','1초','512 MB',16,'<p>BOJ의 인기스타, 방송인 권욱제는 통신 회사에 취업했다. 현재 이 통신 회사는 너무나 큰 통신망을 한 지사에서 관리하느라 큰 비용을 지불하고 있었다. 그래서 회사는 최근 IT의 트렌드 중 하나인 탈중앙화에 편승하여, 통신망을 분할하도록 결정했다. 그래서 욱제한테 통신망을 분할 할때 발생하는 비용을 분석하도록 지시했다.</p>

<p>현재 회사 망에는 1번부터 <em>N</em>번까지 총 <em>N</em>개의 통신 탑이 존재하며, 통신탑 간의 연결이 <em>M</em>개 존재한다. 이때 회사에서는 총 <em>Q</em>번 통신탑 간의 연결을 제거함으로써 하나의 통신망을 여러 개의 통신망으로 분리하려고 한다. 통신망이란, 통신탑의 연결을 통해 도달 가능한 통신탑들의 집합이다. 통신탑 간의 연결 관계를 제거할 때 드는 비용은 제거한 후 통신망이 두 개로 나누어진다면 나눠진 두 개의 통신망에 속한 통신탑들의 갯수의 곱이 되며, 나누어지지 않을 경우 0이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/d75e532b-f1f9-4284-a0ef-8f06ad920998/-/preview/" style="width: 365.833px; height: 224.167px;"></p>

<p style="text-align: center;"><그림 1></p>

<p>그림 1을 예시로 할때, 연결 (3, 4)를 제거하면 {1, 2, 3}, {4, 5, 6}으로 분할 되며, 이때 발생하는 비용은 3 × 3 = 9가 된다. 대신 연결 (2, 3)을 제거하면, 망이 나눠지지 않았기에&nbsp;비용은 0이 된다.</p>

<p>욱제는 회사의 요청에 따라 <em>Q</em>번의 제거를 통해 나오는 비용의 합을 구해야 한다. 하지만 욱제는 회사의 통신망을 이용해 방송하기 바쁘기 때문에 우리가 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 통신탑의 개수인 자연수 <em>N</em>, 통신탑 사이의 연결의 개수인 자연수 <em>M</em>, 통신망 연결 분할 횟수인 자연수 <em>Q</em>가 공백으로 구분되어 주어진다. (1&nbsp;≤ <em>N</em>&nbsp;≤ 100,000, 1&nbsp;≤ <em>M</em>&nbsp;≤ 100,000, 1&nbsp;≤ <em>Q</em>&nbsp;≤ <em>M</em>)</p>

<p>두 번째 줄부터 <em>M</em>개의 줄에 걸쳐 두 개의 자연수 <em>X</em>, <em>Y</em>가 공백으로 구분되어 주어진다. 이는 <em>X</em> 통신탑과 <em>Y</em> 통신탑 사이에 연결이 있음을 뜻한다. (1&nbsp;≤ <em>X</em>,&nbsp;<em>Y</em>&nbsp;≤&nbsp;<em>N,&nbsp;X </em>≠<i>&nbsp;Y</i>)</p>

<p>중복된 연결은 주어지지 않으며, 모든 통신탑은 처음엔 하나의 통신망에 속한다. 조건에 의해 자기 자신과 연결이 있는 통신탑은 없다.</p>

<p>그 다음 줄부터 <em>Q</em>개의 줄에 걸쳐 제거될 연결의 번호인 자연수 <em>A</em>가 주어진다. 이는 <em>A</em>번째로 입력된 (<em>X</em>, <em>Y</em>)의 연결이 제거되었음을 의미한다. (1&nbsp;≤ <em>A</em>&nbsp;≤ <em>M</em>)</p>

<p>이미 제거된 연결은 다시 제거되지 않으며, 제거는 입력 순서대로 진행된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 <em>Q</em>개의 연결을 순서대로 제거하는데 드는 비용의 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 4 3
1 2
2 3
3 4
1 4
4
2
3
','5
','DATA_STRUCTURE'),
                                                                                                                (7698,'BAEKJOON','https://www.acmicpc.net/problem/17400',17400,'깃발춤','2초','512 MB',16,'<p>매일 코딩만 하던 상헌이는 두뇌가 너무 코드에만 범벅이 되고 있는 것 같아 두뇌를 다른 방면으로 몰입시킬 수 있는 깃발춤 공연을 보러 가기로 했다. 깃발춤 공연은 <em>N</em>명의 공연자들이 일렬로 서서 깃발을 박력 있게 흔들며 진행된다. 깃발을 들고 있는 공연자들은 각각 카리스마의 정도 <em>c<sub>i</sub></em>를 지니고 있어, 몇몇 공연자들은 보다 절도 있게 깃발을 흔든다.</p>

<p>상헌이는 깃발춤을 보다가, 문득 깃발춤 공연 중 몇몇 연속된 공연자들이 깃발을 교대로 흔드는 것을 목격했다. 상헌이는 이를 교대 깃발춤이라 명명하였다. 교대 깃발춤은 <em>L</em>번째 공연자부터 <em>R</em>번째 공연자까지 깃발을 각자 왼쪽 또는 오른쪽으로 흔드는 동작인데, <em>L</em>번째 공연자를 포함하여 <em>L</em>번째 공연자과의 거리가 짝수인 공연자는 깃발을 왼쪽으로 흔들고, 거리가 홀수인 공연자는 오른쪽으로 흔든 뒤, 다시 깃발을 몸 쪽으로 원위치시킨다. 여기서 <em>x</em>번째 공연자와 <em>y</em>번째 공연자 사이의 거리는 |<em>x</em> - <em>y</em>|로 표현된다.</p>

<p>문제 해결에서 벗어날 수 없었던 상헌이는 교대 깃발춤에서 왼쪽으로 깃발을 흔든 공연자들의 카리스마의 합과 오른쪽으로 깃발을 흔든 공연자들의 카리스마의 합의 차이의 절댓값을 교대 깃발춤의 균일도라고 부르기로 하였다. 교대 깃발춤의 균일도가 큰 값을 가지면, 한쪽이 다른 쪽보다 압도적으로 카리스마가 느껴진다는 뜻이기에 비대칭적으로 보일 수 있다. 상헌이는 교대 깃발춤의 균일도가 중요한 의미를 지닌다고 생각한다. 또 깃발을 흔드는 공연자들은 공연의 열기와 순간순간의 실수에 휩쓸리기 때문에, 공연자들의 카리스마가 증가하거나 감소할 수 있다. 이런 모든 상황을 고려하며 상헌이는 매 교대 깃발춤의 균일도를 구하고 싶어졌다. 상헌이를 도와주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 깃발춤을 진행하는 공연자의 명수인 자연수 <em>N</em>과 상황 변화의 개수인 자연수 <em>Q</em>가 공백으로 구분되어 주어진다. (1 ≤ <em>N</em> ≤ 300,000, 1&nbsp;≤ <em>Q</em>&nbsp;≤ 300,000)<br>
두 번째 줄에는 정수 <em>c<sub>1</sub></em>, <em>c<sub>2</sub></em>, ..., <em>c<sub>N</sub></em> 이 공백으로 구분되어 주어지며, <em>c<sub>i</sub></em> 는 <em>i </em>번째 공연자의 카리스마를 의미한다. (-100,000 ≤ <em>c<sub>i</sub></em> ≤ 100,000)<br>
세 번째 줄부터<em> Q </em>개의 줄에 걸쳐 다음 형식 중 하나로 세 정수가 공백으로 구분되어 주어진다.<br>
- <code>1</code> <em>L</em> <em>R</em> : <em>L </em>번째 공연자부터 <em>R</em> 번째 공연자까지 구성된 교대 깃발춤이 시연된다. (1 ≤ <em>L</em>&nbsp;≤ <em>R</em> ≤ <em>N</em>)<br>
- <code>2</code> <em>L</em> <em>x</em> : <em>L </em>번째 공연자의 카리스마가 정수 <em>x</em>만큼 증가한다. (1 ≤ <em>L</em> ≤ <em>N</em>, -100,000 ≤ x ≤ 100,000)<br>
첫 번째 종류(<code>1</code> <em>L</em> <em>R</em> 꼴)의 쿼리는 한 번 이상 주어짐이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 종류의 쿼리가 입력될 때마다 매 줄에 해당하는 교대 깃발춤의 균일도를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 3
3 1 4 1 5 9
1 2 4
2 3 10
1 3 6
','2
9
','DATA_STRUCTURE'),
                                                                                                                (7701,'BAEKJOON','https://www.acmicpc.net/problem/17407',17407,'괄호 문자열과 쿼리','0.5초','512 MB',18,'<p>괄호 문자열은&nbsp;(와 )로 이루어진 문자열이고,&nbsp;올바른 괄호 문자열은 다음과 같이 정의된다.</p>

<ol>
	<li>빈 문자열은 올바른 괄호 문자열이다.</li>
	<li>S가 올바른 괄호 문자열일 때, (S)도 올바른 괄호 문자열이다.</li>
	<li>S와 T가 올바른 괄호 문자열이라면, ST도 올바른 괄호 문자열이다.</li>
	<li>모든 올바른 괄호 문자열은 위의 3개 규칙으로만 만들 수 있다.</li>
</ol>

<p>(와 )로 이루어진 괄호 문자열 S = s<sub>1</sub>s<sub>2</sub>...s<sub>N</sub>과 M개의 쿼리가 주어진다. 쿼리는 정수 하나 index로 이루어져 있고,&nbsp;쿼리가 의미하는 것은 다음과 같다.</p>

<ul>
	<li>S의 i번째 문자가 (면 )로, )면 (로 변경한다.</li>
</ul>

<p>쿼리의 수행은 누적되며, i번째 쿼리는 i-1번째 쿼리가 수행된 결과에 수행되어야 한다. 각 쿼리를 수행한 결과가&nbsp;올바른 괄호 문자열이었던 횟수를 모두 세어보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 문자열 S가 주어진다. 둘째 줄에 쿼리의 개수 M이 주어진다. 셋째 줄부터 M개의 줄에 쿼리 index가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 쿼리를 수행한 결과가 올바른 괄호 문자열이었던 횟수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>S = "<code>()()()()</code>"에 예제 1의 쿼리를 수행한 결과는 다음과 같다.</p>

<ul>
	<li><code>((()()()</code></li>
	<li><code>((()()))</code></li>
	<li><code>((((()))</code></li>
	<li><code>(((())))</code></li>
	<li><code>(()())))</code></li>
	<li><code>(()())()</code></li>
	<li><code>)()())()</code></li>
	<li><code>)))())()</code></li>
</ul>

				</div>
				</div>','()()()()
8
2
7
4
5
3
7
1
2
','3
','DATA_STRUCTURE'),
                                                                                                                (7699,'BAEKJOON','https://www.acmicpc.net/problem/17408',17408,'수열과 쿼리 24','1초','512 MB',17,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오</p>

<ul>
	<li><code>1 i v</code>: A<sub>i</sub>를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 10<sup>9</sup>)</li>
	<li><code>2 l r</code>: l ≤ i <&nbsp;j ≤ r을 만족하는 모든 A<sub>i</sub> + A<sub>j</sub> 중에서 최댓값을&nbsp;출력한다. (1 ≤ l < r ≤ N)</li>
</ul>

<p>수열의 인덱스는 1부터 시작한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (2 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (2&nbsp;≤ M ≤ 100,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
5 4 3 2 1
6
2 2 4
2 1 4
1 5 5
2 3 5
1 4 9
2 3 5
','7
9
8
14
','DATA_STRUCTURE'),
                                                                                                                (7700,'BAEKJOON','https://www.acmicpc.net/problem/17409',17409,'증가 수열의 개수','1초','512 MB',17,'<p>크기가 N인 수열 A와 정수 K가 주어졌을 때, A의 증가하는 부분 수열 중에서 길이가 K인 것의 개수를 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N, K가 주어진다. 둘째 줄에 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 A의 증가하는 부분 수열 중에서 길이가 K인 것의 개수를 10<sup>9</sup>+7로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 1
1 2 3 5 4
','5
','DATA_STRUCTURE'),
                                                                                                                (7703,'BAEKJOON','https://www.acmicpc.net/problem/17411',17411,'가장 긴 증가하는 부분 수열 6','2초','512 MB',19,'<p>수열 A가 주어졌을 때, 가장 긴 증가하는&nbsp;부분&nbsp;수열과 개수를&nbsp;구하는 프로그램을 작성하시오.</p>

<p>예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분&nbsp;수열은&nbsp;A = {<strong>10</strong>, <strong>20</strong>, 10, <strong>30</strong>, 20, <strong>50</strong>} 이고, 길이는 4이고,&nbsp;1개이다. A = {10, 20, 30, 10, 20, 30}인 경우에는 가장 긴 증가하는 부분 수열의 길이는 3이고, 4개가 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.</p>

<p>둘째 줄에는 수열 A를 이루고 있는 A<sub>i</sub>가 주어진다. (-1,000,000,000&nbsp;≤ A<sub>i</sub>&nbsp;≤ 1,000,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이와 개수를 출력한다. 개수는 매우 커질 수 있기 때문에 10<sup>9</sup>+7로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
10 20 10 30 20 50
','4 1
','DATA_STRUCTURE'),
                                                                                                                (7712,'BAEKJOON','https://www.acmicpc.net/problem/17421',17421,'빗물이 넘쳐흘러','1초(추가시간없음)','512 MB',18,'<p>정우가 살고있는&nbsp;마을은 분지(주위가 산지로 둘러싸여 주변보다 낮은 지형)이다. 한가로이 낮잠을 즐기던 정우는&nbsp;마을의 왼쪽으로부터&nbsp;물이 흘러 들어오고&nbsp;있는 것을 보았다!</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3fdde286-20ea-47e0-ad72-95105e18baf9/-/crop/792x653/0,0/-/preview/" style="height: 275px; width: 333.333px;"></p>

<p>정우가 일찍 발견한 덕에 주민들과 정우는 무사히 탈출했지만, 호기심 꾸러기 정우는&nbsp;흘러들어온 물이 언제 처음으로&nbsp;<em>K</em>덩이가 되는지 궁금해졌다. (위의 그림에서 물은 3덩이이다.)</p>

<p>호기심 많고 마을 사람들도 구한 멋진 정우이지만, 똑똑하지는 않기 때문에 여러분이 도와주도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 마을의 가로 길이&nbsp;<em>N</em>, 정우가 궁금해하는&nbsp;<em>K</em>가&nbsp;공백을 사이에 두고&nbsp;주어진다.</p>

<p>둘째 줄에 마을의 생김새에 대한&nbsp;정보가 주어진다. <em>N</em>개의 수&nbsp;<em>A<sub>1</sub>,&nbsp;A<sub>2</sub>, ... ,&nbsp;A<sub>N-1</sub>, A<sub>N</sub></em>이 주어지는데, <em>A</em><sub><em>i</em></sub>는 <em>i</em>번째 땅의 깊이이다.</p>

<p>문제 설명의 그림에 나와있는 마을은 <em>N</em> = 8, <em>A</em> = [3, 6, 4, 2, 4, 3, 5, 5]인 경우이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 물이 최초로 <em>K</em>덩이가 되는 순간&nbsp;<strong>직전</strong>의 물의 양을 출력한다.&nbsp;(왜 직전인지는 예제 해설을 보자)</p>

<p>만약 그런 순간이 없다면 -1을 출력한다.</p>

<section id="output">
<p><strong>정답이 32비트 정수를 넘을 수 있으므로 유의하라.</strong></p>
</section>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 2
3 1 4
','2
','DATA_STRUCTURE'),
                                                                                                                (7709,'BAEKJOON','https://www.acmicpc.net/problem/17423',17423,'민원이 넘쳐흘러','5초(추가시간없음)','512 MB',20,'<p style="text-align: center;"><em>??&nbsp;DJ욱제는 슈퍼카 위에서&nbsp;디제잉을 하고 있다.&nbsp;??</em></p>

<p style="text-align: justify;"><em>DJ욱제</em>는 자신의 엄청난 디제잉을 사람들에게 알리기로 했다. 그래서 새벽 3시에 슈퍼카를 타고 아파트 단지를 누비며 최고 볼륨으로 디제잉을 하기 시작했다.&nbsp;??</p>

<p style="text-align: justify;">하지만 스피커 하나로는 예술의 경지에 다가갈 수 없었다. 그래서&nbsp;<em>DJ욱제</em>는 다음과 같이 광역디제잉(<s>광역딜</s>)을 하기로 했다.</p>

<ol>
	<li style="text-align: justify;">아파트 단지는 2차원 격자로 표현되며,&nbsp;두 점 (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>)의 거리는 |<em>x</em><sub>1</sub> - <em>x</em><sub>2</sub>|&nbsp;+ |<em>y</em><sub>1</sub> - <em>y</em><sub>2</sub>|&nbsp;이다.</li>
	<li style="text-align: justify;"><em>DJ욱제</em>는 <em>N</em>개의 스피커를 각&nbsp;(<em>x<sub>i</sub></em>, <em>y<sub>i</sub></em>)에 설치했다.</li>
	<li style="text-align: justify;">스피커들은 크기가 제각각이다.&nbsp;<em>i</em>번째 스피커의 크기가&nbsp;<em>S<sub>i</sub></em>이고 볼륨이 <em>V</em>이면, 그 스피커의 음악은 스피커와의 거리가 <em>V</em>×<em>S<sub>i</sub></em>&nbsp;이내인 모든 점에서 들을 수 있다.</li>
	<li style="text-align: justify;">볼륨은&nbsp;정수 단위로만 조작 가능하며, 모든 스피커의 볼륨은&nbsp;같다.</li>
	<li style="text-align: justify;">『 <strong>예술은&nbsp;볼륨이다.</strong> 』</li>
</ol>

<p style="text-align: justify;"><em>DJ욱제</em>는 볼륨을 높이며 예술의 경지에 다다르고 있다! 하지만&nbsp;예술을 모르는 어떤 사람들은 한 번에 <strong>두 개 이상의 스피커에서 음악이 들리면</strong>&nbsp;민원을 넣는다고 한다. (;;) 그래서 <em>DJ욱제</em>는 민원이 들어오지 않는 선에서&nbsp;볼륨을 최대한으로 키우기로 했다. 소리가&nbsp;들리는 범위의 경계선이나 경계점이 겹치는 경우는&nbsp;음악이 겹치지 않는 걸로 치자.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/a4f4b6ae-caf7-411a-8fee-f35155a474d0/-/crop/1883x1090/0,0/-/preview/" style="width: 375px; height: 217.5px;"></p>

<p style="text-align: justify;"><em>DJ욱제</em>의 예술(볼륨)을 온 몸으로 느껴보자!&nbsp;<em>DJ욱제</em>의 예술(볼륨)은 얼마나 커질 수 있을까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에&nbsp;스피커&nbsp;개수 <em>N</em>이&nbsp;주어진다.</p>

<p>둘째 줄에 스피커의 크기 <em>S<sub>1</sub></em>,&nbsp;<em>S<sub><span style="font-size: 10.8333px;">2</span></sub></em>, ...,&nbsp;<em>S<sub>N</sub></em>가 순서대로 주어진다.</p>

<p>셋째 줄부터&nbsp;<em>N</em>개의 줄에 걸쳐, <em>i+2</em>번째 줄에 <em>i</em>번 스피커의 좌표&nbsp;<em>x<sub>i</sub></em>, <em>y<sub>i</sub></em>가 주어진다. 중복되는 좌표는 없다.</p>

<p>주어지는 모든 입력은 1 이상의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>DJ욱제</em>가 다다를 수 있는 예술(볼륨)의 최대 크기를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2 1 1 3
2 2
1 7
6 6
5 13
','2
','DATA_STRUCTURE'),
                                                                                                                (7708,'BAEKJOON','https://www.acmicpc.net/problem/17424',17424,'2xN 타일링과 쿼리','2초','256 MB',22,'<p>2xN&nbsp;크기의 직사각형에 1x2 또는 2x1크기의 타일로&nbsp;채우는 방법의 수를 구하는 문제는 잘 알려져 있다.</p>

<p>최초에 아무런 제한이 없는 2xN&nbsp;직사각형에 블럭을 놓는 칸에 대한 제한이 빈번히 생기고 사라질 때 제한을 제외한 나머지 칸을 전부 채우는 방법의 수를 구하는 프로그램을&nbsp;작성하시오.</p>

<p>각 쿼리는 다음과 같다.</p>

<ul>
	<li>1 x y : (x,y)의 위치에 블럭을 놓을 수 없다는 제한을 추가한다. 이전에 제한이 없었음이 보장된다.</li>
	<li>2 x y : (x,y)의 위치에 블럭을 놓을 수 없다는 제한을 삭제한다. 이전에 제한이 있었음이 보장된다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째줄에 N과 쿼리의 수를 나타내는 정수 Q가 공백으로&nbsp;구분하여 주어진다. (1 ≤ N&nbsp;≤ 10<sup>5</sup>????, 1 ≤ Q ≤ 2 x 10<sup>5</sup>)</p>

<p>둘째줄부터 Q줄에 걸쳐 2가지 종류의 쿼리가 주어진다. 각 쿼리는 t x y꼴로 주어지며 1 ≤ t, x ≤ 2, 1 ≤ y ≤ N을 만족한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q개의 줄에 걸쳐 i번째 쿼리까지 적용했을 때의 경우의 수를 (10<sup>9</sup> + 7)로 나눈 나머지를 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 6
1 1 2
1 1 3
1 2 1
2 1 2
1 1 5
2 1 3
','0
2
0
2
0
1
','DATA_STRUCTURE'),
                                                                                                                (7707,'BAEKJOON','https://www.acmicpc.net/problem/17429',17429,'국제 메시 기구','3초','1024 MB',22,'<p>야구선수인 <a href="https://www.acmicpc.net/user/messi">메시</a>는 국제 메시&nbsp;기구(IMO, International messi organization)의 금고 관리자이다. 트리를 사랑하는 메시는 금고를 금고 1이 루트인 트리 모양으로 연결해서 관리한다고 한다.</p>

<p>업무시간에 <a href="https://www.acmicpc.net/problem/1000">A+B</a>를&nbsp;풀고 있던 메시는 메일 하나를 받았는데, 그 메일에는 메시&nbsp;흑역사.jpg.exe라는 이름의 첨부파일이 하나 있었다. 안 그래도 어제 도난 사건으로 금고 N개가 다 털려 0원밖에 남지 않아 해고당할 위기에 처했는데 흑역사까지 드러날 위기에 처한 메시는 한 치의 고민도 없이 첨부파일을 열었다. 그러자 이상한 콘솔 창이 등장했다!</p>

<p>금★고의 요☆정 지♨니! 금고 속의 돈을 늘려드립니다! 명령어를 입력하세요. 명령어의 목록은 다음과 같습니다.</p>

<ul>
	<li>"1 X V" 금고 X의 서브트리에 있는 모든 금고에 V원을 더합니다. (1 ≤ X ≤ N, 1 ≤ V&nbsp;≤ 10<sup>9</sup>)</li>
	<li>"2 X Y V" 금고 X부터 금고 Y까지의 경로에 있는 모든 금고에 V원을 더합니다. 단, 경로는 경계를 포함합니다. (1 ≤ X, Y ≤ N, 1&nbsp;≤ V&nbsp;≤ 10<sup>9</sup>)</li>
	<li>"3 X V" 금고 X의 서브트리에 있는 모든 금고의 돈을 V배 합니다. (1 ≤ X ≤ N, 0&nbsp;≤ V&nbsp;≤ 10<sup>9</sup>)</li>
	<li>"4 X Y V" 금고 X부터 금고 Y까지의 경로에 있는 모든 금고의 돈을 V배 합니다. 단, 경로는 경계를 포함합니다. (1 ≤ X, Y ≤ N, 0&nbsp;≤ V&nbsp;≤ 10<sup>9</sup>)</li>
	<li>"5 X" 금고 X의 서브트리에 있는 모든 금고의 돈을 합한 값을 출력합니다. (1 ≤ X ≤ N)</li>
	<li>"6 X Y" 금고 X부터 금고 Y까지의 경로에 있는 모든 금고의 돈을 합한 값을 출력합니다. 단, 경로는 경계를 포함합니다.&nbsp;(1 ≤ X, Y ≤ N)</li>
</ul>

<p>메시는 도난 사건을 없던 일로 만들 기회라고 생각하여 명령어를 입력했지만, 이 파일은 당연하게도 바이러스라서 메시가 3개월간 짜던 A+B의 코드를 다 날려버렸다. 화가 난 메시는&nbsp;위의 명령어를 실행하는 프로그램을 직접 만들기로 했다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N, Q가 주어진다.&nbsp;(1 ≤ N&nbsp;≤ 500,000, 1 ≤ Q&nbsp;≤ 100,000)</p>

<p>다음 N-1줄 중 i번째 줄에는 S<sub>i</sub>, E<sub>i</sub>가 주어지며, 이는 금고 S<sub>i</sub>와 금고 E<sub>i</sub>가 연결되어 있다는 뜻이다. (1 ≤ S<sub>i</sub>, E<sub>i</sub>&nbsp;≤ N)</p>

<p>금고가 연결된 모양은 올바른 트리 모양이다.</p>

<p>다음 Q줄에는 명령어들이 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력 명령어가 주어질 때마다 값을 출력한다. 단, 메시의 컴퓨터는&nbsp;최신 트렌드인 4294967296비트 컴퓨터와는 다르게 32비트 컴퓨터이므로&nbsp;2<sup>32</sup>로 나눈 나머지를 대신 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 10
2 4
4 3
5 4
2 1
3 1 82
6 3 5
2 2 5 45
2 3 2 70
6 3 5
5 3
4 2 1 47
1 1 95
6 3 2
4 5 1 38
','0
230
70
5875
','DATA_STRUCTURE'),
                                                                                                                (7710,'BAEKJOON','https://www.acmicpc.net/problem/17430',17430,'가로등','0.5초','256 MB',11,'<p>2차원 공간 위에 가로등이 N개 배치되어 있다. i번째 가로등의 위치는 (x<sub>i</sub>, y<sub>i</sub>)이고, 각 좌표는 정수이다. 서로 다른 가로등의 위치가 같은 경우는 없다.</p>

<p>두 가로등 i와 j(i < j)가 있을 때, (x<sub>i</sub>, y<sub>j</sub>)와 (x<sub>j</sub>, y<sub>i</sub>)에 가로등이 있으면, 가로등 i와 j는 균형이 잡혀있다고 한다. 모든 가로등 쌍이 균형잡혀 있는지 아닌지 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다.</p>

<p>각 테스트 케이스의 첫째 줄에는 가로등의 수 N이 주어지고, 다음 N개의 줄에 걸쳐서 가로등의 위치&nbsp;x<sub>i</sub>, y<sub>i</sub>가 공백으로 구분해 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 모든 가로등의 쌍이 균형 잡혀 있으면 "<code>BALANCED</code>", 아니면 "<code>NOT BALANCED</code>"를 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
6
2 3
2 -3
2 1
-2 3
-2 1
-2 -3
6
2 4
2 -3
2 1
-2 3
-2 1
-2 -3
','BALANCED
NOT BALANCED
','DATA_STRUCTURE'),
                                                                                                                (7711,'BAEKJOON','https://www.acmicpc.net/problem/17435',17435,'합성함수와 쿼리','1초','512 MB',15,'<p>함수 f : {1, 2, ..., m}→{1, 2, ..., m}이 있다. 이때&nbsp;f<sub>n</sub> : {1, 2, ..., m}→{1, 2, ..., m}을 다음과 같이 정의하자.</p>

<ul>
	<li>f<sub>1</sub>(x) = f(x)</li>
	<li>f<sub>n+1</sub>(x) = f(f<sub>n</sub>(x))</li>
</ul>

<p>예를 들어 f<sub>4</sub>(1) = f(f(f(f(1))))이다.</p>

<p>n과 x가 주어질 때 f<sub>n</sub>(x)를 계산하는 쿼리를 수행하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 정수 m이 주어진다. (1&nbsp;≤ m&nbsp;≤ 200,000)</p>

<p>다음 줄에 f(1), f(2), ..., f(m)이 차례대로 주어진다.</p>

<p>다음 줄에 쿼리의 개수 Q가 주어진다. (1&nbsp;≤ Q&nbsp;≤ 200,000)</p>

<p>다음 Q개의 줄에 각각 정수 n과 x가 주어진다. (1&nbsp;≤ n&nbsp;≤ 500,000; 1&nbsp;≤ x&nbsp;≤ m)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>주어지는 n, x마다 f<sub>n</sub>(x)를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
3 3 5 4 3
5
1 1
2 1
11 3
1000 4
5 1
','3
5
5
4
3
','DATA_STRUCTURE'),
                                                                                                                (7714,'BAEKJOON','https://www.acmicpc.net/problem/17442',17442,'삼분 그래프','2초(추가시간없음)','1024 MB',23,'<p><strong>3분 그래프</strong>라는 음식을 아는가? 3분 그래프는 서울대학교 컴퓨터공학부 학생들의 지친 심신을 위로해주는 보양식으로, 이름에서 알 수 있듯 간편한 조리 방식과 깊은 풍미를 가지고 있어 널리 사랑받는 음식이다. 유향맛, 무향맛, 완전맛, 트리맛 등 다양한 맛이 출시되어 있어서 골라 먹는 재미도 있다. SNUPS의 회장인 동현이도 역시 3분 그래프를 좋아하는데, 동현이가 가장 좋아하는 맛은 <strong>평면맛</strong>이라고 한다.</p>

<p style="margin-top: 15px;"><img alt="alt text" src="https://upload.acmicpc.net/e9f34ce2-0c41-4255-b9ad-d2a516e39d06/-/preview/" style="display: block; margin-left: auto; margin-right: auto; width: 100%; max-width: 300px;"></p>

<p style="margin-bottom: 15px; text-align: center;">3분 그래프 평면맛. 국산 정점을 쓴다.</p>

<p>3분 그래프 평면맛은 이름에서 알 수 있듯이 정점 <span style="font-style: italic;">N</span>개와 간선 <span style="font-style: italic;">M</span>개를 가진 평면 그래프 형태인데, 포장을 뜯으면 그 안에 항상 일정한 형태로 고정되어 들어 있다. 다시 말해, 포장지 왼쪽 아래에 유클리드 좌표계의 원점이 있다고 할 때 각 정점이 가지는 좌표가 항상 일정하다. 간선들은 끝점 외의 점에서 교차하지 않으며, 전체 그래프는 항상 연결되어 있다.</p>

<p>동현이는 3분 그래프 평면맛을 더욱 맛있게 즐기기 위해 많은 고민을 해 오고 있었는데, 그러던 어느 날 갑자기 무언가를 깨달았다. 그것은 바로, <strong>3분</strong> 그래프라는 이름에는 그래프를 <strong>세 부분</strong>으로 나누어 먹으라는 깊은 뜻이 숨겨져 있다는 사실이었다!</p>

<p>이제 동현이는 자신이 알아낸 엄청난 사실을 이용해 3분 그래프를 최상의 맛으로 즐기려고 한다. 이를 위해, 동현이는 총 <span style="font-style: italic;">Q</span>개의 실험을 준비했다. 각 실험은 서로 다른 두 정수의 순서쌍 (<span style="font-style: italic;">A</span>,<span style="font-style: italic;">B</span>)로 나타낼 수 있으며, <span style="font-style: italic;">x</span>=<span style="font-style: italic;">A</span>, <span style="font-style: italic;">x</span>=<span style="font-style: italic;">B</span>의 두 직선으로 그래프를 <strong>삼분</strong>하는 실험을 뜻한다. 단, 직선이 정점을 지나게 될 경우 정점이 부서져 정점을 씹는 맛을 즐길 수 없기 때문에 그런 경우는 없게 할 것이다.</p>

<p>(그래프의 정점을 지나지 않는) 수직선이 그래프를 분할한다는 것은, 그 수직선과 그래프의 간선이 만나는 모든 지점에 대해 그 지점에서 간선을 둘로 나누고, 나뉜 끝부분 두 개에 각각 새로운 정점을 추가하는 것을 의미한다.</p>

<p>분할 지점을 어떻게 잡느냐에 따라 그래프의 연결 성분이 몇 개가 되는지, 즉 그래프가 총 몇 조각으로 잘리게 되는지가 달라질 텐데, 동현이는 <span style="font-style: italic;">Q</span>개의 실험을 각각 독립적으로 수행한 뒤 가장 자신의 마음에 들게 조각이 나뉘는 분할 방식을 고르려고 한다.</p>

<p>아쉽게도 동현이는 3분 그래프 평면맛을 <span style="font-style: italic;">Q</span>개나 살 만큼 부자가 아니었기 때문에 SNUPC를 치러 온 여러분에게 실험을 대신 해 달라고 맡기려고 한다. 동현이가 맛있는 3분 그래프를 즐길 수 있도록 도와주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 3분 그래프의 정점 수 <span style="font-style: italic;">N</span>, 간선 수 <span style="font-style: italic;">M</span>, 동현이가 궁금한 계획의 수 <span style="font-style: italic;">Q</span>가 주어진다. (2 ≤ <span style="font-style: italic;">N</span> ≤ 100,000, 1 ≤ <span style="font-style: italic;">M</span> ≤ 200,000, 1 ≤ <span style="font-style: italic;">Q</span> ≤ 200,000)</p>

<p>다음 <span style="font-style: italic;">N</span>개의 줄에 각 정점의 좌표 <span style="font-style: italic;">x</span>, <span style="font-style: italic;">y</span>가 정점 번호 순서대로 주어진다. 모든 정점의 좌표는 서로 다르다. (1 ≤ <span style="font-style: italic;">x</span> ≤ 10<sup>9</sup>, 1 ≤ <span style="font-style: italic;">y</span> ≤ 10<sup>9</sup>)</p>

<p>다음 <span style="font-style: italic;">M</span>개의 줄에 각 간선이 잇는 두 정점의 번호 <span style="font-style: italic;">U</span>, <span style="font-style: italic;">V</span>가 주어진다. 각 간선은 서로 다른 두 정점을 연결하며, 같은 정점 쌍을 잇는 간선은 최대 하나 있다. 각 간선은 양 끝점을 제외하고 다른 간선과 만나지 않는다. 주어지는 그래프는 연결 그래프이다. (1 ≤ <span style="font-style: italic;">U</span> ≤ <span style="font-style: italic;">N</span>, 1 ≤ <span style="font-style: italic;">V</span> ≤ <span style="font-style: italic;">N</span>, <span style="font-style: italic;">U&nbsp;</span>≠&nbsp;<span style="font-style: italic;">V</span>)</p>

<p>다음 <span style="font-style: italic;">Q</span>개의 줄에 동현이가 준비한 실험 각각을 나타내는 두 수 <span style="font-style: italic;">A</span>, <span style="font-style: italic;">B</span>가 주어진다. 이는 <span style="font-style: italic;">x</span>=<span style="font-style: italic;">A</span>, <span style="font-style: italic;">x</span>=<span style="font-style: italic;">B</span>의 두 직선으로 그래프를 자른다는 뜻이다. 각 직선은 정점을 지나지 않으며, 적어도 하나의 간선을 지난다. (1 ≤ <span style="font-style: italic;">A&nbsp;</span><&nbsp;<span style="font-style: italic;">B</span> ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><span style="font-style: italic;">Q</span>개의 줄에 걸쳐, <span style="font-style: italic;">i</span>번째 줄에는 동현이가 <span style="font-style: italic;">i</span>번째 실험을 수행했을 때 3분 그래프가 총 몇 조각으로 나뉘는지 출력한다. 실험들이 서로 독립적임을 유의하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 7 4
1 3
3 4
5 2
7 3
9 6
11 4
1 2
1 3
2 4
2 5
3 6
4 5
4 6
2 6
4 8
2 10
8 10
','4
6
4
5
','DATA_STRUCTURE'),
                                                                                                                (7713,'BAEKJOON','https://www.acmicpc.net/problem/17443',17443,'여우 퀴즈','3초(추가시간없음)','1024 MB',22,'<p>관악산 기슭에 살던 달빛 여우는 마침내 달빛을 받아 구미호가 되었지만, 구미호의 상징인 여우구슬이 없어 힘이 약한 꼬마 구미호가 되었다. 달빛 여우는 완전한 구미호로 거듭나기 위해서 근처 대학에 들어가 "여우구슬 만들기 강의를 듣기로 했다.</p>

<p>이 강의에서는 첫 주에 OX 문제 목록을 주고, 그 뒤로 매주 그 목록의 연속된 일부분을 골라서 퀴즈를 본다. 이 문제들은 정말 어려워서 학생들의 정답률은 처참하다. 대신 이 퀴즈에는 보너스 점수를 얻을 수 있는 특별한 규칙이 있다. 학생들은 문제의 답으로 O나 X 대신 <strong>F</strong>를 적을 수 있고, 연속한 세 문제의 답을 <strong>F</strong>, <strong>O</strong>, <strong>X</strong> 순으로 적으면 보너스 점수를 얻는다. 그래서 문제 풀기를 포기하고 답을 "F, O, X, F, O, X, …로 적어 내는 학생들도 자주 나온다.</p>

<p>부지런한 달빛 여우는 미리 모든 문제의 답을 생각해 놓았다. 그러나 답에 확신이 없기 때문에 퀴즈를 볼 때는 몇몇 문제에 자신이 생각한 답 대신 F를 적어서 보너스 점수를 노리려고 한다. 또한 강의를 들으면서 새로운 것을 배우면 달빛 여우의 생각이 중간에 달라질 수도 있다.</p>

<p>매 퀴즈에서 달빛 여우가 얻을 수 있는 최고 점수를 구해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 목록에 있는 문제의 수를 의미하는 정수 <span style="font-style: italic;">N</span>(1 ≤ <span style="font-style: italic;">N</span> ≤ 250,000), 문제 하나를 맞혔을 때 얻는 점수를 의미하는 정수 <span style="font-style: italic;">A</span>, 보너스 점수를 의미하는 정수 <span style="font-style: italic;">B</span>(0 ≤ <span style="font-style: italic;">A</span>, <span style="font-style: italic;">B</span> ≤ 100)가 공백을 사이에 두고 주어진다.</p>

<p>두 번째 줄에 각 문제의 정답을 의미하는 문자열 <span style="font-style: italic;">S</span>가 주어진다. <span style="font-style: italic;">S</span>의 길이는 <span style="font-style: italic;">N</span>글자이며 문자 <code>O</code>와 <code>X</code>로만 이루어져 있다.</p>

<p>세 번째 줄에 달빛 여우가 생각한 각 문제의 답을 의미하는 문자열 <span style="font-style: italic;">T</span>가 <span style="font-style: italic;">S</span>와 같은 형식으로 주어진다.</p>

<p>네 번째 줄에는 쿼리의 개수를 의미하는 정수 <span style="font-style: italic;">Q</span>(1 ≤ <span style="font-style: italic;">Q</span> ≤ 250,000)가 주어진다.</p>

<p>다음 <span style="font-style: italic;">Q</span>개의 줄에 걸쳐 각 줄에 쿼리가 하나씩 주어진다. 쿼리는 다음의 두 종류가 있다.</p>

<ul>
	<li><code>Q</code> <span style="font-style: italic;">a</span> <span style="font-style: italic;">b</span>: <span style="font-style: italic;">a</span>번부터 <span style="font-style: italic;">b</span>번까지의 문제로 퀴즈를 본다(1 ≤ <span style="font-style: italic;">a</span> ≤ <span style="font-style: italic;">b</span> ≤ <span style="font-style: italic;">N</span>, <span style="font-style: italic;">a</span>, <span style="font-style: italic;">b</span>는 정수).</li>
	<li><code>C</code> <span style="font-style: italic;">n</span>: 달빛 여우가 <span style="font-style: italic;">n</span>번 문제의 답을 반대로 바꾼다(1 ≤ <span style="font-style: italic;">n</span> ≤ <span style="font-style: italic;">N</span>, <span style="font-style: italic;">n</span>은 정수). 즉 기존에 생각했던 답이 O였다면 X로, X였다면 O로 바꾼다.</li>
</ul>

<p><code>Q</code> 쿼리는 한 개 이상 주어짐이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 <code>Q</code> 쿼리에 대해 달빛 여우가 얻을 수 있는 최고 점수를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 쿼리에서는 3번 문제의 답을 F로 바꾸면 세 문제를 맞혀 9점을 받고 보너스 점수 5점을 추가로 얻을 수 있다.</p>

<p>두 번째 쿼리에서는 달빛 여우가 생각한 7번 문제의 답이 O에서 X로 바뀐다.</p>

<p>세 번째 쿼리에서는 3번 문제와 8번 문제의 답을 F로 바꾸면 두 문제를 맞혀 6점을 받고 보너스 점수 10점을 추가로 얻을 수 있다.</p>

				</div>
				</div>','10 3 5
OOOXXOOXXO
XOOOXOOOOX
3
Q 1 6
C 7
Q 3 10
','14
16
','DATA_STRUCTURE'),
                                                                                                                (7721,'BAEKJOON','https://www.acmicpc.net/problem/17446',17446,'옥상 정원','1초(추가시간없음)','1024 MB',22,'<p>서울대학교 신공학관 옥상에는 대학원생들에게만 보이는 커다란 정원이 있다. 이 정원에는 아름다운 꽃들이 피어 있는 정사각형 모양의 화단들이 격자 모양으로 늘어서 있으며, 화단의 변들을 따라 산책로가 나 있다.</p>

<p>곧 이 정원을 못 보게 되는 평석이는 추억을 간직하기 위해 마지막으로 정원을 방문했다. 평석이는 정원의 산책로를 걸으며 주변 화단들의 사진을 찍었다. 한참 여유를 즐기고 돌아가려던 평석이는 절망적인 사실을 깨달았다. 졸업 기념으로 가려고 애지중지 모셔 놨던 해외 게임쇼 티켓이 없어진 것이다!</p>

<p>평석이는 티켓을 찾기 위해 자신이 걸었던 산책로를 되짚어 보려고 했지만, 곧 연구실로 돌아가야 하기 때문에 모든 길을 다시 가 볼 수는 없었다. 다행히 평석이의 카메라에는 아까 찍은 화단들의 사진이 남아 있었기에, 평석이는 이 화단들의 주변 길들만 먼저 확인해 보기로 했다. 평석이는 시간이 얼마 없으므로 자신이 사진을 찍은 화단들의 네 변에 해당하는 길들만 정확히 한 번씩 지나가 보고, 그렇지 않은 길은 지나가지 않으려고 한다. 또한, 한 방향으로만 걸으면 집중력이 떨어질 수 있으므로 화단의 한 변을 지날 때마다 이동 방향을 바꾸려고 한다.</p>

<p>평석이는 가로 방향의 길과 세로 방향의 길이 만나는 어느 지점에서든 출발할 수 있다. 평석이가 조건을 만족하며 티켓을 찾아다닐 수 있을지 확인해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 정원의 세로 방향으로 늘어서 있는 화단의 개수와 가로 방향으로 늘어서 있는 화단의 개수를 의미하는 정수 <span style="font-style: italic;">N</span>과 <span style="font-style: italic;">M</span>(1 ≤ <span style="font-style: italic;">N</span>, <span style="font-style: italic;">M</span> ≤ 500)이 주어진다.</p>

<p>다음 <span style="font-style: italic;">N</span>개의 줄에 걸쳐 각 줄에 정원의 화단들을 나타내는 <span style="font-style: italic;">M</span>글자의 문자열이 하나씩 주어진다. 문자열은 문자 <code>#</code>와 <code>.</code>로만 이루어져 있으며, <code>#</code>는 평석이가 사진을 찍은 화단, <code>.</code>는 그렇지 않은 화단을 의미한다.</p>

<p>평석이가 사진을 찍은 화단이 하나 이상 있음이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>평석이가 조건을 만족하며 이동할 수 있다면 첫 줄에 <code>YES</code>를 출력한다.</p>

<p>다음 줄에 평석이의 경로를 나타내는 문자열을 출력한다. 문자열은 문자 <code>L</code>, <code>R</code>, <code>U</code>, <code>D</code>로만 이루어져 있어야 하며, 각각 평석이가 왼쪽, 오른쪽, 위, 아래 방향으로 화단 한 변의 길이만큼 걸어감을 의미한다.</p>

<p>조건을 만족하는 경로가 없다면 첫 줄에 <code>NO</code>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 예시의 경로는 다음과 같다.</p>

<p style="margin-top: 15px; margin-bottom: 15px;"><img alt="alt text" src="https://upload.acmicpc.net/91d8f0d0-3c59-4d0a-aef0-43174bf85a52/-/preview/" style="display: block; margin-left: auto; margin-right: auto; width: 100%; max-width: 400px;"></p>

				</div>
				</div>','2 3
##.
..#
','YES
LURDRDRULUL
','DATA_STRUCTURE'),
                                                                                                                (7722,'BAEKJOON','https://www.acmicpc.net/problem/17463',17463,'교준이의 심부름꾼, 민제의 고충 ("Circle" Ver.)','4초(추가시간없음)','1024 MB',27,'<p>민제는 교준이가 통치하는 도시, 강민시(市)에서 살고 있다.</p>

<p>2차원 평면인 이 도시에는&nbsp;중심이 $(X_i, Y_i)$고 반지름이 $R_i$인 $N$개의 원이 존재한다. $N$개의 원은 서로 같은 점을 공유하지 않음이 보장된다.</p>

<p>또한 강민시에는 총 $M$채의 민제네 집이 있다. $i$번째 집의 위치는 $(A_i, B_i)$며, 이 집을 부수었을 때 교준이가 얻는 행복도는 $C_i$다. 집의 위치나 행복도는 서로 같을 수 있으나, 모든 $M$채의 집은 $N$개의 원 위에 존재하지 않음이 보장된다.</p>

<p>집을 부수었을 때 교준이가 얻는 행복도의 정의는 조금 특이하다. 어떤 집도 부숴지지 않았다면, 교준이는 $0$의 행복도를 얻는다. 만일 행복도가 $3$인 집과 행복도가 $6$인 집이 부수어졌다면, 교준이는 $3 \oplus 6 = 5$의 행복도를 얻는다. 즉, 행복도가 $c_1, c_2, \cdots, c_k$인 집 $k$채가 부숴졌다면, 교준이는 총 $( c_1 \oplus c_2 \oplus \cdots \oplus c_k )$의 행복도를 얻게 된다. 이때 $\oplus$는 배타적 논리합을 나타내는 기호다.</p>

<p>민제네 집은 미관상으로 그리 좋지 못하다. 강민시장 교준이는 강민시를 현대도시로 발전시키기 위해서 민제네 집을 모조리 부수어버려야 한다고 생각한다. 또한 교준이는 매우 악랄하게 때문에, 민제에게 직접 민제네 집을 철거하라고 명령할 것이다.</p>

<p>만일 교준이가 민제에게 "$(x, y)$로 가서 거리 $L$ 이내에 있는 너네 집을 모두 부숴라."라고 명령하면, 민제는 $(x, y)$ 위치로 이동한 다음, 이 점으로부터 거리가 $L$ 이하인 모든 민제네 집을 직접 부순다. 이때 두 점 간의 거리라 함은, 한 점에서 다른 점으로 이동하기 위해 지나야 하는 원의 최소 개수를 의미한다. 점 $(x, y)$가 $N$개의 원 위에 존재하지 않음은 항상 보장된다.</p>

<p><strong>민제네 집 철거 공사 계획</strong>을 세우고 있던 교준이는 다음과 같은 궁금증이 생겼다:</p>

<blockquote>
<p>민제에게 "$(U_1, V_1)$로 가서 거리 $L_1$ 이내에 있는 너네 집을 모두 부숴라."라고 명령한 후,</p>

<p>다시 민제에게 "$(U_2, V_2)$로 가서 거리 $L_2$ 이내에 있는 너네 집을 모두 부숴라."라고 명령한 후,</p>

<p>$\cdots$</p>

<p>다시 민제에게 "$(U_K, V_K)$로 가서 거리 $L_K$ 이내에 있는 너네 집을 모두 부숴라."라고 총 $K$차례 명령한다면,</p>

<p>내가 얻는 총 행복도는 얼마일까?</p>
</blockquote>

<p>교준이의 영원한 심부름꾼, 민제는 오늘도 교준이의 궁금증을 해결해주어야 한다. 허나 민제는 "1+9+10=19"라고 말할 정도로 수학을 못하는 바보다. 민제를 위하여 교준이의 질문에 답해주는 프로그램을 작성해보자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 강민시의 원의 개수를 나타내는 자연수 $N$과 민제네 집의 수를 나타내는 자연수 $M$, 교준이의 궁금증 횟수를 나타내는 자연수 $Q$가 사이에 공백을 두고 주어진다.</p>

<p>두번째 줄부터 $N$개의 줄에 걸쳐 $N$개의 원에 관한 정보가 주어진다. $(i+1)$번째 줄에는 세 정수 $X_i$, $Y_i$, $R_i$가 사이에 공백을 두고 주어진다$(1 \le i \le N)$.</p>

<p>$(N+2)$번째 줄부터 $M$개의 줄에 걸쳐 $M$채의 민제네 집에 관한 정보가 주어진다. $(N+i+1)$번째 줄에는 세 정수 $A_i$, $B_i$, $C_i$가 사이에 공백을 두고 주어진다$(1 \le i \le M)$.</p>

<p>$(N+M+2)$번째 줄부터 아래와 같은 형식으로 $Q$개의 교준이의 궁금증에 관한 정보가 주어진다.</p>

<p>하나의 궁금증은 여러 줄에 걸쳐 표현되며, 다음와 같은 형식을 같는다. 첫 번째 줄에는 민제에게 명령하는 총 횟수를 나타내는 자연수 $K$가 주어진다. 두번째 줄부터 $K$개의 줄에 걸쳐 $K$번의 명령에 관한 정보가 주어진다. $(i+1)$번째 줄에는 세 정수 $U_i$, $V_i$, $L_i$가 사이에 공백을 두고 주어진다$(1 \le i \le K)$.</p>

<p>$Q$개의 궁금증은 서로 독립임에 유의하라. 또한 하나의 궁금증에 대하여, 민제는 같은 집을 두 번 이상 부수지 않음에 유의하라.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄부터 $Q$개의 줄에 걸쳐 교준이가 얻는 행복도를 차례대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5 2
2 2 1
6 9 1
6 8 3
6 7 5
8 4 1
2 2 1
3 10 2
4 1 4
6 9 8
8 11 16
1
8 4 1
3
6 9 3
2 2 0
2 2 1
','18
31
','DATA_STRUCTURE'),
                                                                                                                (7717,'BAEKJOON','https://www.acmicpc.net/problem/17469',17469,'트리의 색깔과 쿼리','2초','256 MB',18,'<p>N개의 정점으로 구성된 트리가 있다. 각 정점은 1번부터 N번까지 번호가 매겨져있고, 1 이상 10만 이하의 자연수로 표현되는 색깔을 하나 갖고 있다.&nbsp;루트는 1번 정점이고, 트리이기 때문에 임의의 서로 다른 두 정점을 잇는 경로는 반드시 한 개 존재한다.</p>

<p>정점 u와 v를 잇는 경로가 존재하면 u에서 v로 갈 수 있다고 하자.</p>

<p>여러분은 아래 두 가지 쿼리를 처리해야 한다.</p>

<ul>
	<li>1 a : 정점 a와 a의 부모 정점을 연결하는 간선을 제거한다. (해당 간선이 존재하는 경우에만 주어진다.)</li>
	<li>2 a : 정점 a에서 갈 수 있는 정점들만 보았을 때, 색깔의 종류의 개수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 정점의 개수 N(1 ≤ N ≤ 100,000)과 2번 쿼리의 개수 Q(1 ≤ Q ≤ 1,000,000)가 주어진다.</p>

<p>다음 N-1개 줄의 i번째 줄에는 정점 i+1의 부모 정점을 나타내는 정수 p(1 ≤ p ≤ N)가 주어진다.</p>

<p>다음 N개 줄의 i번째 줄에는 정점 i의 색깔을 나타내는 정수 c(1 ≤ c ≤ 100,000)가 주어진다.</p>

<p>다음 N+Q-1개의 줄에는 여러분이 처리해야 할 쿼리가 주어지는데, 1번 쿼리는 N-1개, 2번 쿼리는 Q개 주어진다.</p>

<p>쿼리는 한 줄에 하나씩 쿼리의 종류를 나타내는 X(1 ≤ X ≤ 2)와 쿼리에서 처리할 정점의 번호 a(1 ≤ a ≤ N)가 주어진다.</p>

<p>입력은 모두 자연수로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q개의 2번 쿼리에 대한 답을 순서대로 한 줄에 하나씩&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 4
5
2
2
1
1
3
2
3
3
1 4
2 1
2 3
1 2
2 5
1 5
2 3
1 3
','3
3
2
2
','DATA_STRUCTURE'),
                                                                                                                (7718,'BAEKJOON','https://www.acmicpc.net/problem/17473',17473,'수열과 쿼리 25','2초','512 MB',26,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>1 L R X</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = A<sub>i</sub> ∧ X 를 적용한다.&nbsp;</li>
	<li><code>2 L R X</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = A<sub>i</sub> ∨ X 를 적용한다.</li>
	<li><code>3 L R</code>: max(A<sub>L</sub>, A<sub>L+1</sub>, ..., A<sub>R</sub>)을 출력한다.</li>
</ul>

<p>∧는 비트 AND, ∨는 비트 OR이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 200,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (0 ≤ A<sub>i</sub> < 2<sup>20</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 200,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ L ≤&nbsp;R ≤ N, 0 ≤ X < 2<sup>20</sup>) 3번 쿼리는 한 번 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>수열의 변화는 다음과 같다.</p>

<ul>
	<li>1, 3, 2, 5, 4</li>
	<li>5, 3, 2, 5, 4</li>
	<li>5, 3, 2, 5, 4</li>
	<li>4, 2, 2, 4, 4</li>
	<li>4, 2, 3, 5, 4</li>
	<li>4, 2, 3, 5, 4</li>
	<li>4, 6, 7, 5, 4</li>
	<li>4, 6, 7, 5, 4</li>
</ul>

				</div>
				</div>','5
1 3 2 5 4
8
3 1 3
2 1 1 5
3 1 3
1 1 4 6
2 3 4 1
3 2 3
2 2 3 4
3 1 5
','3
5
3
7
','DATA_STRUCTURE'),
                                                                                                                (7719,'BAEKJOON','https://www.acmicpc.net/problem/17474',17474,'수열과 쿼리 26','4초','512 MB',24,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>1 L R X</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = min(A<sub>i</sub>,&nbsp;X) 를 적용한다.&nbsp;</li>
	<li><code>2 L R</code>: max(A<sub>L</sub>, A<sub>L+1</sub>, ..., A<sub>R</sub>)을 출력한다.</li>
	<li><code>3 L R</code>: A<sub>L</sub> + A<sub>L+1</sub> + ... + A<sub>R</sub>을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 1,000,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (0 ≤ A<sub>i</sub> < 2<sup>31</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 1,000,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ L ≤&nbsp;R ≤ N, 0 ≤ X < 2<sup>31</sup>) 2번과&nbsp;3번 쿼리는 한 번 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2, 3번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 4 5
5
2 1 5
3 1 5
1 3 5 3
2 1 5
3 1 5
','5
15
3
12
','DATA_STRUCTURE'),
                                                                                                                (7720,'BAEKJOON','https://www.acmicpc.net/problem/17475',17475,'수열과 쿼리 27','4초','512 MB',28,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어지고,&nbsp;B<sub>i</sub> = A<sub>i</sub>, C<sub>i</sub> = A<sub>i</sub>를 만족하는 길이가 N인 두 수열 B와 C도 있다.&nbsp;이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>1 L R X</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = A<sub>i</sub> + X를 적용한다.</li>
	<li><code>2 L R Y</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = max(A<sub>i</sub>,&nbsp;Y)를 적용한다.</li>
	<li><code>3 L R Y</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = min(A<sub>i</sub>,&nbsp;Y)를 적용한다.</li>
	<li><code>4 L R</code>: min(A<sub>L</sub>,&nbsp;A<sub>L+1</sub>,&nbsp;...,A<sub>R</sub>)을 출력한다.</li>
	<li><code>5 L R</code>: min(B<sub>L</sub>,&nbsp;B<sub>L+1</sub>,&nbsp;...,B<sub>R</sub>)을 출력한다.</li>
	<li><code>6 L R</code>: max(C<sub>L</sub>, C<sub>L+1</sub>,&nbsp;...,C<sub>R</sub>)을 출력한다.</li>
</ul>

<p>각 쿼리가 수행된 이후에 모든 1 ≤ i ≤ N에 대해서 B<sub>i</sub> = min(B<sub>i</sub>, A<sub>i</sub>), C<sub>i</sub> = max(C<sub>i</sub>, A<sub>i</sub>)로 변한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 500,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (-10<sup>9</sup> ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 500,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ L ≤&nbsp;R ≤ N, -2,000 ≤ X ≤ 2,000, -10<sup>9</sup> ≤ Y ≤ 10<sup>9</sup>) 4, 5, 6번 쿼리는 한 번 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>4, 5, 6번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2 3
6
5 3 3
1 2 3 -2
3 1 3 0
5 3 3
2 2 3 4
5 1 3
','3
0
0
','DATA_STRUCTURE'),
                                                                                                                (7724,'BAEKJOON','https://www.acmicpc.net/problem/17476',17476,'수열과 쿼리 28','1초','512 MB',25,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>1 L R X</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = A<sub>i</sub> + X를 적용한다.&nbsp;</li>
	<li><code>2 L R</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> =&nbsp;?√A<sub>i</sub>?를 적용한다.</li>
	<li><code>3 L R</code>: A<sub>L</sub> + A<sub>L+1</sub> + ... + A<sub>R</sub>을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1&nbsp;≤ A<sub>i</sub>&nbsp;≤&nbsp;100,000)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ L ≤&nbsp;R ≤ N, 1 ≤ X ≤ 100,000) 3번 쿼리는 한 번 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 4 5
5
1 3 5 2
2 1 4
3 2 4
2 3 5
3 1 5
','5
6
','DATA_STRUCTURE'),
                                                                                                                (7723,'BAEKJOON','https://www.acmicpc.net/problem/17477',17477,'수열과 쿼리 29','4초','512 MB',27,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어지고,&nbsp;B<sub>i</sub> = 0를 만족하는 길이가 N인 수열 B가&nbsp;있다.&nbsp;이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>1 L R X</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = A<sub>i</sub> + X를 적용한다.</li>
	<li><code>2 L R Y</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = max(A<sub>i</sub>,&nbsp;Y)를 적용한다.</li>
	<li><code>3 L R Y</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = min(A<sub>i</sub>,&nbsp;Y)를 적용한다.</li>
	<li><code>4 L R</code>: B<sub>L</sub> + B<sub>L+1</sub> + ... + B<sub>R</sub>을 출력한다.</li>
</ul>

<p>1, 2, 3번 쿼리에 의해 A<sub>i</sub>가 변경될 때마다 B<sub>i</sub>의 값은 1 증가한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 500,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (-10<sup>9</sup> ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 500,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ L ≤&nbsp;R ≤ N, -2,000 ≤ X ≤ 2,000, -10<sup>9</sup> ≤ Y ≤ 10<sup>9</sup>) 4번 쿼리는 한 번 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>4번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 4 5
11
4 1 5
1 1 3 3
4 1 5
2 2 5 5
4 1 5
3 1 4 5
4 1 4
2 1 5 0
4 1 5
3 1 5 1
4 1 2
','0
3
4
5
5
4
','DATA_STRUCTURE'),
                                                                                                                (7725,'BAEKJOON','https://www.acmicpc.net/problem/17479',17479,'정식당','1초','256 MB',8,'<p>2019년 1학기가 시작되고 많은 사람을 만나며 밥과 술에 탕진을 해버린 영기는 2학기에 탕진할 돈을 마련하기 위해&nbsp;중앙대 근처의 고급 레스토랑, "정식당"에서&nbsp;알바를 하게 되었다.</p>

<p>정식당의 사장 정우는 새로 들어온 알바생 영기를&nbsp;위해 정식당만의 특별한 음식 주문법을 알려주려고 한다.</p>

<p>정식당에는 다양한 메뉴들이 있지만 크게 3가지로 나눌 수 있는데 <em>A</em>개의 "일반메뉴", <em>B</em>개의 "특별메뉴", <em>C</em>개의 "서비스메뉴"로 나뉘어져 있다. 일반메뉴는 자유롭게 주문할 수 있으나 특별메뉴와 서비스메뉴는 주문할 때 다음의 제약이 있다.</p>

<ul>
	<li>특별메뉴는 일반메뉴에서 총 20,000원 이상을 주문해야 주문할 수 있다.</li>
	<li>서비스메뉴는 일반메뉴와 특별메뉴에서 총 50,000원 이상을 주문해야 주문할 수 있다.</li>
	<li>서비스메뉴는 단 하나만 주문할 수 있다.</li>
</ul>

<p>다양한 메뉴와 특별한 메뉴 주문법에 영기는 알바를 하면서 혼돈이 오기 시작했다. 받아서는 안될 주문을 받기도 하며 사장님에게 된통 혼나기도 하며 심지어는 자기 발에 걸려 넘어지기까지 했다.</p>

<p>가게를 찾아온&nbsp;손님들이 주문하는 것이 옳은 주문인지 아닌지 헷갈려하는 영기는 우리에게 도움을 요청했다. 영기가&nbsp;주문을 잘 받아올 수 있도록 우리가 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 50,000 이하의 양의 정수 <em>A</em>, <em>B</em>, <em>C</em>가 공백을 두고 주어진다.</p>

<p>두번째 줄부터 <em>A</em>줄에 걸쳐 일반메뉴의 이름과 가격이 공백을 두고 주어진다. 그 다음 <em>B</em>줄에 걸쳐 특별메뉴의 이름과 가격이 공백을 두고 주어진다. 그 다음 <em>C</em>줄에 걸쳐 서비스메뉴의 이름이 주어진다.</p>

<p>그 다음 줄에서 손님이 주문하는 음식의 수를 나타내는 150,000 이하의 자연수&nbsp;<em>N</em>이 주어진다.</p>

<p>그 다음 <em>N</em>줄에 걸쳐 손님이 주문하는 음식의 이름들이 주어진다. 같은 음식을 여러번 주문할 수도 있으며 메뉴에 있는 음식만 주문한다.</p>

<p>일반메뉴와 스페셜메뉴의 가격은 1,000,000 이하의 양의 정수이며 메뉴의 이름은 20자 이하의 알파벳 소문자로만 이루어져 있으며 일반메뉴, 특별메뉴, 그리고 서비스메뉴들의 이름은 모두 다르다</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>영기가 받은 주문이 옳은 주문이면 "<code>Okay</code>"를, 그렇지 않은 주문이라면 "<font face="monospace">No</font>"를 출력하자. 따옴표는 출력하지 않는다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>이 문제는 픽션입니다. 문제에 나오는 인물, 사건, 배경은 실제와 아무런 관련이 없습니다.</p>

				</div>
				</div>','3 2 3
noodle 10000
tteokbokki 5000
sundae 7000
cutlet 12000
friedrice 8000
dumpling
potatochips
fishcake
6
noodle
noodle
cutlet
friedrice
cutlet
potatochips
','Okay
','DATA_STRUCTURE'),
                                                                                                                (7726,'BAEKJOON','https://www.acmicpc.net/problem/17481',17481,'최애 정하기','2초','256 MB',17,'<p>흑석이와 상도는 국내 최고의 걸그룹인 CAU(Complete &amp; Awesome Unit)을 좋아한다. CAU에는&nbsp;흑석이와 상도는 좋아하는 멤버가 각각 여러명 존재한다.</p>

<p>흑석이와 상도는 최고로 좋아하는 멤버인 최애 멤버를 정하고자 한다. 그런데 두 친구가 같은 멤버를 좋아하는 것은 두 친구 간의 우정 때문에 그럴 수 없다고 한다.</p>

<p>따라서 우리는 친구들의 우정을 지키기 위해 최고로 좋아하는 멤버인 최애 멤버 1명을 서로 다른 멤버로 정하고자 한다.</p>

<p>친구들의 우정을 지키기 위한 프로그램을 작성해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 친구들의 수 N과 걸그룹의 멤버 수 M이 주어진다. (2 ≤ N, M ≤ 1000)</p>

<p>다음 M개 줄에 걸쳐서 걸그룹 멤버의 이름이 각각 주어진다. 걸그룹 멤버의 이름은 영문 대문자로만 이뤄져 있으며, 최대 길이는 100글자이다.</p>

<p>다음 N개 줄에 걸쳐서&nbsp;친구 별로 좋아하는 멤버&nbsp;수 K(1 ≤ K ≤ M)와 좋아하는 걸그룹 멤버 이름들이 공백을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에는 친구들의 우정을 지킬 수 있는 지 여부를 출력한다.</p>

<p>우정을 지킬 수 없는 경우 두 번째 줄에는 최대한 겹치지 않게 친구들 전체가 좋아할 수 있는 최대 멤버&nbsp;수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5
YEJI
LIA
RYUJIN
CHAERYEONG
YUNA
3 YEJI RYUJIN YUNA
2 LIA RYUJIN
3 CHAERYEONG YEJI RYUJIN
4 LIA RYUJIN CHAERYEONG YUNA
','YES
','DATA_STRUCTURE'),
                                                                                                                (7727,'BAEKJOON','https://www.acmicpc.net/problem/17486',17486,'수열과 쿼리 30','2초','512 MB',27,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다.&nbsp;이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>1 L R X</code>: 모든 L ≤ i ≤ R에 대해서 A<sub>i</sub> = A<sub>i</sub> + X를 적용한다.</li>
	<li><code>2 L R S E</code>: A의 [L, R] 구간을 [S, E]에 있는 수로 변경한다. 즉, 이 쿼리의 결과를 수열 B라고 했을 때,&nbsp;B<sub>L</sub> = A<sub>S</sub>, B<sub>L+1</sub> = A<sub>S+1</sub>, ..., B<sub>R</sub> = A<sub>E</sub>가 되는 것이고, L ≤ i ≤ R에 포함되지 않은 모든 i의&nbsp;B<sub>i</sub> = A<sub>i</sub>이다.</li>
	<li><code>3 L R</code>: A<sub>L</sub> + A<sub>L+1</sub> + ... + A<sub>R</sub>을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 200,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (-10<sup>6</sup> ≤ A<sub>i</sub> ≤ 10<sup>6</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 200,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ L ≤&nbsp;R ≤ N, 1 ≤ S ≤ E ≤ N, E-S = R-L, -10<sup><span style="font-size: 10.8333px;">6</span></sup>&nbsp;≤ X&nbsp;≤ 10<sup>6</sup>) 3번 쿼리는 한 번 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 4 5
5
3 1 5
1 1 3 1
3 1 3
2 1 3 2 4
3 1 5
','15
9
20
','DATA_STRUCTURE'),
                                                                                                                (7728,'BAEKJOON','https://www.acmicpc.net/problem/17490',17490,'일감호에 다리 놓기','2초','256 MB',13,'<p>학교의 홍보대사를 맡게 된 건덕이는 건국대학교의 모든 강의동을 신입생들에게 소개해야 한다.</p>

<p>건국대학교 중앙에 위치한 일감호를 따라 한 바퀴를 돌며 모든 강의동을 소개하는 것이 그의 일이지만, 몇몇 구간들이 공사 중이어서 그 구간을 통해서는 갈 수 없는 상황이다. 급한대로 건덕이는 호수에 돌을 던져 징검다리를 놓아 길을 만들어보려고 한다.</p>

<p>강의동은 일감호의 둘레에 따라 원형으로 배치돼 있으며, 강의동 양 옆의 강의동은 서로 이웃한다. 또, 원형으로 배치돼 있기 때문에 <em>N</em>개의 강의동이 있다면 <em>N</em>번째 강의동과 1번째 강의동은 서로 이웃한다.</p>

<p>일감호 안에는 와우도라는 섬이 있다. 건덕이는 한 강의실에서 다른 모든 강의실로 이동할 수 있도록 강의동에서 와우도까지 징검다리를 놓기로 했다. 하지만 건덕이의 눈에는 <em>K</em>개의 돌밖에 보이지 않는다. 건덕이는 주어진 돌을 활용해서 징검다리를 완성할 수 있을까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 강의동의 수 <em>N</em>, 공사구간의 수 <em>M</em>, 건덕이가 가진 돌의 수 <em>K</em>가 공백으로 구분돼 주어진다. 강의동은 1동부터 N동까지 존재한다.</p>

<p>다음 줄에는 강의동에서 와우도까지 놓아야하는 돌의 개수 S<sub>1</sub>, S<sub>2</sub>, ...,&nbsp;S<sub>N</sub>이 공백으로 구분돼 주어진다. 이는 <em>T</em>번째 강의동에서 와우도까지 S<sub>T</sub>개의 돌을 놓아야 함을 의미한다. 이어서 <em>M</em>개의 줄에 i, j가 주어진다. 이는 i번째 강의동에서 j번째 강의동까지 가는 길이 공사중임을 의미한다. 이 때 입력되는 i, j번째 건물은 이웃한 강의동이다.&nbsp;공사중인 구역은 한 번만 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>건덕이가 가지고 있는 돌을 놓아 모든 강의동을 연결할 수 있으면 <code>YES</code>를, 그렇지 않으면 <code>NO</code>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3 9
2 1 3 2 5
2 3
4 5
5 1
','YES
','DATA_STRUCTURE'),
                                                                                                                (7729,'BAEKJOON','https://www.acmicpc.net/problem/17503',17503,'맥주 축제','1초','256 MB',10,'<p>내일부터 <em>N</em>일 동안 대구광역시에서 맥주 축제가 열립니다!</p>

<p>이 축제에서는 무려 <em>K</em>종류의 맥주를 무료로 제공합니다.</p>

<p>축제 주최자는 축제에서 더 많은 참가자들이 다양한 종류의 맥주를 즐겼으면 합니다. 그래서 축제에서 참가자들은 하루에 맥주 1병만 받을 수 있고, 이전에 받았던 종류의 맥주는 다시 받을 수 없습니다.</p>

<p>맥주를 정말로 사랑하는 대학생 전씨는 무료 맥주 소식에 신이 났습니다. 전씨는 이 맥주 축제에 참가해 총 <em>N</em>일 동안 맥주 <em>N</em>병을 마시려 합니다.</p>

<p>하지만 전씨에게는 큰 고민이 있었습니다. 전씨는 맥주를 사랑하지만, 도수가 높은 맥주를 마시면 기절하는 맥주병이 있습니다. 전씨는 맥주를 마시다 기절하면 늦잠을 자 다음 날 1교시 수업에 결석해 F를 받게 될 수도 있습니다.</p>

<p>전씨는 고민을 해결하기 위해 천재석사 현씨과 천재박사 승씨에게 자신의 간을 강력하게 만들어달라고 부탁했습니다. 하지만 간을 강력하게 만드는 비용이 너무 비싸서, 전씨는 간을 가능한 한 조금만 강화할 계획을 세웠습니다.</p>

<p>우선, <em>K</em>종류의 맥주에 각각 선호도와 도수 레벨을 매겼습니다. 선호도는 전씨가 해당 맥주를 얼마나 좋아하는지를 나타내는 수치이고, 도수 레벨은 해당 맥주의 도수가 얼마나 강한지를 나타내는 수치입니다. 편의상 전씨는 선호도와 도수 레벨을 정수로 매겼습니다.</p>

<p>만약, 마시는 맥주의 도수 레벨이 전씨의 간 레벨보다 높으면 맥주병이 발병해 기절해버리고 맙니다.</p>

<p>또한, 전씨는 맥주병에 걸리지 않으면서도 자신이 좋아하는 맥주를 많이 마시고 싶어합니다. 따라서, 마시는 맥주 <em>N</em>개의 선호도 합이 <em>M</em>이상이 되게 하려 합니다.</p>

<p>거창한 계획을 세운 전, 현, 승 세 사람은 서로 머리를 맞대고 고민하다가, 스트레스를 받아 연구를 집어치고 맥주를 마시러 떠나버렸습니다.</p>

<p>이를 본 여러분은 세 사람을 대신해 조건을 만족하는 간 레벨의 최솟값을 출력하는 프로그램을 만들어 주려고 합니다.</p>

<p>세 사람을 도와주세요!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 축제가 열리는 기간 <em>N</em> (1 ≤ <em>N</em> ≤ 200,000) 과, 채워야 하는 선호도의&nbsp;합 <em>M</em> (1 ≤ <em>M</em> <&nbsp;2<sup>31</sup>) 과,&nbsp;마실 수 있는 맥주 종류의&nbsp;수 K (<em>N</em> ≤ <em>K</em> ≤ 200,000) 가 주어집니다.</p>

<p>다음 <em>K</em>개의 줄에는 1번부터 <em>K</em>번 맥주의 선호도&nbsp;<em>v<sub>i</sub></em> (0 ≤ <em>v<sub>i</sub></em> ≤ 10,000) 와 도수 레벨 <em>c<sub>i</sub></em> (1 ≤ <em>c<sub>i</sub></em> <&nbsp;2<sup>31</sup>) (<em>v<sub>i</sub></em>, <em>c<sub>i</sub></em>는 정수) 이 공백을 사이에 두고 주어집니다.</p>

<p>1번부터 K번 맥주의 종류는 모두 다릅니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 주어진 선호도의 합 <em>M</em>을 채우면서 <em>N</em>개의 맥주를 모두 마실 수 있는 간 레벨의 최솟값을 출력합니다.</p>

<p>만약 아무리 레벨을 올려도 조건을 만족시킬 수 없으면 첫 번째 줄에 "<code>-1</code>" 하나만 출력하고 더 이상 아무것도 출력하지 않아야 합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 9 5
2 5
4 6
3 3
4 3
1 4
','5
','DATA_STRUCTURE'),
                                                                                                                (7730,'BAEKJOON','https://www.acmicpc.net/problem/17507',17507,'시간여행자의 실험기록','1초','512 MB',22,'<p>시간 여행 능력을 가진 화학자 Lawali는 전설의 마법 포션, 엘릭서를 만드는 실험을 설계했다. 긴 시간의 연구 끝에 Lawali는&nbsp;특정한 마법 포션들을&nbsp;정확한&nbsp;순서로 섞었을 때 엘릭서를 만들 수 있음을 알아냈으나,&nbsp;필요한 포션의 종류와 그 순서는&nbsp;알아내지 못했다. 엘릭서를 만드는데 필요한 N가지 포션은 아주 희귀해서, Lawali는 포션을&nbsp;각 종류별로 한 병밖에 구하지 못했다. Lawali는 엘릭서 제조법을 알아내기 위해 연구를 진행하려 하였으나, 한번 섞인 포션은&nbsp;다시 분리할 수 없기 때문에&nbsp;Lawali는 그의 시간 여행 능력을 실험을 위해 사용하기로 결심했다. Lawali가 사용할 수 있는 시간 여행 능력은 다음과 같다.</p>

<ol>
	<li>JUMP: 시간을 k일만큼&nbsp;앞으로 되돌린다.</li>
	<li>SAVE: 현재 시간선을 저장한다.&nbsp;</li>
	<li>LOAD: SAVE 능력으로 저장된 시간선 중 하나로&nbsp;이동한다. 이 때 실험실의 상태는 저장했던 당시 실험실의&nbsp;상태와 정확히 같다.</li>
</ol>

<p>이 연구&nbsp;과정을 기록하기 위해 Lawali는 두 가지 도구를 사용하기로 결정했다. 하나는 실험실에 그대로 놔둘 공책과 가지고 다니는 수첩이다. 실험실에 놔두는 공책은 JUMP와 LOAD 능력의 영향을 받고, 수첩은 영향을 받지 않는다.</p>

<p>실험은 서로 다른 두 포션을 선택하여 섞는 것으로 이루어진다. 실험에 대한 세부 사항은 다음과 같다.</p>

<ul>
	<li>포션을 한 번 섞을 때는 반드시 두 병의 포션만을 섞으며,&nbsp;섞고 나면 양이 반으로 줄어들어 한병 분량의 새로운 포션이 나온다.</li>
	<li>정확한 결과가 나오기 위해서 사용해야 하는 최소 양은&nbsp;포션 한 병 분량이다. 다시 말해 포션두 병을 섞을 때는 남김 없이 모두 투입해야 한다.</li>
	<li>같은 과정을 거쳐 만든 결과물은&nbsp;유일하다. 즉 같은 과정을 거쳐 만든 포션은 항상 같으며, 다른 과정을 거쳐 만든 어떤 포션과도 일치하지 않는다. Lawali는 이 포션에 새로운 번호를 붙여 관리한다.</li>
</ul>

<p>연구는 총 Q번의 과정으로 진행되며, 한번의 연구&nbsp;과정은 다음과 같다.</p>

<ol>
	<li>SAVE 능력을 사용한다. 이 능력을 사용하는 데에는 시간이 소요되지 않는다.</li>
	<li>아래 4가지 행동&nbsp;중 하나를 수행한다.</li>
</ol>

<p>행동&nbsp;내용은 다음과 같으며, 각&nbsp;행동을 수행하고 나서는 하루 동안의 휴식이 필요하다.</p>

<ul>
	<li>1 a&nbsp;b&nbsp;c&nbsp;: 포션 a와 포션 b를 섞어서 나온 새로운 포션에 c라는 번호를 부여한다. 그리고 이 과정을 공책에 a b c와 같은 형태로 기록한다.</li>
	<li>2 q&nbsp;: 현재 존재하는 포션 중 포션 q 또는 포션 q가&nbsp;포함된 포션의 번호를 수첩에 기록한다.</li>
	<li>3 k : JUMP&nbsp;능력을 사용하여 k일&nbsp;전으로 돌아간다.</li>
	<li>4 j&nbsp;: LOAD&nbsp;능력을 사용하여 SAVE&nbsp;능력을 j번째로 사용한 시점으로 이동한다.&nbsp;</li>
</ul>

<p>Lawali의 연구를 돕기 위해 실험 종료 후 수첩에 기록된 내용과 공책에 기록된 내용을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과&nbsp;Q가 공백으로 구분하여 주어진다. (1 ≤ N, Q ≤ 10<sup>5</sup>)</p>

<p>둘째 줄부터 Q개의 줄에 걸쳐 Lawali가 수행할 행동이 주어진다.</p>

<p>i+1번째 줄의 첫 번째는 행동의&nbsp;종류를 의미하는 정수 t가 주어진다, (1 ≤ t ≤ 4)</p>

<p>t가 1일 경우 세&nbsp;정수 a, b, c가 공백으로 구분하여 주어진다. (a&nbsp;≠ b, b&nbsp;≠ c, c&nbsp;≠ a, 1 ≤ a, b, c&nbsp;≤ 2 × 10<sup>5</sup>)</p>

<p>t가 2인 경우에는 정수 q가 주어진다. (1 ≤ q&nbsp;≤ 2 × 10<sup>5</sup>)</p>

<p>t가 3인 경우에는 정수 k가 주어진다. (1 ≤ k ≤ Q)</p>

<p>t가 4인 경우에는 정수 j가 주어진다. (1 ≤ j&nbsp;< i)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 수첩에 기록된 내용의 갯수&nbsp;T와&nbsp;공책에 기록된 내용의 갯수 P를 공백으로 구분하여 출력한다.</p>

<p>다음 T개의 줄에 걸쳐 해당하는 포션의 번호를 순서대로&nbsp;출력한다.</p>

<p>다음 P개의 줄에 걸쳐 해당하는 실험의 내용 x y z를 공백으로 구분하여 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 10
1 1 2 6
2 2
3 4
2 1
4 3
1 6 4 7
2 4
3 4
2 2
4 6
','4 1
6
1
7
6
1 2 6
','DATA_STRUCTURE'),
                                                                                                                (7741,'BAEKJOON','https://www.acmicpc.net/problem/17608',17608,'막대기','1초(추가시간없음)','512 MB',4,'<p>아래 그림처럼 높이만 다르고 (같은 높이의 막대기가 있을 수 있음) 모양이 같은 막대기를 일렬로 세운 후, 왼쪽부터 차례로 번호를 붙인다. 각 막대기의 높이는 그림에서 보인 것처럼 순서대로 6, 9, 7, 6, 4, 6 이다. 일렬로 세워진 막대기를 오른쪽에서 보면 보이는 막대기가 있고 보이지 않는 막대기가 있다. 즉, 지금 보이는 막대기보다 뒤에 있고 높이가 높은 것이 보이게 된다. 예를 들어, 그림과 같은 경우엔 3개(6번, 3번, 2번)의 막대기가 보인다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/a2ebef22-157f-4059-9bdd-6a0662b81698/-/crop/675x304/47,12/-/preview/" style="width: 333px; height: 150px;"></p>

<p>N개의 막대기에 대한 높이 정보가 주어질 때, 오른쪽에서 보아서 몇 개가 보이는지를 알아내는 프로그램을 작성하려고 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 막대기의 개수를 나타내는 정수 N (2 ≤ N ≤ 100,000)이 주어지고 이어지는 N줄 각각에는&nbsp;막대기의 높이를 나타내는 정수 h(1 ≤ h ≤ 100,000)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>오른쪽에서 N개의 막대기를 보았을 때, 보이는 막대기의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
6
9
7
6
4
6
','3
','DATA_STRUCTURE'),
                                                                                                                (7744,'BAEKJOON','https://www.acmicpc.net/problem/17612',17612,'쇼핑몰','1초(추가시간없음)','512 MB',14,'<p>대형 쇼핑몰에서 쇼핑을 마친 N명의&nbsp;고객들이 계산을 하고 쇼핑몰을 떠나고자 계산대 앞에 줄을 서 있다. 각 고객은 커다란 짐수레(cart)에 물건을 담아 계산대로 간다. 쇼핑몰에는 아래 그림과 같이 K개의 계산대가 병렬로 배치되어 있다.&nbsp; 쇼핑몰 안내원들은 계산대에 온 사람들을 가장 빨리 계산을 마칠 수 있는 계산대로 안내를 한다. 안내원은 각 계산대에서 기다리고 있는 사람들이 계산을 하는데 얼마나 걸리는지 이미 알고 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/5b0b8a21-5bb6-44df-92f3-cbbb9f042339/-/preview/" style="height: 90px; width: 134px;"></p>

<p>안내원이 고객을 계산대로 안내할 때 두 계산대에서 기다려야 할 시간이 같을 경우에는 가장 번호가 작은 계산대로 안내를 한다. 즉 3번, 5번 계산대에서 기다릴 시간이 똑같이 15분으로 최소일 경우에는 3번으로 안내를 한다.</p>

<p>계산을 마친 고객은 출구를 통하여 쇼핑몰을 완전히 빠져 나간다. 만일 계산대에서 계산을 마친 고객의 시간이 동일하다면 출구에 가까운 높은 번호 계산대의 고객부터 먼저 빠져나간다. 예를 들어 두 계산대 4번과 10번에서 두 고객이 동시에 계산을 마쳤다면 계산대의 번호가 더 높은 10번 계산대의 고객이 먼저 쇼핑몰을 나간다. 물건을 계산하는 데에는 종류에 관계없이 동일하게 1분이 소요된다. 즉, 물건이 w개 있는 손님이 계산을 마치는 데에는 정확히 w분이 소요된다.</p>

<p>여러분은 계산대로 들어가기 위하여 줄을 서 있는 고객 N명의 정보( 회원번호, 구매한 물건의 수)를 알고 있을 때, 이들이 계산을 하고 쇼핑몰을 빠져나오는 순서를 구해야 한다. 계산대로 들어가고 계산대에서 나오는데 걸리는 시간은 없다고 가정한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에는 2개의 정수 N(1 ≤ N ≤ 100,000)과 k(1 ≤ k ≤ 100,000)가 주어진다. 다음 줄부터 N개의 줄에 걸쳐&nbsp;고객 N명의 정보가 줄 맨 앞의 고객부터 맨 뒤 고객까지 순서대로 주어진다. i번째 줄은 줄의 앞에서 i번째 고객의&nbsp;회원번호 id<sub>i</sub>(1 ≤ id<sub>i</sub> ≤ 1,000,000)와 그가 구입한 물건의 수 w<sub>i</sub>(1 ≤ w<sub>i</sub> ≤ 20)로 이루어져 있다. N명의 회원번호는 모두 다르다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>고객 N명의 회원번호를 쇼핑몰을 빠져나가는 순서대로 r<sub>1</sub>, r<sub>2</sub>, ..., r<sub>N</sub>이라 할 때, 1×r<sub>1</sub> + 2×r<sub>2</sub> + ... + N×r<sub>N</sub>의 값을 출력한다. 출력값이 int 범위를 넘어갈 수 있음에 유의하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 3
123 4
21 5
34 14
56 1
45 7
723 5
55 7
13 5
910 10
73 3
','13900
','DATA_STRUCTURE'),
                                                                                                                (7747,'BAEKJOON','https://www.acmicpc.net/problem/17619',17619,'개구리 점프','1초','512 MB',13,'<p>통나무 N개가 가로 (수평) 방향으로 연못에 떠 있다. 개구리는 한 통나무 A에서 다른 통나무 B로 정확히 수직 방향으로 점프할 수 있다. 단, 점프할 때 다른 통나무 위를 (끝 점 포함) 지나면 안된다.</p>

<p>예를 들어 <그림 1>에서 1번 통나무에서 2번 통나무로 점선을 따라 개구리가 점프하는 것이 가능하다. 1번 통나무에서 2번 통나무로 점프한 후 다시 3번 통나무로 점프하면 1번 통나무에서 3번 통나무로 이동하는 것이 가능하다. (통나무 위에서 걸어서 움직이는 것은 언제든 가능하다.)</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/98a76e73-0187-43bb-90f9-435f8055e74f/-/preview/" style="width: 361.667px; height: 129.167px;"></p>

<p style="text-align: center;"><그림 1></p>

<p>통나무들의 위치를 입력받아 질문으로 주어진 통나무들의 쌍에 대해서 개구리가 한 통나무에서 다른 통나무로 한번 이상의 점프로 이동이 가능한지 판단하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 통나무 개수 N과 질문의 개수 Q가 주어진다. 다음 N개의 줄에 각 통나무에 x<sub>1</sub>, x<sub>2</sub>, y의 세 정수 좌표가 주어진다. 주어진 통나무는 두 점 (x<sub>1</sub>, y)와 (x<sub>2</sub>, y)를 잇는 형태이다. (x<sub>1</sub> < x<sub>2</sub>)&nbsp;모든 좌표는 0이상 10<sup>9</sup>이하이다. 통나무들은 주어진 순서대로 1번부터 번호가 붙어 있다. 서로 다른 두 통나무는 (끝점에서도) 만나지 않는다. 다음 Q개의 줄에 서로 다른 두 통나무의 번호가 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ Q ≤ 100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q개의 줄을 출력한다. 각 줄에는 주어진 순서대로 질문에 대한 대답이 출력되어야 한다. 질문에 주어진 두 통나무에 대해서 개구리가 한 통나무에서 다른 통나무로 한번 이상의 점프로 이동이 가능한 경우 대답은 1, 그렇지 않은 경우 대답은 0이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2
1 5 2
3 7 4
7 9 1
10 13 4
1 3
1 4
','1
0
','DATA_STRUCTURE'),
                                                                                                                (7750,'BAEKJOON','https://www.acmicpc.net/problem/17635',17635,'다리','4초','512 MB',24,'<blockquote>
<p style="text-align: right;">상트페테르부르크 시의 수로 길이의 총합은 약 282 km이고, 도시 면적 중 물이 차지하는 비중은 약 7%이다.</p>

<hr>
<p style="text-align: right;">Wikipedia</p>
</blockquote>

<p>상트페테르부르크는 n개의 섬을 m개의 다리로 이어 만든 도시이다. 섬은 1부터 n까지 정수로 표현할 수 있고, 다리는 1부터 m까지 정수로 표현한다. 각각의 다리는 서로 다른 두 섬을 연결한다. 어떤 다리는 표트르 대제 시절에 만들었고, 어떤 다리는 만든지 얼마 되지 않는다. 그래서 다리들마다 다양한 무게 제한이 있다. 즉, 자동차가 다리 i를 지나려면 무게가 d<sub>i</sub> 이하여야 한다. 때떄로 상트페테르부르크의 다리들을 보수할 때가 있다. 그렇지만 보수를 한다고 꼭 다리가 더 튼튼해지는 것은 아니어서, d<sub>i</sub> 값이 늘 수도 있고 줄어들 수도 있다. 이 도시의 시민과 관광객을 위해서, 다음 두 가지 질의를 처리할 수 있는 프로그램이 있다면 좋을 것이다.</p>

<ol>
	<li>다리 b<sub>j</sub>의 무게 제한이 r<sub>j</sub>로 바뀌었다.</li>
	<li>무게가 w<sub>j</sub>인 자동차로 섬 s<sub>j</sub>에서 출발해서 도착할 수 있는 섬의 수를 구하시오.</li>
</ol>

<p>두번째 형태의 질의를 모두 답하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 두 정수 n, m가 주어진다. ? 이는 각각 상트페테르부르크의 섬과 다리의 수이다. (1 ≤ n ≤ 50 000, 0 ≤ m ≤ 100 000)</p>

<p>다음 m 줄 중 i 번째 줄에는 세 정수 u<sub>i</sub>, v<sub>i</sub>, d<sub>i</sub>가 주어지는데, 섬 u<sub>i</sub>과 섬 v<sub>i</sub>를 잇는 다리의 무게 제한은 최초에는 d<sub>i</sub>라는 뜻이다. (1 ≤ u<sub>i</sub>, v<sub>i</sub> ≤ n; u<sub>i</sub>&nbsp;≠ v<sub>i</sub> ; 1 ≤ d<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>그 다음 줄에는 하나의 정수 q가 주어진다. ? 이는 질의의 수이다. (1 ≤ q ≤ 100 000). 다음 q 줄에 질의가 주어진다.</p>

<p>각 질의는 정수 t<sub>j</sub>로 시작한다. (t<sub>j</sub> ∈ {1, 2})</p>

<p>만약 t<sub>j</sub> = 1이라면, 이 질의는 첫 번째 형태이고, 두 정수 b<sub>j</sub>와 r<sub>j</sub>가 뒤따라 주어지는데, 이는 다리 b<sub>j</sub>의 무게 제한이 r<sub>j</sub>로 바뀐다는 뜻이다. (1 ≤ b<sub>j</sub> ≤ m, 1 ≤ r<sub>j</sub> ≤ 10<sup>9</sup>)</p>

<p>만약 t<sub>j</sub> = 2이면, 이 질의는 두번째 형태이고, 두 정수 s<sub>j</sub>와 w<sub>j</sub>가 뒤따라 주어지는데, 이는 무게가 w<sub>j</sub>인 자동차가 섬 s<sub>j</sub>에서 출발하여 도착할 수 있는 섬의 수를 구하라는 뜻이다. (1 ≤ s<sub>j</sub> ≤ n, 1 ≤ w<sub>j</sub> ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>두번째 형태의 질의 하나마다 한 줄에 하나씩 질의의 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>녹색 에지는 질의에서 물어보는 자동차가 건널 수 있는 다리를 나타낸다. 녹색 노드는 이 자동차가 도착할 수 있는 섬을 나타낸다. 화살표가 가리키는 섬은 이 자동차가 처음에 있던 곳이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/58aaa117-3865-40e2-abda-d9d949c8c50a/-/preview/" style="width: 564px; height: 174px;"></p>

<p style="text-align: center;">첫 번째 테스트 데이터</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/da0840d6-e546-4920-bd91-e76a93ec9f16/-/preview/" style="width: 550px; height: 479px;"></p>

<p style="text-align: center;">두번째 테스트 데이터</p>

				</div>
				</div>','3 4
1 2 5
2 3 2
3 1 4
2 3 8
5
2 1 5
1 4 1
2 2 5
1 1 1
2 3 2
','3
2
3
','DATA_STRUCTURE'),
                                                                                                                (7748,'BAEKJOON','https://www.acmicpc.net/problem/17636',17636,'가로등','5초','512 MB',24,'<p>이노폴리스에서는 자율 주행 택시가 운행하고 있다. 이 도시의 도로망은 n + 1개의 택시를 탈 수 있는 정류 장과 이들을 잇는 n개의 도로로 이루어져 있다. 도로 하나마다 가로등이 있다. i 번 가로등이 켜져 있다면, 정류장 i와 정류장 i + 1를 잇는 도로를 밝힌다. 만약 꺼져 있다면, 이 도로는 어둡다.</p>

<p>보안 문제로, 자율 주행 택시는 가로등이 켜진 도로만 달릴 수 있다. 다른 말로 하면, 택시가 정류장 a에서 정류장 b로 가려면 (a < b), 정류장 a과 정류장 a + 1를 잇는 도로, 정류장 a + 1과 정류장 a + 2를 잇는 도로, . . . , 정류장 b ? 1과 정류장 b를 잇는 도로의 가로등이 켜져야 한다.</p>

<p>고장이 나거나, 수리를 하면 가로등이 켜지거나 꺼질 수 있다.</p>

<p>시점 0에서는 가로등의 초기 상황이 주어진다. 1, 2, . . . , q 시간이 지나면 다음 두 상황 중 하나가 벌어질 수 있다.</p>

<ul>
	<li>“<code>toggle i</code>” ? i 번 가로등이 반전된다. 즉, 이 가로등이 켜져 있었다면 꺼지고, 꺼져 있었다면 켜진다.</li>
	<li>“<code>query a b</code>” ? 자율 주행 택시를 운영하는 곳의 대표가 다음을 궁금해한다. 시점 0에서 시작해서 현재에 이르기 까지 자율 주행 택시가 정류장 a에서 정류장 b까지 운행할 수 있었던 총 시간은 얼마일까?</li>
</ul>

<p>자율 주행 택시를 운영하는 곳이 이 질의를 답하는 것을 도와주자</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 두 정수 n, q가 주어진다. (1 ≤ n, q ≤ 300 000) ? 이는 가로등의 수와 이벤트의 개수이다.</p>

<p>두번째 줄에는 최초의 가로등 상태를 알려주는 문자열 s가 주어진다. (|s| = n), 만약 가로등 i가 켜져 있으면 s<sub>i</sub>는 ‘1’이고, 가로등 i가 꺼져 있으면 s<sub>i</sub>는 ‘0’이다.</p>

<p>다음 q 줄 각각은 이벤트를 설명한다. 이 중 i 번째 줄은 i 시간이 지났을 때 이벤트를 설명한다.</p>

<ul>
	<li>“<code>toggle i</code>” (1 ≤ i ≤ n) ? 가로등 i이 반전된다.</li>
	<li>“<code>query a b</code>” (1 ≤ a < b ≤ n + 1) ? 정류장 a에서 정류장 b까지 자율 주행 택시가 운행할 수 있었던 총 시간 수를 계산한다.</li>
</ul>

<p>이벤트 중 최소 하나는 <code>query</code>이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 <code>query</code> 이벤트마다 하나의 정수를 출력하고, 이 수는 질의에 대한 답이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 입력의 결과는 다음과 같다.</p>

<table class="table table-bordered" style="width:50%;">
	<thead>
		<tr>
			<th>시간</th>
			<th>가로등 상태</th>
			<th>이벤트</th>
			<th>응답</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1</td>
			<td><code>11011</code></td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td><code>query 1 2</code></td>
			<td>1</td>
		</tr>
		<tr>
			<td>2</td>
			<td><code>11011</code></td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td><code>query 1 2</code></td>
			<td>1 and 2</td>
		</tr>
		<tr>
			<td>3</td>
			<td><code>11011</code></td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td><code>query 1 6</code></td>
			<td>None</td>
		</tr>
		<tr>
			<td>4</td>
			<td><code>11011</code></td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td><code>query 3 4</code></td>
			<td>None</td>
		</tr>
		<tr>
			<td>5</td>
			<td><code>11011</code></td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td><code>toggle 3</code></td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>6</td>
			<td><code>11111</code></td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td><code>query 3 4</code></td>
			<td>6</td>
		</tr>
		<tr>
			<td>7</td>
			<td><code>11111</code></td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td><code>query 1 6</code></td>
			<td>6 and 7</td>
		</tr>
	</tbody>
</table>

				</div>
				</div>','5 7
11011
query 1 2
query 1 2
query 1 6
query 3 4
toggle 3
query 3 4
query 1 6
','1
2
0
0
1
2
','DATA_STRUCTURE'),
                                                                                                                (7755,'BAEKJOON','https://www.acmicpc.net/problem/17668',17668,'시험','3초','1024 MB',21,'<p>$N$명의 학생이 수학 부문과 정보 부문이 있는 시험을 쳤다. $i$번째 ($1 \le i \le N$) 학생은 수학에서는 $S_i$점을, 정보에서는 $T_i$점을 받았다. T교수와 I교수는 각 학생이 시험을 통과할지 말지를, 점수를 기반으로 정하려고 한다.</p>

<ul>
	<li>T 교수는 두 과목을 모두 중요하게 본다. 수학에서 $A$점, 정보에서 $B$점을 받아야만 통과한 것으로 생각한다.</li>
	<li>I 교수는 총점만 중요하게 본다. 수학과 정보를 합쳐서 $C$점 받아야 통과한 것으로 생각한다.</li>
	<li>두 교수의 기준을 모두 통과한 학생만 시험을 통과할 수 있다.</li>
</ul>

<p>당신은 기준인 $A$, $B$, $C$를 모른다. 하지만, $Q$가지의 세 정수 $(X_j,\ Y_j,\ Z_j)$ ($1 \le j \le Q$) 가 주어져서 몇 명의 학생들이 $A=X_j,\ B=Y_j,\ C=Z_j$일 때 시험을 통과하는지 알고 싶다.&nbsp;&nbsp;&nbsp;</p>

<p>학생들의 수, 점수 정보와 점수 기준이 주어졌을 때, 이 조건 하에서 시험을 통과하는 학생의 수를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력에서 다음과 같은 형식으로 주어진다. 모든 값은 정수이다.</p>

<p>$N$ $Q$ $S_1$ $T_1$ $\vdots$ $S_N$ $T_N$ $X_1$ $Y_1$ $Z_1$ $\vdots$ $X_Q$ $Y_Q$ $Z_Q$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 $Q$개의 줄을 출력하여라. $j$번째 ($1 \le j \le Q$)줄은 몇 명의 학생들이 $A=X_j,\ B=Y_j,\ C=Z_j$일 때 시험을 통과하는 학생 수이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 4
35 100
70 70
45 15
80 40
20 95
20 50 120
10 10 100
60 60 80
0 100 100
','2
4
1
1
','DATA_STRUCTURE'),
                                                                                                                (7757,'BAEKJOON','https://www.acmicpc.net/problem/17671',17671,'두 안테나','3초','512 MB',25,'<p>1번부터 $N$번까지의 번호가 붙어있는 $N$개의 안테나가 일렬로 놓여 있다. 각 안테나는 다른 연속된 안테나와 1km 떨어져 있다. $i$번 ($1 \le i \le N$) 안테나의 높이는 $H_i$이다. $i$번 안테나는 자신으로 부터 $A_i$km 이상 $B_i$km 이하 떨어져 있는 안테나에게만 정보를 보낼 수 있다. 만약 $x$번 안테나와 $y$번 안테나가 ($1 \le x < y \le N$) 서로 정보를 주고 받을 수 있다면, 이 둘은 통신할 수 있고, 통신 비용은 $|H_x - H_y|$이다.</p>

<p>JOI 공화국의 수상 K씨는 시민들로부터 연결상태에 관한 불만 $Q$개를 들었다. 조사 결과 $j$ 번째 ($1 \le j \le Q$) 불만은, $L_j, \ L_j +1, \cdots, R_j$번 안테나 중 무언가가 이상이 있는것으로 밝혀졌다. 당신은, 이 안테나들중 서로 통신할 수 있는 안테나 쌍이 있는지, 만약 있다면 그 중 가장 통신 비용이 높은 쌍의 통신 비용은 얼마인지 알아보는 일을 맡았다.</p>

<p>안테나의 정보와 불만의 정보가 주어졌을 때, $L_j, \ L_j +1, \cdots, R_j$번 안테나 중 서로 통신할 수 있는 쌍이 있는지, 있다면 통신 비용의 최댓값은 얼마인지를 알려주는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력에서 다음과 같은 형식으로 주어진다. 모든 값은 정수이다.</p>

<p>$N$</p>

<p>$H_1$ $A_1$ $B_1$</p>

<p>$\vdots$</p>

<p>$H_N$ $A_N$ $B_N$</p>

<p>$Q$</p>

<p>$L_1$ $R_1$</p>

<p>$\vdots$</p>

<p>$L_Q$ $R_Q$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 $Q$개의 줄을 출력하여라. $j$번째 ($1 \le j \le Q$)줄은 $L_j, \ L_j +1, \cdots, R_j$번 안테나 중 서로 통신할 수 있는 쌍이 없으면 <code>-1</code>, 있다면 통신 비용의 최댓값이어야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
10 2 4
1 1 1
2 1 3
1 1 1
100 1 1
5
1 2
2 3
1 3
1 4
1 5
','-1
1
8
8
99
','DATA_STRUCTURE'),
                                                                                                                (7759,'BAEKJOON','https://www.acmicpc.net/problem/17672',17672,'두 요리','5초','1024 MB',25,'<p>요리사 비타로는 요리 대회에 참여했다. 이 대회에서 참가자는 IOI 돈부리와 JOI 카레를 요리해야 한다.</p>

<p>IOI 돈부리를 요리하는 방법은 $N$단계로 이루어져 있다. $i$ 번째 ($1 \le i \le N$) 단계는 정확히 $A_i$분이 걸린다. 처음에, 그는 첫 번째 단계만 실행할 수 있다. $i$번째 ($2 \le i \le N$) 단계를 실행하려면, $(i-1)$번째 단계를 끝마쳐야 한다.</p>

<p>JOI 카레를 요리하는 방법은 $M$단계로 이루어져 있다. $j$ 번째 ($1 \le j \le M$) 단계는 정확히 $B_j$분이 걸린다. 처음에, 그는 첫 번째 단계만 실행할 수 있다. $j$번째 ($2 \le j \le M$) 단계를 실행하려면, $(j-1)$번째 단계를 끝마쳐야 한다.</p>

<p>각 단계를 집중해야 하기 때문에, 한 단계를 시작하면, 그 단계를 끝날 때 까지 다른 단계를 실행할 수 없다. 한 단계가 끝난 이후에는 다른 요리의 단계를 시작해도 상관 없다. 대회가 시작하면 두 요리가 끝나기 까지의 쉬는 시간은 없다.</p>

<p>이 대회에서는, 각 참가자는 <strong>예술 점수</strong>를 다음 기준에 따라 받는다.</p>

<ul>
	<li>IOI 돈부리를 만드는 $i$번째 ($1 \le i \le N$) 단계를 처음부터 $S_i$분 안에 끝냈을 경우 $P_i$점을 얻는다. $P_i$는 음수 일 수도 있다.</li>
	<li>JOI 카레를 만드는 $j$번째 ($1 \le j \le M$) 단계를 처음부터 $T_j$분 안에 끝냈을 경우 $Q_j$점을 얻는다. $Q_j$는 음수 일 수도 있다.</li>
</ul>

<p>비타로는 예술 점수를 최대화 하고 싶다.</p>

<p>요리 단계의 수와, 각 단계에 걸리는 시간과, 예술 점수의 정보가 주어졌을 때, 비타로가 얻을 수 있는 예술 점수의 최댓값을 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력에서 다음과 같은 형식으로 주어진다. 모든 값은 정수이다.</p>

<p>$N$ $M$</p>

<p>$A_1$ $S_1$ $P_1$</p>

<p>$\vdots$</p>

<p>$A_N$ $S_N$ $P_N$ $B_1$ $T_1$ $Q_1$</p>

<p>$\vdots$</p>

<p>$B_M$ $T_M$ $Q_M$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 한 개의 줄을 출력하여라. 이는 비타로가 얻을 수 있는 예술 점수의 최댓값이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
2 1 1
3 8 1
2 13 1
1 13 1
3 6 1
2 11 1
2 15 1
','6
','DATA_STRUCTURE'),
                                                                                                                (7758,'BAEKJOON','https://www.acmicpc.net/problem/17674',17674,'특별관광도시','2초','512 MB',23,'<p>JOI나라에는 $N$개의 도시가 있다. 이 도시들은 1번부터 $N$번까지 번호가 붙어있다. 이 도시에는 $N-1$개의 도로가 있고, 1번부터 $N-1$번까지의 번호가 붙어있다. $i$번 ($1 \le i \le N-1$) 도로는 노선이 두개가 있다. 한 노선은 $A_i$번 도시에서 $B_i$번 도시로 향하는 노선이고, 다른 노선은 $B_i$번 도시에서 $A_i$번 도시로 향하는 노선이다. 즉, 모든 도로는 양방향이다. 어떤 두 도시간에도 몇개의 도로를 사용해서 이동하는 것이 가능하다.</p>

<p>처음에 모든 노선들은 정비되어있지 않다. 각 도로의 각 노선에 대해, 우리는 노선을 정비하는 비용을 알고 있다. $i$번 ($1 \le i \le N-1$) 도로의 $A_i$번 도시에서 $B_i$번 도시로 향하는 노선을 정비하는 비용은 $C_i$이고, $B_i$번 도시에서 $A_i$번 도시로 향하는 노선을 정비하는 비용은 $D_i$이다.</p>

<p>JOI나라의 장관인 K이사장은 몇몇 도시를 돌라 그 도시를 <strong>특별관광도시</strong>로 만들것이다. $x$번 ($1 \le x \le N$)을 특별관광도시로 만들 때, 각 도로 $i$($1 \le i \le N-1$)에 대해, 다음 일이 일어날 것이다.</p>

<ul style="list-style-type:none">
	<li>$A_i$번과 $B_i$번 도시 중에서 $x$번 도시에 가까운 도시는 $a$번 도시이고, 먼 도시는 $b$번 도시라고 하자. 여기서, 가까운 도시라고 함은 $x$번 도시에 가기 위해 사용해야 하는 도로의 수가 더 적은 도시를 말한다. 이 때, $b$번 도시에서 $a$번 도시로 향하는 노선이 정비되지 않은 상태라면 정비된다.</li>
</ul>

<p>특별관광도시를 만들기 위해 노선을 정비하는 비용은 세금으로 충당되지만, 특별관광도시가 만들어 진 이후에 남은 도로를 정비하는 비용은 K이사장의 개인 자금에서 나간다.</p>

<p>K이사장이 계획한 $Q$개의 계획이 있다. $j$ 번째 ($1 \le j \le Q$) 계획에서는, 그는 특별관광도시가 없고 모든 노선이 정비되지 않은 상태에서 시작해서 정확히 $E_j$개의 도시를 특별관광도시로 만들것이다. 하지만, 어떤 도시들이 특별관광도시가 될지는 계획되지 않았다. 그는 개인 자금에서 나가는 도로 정비 비용을 최소로 하고 싶다.</p>

<p>JOI나라의 도시 수, 도로의 정보와 계획의 정보가 주어졌을 때, 각 계획마다 K이사장의 개인 자금에서 나가는 도로 정비 비용을 최소로 하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력에서 다음과 같은 형식으로 주어진다. 모든 값은 정수이다.</p>

<p>$N$</p>

<p>$A_1$ $B_1$ $C_1$ $D_1$</p>

<p>$\vdots$</p>

<p>$A_{N-1}$ $B_{N-1}$ $C_{N-1}$ $D_{N-1}$</p>

<p>$Q$</p>

<p>$E_1$</p>

<p>$\vdots$</p>

<p>$E_Q$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 $Q$개의 줄을 출력하여라. $j$ 번째 ($1 \le j \le Q$)줄은 $j$ 번째 계획에서 이사장의 개인 자금에서 나가는 도로 정비 비용의 최솟값이어야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2 1 2
1 3 3 4
1 4 5 6
2
1
2
','9
1
','DATA_STRUCTURE'),
                                                                                                                (7760,'BAEKJOON','https://www.acmicpc.net/problem/17676',17676,'시간을 달리는 비타로','3초','512 MB',24,'<p>비버랜드에는 $N$개의 도시가 있다. 이 도시들은 1번부터 $N$번까지 번호가 붙어있다. $i$번째 ($1 \le i \le N-1$) 도로는 $i$번 도시와 $i+1$번 도시를 양방향으로 잇는다. 또한, 비버랜드의 하루는 1 000 000 000개의 단위시간으로 분열되어 있고, 이 단위시간을 <em>쵸</em>라고 부른다. 하루가 시작하고 나서 $x$쵸가 지난 시간을 시각 $x$라 부른다. 한 도로를 통과하는 데에는 1쵸가 걸리고, $i$번째 도로는 시각 $L_i$와 시각 $R_i$ 사이에만 통과할 수 있다. 구체적으로, $i$번째 도로를 통과하기 위해서 우리는 도시 $i$나 $i+1$을 $L_i \le x \le R_i -1$ 을 만족하는 시각 $x$에 떠나야 하고, 다른 도시에 시각 $x+1$에 도착해야 한다.</p>

<p>비타로는 비버랜드에 사는 평범한 비버다. 아니, 비버였다 라고 하는게 옳은 것일까. 지각을 자주한 비타로는 이를 개선하려고 한 결과로 시간을 거슬러 올라가는게 가능해 졌다. 이 능력을 한 번 사용하면 1쵸 뒤로 갈 수 있다. 하지만, 어제로 갈 수는 없다. 만약 그가 능력을 시각 0과 시각 1 사이에 사용했다면, 그는 시각 0으로 돌아갈 것이다. 그는 이 기술을 도시에 있을 때 사용할 수 있다. 비타로의 위치는 능력을 사용해도 변하지 않는다.</p>

<p>비타로는 기술을 사용하면 피곤해 진다. 최소한의 기술을 사용하여 이동하는 방법을 찾기 위한 비타로는 $Q$개의 사고실험을 진행했다. 사고 실험의 $j$ 번째 단계에서는, 그는 다음 중 한 행동을 한다:</p>

<ul>
	<li>$P_j$ 번째 도로가 여행될수 있는 시각을 바꾼다. 바뀐 이후에는, 시각 $S_j$와 시각 $E_j$ 사이에만 $P_j$ 번째 도로를 통과할 수 있다.</li>
	<li>그가 $A_j$번 도시, 시각 $B_j$에 있다고 할 때, $C_j$번 도시, 시각 $D_j$로 이동하기 위해 사용해야하는 능력의 수의 최솟값을 구하여라.</li>
</ul>

<p>그는 사고실험의 결과를 궁금해한다.</p>

<p>비버랜드의 도시의 수, 도로의 정보, 사고실험의 방법이 주어졌을 때, 사고 실험의 결과를 계산하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력에서 다음과 같은 형식으로 주어진다. 모든 값은 정수이다.</p>

<p>$N$ $Q$</p>

<p>$L_1$ $R_1$</p>

<p>$\vdots$</p>

<p>$L_{N-1}$ $R_{N-1}$</p>

<p>(Query 1)</p>

<p>$\vdots$</p>

<p>(Query $Q$)</p>

<p>여기서, (Query $j$)는 공백으로 구분된 4개나 5개의 정수로 이루어져 있다. $T_j$가 첫 번째 정수라고 하자. 그러면,</p>

<ul>
	<li>$T_j=1$인 경우, (Query $j$)는 4개의 정수 $T_j$, $P_j$, $S_j$, $E_j$로 이루어져 있다. 이것은, 사고 실험의 $j$번째 단계에서, $P_j$번째 도로를 지날수 있는 시간이 시각 $S_j$와 시각 $E_j$ 사이로 바뀐다는 것을 의미한다.</li>
	<li>$T_j=2$인 경우, (Query $j$)는 5개의 정수 $T_j$, $A_j$, $B_j$, $C_j$, $D_j$로 이루어져 있다. 이는, $j$번째 사고 실험에서, 당신의 프로그램이 비타로가 $A_j$번 도시, 시각 $B_j$에 있다고 할 때, $C_j$번 도시, 시각 $D_j$로 이동하기 위해 사용해야하는 능력의 수의 최솟값을 구해야 한다는 것을 의미한다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$T_j=2$인 각 단계에 대해서, 사용해야 하는 능력의 수의 최솟값을 한 줄에 하나씩 차례로 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
0 5
0 5
2 1 3 3 3
1 2 0 1
2 1 3 3 3
','2
4
','DATA_STRUCTURE'),
                                                                                                                (7762,'BAEKJOON','https://www.acmicpc.net/problem/17677',17677,'케이크 3','4초','256 MB',23,'<p>오늘은 IOI양의 생일이다. 이 날을 위해 JOI군은 생일 케이크를 예약했다. 원형 케이크 하나를 통채로 예약할 생각이었지만 착오가 있어서 $N$조각의 케이크를 예약해 버렸다. 각 조각에는 1번 부터 $N$번까지 번호가 붙어 있고, $i$ 번째 ($1 \le i \le N$) 조각의 가치는 $V_i$이고, 색의 짙음은 $C_i$이다.</p>

<p>JOI군은 서로 다른 $M$개의 케이크를 골라, 원하는 순서대로 배열해 합쳐서 원형 케이크를 만들기로 결심했다. 케이크 조각들이 $k_1$번, $\cdots$, $k_M$번 조각의 순서로 나열되어 있을 때, 이 케이크의 아름다움은</p>

<p>$$ \sum_{j=1}^{M} {V_{k_j}} - \sum_{j=1}^{M} {\left| C_{k_j} - C_{k_{j+1}}\right|} $$</p>

<p>으로 정의된다. (단, $k_{M+1} = k_1$ 이다.) 즉, 아름다움은 사용된 케이크 조각의 가치의 합으로 부터 인접한 두 케이크의 색의 짙음에 차의 절댓값의 합계로 정의된다. JOI군은 되도록이면 원형 케이크의 가치의 합을 최대로 하고싶다.</p>

<p>케이크 조각의 갯수, 각 케이크 조각의 가치와 색의 짙음, 원형 케이크를 만들기 위해 필요한 조각의 갯수가 주어졌을 때, JOI군이 만들 수 있는 원형 케이크의 아름다움의 최댓값을 구하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력에서 다음과 같은 형식으로 주어진다. 모든 값은 정수이다.</p>

<p>$N$ $M$</p>

<p>$V_1$ $C_1$</p>

<p>$\vdots$</p>

<p>$V_N$ $C_N$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>표준 출력으로 한 개의 줄에 하나의 수를 출력하여라. 이는 JOI군이 만들 수 있는 원형 케이크의 아름다움의 최댓값이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
2 1
4 2
6 4
8 8
10 16
','6
','DATA_STRUCTURE'),
                                                                                                                (7761,'BAEKJOON','https://www.acmicpc.net/problem/17678',17678,'합병','3초','256 MB',21,'<p>JOI합중국에는 $N$개의 도시가 있어서, 1번부터 $N$번까지의 번호가 붙어있다. 또한, JOI합중국에는 $N-1$개의 국도가 있다. $i$ 번째($1 \le i \le N-1$) 국도는 $A_i$번 도시와 $B_i$번 도시를 양방향으로 잇는다. 어떤 두 도시에 대해서도, 국도 몇개를 이용하면 서로 오가는 것이 가능하다.</p>

<p>현재, JOI합중국은 1번부터 $K$번까지의 번호가 붙어있는 $K$개의 주로 나뉘어 있다. $j$번 ($1 \le j \le N$)도시는 $S_j$번 주에 속한다. 모든 주에는 적어도 하나의 도시가 속해 있다.</p>

<p>JOI합중국의 대통령인 $K$이사장은, 이 나라가 분열하지 않을까 걱정이 되었다. 다음 조건을 모두 만족하도록 모든 도시를 2개의 그룹 $X$, $Y$로 나누는 것이 가능할 때, JOI합중국은 <strong>분열가능</strong>한 상태라고 말한다.</p>

<ul>
	<li>모든 도시는 그룹 $X$혹은 그룹 $Y$에 속한다.</li>
	<li>그룹 $X$에는 적어도 하나의 도시가 속해 있다.</li>
	<li>그룹 $Y$에는 적어도 하나의 도시가 속해 있다.</li>
	<li>모든 주에 대해서, 그 주에 있는 모든 도시는 모두 같은 그룹에 속해 있다.</li>
	<li>그룹 $X$에 속한 어떤 두 도시에 대해서도, 그룹 $X$에 속한 도시만을 경유해서 서로 오가는 것이 가능하다.</li>
	<li>그룹 $Y$에 속한 어떤 두 도시에 대해서도, 그룹 $Y$에 속한 도시만을 경유해서 서로 오가는 것이 가능하다.</li>
</ul>

<p>$K$이사장은, JOI합중국이 분열가능하지 않은 상태를 만들기 위해, 주를 합병하려고 한다. 한번의 합병은 두개의 주를 골라서 합치는 것을 말한다. 새로운 주는, 기존의 두 주에 속해 있던 도시 들이 속해있다. K이사장은 주를 최소한의 횟수만큼 합병하여 JOI합중국을 분열가능하지 않은 상태로 만들고 싶어한다.</p>

<p>도시와 국도의 위치, 현재 어떤 도시가 어떤 주에 속해있는가에 대한 상태가 주어졌을 때, JOI 합중국이 분열가능하지 않은 상태로 만들기 위한 합병의 최소 횟수를 구하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력에서 다음과 같은 형식으로 주어진다. 모든 값은 정수이다.</p>

<p>$N$ $K$</p>

<p>$A_1$ $B_1$</p>

<p>$\vdots$</p>

<p>$A_{N-1}$ $B_{N-1}$</p>

<p>$S_1$</p>

<p>$\vdots$</p>

<p>$S_N$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>JOI합중국을 분열가능하지 않은 상태로 만들기 위한 합병의 최소횟수를 표준 출력의 첫째 줄에 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 4
1 2
2 3
3 4
3 5
1
2
1
3
4
','1
','DATA_STRUCTURE'),
                                                                                                                (7787,'BAEKJOON','https://www.acmicpc.net/problem/17823',17823,'수열과 쿼리 33','5초','512 MB',28,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다.&nbsp;이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>l r k</code>: 부분수열&nbsp;A<sub>l</sub>, A<sub>l+1</sub>, ..., A<sub>r</sub>&nbsp;에 대해, 해당 부분 수열에서 k개의 부분&nbsp;수열을 골라서 부분 수열의 원소의 합의 최댓값을 출력하라. 고른 부분 수열은 각각 비어있지 않아야 하며, 서로 겹쳐서는 안된다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N, 쿼리의 개수 M이 주어진다. (1 ≤ N, M ≤ 35,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (-35,000&nbsp;≤ A<sub>i</sub>&nbsp;< 35,000)</p>

<p>셋째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ l ≤ r&nbsp;≤ N, 1 ≤ k ≤ r - l + 1)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
-1 2 -3 4 -5
1 5 1
1 5 2
1 5 3
1 5 4
1 5 5
','4
6
5
2
-3
','DATA_STRUCTURE'),
                                                                                                                (7809,'BAEKJOON','https://www.acmicpc.net/problem/17941',17941,'목장 CCTV','2초','256 MB',17,'<p>준호는 한양대학교의 숨겨진 공간에 직사각형 모양의 목장을 만들어 <em>N</em>행 <em>M</em>열을 이루는 양 <em>N</em>×<em>M</em> 마리를 키우고 있다. 준호는 산더미 같은 할 일에 지칠 땐 목장에서 양들을 보며 힐링하기 때문에 양들을 지켜보는 시간을 매우 소중하게 생각한다. 그러나 준호는 매우 바쁜 사람이기 때문에 며칠동안 다른 지역에 출장 가야하는 일이 매우 많았고, 그 때마다 양을 지켜보는 시간을 가질 수 없었다. 결국 준호는 멀리서나마 양을 지켜보고 싶은 마음에&nbsp;한번의 출장동안만 사용할 수 있는 일회용 CCTV를 목장에&nbsp;설치하게 되었다.</p>

<p>이 CCTV는 굉장히 특이한데, 설치지점으로부터 아래로 <em>R</em>행, 오른쪽으로 <em>C</em>열의 직사각형이 촬영 범위로, 하루에 한번씩 촬영범위 안에서 가장 크기가 큰 양의 사진을 찍어 전송하는 기능만을 제공한다. 또한 준호의 양들도 준호가 없을 때만 보이는 특이한 습성이 있다. 양들은 준호가 없으면 불안함을 느끼기 때문에, 준호가 떠난 다음날부터 준호가 돌아올 때까지 모든 양들이 상하좌우 중 한 방향을 골라서 매일매일 하루에 한 칸씩 같은 방향으로 움직인다. 단, 목장은 크기가 매우 크기 때문에 양들이 목장의 경계까지 이동하여 움직이지 못하는 경우는 발생하지 않는다.&nbsp;물론 양들이 움직여도 CCTV는 제자리에 고정되어 움직이지 않는다.</p>

<p>준호는 이러한 환경에서도 CCTV가 정상적으로 작동하는지 의문이 생겼고 당신에게 이 CCTV가 제대로 작동하는지 검증하는 프로그램을 작성해달라고 부탁했다. 검증에 필요한 정보들이 주어졌을 때, CCTV가 매일 전송해야 하는 양의 크기를 출력하는 프로그램을 작성하자. 단, 모든 결과를 출력하기에는 양이 많으니 준호가 한번 다른 지역에 갈 때마다 그 때의 모든 결과를 XOR한 결과를 출력하도록 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 준호가 기르고 있는 양의 행과 열을 나타내는 정수 N, M (1 ≤ N, M ≤ 500) 이 주어진다.</p>

<p>다음 N개의 줄에 걸쳐 양들의 크기에 대한 정보가 주어진다. 각 줄에는 양의 크기를 나타내는 정수 A<sub>ij</sub>&nbsp;(1 ≤&nbsp;A<sub>ij</sub>&nbsp;≤&nbsp;100,000, 1 ≤&nbsp;i&nbsp;≤&nbsp;N, 1 ≤&nbsp;j&nbsp;≤&nbsp;M) M개가 주어진다.&nbsp;</p>

<p>셋째 줄에는 준호가 다른 지역에 출장 가는 횟수를 나타내는 양의 정수 Q (1 ≤&nbsp;Q ≤ 50,000) 가 주어진다.</p>

<p>다음 Q개의 줄에 걸쳐 각 출장에 대해 설치한 일회용 CCTV와 양들의 이동에 관한 정보가 주어진다. 각 줄은 CCTV의 설치 위치를 나타내는 정수 X, Y (1 ≤&nbsp;X ≤&nbsp;N, 1 ≤&nbsp;Y ≤&nbsp;M), 촬영범위를 나타내는 정수 R, C&nbsp;(1 ≤&nbsp;R ≤&nbsp;N, 1 ≤&nbsp;C ≤&nbsp;M), 준호가 다른 지역에 가 있는 일자를&nbsp;나타내는 정수 K (1 ≤&nbsp;K ≤&nbsp;max(N, M)), 기간 동안 양들이 움직이는 방향을 나타내는 정수 D (1 ≤&nbsp;D&nbsp;≤&nbsp;4) 가 주어진다. 방향은 각각 상하좌우가 1, 2, 3, 4에 대응한다.</p>

<p>CCTV의 촬영범위 안에 빈 공간이 생기는 경우는 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em>개의 줄에 걸쳐, 각각 준호가 출장을 가 있는 <em>K</em>일 동안 매일 CCTV가 전송해야 하는 양의 크기를 구하여 얻은 정수 <em>K</em>개를 XOR한 값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
2 6 12 2 11
20 9 10 6 10
8 18 4 18 15
10 14 11 10 3
17 11 15 13 16
2
2 2 2 2 2 4
1 1 1 2 5 1
','6
31
','DATA_STRUCTURE'),
                                                                                                                (7810,'BAEKJOON','https://www.acmicpc.net/problem/17942',17942,'알고리즘 공부','1초','512 MB',15,'<p>늘 돈이 부족한 희정이는&nbsp;HCPC에 참가하여 좋은 성적을 거두어서 상금을 타기로 마음먹었다. 이를 위해 먼저 출제위원장인 정호의 노트북을 해킹하여 N개의 알고리즘을 출제 범위로 두고 문제가 출제된다는 사실을 알게 되었다. 출제 범위를 알았으니 이제 희정이에게 남은 것은 알고리즘을 공부하는 것이다. 알고리즘 공부에는 사실 특별한 규칙이 숨어있는데 이는 다음과 같다.</p>

<p>각 알고리즘들을 처음 배울 때에는 K<sub>i</sub>만큼의 알고리즘 공부량이 필요하다. 그리고 몇몇 알고리즘은 서로 연관성이 있어 어느 한 알고리즘을 배우면 다른 특정한 알고리즘을 배울 때 필요한 공부량이 줄어드는 경우가 있다. 한 알고리즘을 배울 때 필요한 공부량이 여러 개의 다른&nbsp;알고리즘에 의해서 줄어드는 경우는 그 감소량을 모두 합산해서 적용한다. 또한 알고리즘 공부량은 소모되지 않으며&nbsp;누적된다. 예시로 처음 배울 때 3의 공부량이 필요한 알고리즘과 5의 공부량이 필요한 알고리즘을 모두 배우기 위해선 그 둘의 합&nbsp;8이 아니라 그 둘의 최대값&nbsp;5의 공부량이 필요하다.</p>

<p>그러나 막상 알고리즘 공부를 하려고 보니 벌써부터 중간고사가 닥쳐오고 있었기 때문에 모든 알고리즘을 배우기에는 시간이 부족했다. 희정이는 결국 최소한의 시간을 투자해 최소한 M개의 알고리즘만이라도 공부하기로 결심했다. 당신이 할 일은 알고리즘을 처음 배우는데 필요한 공부량과 각 알고리즘 사이의 연관성이 주어졌을 때, 최소 M개의 알고리즘 배우는데 필요한 알고리즘 공부량을 구하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 출제 범위인 알고리즘의 개수를 나타내는 양의 정수 N, 최소한 배우고자 하는 알고리즘의 개수를 나타내는 양의 정수 M이 주어진다. ( 1 ≤ M ≤&nbsp;N ≤&nbsp;100,000 )</p>

<p>둘째줄에는 각 알고리즘을 처음 배우는데 필요한 알고리즘 공부량을 나타내는 N개의 양의 정수 K<sub>i</sub>가 사이에 공백을 두고 주어진다. (1 ≤&nbsp;K<sub>i&nbsp;</sub>≤&nbsp;10<sup>8</sup>)</p>

<p>셋째줄에는 서로 연관성이 있는 알고리즘 관계의 개수를 나타내는 양의 정수 R이 주어진다.&nbsp;( 0 ≤&nbsp;R ≤&nbsp;100,000 )</p>

<p>다음 K줄에 걸쳐서, 각 줄에 A, B, D가 주어지며 이는 A번 알고리즘을 배우면 B번 알고리즘을 배우는데 필요한 공부양이 D만큼 줄어듦을 의미한다. (1 ≤&nbsp;A, B ≤&nbsp;N, 1 ≤&nbsp;D ≤&nbsp;10<sup>8</sup>)</p>

<p>A와 B의 쌍이 같은 관계가 여러 번 주어지지 않으며, A = B인 관계는 주어지지 않는다. 또한, 공부양이 아무리 줄어도 0 이하로 내려가지 않음이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>최소 M개의 알고리즘을 익히기 위해서 필요한 최소 알고리즘 공부량을 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
18 20 77 82
3
1 3 60
1 4 3
3 4 60
','19
','DATA_STRUCTURE'),
                                                                                                                (7812,'BAEKJOON','https://www.acmicpc.net/problem/17952',17952,'과제는 끝나지 않아!','2초','256 MB',8,'<p>성애는 이번 학기에 전공을 정말 많이 듣는다. 이로 인해 거의 매일을 과제를 하면서 보내고 있다. 그런데도 과제가 줄어들 기미가 보이지 않는데, 바로 분단위로 과제가 추가되고 있기 때문이다. 다행히 과제 제출 기한은 학기가 끝날 때까지이다. 너무나도 많은 과제를 하다가 미쳐버린 성애는 아래와 같은 규칙으로 과제를 해 나가고 있다.</p>

<ol>
	<li>과제는 가장 최근에 나온 순서대로 한다. 또한 과제를 받으면 바로 시작한다.</li>
	<li>과제를 하던 도중 새로운 과제가 나온다면, 하던 과제를 중단하고 새로운 과제를 진행한다.</li>
	<li>새로운 과제가 끝났다면, 이전에 하던 과제를 이전에 하던 부분부터 이어서 한다. (성애는 기억력이 좋기 때문에 아무리 긴 시간이 지나도 본인이 하던 부분을 기억할 수 있다.)</li>
</ol>

<p>성애는 과제를 받자마자 이 과제가 몇 분이 걸릴지 정확하게 알 수 있고, 성애가 제출한 과제는 무조건 만점을 받는다.</p>

<p>성애는 이번 학기에 자기가 받을 과제 점수를 예상해보고 싶다. 하지만 과제 점수를 예상하는 지금도 과제가 추가되고 있기에 여유를 부릴 수가 없다. 여러분이 성애가 받을 과제 점수를 구해주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 이번 학기가 몇 분인지를 나타내는 정수 N이 주어진다. (1 ≤ N ≤ 1,000,000)</p>

<p>두번째 줄부터 N줄 동안은 학기가 시작하고 N분째에 주어진 과제의 정보가 아래의 두 경우 중 하나로 주어진다.</p>

<ul>
	<li>1 A T: 과제의 만점은 A점이고, 성애가 이 과제를 해결하는데 T분이 걸린다. A와 T는 모두 정수이다. (1 ≤ A ≤ 100, 1 ≤ T ≤ 1,000,000)</li>
	<li>0: 해당 시점에는 과제가 주어지지 않았다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>성애가 받을 과제 점수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 100 3
0
0
','100
','DATA_STRUCTURE'),
                                                                                                                (7813,'BAEKJOON','https://www.acmicpc.net/problem/17960',17960,'3차원 점과 쿼리','7초','1024 MB',23,'<p>3차원 평면에 찍힌 N개의 점이 주어질 때 다음 쿼리를 처리하는 프로그램을 작성하시오</p>

<ul>
	<li>l<sub>x</sub>&nbsp;l<sub>y</sub>&nbsp;l<sub>z</sub>&nbsp;r<sub>x</sub>&nbsp;r<sub>y</sub>&nbsp;r<sub>z</sub>&nbsp;: 점 (l<sub>x</sub>, l<sub>y</sub>, l<sub>z</sub>)과 점 (r<sub>x</sub>, r<sub>y</sub>, r<sub>z</sub>)을 꼭짓점으로 하는 직육면체 영역에 포함된 점의 갯수를 출력한다.</li>
</ul>

<p>&nbsp;</p>

<p>직육면체의 모든 모서리는 축에 평행하며 주어지는 (l<sub>x</sub>, l<sub>y</sub>, l<sub>z</sub>)와 (r<sub>x</sub>, r<sub>y</sub>, r<sub>z</sub>)를 연결한 선은 이 직육면체의 대각선이다</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 점의 수 N과 쿼리의 수 Q가 공백으로 구분하여 주어진다. (1 ≤ N, Q&nbsp;≤ 10<sup>5</sup>)</p>

<p>다음 N개의 줄에 걸쳐 점의 좌표를 의미하는 세 정수 x, y, z가 공백으로 구분하여 주어진다. (0&nbsp;≤ x, y, z ≤ 10<sup>9</sup>)</p>

<p>다음 Q개의 줄에 걸쳐 6개의 정수 a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, d<sub>i</sub>, e<sub>i</sub>, f<sub>i</sub>가 주어진다. (0 ≤ a<sub>i</sub>,&nbsp;b<sub>i</sub>, c<sub>i</sub>, d<sub>i</sub>, e<sub>i</sub>, f<sub>i </sub>< 2<sup>63</sup>)</p>

<p>i번째 쿼리의 l<sub>x</sub>&nbsp;l<sub>y</sub>&nbsp;l<sub>z</sub>&nbsp;r<sub>x</sub>&nbsp;r<sub>y</sub>&nbsp;r<sub>z</sub>는&nbsp;다음과 같다.</p>

<ul>
	<li>l<sub>x</sub>&nbsp;= (a<sub>i</sub>&nbsp;xor S<sub>i-1</sub>) mod (10<sup>9</sup>&nbsp;+ 1)</li>
	<li>l<sub>y</sub>&nbsp;= (b<sub>i</sub>&nbsp;xor S<sub>i-1</sub>) mod (10<sup>9</sup>&nbsp;+ 1)</li>
	<li>l<sub>z</sub>&nbsp;= (c<sub>i</sub>&nbsp;xor S<sub>i-1</sub>) mod (10<sup>9</sup>&nbsp;+ 1)</li>
	<li>r<sub>x</sub>&nbsp;= (d<sub>i</sub>&nbsp;xor S<sub>i-1</sub>) mod (10<sup>9</sup>&nbsp;+ 1)</li>
	<li>r<sub>y</sub>&nbsp;= (e<sub>i</sub>&nbsp;xor S<sub>i-1</sub>) mod (10<sup>9</sup>&nbsp;+ 1)</li>
	<li>r<sub>z</sub>&nbsp;= (f<sub>i</sub>&nbsp;xor S<sub>i-1</sub>) mod (10<sup>9</sup>&nbsp;+ 1)</li>
</ul>

<p>S<sub>i</sub>&nbsp;= S<sub>i-1</sub>&nbsp;+ ans<sub>i</sub>&nbsp;이며 S<sub>0</sub>는 0이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q개의 줄에 각 쿼리의 정답을 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 8
1 0 5
1 1 10
5 1 10
0 10 5
2 10 0
0 0 3 5 5 8
0 0 2 6 5 6
1 1 0 2 4 11
2 2 6 7 9 4
2 3 1 0 9 4
5 4 0 14 5 14
6 6 2 1 2 14
6 7 3 15 5 0
','1
0
2
0
1
3
0
1
','DATA_STRUCTURE'),
                                                                                                                (7816,'BAEKJOON','https://www.acmicpc.net/problem/17961',17961,'수열과 쿼리 35','7초','512 MB',26,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 수열의 모든 수는 1 이상 N 이하이며&nbsp;서로 다르다.&nbsp;이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>l r k</code>: 부분배열 [A<sub>l</sub>, A<sub>l+1</sub>, ..., A<sub>r</sub>] 을 k만큼 오른쪽으로 시프트한다. 고로, A<sub>l</sub> 은 A<sub>l+k</sub>, A<sub>r-k</sub> 는 A<sub>r</sub>, A<sub>r-k+1</sub> 은 A<sub>l</sub>, A<sub>r</sub> 은 A<sub>l+k-1</sub> 이 된다. 이후, 수열에 길이 3의 증가하는 부분 수열 (subsequence) 이 있다면 <code>YES</code>, 아니면 <code>NO</code>를 출력한다.&nbsp;</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<section id="input">
<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 120,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 모든 수는 서로 다르다. (1&nbsp;≤ A<sub>i</sub>&nbsp;≤&nbsp;N)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 120,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ L ≤&nbsp;R ≤ N, 0&nbsp;≤ K&nbsp;≤ R-L+1)</p>
</section>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<section id="output">
<p>쿼리의 결과를 한 줄에 하나씩 출력한다.</p>
</section>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
2 5 6 1 3 4
1
1 6 5
','YES
','DATA_STRUCTURE'),
                                                                                                                (7821,'BAEKJOON','https://www.acmicpc.net/problem/18115',18115,'카드 놓기','2초(추가시간없음)','1024 MB',8,'<p>수현이는 카드 기술을 연습하고 있다. 수현이의 손에 들린 카드를 하나씩 내려놓아 바닥에 쌓으려고 한다. 수현이가 쓸 수 있는 기술은 다음 3가지다.</p>

<ol>
	<li>제일 위의 카드 1장을 바닥에 내려놓는다.</li>
	<li>위에서 두 번째 카드를 바닥에 내려놓는다. 카드가 2장 이상일 때만 쓸 수 있다.</li>
	<li>제일 밑에 있는 카드를 바닥에 내려놓는다. 카드가 2장 이상일 때만 쓸 수 있다.</li>
</ol>

<p>수현이는 처음에 카드 <em>N</em>장을 들고 있다. 카드에는 1부터 <em>N</em>까지의 정수가 중복되지 않게 적혀 있다. 기술을 <em>N</em>번 사용하여 카드를 다 내려놓았을 때, 놓여 있는 카드들을 확인했더니 위에서부터 순서대로 1, 2, …, <em>N</em>이 적혀 있었다!</p>

<p>놀란 수현이는 처음에 카드가 어떻게 배치되어 있었는지 궁금해졌다. 처음 카드의 상태를 출력하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 <em>N&nbsp;</em>(1 ≤ <em>N</em> ≤ 10<sup>6</sup>)이 주어진다.</p>

<p>두 번째 줄에는 길이가 <em>N</em>인 수열 <em>A</em>가 주어진다.&nbsp;<em>A<sub>i</sub></em>가 <em>x</em>이면,&nbsp;<em>i</em>번째로 카드를 내려놓을&nbsp;때 <em>x</em>번 기술을 썼다는 뜻이다.&nbsp;<em>A<sub>i</sub></em>는 1, 2, 3 중 하나이며, <em>A<sub>n</sub></em>은 항상 1이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>초기 카드의 상태를 위에서부터 순서대로 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 1 1 1 1
','5 4 3 2 1
','DATA_STRUCTURE'),
                                                                                                                (7827,'BAEKJOON','https://www.acmicpc.net/problem/18116',18116,'로봇 조립','4초(추가시간없음)','1024 MB',12,'<p>성규는 로봇을 조립해야 한다. 상자 안에는 여러 로봇의 부품들이 섞여 있다. 그런데 어떤 부품이 어느 로봇의 부품인지 표시가 되어있지 않다. 호재는 전자과라서 두 부품을 보면 같은 로봇의 부품인지 알 수 있다. 그래서 성규는 호재의 지시에 따라 부품들을 정리하기로 하였다.</p>

<p>부품들은 1부터&nbsp;10<sup>6</sup>까지의 정수로 표현된다. 그리고 부품 <em>i</em>가 속한 로봇은 robot(<em>i</em>)라고도 표현한다. 예를 들어, 부품 11과 부품 22가 로봇 A의 부품이라고 알고 있는 경우, robot(11)은 로봇 A를 의미하고, robot(22)도 로봇 A를 의미한다.</p>

<p>서로 다른 로봇은 공통 부품을 가지지 않는다. 즉 어떤 부품이 로봇 A의 부품이라면, 로봇 B의 부품은 될 수 없다.</p>

<p>호재는 2가지 지시를 한다.</p>

<ul>
	<li>서로 다른 부품 2개를 말해주며, 두 부품은 같은 로봇의 부품이라는 정보를 알려준다.</li>
	<li>부품 <em>i</em>에 대해서, 지금까지 알아낸 robot(<em>i</em>)의 부품이 몇 개냐고 물어본다.</li>
</ul>

<p>초기에는 부품에 대한 정보가 존재하지 않는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 호재의 지시 횟수 <em>N</em>이 들어온다. (1&nbsp;≤ <em>N</em>&nbsp;≤ 10<sup>6</sup>)</p>

<p>다음 줄부터 <em>N</em>개의 지시가 들어온다.</p>

<p>부품 2개가 같은 로봇의 부품인지 알려줄 때에는 \(I\)<em>&nbsp;a b</em> 의 형태로 들어온다. 부품 <em>a</em>와 부품 <em>b</em>는 같은 로봇의 부품이라는 의미이다. (1&nbsp;≤<strong>&nbsp;</strong><em>a</em>,&nbsp;<em>b</em>&nbsp;≤ 10<sup>6</sup>, <em>a</em>&nbsp;≠&nbsp;<em>b, a</em>,&nbsp;<em>b</em>는 정수)</p>

<p>어떤 로봇의 부품이 몇 개인지 물어볼 때에는 <em>Q c</em> 의 형태로 들어온다. 지금까지 알아낸 robot(<em>c</em>)의 부품이 몇 개냐는 의미이다. (1&nbsp;≤ <em>c</em>&nbsp;≤ 10<sup>6</sup>, <em>c</em>는 정수)</p>

<p>입력으로 <em>Q c</em>의 형태가&nbsp;적어도 한 번 들어온다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em>로 시작하는 입력에 대해서 한 줄에 하나씩, 지금까지 알아낸 해당 로봇의 부품 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
I 1 2
I 3 2
Q 1
Q 4
','3
1
','DATA_STRUCTURE'),
                                                                                                                (7841,'BAEKJOON','https://www.acmicpc.net/problem/18135',18135,'겨울나기','2초','256 MB',17,'<p>가톨릭대학교 텔레토비 동산에는 겨울을 준비하는 다람쥐 다다가 살고 있다. 다다는 교내에서 자신만의 원형의 산책로를 가지고 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/945f62f4-b2eb-4690-bf87-811a2e97ee77/" style="width: 347.5px; height: 277.5px;"></p>

<p>다다는 원형의 산책로를<em> N</em> (1 ≤ <em>N</em> ≤ 2,000,000)개의 칸으로 구분하고 1번부터 <em>N</em>번 까지 번호를 매겼고, 한 개의 칸 혹은 연속된 여러 칸을<em> M</em> (1 ≤ <em>M</em> ≤ 1,000,000)개의 영역으로 지정했으며, 1번부터 <em>M</em>번까지 번호를 매겼다. 한 영역은 꽃밭, 건물 등 학교에서의 한 장소나 시설을 의미한다. 1번 칸은 무조건 1번 영역에 속하고 어떤 영역에도 속하지 않는 칸은 없다. 칸과 영역의 번호는 시계방향으로 순서대로 매겨지며, 다다의 이동 방향도 시계방향으로만 움직인다.</p>

<p>영역은 겹치지 않으며, 각 영역마다 도토리를 저장해 두었다.</p>

<p>겨울이 오기 전 산책로를 따라 걸으며 어떤 영역에 포함되는 칸을 지나면 그 영역에 저장된 도토리의 수량을 합하며 점검하고, 산책 중에 학생들에게 받은 도토리들을 저장하려고 한다. 겨울잠이 끝나고 다람쥐 다다가 눈을 뜰 수 있도록 다다를 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 두 정수 산책로의 칸수 <em>N</em>, 영역 수 <em>M</em>이 주어진다.</p>

<p>두 번째 줄부터 <em>M</em>개의 줄에 세 개의 정수 <em>a</em> (1 ≤ <em>a</em> ≤ N), <em>b</em> (1 ≤ <em>b</em> ≤ N), <em>c</em> (0 ≤ <em>c</em> ≤ 100,000)가 주어지고 영역의 시작 칸의 번호, 끝 칸의 번호, 그 영역에 저장되어있는 도토리의 개수를 뜻한다. 1번 영역부터 순서대로 입력이 주어진다.</p>

<p>이어서 <em>M</em>+2번째 줄부터 다다의 작업들이 주어지는데, 3개의 정수 혹은 4개의 정수가 주어진다.</p>

<p>첫 번째 정수가 1인 경우는 이어서 <em>x</em> (1 ≤ <em>x</em> ≤ N), <em>y</em> (1 ≤ <em>y</em> ≤ N)가 2인 경우에는 이어서 <em>x, y, z</em> (1 ≤ <em>z</em> ≤ 1,000,000)가 입력으로 주어진다.&nbsp;<em>x</em>는 산책을 시작하는 칸 번호, <em>y</em>는 산책을 종료하는 칸 번호, <em>z</em>는 추가로 저장할 도토리의 개수를 의미한다.</p>

<p>0 0 0을 입력받은 경우는 작업입력을 종료한다.</p>

<p>첫 번째 정수가 1인 경우 다다가 <em>x</em>번째 칸부터 <em>y</em>번째 칸까지 산책하며 지나가는 영역에 저장된 도토리 개수를 점검하는 작업이고, 첫 번째 정수가 2인 경우 다다가 학생들에게 받은 도토리를 <em>x</em>번째 칸부터 <em>y</em>번째 칸에 해당하는 영역들에 <em>z</em>개씩 저장하는 작업을 의미한다.</p>

<p>주어지는 <em>x</em>는 <em>y</em>보다 큰 경우도 존재한다. 다다는 시계방향으로만 산책을 하기 때문에 <em>x</em>가 <em>y</em>보다 큰 경우 <em>x</em> ? <em>x</em>+1 ? … ? <em>N</em> ? 1 ? 2 ? … ?<em> y</em> 의 순서로 칸을 이동하는 점을 유의하라</p>

<p>작업의 개수는 200,000 개를 넘지 않으며, 한 번의 작업에서 한 영역을 두 번 방문하는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>다다의 작업입력 중 첫 번째 정수가 1인 경우 이어 입력받은 <em>x</em>부터 <em>y</em>칸에 해당하는 영역에 저장된 도토리 개수의 합을 출력한다. 모든 값의 범위는 2<sup>63</sup>보다 작다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12 6
1 2 1
3 3 1
4 5 1
6 8 1
9 11 1
12 12 1
1 1 2
2 1 2 2
1 1 2
1 3 1
2 3 3 2
1 3 1
0 0 0
','1
3
8
10
','DATA_STRUCTURE'),
                                                                                                                (7840,'BAEKJOON','https://www.acmicpc.net/problem/18157',18157,'수열과 쿼리 36','1초','512 MB',26,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 수열의 모든 수는 1 이상 N 이하이며&nbsp;서로 다르다.&nbsp;이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>l r</code>: l ≤ x ≤ y ≤ r 이며, $(max_{i=x}^{y} A_i) - (min_{i=x}^{y} A_i) = y - x$ 를 만족하는 $(x, y)$ 정수 쌍의 개수를 출력하라.&nbsp;</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 120,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 모든 수는 서로 다르다. (1&nbsp;≤ A<sub>i</sub>&nbsp;≤&nbsp;N)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 120,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ l&nbsp;≤ r&nbsp;≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<section id="output">
<section id="output">
<p>쿼리의 결과를 한 줄에 하나씩 출력한다.</p>
</section>
</section>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 3 2 5 4
5
1 1
1 2
1 3
1 4
1 5
','1
2
5
6
10
','DATA_STRUCTURE'),
                                                                                                                (7846,'BAEKJOON','https://www.acmicpc.net/problem/18189',18189,'참 어려운 문제','2초(추가시간없음)','512 MB',22,'<p><em>N</em>개의 정점으로 이루어진 루트 있는 트리가 있다. 모든 정점에는 1번부터 <em>N</em>번까지 번호가 붙어있다. 또한 <em>i</em>번 정점은 <em>A<sub>i</sub></em>번 색으로 칠해져 있다(1 ≤ <em>i</em> ≤ <em>N</em>).</p>

<p>이 트리에는 아주 특이한 성질이 있다. 색깔이 같은 두 정점을 고르면, 이 둘은 항상 조상-자식 관계가 아니다.</p>

<p>교준이는 이 트리의 구조는 알지만, 루트가 어떤 정점인지는 알지 못한다. 루트가 될 수 있는 정점을 모두 찾는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정점의 개수를 의미하는 자연수 <em>N</em>이 주어진다.</p>

<p>두번째 줄에 정점의 색을 의미하는 <em>N</em>개의 자연수 <em>A</em><sub>1</sub>, ···, <em>A<sub>N</sub></em>가 사이에 공백을 두고 주어진다.</p>

<p>세번째 줄부터 (<em>N</em>-1)개의 줄에 걸쳐, (<em>N</em>-1)개의 간선의 정보가 주어진다. (<em>i</em>+2)번째 줄에는 <em>i</em>번째 간선의 정보를 나타내는 두 자연수 <em>B<sub>i</sub></em>와 <em>C<sub>i</sub></em>가 사이에 공백을 두고 주어진다(1 ≤&nbsp;<em>i</em> < <em>N</em>).</p>

<p><em>i</em>번째 간선은 <em>B<sub>i</sub></em>번 정점과 <em>C<sub>i</sub></em>번 정점을 서로 연결한다(1 ≤&nbsp;<em>i</em> < <em>N</em>).</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 루트가 될 수 있는 정점의 개수를 출력한다.</p>

<p>두번째 줄에 루트가 될 수 있는 정점의 번호의 합을 출력한다.</p>

<p>세번째 줄에 루트가 될 수 있는 정점의 번호의 제곱의 합을 출력한다.</p>

<p>어떠한 정점도 루트가 될 수 없다면, 이들의 값은 전부 0임에 유의하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
3 2 4 1 4 3
1 2
2 3
2 5
2 6
3 4
','1
2
4
','DATA_STRUCTURE'),
                                                                                                                (7848,'BAEKJOON','https://www.acmicpc.net/problem/18196',18196,'정기 모임','2초(추가시간없음)','512 MB',21,'<p>정점이 <em>N</em>개인 트리가 주어진다. 각 정점은 1번부터 <em>N</em>번까지 차례대로 번호가 부여되어 있다. <em>i</em>번째 간선은 <em>A<sub>i</sub></em>번 정점과 <em>B<sub>i</sub></em>번 정점을 연결하며, 가중치는 <em>C<sub>i</sub></em>다(1 ≤ <em>i</em> < <em>N</em>).</p>

<p>트리에서 두 정점 사이의 거리는 그 둘을 잇는 최단경로 상의 간선의 가중치의 최댓값으로 정의한다. 단, 같은 두 정점 사이의 거리는 0으로 정의한다.</p>

<p>트리에 사는 사람들이 <em>Q</em>개의 모임을 개최하려 한다.&nbsp;<em>i</em>번째 모임에는 <em>S<sub>i</sub></em>&nbsp;이상 <em>E<sub>i</sub></em>&nbsp;이하의 번호를 가진 정점에 사는 사람들이 참석한다. 각 모임은 트리 상의 어떤 정점 <em>v</em>에서 이루어진다. 사람들이 모이는 정점 <em>v</em>를 잘 정하여, 모임에 참석하는 각 사람이 정점 <em>v</em>까지 이동하는 거리의 최댓값을 최소화하고자 한다.</p>

<p>이때 이 최솟값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 트리의 정점 개수를 의미하는 자연수 <em>N</em>과 모임이 개최되는 횟수를 의미하는 자연수 <em>Q</em>가 사이에 공백을 두고 주어진다.</p>

<p>두번째 줄부터 (<em>N</em>-1)개의 줄에 걸쳐, 트리의 간선에 관한 정보가 주어진다. (<em>i</em>+1)번째 줄에는 세 개의 자연수 <em>A<sub>i</sub></em>, <em>B<sub>i</sub></em>, <em>C<sub>i</sub></em>가 사이에 공백을 두고 주어진다(1 ≤ <em>i</em> < <em>N</em>). 이는 <em>A<sub>i</sub></em>번 정점과 <em>B<sub>i</sub></em>번 정점을 연결하는 가중치 <em>C<sub>i</sub></em>의 간선이 존재함을 의미한다.</p>

<p>(<em>N</em>+1)번째 줄부터 <em>Q</em>개의 줄에 걸쳐, <em>Q</em>개의 모임에 관한 정보가 주어진다. (<em>N</em>+<em>i</em>)번째 줄에는 <em>i</em>번째 모임을 나타내는 두 개의 자연수 <em>S<sub>i</sub></em>와 <em>E<sub>i</sub></em>가 사이에 공백을 두고 주어진다(1 ≤ <em>i</em> ≤&nbsp;<em>Q</em>).</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄부터 <em>Q</em>개의 줄에 걸쳐, 답을 차례대로 출력한다. <em>i</em>번째 줄에는 <em>i</em>번째 모임에 대한 답을 출력한다(1 ≤ <em>i</em> ≤&nbsp;<em>Q</em>).</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
1 2 1
2 3 2
1 2
2 3
1 3
','1
2
2
','DATA_STRUCTURE'),
                                                                                                                (7854,'BAEKJOON','https://www.acmicpc.net/problem/18227',18227,'성대나라의 물탱크','1초','256 MB',18,'<p>성대나라에는 각 도시별로 가뭄을 대비하기 위한 물탱크가 하나씩 존재한다. 이 물탱크들은 모두 연결되어있으며, 루트(성대나라의 수도)가 있는 트리의 형태를 가진다.<br>
지금 성대나라는 물탱크의 물을 사용하여 가뭄을 버텨냈으나, 그 영향으로 모든 물탱크에 물이 비어버리고 말았다.</p>

<p>성대나라의 물관리 시스템은 다소 특수해서, 물은 항상 다음과 같은 방식으로 채워진다:</p>

<p style="text-align: center;">A번 도시에 물을 채우기로 했다면, 수도에서부터 A번 도시까지 잇는 직선 경로에<br>
수도부터 차례대로 1L, 2L, ?이 채워져서 A번 도시에는&nbsp;(수도부터 A번&nbsp;도시까지의 도시 수) L 만큼 추가된다.</p>

<p>예를 들어, 아래 그림과 같이 물탱크가 연결되어 있을 때, "4번 도시에 물을 채운다"라고 하면, 1번 도시에 1L, 4번 도시에 2L의 물이&nbsp;추가된다. 만약&nbsp;"5번 도시에 물을 채운다"라고 하면 1번 도시에 1L, 2번 도시에 2L, 5번 도시에 3L의 물이&nbsp;추가된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/fec2163d-bb74-46cd-b0eb-dad3b005ea12/-/crop/596x510/38,52/-/preview/" style="height: 281px; width: 328px;"></p>

<p>성대나라의 물탱크 관리 담당인 균관이는 어느 도시에 몇 리터의 물이 저장되어있는지 자신이 궁금해질 때마다 알기를 원한다. 균관이를 도와주는 프로그램을 만들어보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 성대나라의 도시의 수 <em>N&nbsp;</em>(1 ≤ <em>N</em> ≤ 200,000)과 수도의 번호 <em>C&nbsp;</em>(1 ≤ <em>C&nbsp;</em>≤&nbsp;<em>N</em>)가 공백으로 구분되어 주어진다.</p>

<p>둘째 줄부터 <em>N</em>-1개의 줄에 연결되어있는 두 도시의 번호 쌍 <em>x</em>, <em>y</em>가 공백으로 구분되어 주어진다(1 ≤ <em>x</em>,&nbsp;<em>y&nbsp;</em>≤ <em>N</em>, <em>x&nbsp;</em>≠&nbsp;<em>y</em>). 물탱크의 연결 형태는 트리 구조임이 보장된다.&nbsp;<em>N</em>+1번째 줄에 질의의 수 <em>Q</em>(1 ≤ <em>Q&nbsp;</em>≤&nbsp;200,000)가 주어진다.&nbsp;<em>N</em>+2번째 줄부터 <em>Q</em>개의 줄에 질의가 들어온다. 질의는 다음과 같이 두 종류 중 하나로 주어진다:</p>

<ul>
	<li>1 <em>A</em> :&nbsp;<em>A</em>도시에 물을 채운다.</li>
	<li>2 <em>A</em>&nbsp;: 현재 <em>A</em>도시에 얼마만큼의 물이 채워져 있는지 출력하라.</li>
</ul>

<p>두 경우 모두 1 ≤ <em>A</em> ≤ <em>N&nbsp;&nbsp;</em>을 만족한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2로 시작하는 질의가 올 때 마다 그 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 1
1 2
1 3
1 4
2 5
4 6
4 7
8
1 6
2 1
2 4
2 6
1 1
2 1
2 4
2 6
','1
2
3
2
2
3
','DATA_STRUCTURE'),
                                                                                                                (7857,'BAEKJOON','https://www.acmicpc.net/problem/18246',18246,'색종이와 쿼리','1초','512 MB',20,'<p>2차원 좌표평면상에 각 변이 좌표축과 평행한 직사각형 모양의 색종이 N장이 있다.</p>

<p>(y1, x1, y2, x2)를 (y1, x1)은 직사각형의 왼쪽 아래 좌표, (y2, x2)은 직사각형의 오른쪽 위 좌표를 뜻하는 직사각형의 내부 영역이라 정의한다.</p>

<p>아래는 (2, 0, 5, 8), (0, 1, 6, 3), (1, 2, 4, 5), (3, 4, 7, 7)에 각각 한 장씩, 총 네 장의 색종이가 2차원 좌표평면에 놓여진 경우의 예시이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/b7200ed0-029e-47bf-8f89-7e265caf228f/-/preview/" style="height: 295.833px; width: 333.333px;"><br>
&nbsp;</p>

<p>이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li>y<sub>1</sub>&nbsp;x<sub>1</sub>&nbsp;y<sub>2</sub>&nbsp;x<sub>2</sub> : (y<sub>1</sub>, x<sub>1,&nbsp;</sub>y<sub>2</sub>, x<sub>2</sub>)에서 색종이가 가장 많이 겹쳐 있는 영역에 놓여 있는 색종이의 장 수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 색종이의 장수 N과&nbsp;쿼리의 개수&nbsp;M이&nbsp;주어진다.&nbsp;(1 ≤ N, M&nbsp;≤ 100,000)</p>

<p>다음 N개의 줄에는 색종이가 놓여진 영역&nbsp;(y<sub>1</sub>, x<sub>1</sub>, y<sub>2</sub>, x<sub>2</sub>)가 한 줄에 하나씩 주어진다.&nbsp;(0&nbsp;≤&nbsp;y<sub>1</sub>&nbsp;< y<sub>2</sub>&nbsp;≤ 1,500, 0&nbsp;≤ x<sub>1</sub>&nbsp;<&nbsp;x<sub>2</sub>&nbsp;≤ 1,500)</p>

<p>다음 M개의 줄에는 쿼리&nbsp;y<sub>1</sub>, x<sub>1</sub>, y<sub>2</sub>, x<sub>2</sub>가 한 줄에 하나씩 주어진다.&nbsp;(0&nbsp;≤&nbsp;y<sub>1</sub>&nbsp;<&nbsp;y<sub>2</sub>&nbsp;≤ 1,500, 0&nbsp;≤ x<sub>1</sub>&nbsp;<&nbsp;x<sub>2</sub>&nbsp;≤ 1,500)</p>

<p>주어지는 좌표는 모두 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리를 수행한 결과를&nbsp;한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 5
2 0 5 8
0 1 6 3
1 2 4 5
3 4 7 7
2 3 4 5
4 0 6 6
0 3 2 5
1 0 5 3
6 1 7 4
','3
2
1
3
0
','DATA_STRUCTURE'),
                                                                                                                (7856,'BAEKJOON','https://www.acmicpc.net/problem/18254',18254,'쿼리와 쿼리','2.5초','1024 MB',26,'<p>크기가 <em>N</em>인 배열 A[1], A[2], ... A[N]이 주어진다. 이 배열에 다음 업데이트 연산을 <em>M</em>번 시행할 것이다. 단, ^는 Bitwise XOR 연산이다.</p>

<ul>
	<li><em>l r x</em> : <em>l</em> ≤ <em>i </em>≤ <em>r</em>인 모든 A[i]에 A[i]=A[i]^<em>x</em>를 실행한다.</li>
</ul>

<p>여기에 다음 쿼리를 해결하는 프로그램을 작성하시오.</p>

<ul>
	<li>1 <em>L R v</em> : <em>L</em> ≤ i ≤ <em>R</em>인 모든 i에 대해 x<sub>i</sub>=x<sub>i</sub>^<em>v</em>를 실행한다. 여기서 x<sub>i</sub>는 i번째 업데이트에서의 <em>x</em>값이다.</li>
	<li>2 <em>s e</em> : <em>M</em>개의 업데이트 연산을 시행 후의 배열에서 A[<em>s</em>]^A[<em>s</em>+1]^...^A[<em>e</em>]의 값을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 <em>N M Q</em>가 공백으로 구분하여 순서대로 주어진다.(1 ≤ <em>N</em>, <em>M</em>, <em>Q</em> ≤ 10<sup>5</sup>)</p>

<p>둘째 줄에 A[1]부터 A[<em>N</em>]까지 공백으로 구분하여 순서대로 주어진다. (0 ≤ A[i] ≤ 10<sup>9</sup>)</p>

<p>다음 <em>M</em>개의 줄에 업데이트 연산을 의미하는 세 개의 정수 <em>l r x</em>가 순서대로 주어진다. (1 ≤&nbsp;<em>l</em> ≤&nbsp;<em>r</em> ≤&nbsp;<em>N</em>, 0 ≤&nbsp;<em>x</em> ≤&nbsp;10<sup>9</sup> )</p>

<p>다음 <em>Q</em>개의 줄에 쿼리가 주어진다. 각 쿼리는 1 <em>L R v</em> 또는 2 <em>s e</em> 중 한 가지이다. (1 ≤&nbsp;<em>L</em> ≤&nbsp;<em>R</em> ≤&nbsp;<em>M</em>, 0 ≤&nbsp;<em>v</em> ≤&nbsp;10<sup>9</sup>, 1 ≤&nbsp;<em>s</em> ≤&nbsp;<em>e</em> ≤&nbsp;<em>N</em>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리가 주어질 때마다 각 줄에 정답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9 8 9
22 2 20 6 20 3 22 28 7
6 9 11
3 6 9
3 4 14
4 9 30
2 4 30
2 7 22
4 7 5
1 7 29
2 2 9
2 4 5
1 5 6 2
1 1 8 22
2 2 4
2 1 3
2 4 6
1 4 5 7
2 1 3
','20
2
8
12
19
12
','DATA_STRUCTURE'),
                                                                                                                (7859,'BAEKJOON','https://www.acmicpc.net/problem/18258',18258,'큐 2','1초(하단참고)','512 MB',7,'<p>정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.</p>

<p>명령은 총 여섯 가지이다.</p>

<ul>
	<li>push X: 정수 X를 큐에 넣는 연산이다.</li>
	<li>pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
	<li>size: 큐에 들어있는 정수의 개수를 출력한다.</li>
	<li>empty: 큐가 비어있으면 1, 아니면 0을 출력한다.</li>
	<li>front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
	<li>back: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 2,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','15
push 1
push 2
front
back
size
empty
pop
pop
pop
size
empty
pop
push 3
empty
front
','1
2
2
0
1
2
-1
0
1
-1
0
3
','DATA_STRUCTURE'),
                                                                                                                (7876,'BAEKJOON','https://www.acmicpc.net/problem/18342',18342,'순례의 시작','3초','1024 MB',24,'<p>그는 드디어 순례자가 되기로 결심했고, 이제 조금씩 순례의 시작을 위한 준비를 하며 성물을 모으고 있다. 왜냐하면, 신께서 이르시길, 순례자는 순례 도중에 반드시 서로 다른 <strong>여덟&nbsp;</strong>개의 성물을 지니고 있어야 하기 때문이다.</p>

<p>성물에는 신의 힘이 깃들어 있어 순례 도중에 순례자가 지치지 않게 도와주지만, 그 자체에 무게가 있어 너무 무거우면 지니고 다니기 힘들다. 그래서, 선택한 여덟 성물에 깃든 신의 힘을 각각 $P_1, P_2, \cdots, P_8$이라고 하고, 무게를 각각 $W_1, W_2, \cdots, W_8$이라고 하면 $\frac{P_1+P_2+\cdots+P_8}{W_1+W_2+\cdots+W_8}$정도 순례가 편해진다.</p>

<p>그가 모은 성물이 모은 순서대로 주어질 때, 가진 성물이 하나씩 추가될 때마다, 가지고 있는 성물 중에서 정확히 여덟 개의 성물을 골랐을 때, 순례가 편해지는 정도의 최댓값을 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에, 모은 성물의 개수를 의미하는 자연수 $N$이 주어진다.</p>

<p>다음 $N$ 개의 줄의 $i$ 번째 줄에, $i$ 번째로 모은 성물에 깃든 힘을 나타내는 자연수 $p_i$와 무게를 나타내는 자연수 $w_i$ ($1 \leq p_i, w_i \leq 10^6$)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$N-7$ 개의 줄에 걸쳐 답을 출력한다. $i$ 번째 줄에는 $i+7$ 개의 성물을 모은 시점에 여덟 개의 성물을 골랐을 때, 순례가 편해지는 정도의 최댓값을 출력한다. 정답과의 절대오차 혹은 상대오차가 $10^{-9}$이하면 정답으로 인정한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 1
1 1
1 1
1 1
1 1
1 1
1 1
1 1
9 1
1 2
','1.0
2.0
2.0
','DATA_STRUCTURE'),
                                                                                                                (7874,'BAEKJOON','https://www.acmicpc.net/problem/18343',18343,'신탁','3초','1024 MB',25,'<p><strong>신탁</strong>이란 신이 자신의 의지를 순례자에게 전달하려는 것이고, 그렇기에 신탁을 이해하는 것은 순례자들의 기본 소양이다.</p>

<p>신탁을 이루는 <strong>문자</strong>는 <code>1</code>에서 <code>88888888&nbsp;</code>사이에 있는 <code>88888888</code>가지 정수다. 즉, <code>123</code>도 하나의 문자가 되고, <code>88888888</code>도 하나의 문자가 된다. 하나의 문자는 하나의 뜻을 가지고 있다.</p>

<p>신탁은 홀수개 문자의 나열이다. 신탁을&nbsp;<strong>해석하는 방법</strong>은 신탁에&nbsp;<strong>변환</strong>을 거듭해서 단 하나의 문자만 남기는 것이고, 남겨진 문자가 신탁의 뜻이 된다. 신탁을 변환하는 순서에 따라 마지막에 남는 문자의 종류가 달라질 수 있기 때문에, 신탁은 여러 뜻을 가질 수 있다.</p>

<p>신탁을 변환하는 법은 다음과 같다.</p>

<ol>
	<li>연속된 홀수개의 문자를 선택하고 신탁에서 지운다.</li>
	<li>선택된 문자들을 그 문자를 나타내는 정수를 감소하지 않는 순으로&nbsp;정렬했을 때 가장 가운데에 오는 문자를 구한다.</li>
	<li>1번 단계에서 문자들이 지워진 위치에 2번 단계에서 구한 문자를 다시 집어넣는다.</li>
</ol>

<p>예를 들어, <code>[3,3,1,1,2,1,1]</code>이라는 신탁이 있다고 하자. 이 신탁을 읽는 예를 들어 보면,</p>

<ul>
	<li><code>[<strong>3,3,1,1,2,1,1</strong>]</code> $\rightarrow$ <code>[1]</code></li>
	<li><code>[3,3,<strong>1,1,2,1,1</strong>]</code> $\rightarrow$ <code>[<strong>3,3,1</strong>]</code> $\rightarrow$ <code>[3]</code></li>
</ul>

<p>등이 방법이 있다. 그리고 놀랍게도 이 신탁을 2로 해석하는 방법은 존재하지 않는다. 그래서, <code>[3,3,1,1,2,1,1]</code>라는 신탁은 <code>1</code> 또는 <code>3</code>으로 해석될 수 있다.&nbsp;주어진 신탁이 어떤 뜻으로 해석될 수 있는지 모두 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에, 신탁의 개수를 나타내는 자연수 $T$가 주어진다.</p>

<p>그다음 줄부터 각 신탁마다 두 개의 줄이 입력으로 주어진다:</p>

<p>첫 번째 줄에, 신탁의 길이를 나타내는 자연수 $N$이 주어진다.</p>

<p>두 번째 줄에, 신탁의 구성을 나타내는 $N$ 개의 정수 $c_1, c_2, \cdots, c_N$ ($1\leq c_i \leq 88\ 888\ 888$)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$T$ 개의 신탁 각각에 대해 두 개의 줄을 출력한다:</p>

<p>주어진 신탁이 $K$ 종류의 문자로 해석될 수 있다면, 첫 번째 줄에 $K$를 출력한다.</p>

<p>해석 결과로 가능한 서로 다른 $K$ 개의 문자를 정수의 오름차순으로 $C_1, C_2, \cdots, C_K$라고 할 때, 두 번째 줄에 $C_1, C_2, \cdots, C_K$를 공백으로 구분하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
7
3 3 1 1 2 1 1
','2
1 3
','DATA_STRUCTURE'),
                                                                                                                (7882,'BAEKJOON','https://www.acmicpc.net/problem/18372',18372,'트리와 쿼리 14','5초','1024 MB',26,'<p>N개의 정점으로 이루어진 트리가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있다. 간선의 가중치는 모두 1이다.</p>

<p>아래의&nbsp;쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><font face="monospace">k v<sub>1</sub> r<sub>1</sub> v<sub>2</sub> r<sub>2</sub> ... v<sub>k</sub> r<sub>k</sub></font>: 어떠한 정점 x가 v<sub>i</sub>와 거리 r<sub>i</sub> 이내에 있다면 (거리가 r<sub>i</sub>보다 작거나 같다면), x가 i번 조건을 만족한다고 하자. 트리에 있는 모든 정점들 중, 쿼리로 주어진 k개 조건 중 k-1개 이상의 조건을 만족하는 정점의 개수를 출력하라.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정수 N이 주어진다. (1 ≤ N&nbsp;≤ 100,000)</p>

<p>이후 N-1개의 줄에는 각 간선이 연결하는 두 정점 번호 u,&nbsp;v가 주어진다. (1 ≤ u, v ≤ N)</p>

<p>다음 줄에 정수 M이 주어진다.&nbsp;(1 ≤ M&nbsp;≤ 300,000)</p>

<p>이후 M개의 줄에 위에서 설명한 것과 같은 쿼리가 주어진다. 각 쿼리는 지문과&nbsp;다르게 한 줄에 들어오지 않으며, k + 1개의 줄로 분리되어 주어진다. 예제 입력을 참고하라. (1 ≤ v<sub>i</sub> ≤ N, 0 ≤ r<sub>i </sub>< N, 1 ≤ k)</p>

<p>쿼리로 주어지는 k의 합은 300000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 3
6 4
9 8
1 8
3 4
2 8
10 3
4 5
8 7
2
3
8 1
3 1
3 2
2
7 3
6 0
','5
7
','DATA_STRUCTURE'),
                                                                                                                (7885,'BAEKJOON','https://www.acmicpc.net/problem/18376',18376,'트리와 K번째 지름','3초(추가시간없음)','1024 MB',24,'<p>오늘 알고리즘 과목의 중간고사가 있는&nbsp;메시는 시험장에 들어서자마자 감독관에게 가중치 없는 트리를 받았다. 각각의 정점은 거리 1의 간선으로 연결되어 있으며, 임의의 두 정점 사이의 최단 경로가 유일하게 존재한다. i번 정점에 쓰여있는&nbsp;정수를 J<sub>i</sub>라고 할 때, J<sub>i</sub> = i이다.&nbsp;곧이어 들어온 이메이미&nbsp;교수가 칠판에 다음과 같은 시험 문제를 적기 시작했다.</p>

<p>"트리의 s번 정점에서 출발하여 e번 정점에&nbsp;도착하는&nbsp;최단 경로를 10<sup>9</sup>&nbsp;×&nbsp;J<sub>s</sub> + J<sub>e</sub>라는 수로 인코딩할 때, 주어진 트리에서 가장 긴 최단경로 (트리의 지름) 중 인코딩된 수가&nbsp;K번째로 작은&nbsp;것을 구하여라. 단, 인코딩된 수가 다르면 다른 지름으로 취급한다"</p>

<p>메시는 문제를 여기까지만 듣고 트리의 모든 지름을 O(N<sup>2</sup>)의 시간복잡도에 구하는 알고리즘을 짰다. 트리의 정점 수가 좀 많았지만 시험 시간은 48시간이기 때문에 아무런 문제가 되지 않았다. 메시는 지루한 기분을 달래기 위해 테트리스를 하기 시작했다.</p>

<p>하지만 이메이미&nbsp;교수의 시험이 호락호락할 리가 없다! 이메이미&nbsp;교수는 메시가 테트리스를 켠 것을 확인한 뒤&nbsp;학생들의 화면에 queries.txt를 전송하고는 다음과 같이 말했다.</p>

<p>"설마 위 문제를 해결하지 못한 학생은 없겠죠? queries.txt에는 Q줄에 걸쳐 쿼리 u v L이 주어집니다. 각 쿼리마다 J<sub>u</sub>와 J<sub>v</sub>를 서로 바꾼 뒤 마찬가지로 인코딩한 수가 L번째로 작은 지름을 구하세요."</p>

<p>메시는 황급히 테트리스를 끄고&nbsp;문제를 해결하려고 했지만 머릿속에 기록 경신을 코앞에 둔 테트리스만&nbsp;생각나 집중할 수가 없었다.&nbsp;메시가 이 수업을 드랍하지 않게 하기&nbsp;위해 이 문제를 대신 해결해 주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>1번째 줄에는 트리의 정점 수 N, 쿼리의 수 Q가 공백으로 구분되어 주어진다.</p>

<p>2번째 줄부터 N - 1개의 줄에 걸쳐 트리의&nbsp;간선이 연결하는 두 정점의 번호 a, b가 공백으로 구분되어 주어진다.</p>

<p>N + 1번째 줄에는 K가 주어진다. 이는 처음 주어진 트리에서 K번째로 작은 지름을 구해야 한다는 것을 의미한다.</p>

<p>N + 2번째 줄부터 Q개의 줄에 걸쳐 쿼리 u, v, L이 공백으로 구분되어 주어진다. 이는 J<sub>u</sub>와 J<sub>v</sub>를 바꾼 뒤 L번째로 작은 지름을 구해야 한다는 것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>지름을 구하라는 쿼리가 들어올 때마다 지름을 인코딩한 수를 한 줄에 하나씩 출력한다. 조건을 만족하는 지름이 존재하지 않을 경우 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 1
1 2
1 3
1 4
1
1 2 1
','2000000003
1000000003
','DATA_STRUCTURE'),
                                                                                                                (7886,'BAEKJOON','https://www.acmicpc.net/problem/18377',18377,'은광','1초(추가시간없음)','1024 MB',23,'<p>은의 땅이라는 별명을 가진 나라가 있다. 이 나라에는 개발되지 않은 많은 은광들이 존재한다 믿어지고 있다. 특이하게도 이 나라에 은광이 존재할 수 있는 점들은 x좌표와 y좌표가 1&nbsp;이상 N&nbsp;이하인 N × N개의 격자점이다.</p>

<p>사실 이 나라에는 원래 은광이 하나도 없었다고 한다. 이를 딱하게 여긴 마법사 메시는 마법을 써서 이 나라에 은광을 만들어주기로 했다. 메시가 사용하는 마법은 두 종류이다. 하나는 x좌표가 같은 N개의 점들 중 은광이 있던 점들의 은광을 없애고 없던 점들에 은광을 만드는 것이고, 다른 하나는 y좌표가 같은 N개의 점들에 대해 같은 방법으로 상태를 반전시키는 것이다.</p>

<p>은광 개발업자는 x축 또는 y축과 평행한 변들을 가진 (K - 1)&nbsp;× (K - 1)&nbsp;정사각형 모양의 땅 R을 사서 R에 포함된 은광들을 모두 개발할 것이다. R의 꼭짓점의 x좌표와 y좌표는 1&nbsp;이상 N&nbsp;이하의 정수여야 하며.&nbsp;이때 은광들을 개발하여 얻게 되는 개발 이익은 R 내부나 경계에 있는 은광의 개수이다.&nbsp;개발업자는 R에 포함된 은광들의 개발 이익이 최대가 되는 영역 R을 모두 찾을 것이다.</p>

<p>메시의 마법으로 땅의 상태가 바뀔 때마다 (K - 1) × (K - 1)&nbsp;정사각형 모양의 땅을 사서 얻을 수 되는 최대 개발 이익과, 최대 개발 이익을 얻을 수 있는 방법의 수를 알아내어 은 재벌이 되어보자!</p>

<p>0&nbsp;×&nbsp;0&nbsp;정사각형 모양의 땅을 사면, 격자점 1개의 은광을 개발할 수 있음에 유의하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>1번째 줄에 나라의 크기 N,&nbsp;살 수 있는 땅의 크기 K, 메시가 마법을 사용하는 횟수 Q가&nbsp;공백으로 구분되어&nbsp;주어진다.</p>

<p>2번째 줄부터 Q개의 줄에 걸쳐 메시가 사용하는 마법에 대한 정보 a, b가 공백으로 구분되어&nbsp;주어진다. a = 1이면 x좌표가 b인 격자점들의 상태가 반전되고, a = 2이면 y좌표가 b인 격자점들의 상태가 반전된다. (1 ≤ a ≤ 2, 1&nbsp;≤&nbsp;b ≤&nbsp;N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p class="0">메시가 마법을 사용할 때마다 한&nbsp;줄에 개발할 수 있는 은광의 최대 개수와 그&nbsp;방법의 수를 공백으로 구분하여&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 2 2
1 1
2 1
','2 2
2 3
','DATA_STRUCTURE'),
                                                                                                                (7887,'BAEKJOON','https://www.acmicpc.net/problem/18378',18378,'SUN인장 분자 만들기','5초(추가시간없음)','1024 MB',28,'<p>화학과 대학원생 탐레프는 S, U, N 원자로 이루어진 분자를 만드려고 한다. 레프는 이미 분자 구조를 결정했다. 레프의 분자 구조는 원자를 정점으로 하고, 두 원자의 결합을 간선으로 했을 때 특이한 선인장 그래프를 이룬다. 특이한 선인장 그래프란, 모든 <strong>정점</strong>이 하나 이하의 단순 사이클에만 포함되는 그래프를 말한다.</p>

<p>아직 레프는 어떤 위치에 어떤 원자를 채울지 결정하지 않았다. 레프는 같은 종류의 두 원자를 결합시키는 방법을 모르기 때문에 결합된 두 원자가 같은 종류이면 안 된다. 각각의 위치에 S, U, N 원자를 두기 위해&nbsp;필요한 에너지가 각각 주어질 때, 레프는 가장 안정한 분자를 만드려고 한다. 가장 안정한 분자는 모든 위치에 대해 필요한 에너지의 합이 가장 낮은 분자를 말한다.</p>

<p>레프는 실험을 통해 어떤 위치에 어떤 원자를 두기 위해&nbsp;필요한 에너지를 계속해서 수정해나간다. 필요한 에너지가 수정될 때마다 레프에게 만들 수 있는 가장 안정한 분자를 알려주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>1번째 줄에 분자 구조 내의 원자 수 N, 결합 수 M, 레프가 실험을 하는 횟수 Q가 공백으로 구분되어 주어진다.</p>

<p>i + 1번째 줄부터 N개의 줄에 분자 구조의 i번째 위치에 S, U, N 원자를 두기 위해&nbsp;필요한 에너지 S<sub>i</sub>, U<sub>i</sub>, N<sub>i</sub>가 각각&nbsp;공백으로 구분되어 주어진다. (1 ≤&nbsp;i ≤&nbsp;N)</p>

<p>i + N + 1번째 줄부터 M개의 줄에 i번째 결합이 연결하는 두 원자 위치의&nbsp;번호가 공백으로 구분되어 주어진다. (1&nbsp;≤&nbsp;i&nbsp;≤&nbsp;M)</p>

<p>i + N + M + 1번째 줄부터 Q개의 줄에 i번째 실험의 결과를&nbsp;나타내는 두 정수 A<sub>i</sub>, B<sub>i</sub>, C<sub>i</sub>가 공백으로 구분되어 주어진다. (1&nbsp;≤&nbsp;i&nbsp;≤&nbsp;Q) 이는 A<sub>i</sub>번 위치에 B<sub>i</sub>&nbsp;원자를 두는데 필요한 에너지를 C<sub>i</sub>로 수정한다는 의미이다. 참고로 B<sub>i</sub>가 1인 경우 S, 2인 경우 U, 3인 경우 N 원자를 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q줄에 걸쳐 필요한 에너지가 수정될 때마다 만들 수 있는 가장 안정한 분자를 만드는데 필요한 에너지의 합을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 7 3
50 70 90
50 70 90
50 70 90
50 70 90
50 70 90
50 70 90
1 2
6 4
1 5
4 3
3 6
5 4
5 2
5 2 4
3 2 27
4 2 51
','354
311
311
','DATA_STRUCTURE'),
                                                                                                                (7888,'BAEKJOON','https://www.acmicpc.net/problem/18379',18379,'이메이미의 수쿼 노트','2초(추가시간없음)','1024 MB',22,'<p>이메이미는 수열과 쿼리 문제를 풀다가 로컬에서는 잘 나오는데 틀렸다고 함이라는 결과를 받고 펜과 노트로 디버깅을 하는 중이다. 이메이미는 이미 노트에 길이 N의 초기 수열을 적어 두었고, 노트에 쿼리를 하나씩 추가하며 수열을 직접 계산하려고 한다. 하나의 쿼리는 [T, L, R, V]&nbsp;4개의 수로 이루어져 있는데, T의 값은 연산의 종류를 뜻하며 아래와 같은 연산을 한다.</p>

<ul>
	<li>T = 0&nbsp;: 수열의 L번째 원소부터 R번째 원소까지 V를 더한다.</li>
	<li>T = 1&nbsp;: 수열의 L번째 원소부터 R번째 원소까지 V를 곱한다.</li>
	<li>T = 2&nbsp;: 수열의 L번째 원소부터 R번째 원소까지의 합을 출력한다.</li>
</ul>

<p>그런데 지금까지의 쿼리를 잘못 적었다는 것을 깨달은 이메이미는 충격에 빠졌다. 지금까지의 쿼리를 모두 다시 적는 것은 힘든 일이기 때문에 이메이미는 지금까지의 쿼리를 수정하는 대신 지금까지의 쿼리를 수정하는 새로운 쿼리를 적는 것으로 대신하기로 했다. T = 3을 적은 것은 지금까지 쿼리의 T를 잘못 적었다는 의미이며, 지금까지 적은 쿼리 [T, L, R, V]가 사실 [(T + V) mod 4, L, R, V]였다는 의미이다. 수정된 쿼리의 T도 3일 경우 그 앞의 쿼리들은 여러 번 수정될 수도 있지만, 수정된 쿼리의 T이 2일 경우에 그 값을 출력할 필요는 없다.</p>

<p>이메이미는 원소가 열 개가 넘는 수열을 계산하기가 힘들어서 고생하고 있다. 이메이미의 노트를 보고 대신 계산해주는 프로그램을 만들어주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>1번째 줄에는 수열의 크기&nbsp;N, 쿼리의 수 M이 공백으로 구분되어 주어진다.</p>

<p>2번째 줄에는 수열의 원소 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 공백으로 구분되어 주어진다.</p>

<p>i + 2번째 줄에는 i번째 쿼리 T<sub>i</sub>, L<sub>i</sub>, R<sub>i</sub>, V<sub>i</sub>가 공백으로 구분되어 주어진다. (1 ≤&nbsp;i&nbsp;≤&nbsp;M)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>T<sub>i</sub> = 2인 쿼리가 주어질 때마다 쿼리의 답을 998,244,353으로 나눈 나머지를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>&nbsp;문제를 엄밀하게 정의하기 위해 i번째로 들어온 쿼리를 Q<sub>i</sub> = [T<sub>i</sub>, L<sub>i</sub>, R<sub>i</sub>, V<sub>i</sub>]라고 하자. 쿼리열 Q = [Q<sub>1</sub>, Q<sub>2</sub>, ..., Q<sub>q</sub>]는 정의역과 공역이 길이 N의 수열인 함수로 정의되며, 아래와 같이 재귀적으로 정의할 수 있다.</p>

<ul>
	<li>[](A) = A</li>
	<li>$(Q+[0, L, R, V])(A)[i] = \begin{cases} Q(A)[i] + V &amp; \text{if }L\leq i\leq R \\ Q(A)[i] &amp; \text{otherwise} \end{cases}$</li>
	<li>$(Q+[1, L, R, V])(A)[i] = \begin{cases}&nbsp;Q(A)[i] \times V &amp; \text{if }L\leq i\leq R \\&nbsp;Q(A)[i] &amp; \text{otherwise} \end{cases}$</li>
	<li>Q + [2, L, R, V] = Q</li>
	<li>Q + [3, L, R, V] = [[(T<sub>1</sub> + V) mod 4, L<sub>1</sub>, R<sub>1</sub>, V<sub>1</sub>], ..., [(T<sub>q</sub> + V) mod 4, L<sub>q</sub>, R<sub>q</sub>, V<sub>q</sub>]]</li>
</ul>

<p>&nbsp;T<sub>i</sub>&nbsp;= 2인 모든 i에 대해 $\left(\sum\limits_{j=L_i}^{R_i}{[Q_1, Q_2, \cdots, Q_i](A)[j]}\right)\mod 998,244,353$를 출력하는 프로그램을 작성해야 한다.</p>

				</div>
				</div>','1 5
0
0 1 1 5
1 1 1 7
2 1 1 2
3 1 1 1
2 1 1 0
','35
7
','DATA_STRUCTURE'),
                                                                                                                (7891,'BAEKJOON','https://www.acmicpc.net/problem/18407',18407,'가로 블록 쌓기','1초','512 MB',18,'<p>가로 블록만 등장하는 테트리스 게임을 해보려고 한다. 가로 블록은 총 N개가 등장할 예정이고, 등장하는 순서대로 1, 2, ..., N번이다. i번 블록의 높이는 1이고, 너비는 W<sub>i</sub>이다. i번 블록은 왼쪽 벽으로부터 거리가 D<sub>i</sub> 떨어진 곳에 떨어뜨려야 한다. 블록을 회전시키거나, 위치를 이동시키는 것은 불가능하다.</p>

<p>블록은&nbsp;위에서부터 떨어지며, 다른 블록 또는 바닥을 만날때 까지 한 칸씩 떨어진다. N개의 블록 정보가 주어졌을 때, 블록이 쌓인 높이를 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 블록의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에 블록의 정보 W<sub>i</sub>, D<sub>i</sub>&nbsp;(1 ≤ W<sub>i</sub>, D<sub>i</sub> ≤ 1,000,000,000)가 한 줄에 하나씩 1번 블록부터 순서대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>블록이 모두 쌓인 후 높이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4 2
4 6
4 5
3 1
3 3
','3
','DATA_STRUCTURE'),
                                                                                                                (7892,'BAEKJOON','https://www.acmicpc.net/problem/18436',18436,'수열과 쿼리 37','1초','512 MB',15,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 있다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 i x</code>: A<sub>i</sub>를 x로 바꾼다.</li>
	<li><code>2 l r</code>: l ≤ i ≤ r에 속하는 모든 A<sub>i</sub>중에서 짝수의 개수를 출력한다.</li>
	<li><code>3 l r</code>: l ≤ i ≤ r에 속하는 모든 A<sub>i</sub>중에서 홀수의 개수를 출력한다.</li>
</ul>

<p>수열의 인덱스는 1부터 시작한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ i ≤ N, 1 ≤ l ≤ r ≤ N, 1 ≤ x ≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2, 3번 쿼리의 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
1 2 3 4 5 6
4
2 2 5
3 1 4
1 5 4
2 1 6
','2
2
4
','DATA_STRUCTURE'),
                                                                                                                (7893,'BAEKJOON','https://www.acmicpc.net/problem/18437',18437,'회사 문화 5','2초','512 MB',18,'<p>총 N명의 직원이 재직 중인 회사가 있고, 각 직원은 1번부터 N번까지 번호가 매겨져 있다. 이 회사는 수직적인 구조를 가지고 있고,&nbsp;대표를 제외한 모든 직원은 한 명의 직속 상사를 갖고 있다. 직속 상사의 직속 상사도 상사이고, 직속 상사의 상사도 상사이다. 따라서, 대표를 제외한 모든 직원은 한 명 이상의 상사를 가지고 있고, 한 명의 직속 상사를 갖고 있다. 상사가 없는 사람은 대표이다.</p>

<p>이 회사가 가지고 있는 문화는 아래와&nbsp;같은 쿼리로 나타낼 수 있다. 가장 처음에 컴퓨터는 켜져있는 상태이다.</p>

<ul>
	<li><code>1 i</code>: i번 직원을 상사로 가지고 있는 모든 직원은 컴퓨터를 켠다.</li>
	<li><code>2 i</code>: i번 직원을 상사로 가지고 있는 모든 직원은 컴퓨터를 끈다.</li>
	<li><code>3 i</code>: i번 직원을 상사로 가지고 있는&nbsp;직원 중에서 컴퓨터가 켜져있는 사람의 수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 직원의 수 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 각 직원의 상사 번호가 주어진다. i번째 정수는 i번 직원의 직속 상사 번호이다. 대표의 번호는 1번이고, 상사 번호로 0이 주어진다.</p>

<p>셋째 줄에 쿼리의 수 M (1 ≤ M ≤ 100,000)이 주어진다.&nbsp;</p>

<p>넷째 줄부터 M개의 줄에 쿼리가 주어진다. (1 ≤ i ≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
0 1 2
8
3 1
2 1
3 1
1 1
3 1
2 2
3 1
3 2
','2
0
2
1
0
','DATA_STRUCTURE'),
                                                                                                                (7932,'BAEKJOON','https://www.acmicpc.net/problem/18798',18798,'OR과 쿼리','1.5초','256 MB',21,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>과 음이 아닌 정수 K가 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li>
	<p><code>1 l r x</code> : 모든 l ≤ i ≤ r에 대해, A<sub>i</sub>를 A<sub>i</sub> ∨ x로 바꾼다. (단, ∨는 bitwise OR 연산이다.)</p>
	</li>
	<li>
	<p><code>2 l r</code> : A<sub>i</sub> = K를 만족하는 l ≤ i ≤ r의 개수를 출력한다.</p>
	</li>
</ul>

<p>수열의 인덱스는 1부터 시작한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 250,000), K (0 ≤ K < 2<sup>30</sup>)가 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (0 ≤ A<sub>i</sub> < 2<sup>30</sup>)</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 250,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. 2번 쿼리는 하나 이상 주어진다. (1 ≤ l ≤ r ≤ N, 0 ≤ x < 2<sup>30</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 2번 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
1 2 3 4 5
3
2 1 5
1 1 3 2
2 1 5
','1
2
','DATA_STRUCTURE'),
                                                                                                                (7933,'BAEKJOON','https://www.acmicpc.net/problem/18801',18801,'댐','1.5초','256 MB',26,'<p>직선 형태의 강에 N+1개의 댐이 있다. 가장 왼쪽 댐의 왼쪽과 가장 오른쪽 댐의 오른쪽으로는 강이 더 이상 이어지지 않기에, 댐으로 인해 강은 길이가 같은 N개의 구간으로 나뉘어져 있다. 각 구간에서 강의 수위는 서로 다를 수 있다.</p>

<p>지나친 수질오염으로 인해 당신은 N+1개의 댐 중 몇 개를 파괴하기로 결정했다. 적어도 한 개의 댐을 파괴하여야 하며, 당연하지만 양쪽 끝에 있는 댐은 파괴할 수 없다.</p>

<p>댐을 파괴하고 나면 댐 양옆에 있던 물의 수위가 같아지도록 물이 이동할 것이다. 예를 들어 N=5이고 최초에 강의 수위가 다음과 같은 수열로 표현되었다고 하자.</p>

<p style="text-align: center;">2 5 2 6 9</p>

<p>이 상태에서 두 번째, 세 번째, 다섯 번째 댐을 파괴한다면 강의 수위는 다음과 같게 변한다.</p>

<p style="text-align: center;">3 3 3 7.5 7.5</p>

<p>그러나 몇몇 댐을 파괴함으로 인해 강의 수위가 급격하게 바뀐다면 다른 댐들도 균형을 잃고 무너질 수 있다.</p>

<p>N+1개의 댐에 대해 댐이 견딜 수 있는 강의 수위의 범위가 주어진다. 만약 어떤 댐의 왼쪽 혹은 오른쪽에 오는 강의 구간의 수위가 그 댐이 견딜 수 있는 수위의 범위를 벗아난다면 그 댐은 무너질 것이다. 초기 상태에서는 모든 댐이 무너지지 않는 상태임이 보장된다.</p>

<p>양쪽 끝에 있는 댐을 제외한 적어도 한 개의 댐을 파괴하고 나서, 다른 댐은 무너지지 않게 하는 방법을 제시하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 300,000)</p>

<p>두 번째 줄에는 댐으로 인해 나뉘어진 N개의 구간에서 강의 수위를&nbsp;나타내는 수열 A가 주어진다. (1&nbsp;≤ A<sub>i</sub> ≤ 7,777,777)</p>

<p>그 뒤로 N+1개의 줄에는 각 댐의 정보가 주어진다. i번째 댐의 정보는 두 정수 l<sub>i</sub>과 u<sub>i</sub>로 표현되며 이는 그 댐이 견딜 수 있는 강의 수위가 l<sub>i</sub>이상 u<sub>i</sub>이하임을 뜻한다. (1&nbsp;≤ l<sub>i</sub>&nbsp;≤ u<sub>i</sub>&nbsp;≤ 7,777,777)</p>

<p>자연수 i (1&nbsp;≤ i&nbsp;≤ N)에 대해 l<sub>i&nbsp;</sub>≤&nbsp;h<sub>i&nbsp;</sub>≤&nbsp;u<sub>i</sub>&nbsp;이며 l<sub>i+1&nbsp;</sub>≤&nbsp;h<sub>i&nbsp;</sub>≤&nbsp;u<sub>i+1</sub>&nbsp;이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 파괴할 댐의 수 K를 출력한다. (1&nbsp;≤ K&nbsp;≤ N - 1)</p>

<p>둘째 줄에 파괴할 댐의 번호 K개를 공백으로 구분하여 출력한다. 댐의 인덱스는 0부터 시작한다. 따라서 당신이 출력해야 할 댐의 번호는 1 이상 N-1 이하이다. 댐의 번호는 모두 서로 달라야 한다.</p>

<p>만약 조건을 만족하도록 댐을 파괴하는 방법이 존재하지 않는다면 첫째 줄에 -1을 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
2 5 2 6 9
2 4
2 5
2 5
2 8
6 9
6 9
','3
1 2 4
','DATA_STRUCTURE'),
                                                                                                                (7934,'BAEKJOON','https://www.acmicpc.net/problem/18803',18803,'방역','2초','256 MB',26,'<p>설곽국은 1부터 N까지의 번호가 매겨진 N개의 도시로 이루어진 국가이다. 도시 사이에는 두 도시를 연결하는 N-1개의 도로가 존재하며 모든 도시들은 연결되어 있다. 모든 도로의 길이는 1으로 같다.</p>

<p>최근 설곽국에서는 옆나라 경곽국으로부터&nbsp;들어온 신종 바이러스가 유행하고 있다. 설곽국의 보건복지부 장관 근영이는 바이러스를 확산시키는 가장 큰 요인은 장거리 여행이라고 생각하여, 몇몇 도시를 봉쇄하고 봉쇄된 도시와 연결된 도로를 폐쇄하려고 한다.</p>

<p>근영이가 생각하기에 장거리 여행이란 이동거리가 K 이상이고 같은 도시를 두 번 이상 지나지 않는 여행을 의미한다.</p>

<p>예를 들어, K&nbsp;= 3이고 도시와 도로의&nbsp;모양이 아래 그림과 같다고 하자.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/88d3bafc-aea9-4473-934f-de63e4858bee/-/preview/" style="width: 330px; height: 330px;"></p>

<p>이 때 장거리 여행으로 가능한 경로는&nbsp;1,2,3,6번 도시를 순서대로 지나는 경로나, 5,3,6,7번 도시를 순서대로 지나는 경로 등이 있다. 물론 이 외에도 여러가지 장거리 여행의 방법이 있다.</p>

<p>만약 여기서 3번 도시를 봉쇄한다면, 같은 도시를 두 번 이상 지나지 않는 어떤 경로도 길이가 2를 넘지 않으므로 장거리 여행은 불가능해진다. 또한&nbsp;모든 도시를 봉쇄했을 때도 장거리 여행은 불가능해진다.</p>

<p>근영이는 적절한 도시들을 봉쇄하여 장거리 여행이 불가능하게 만들고 싶다. 장거리 여행이 불가능하도록 도시를 봉쇄하는 방법의 수를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 도시의 개수를 나타내는 자연수 N과 근영이가 생각하고 있는 양의 정수 K가 주어진다. (1&nbsp;≤ K&nbsp;≤ N&nbsp;≤ 300,000)</p>

<p>둘째 줄부터 N번째 줄까지는 도로의 정보를 나타내는 두 자연수 x, y (1 ≤ x, y ≤ N)가 주어진다. 이는 x번 도시와&nbsp;y번 도시를 연결하는 도로가 존재함을 의미힌다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 장거리 여행이 불가능하도록 도시를 봉쇄하는 방법의 수를&nbsp;10<sup>9</sup>+7로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 1
1 2
2 3
3 4
','8
','DATA_STRUCTURE'),
                                                                                                                (7935,'BAEKJOON','https://www.acmicpc.net/problem/18804',18804,'대안적 사실','1.5초','256 MB',27,'<p>서기 3020년, 미국 제 237대 대통령의 취임식이 열렸다. 아니, 정확히 말하자면&nbsp;대통령들의 취임식이라고 해야 할 것이다. 미국은 2884년 대선부터 N두제를 도입하여 N명의 대통령이 선출되니까 말이다. 서현이는 유명 언론사의 정치부 기자로써, 모든 취임식에 참석하여 i번째 대통령의 취임식에 참석한 사람은 A<sub>i</sub>명이라는 사실을 알아냈다.</p>

<p>이제 서현이는 이를 바탕으로 기사를 쓰려고 한다. 하지만 서현이는 기사에 적힌 내용이 꼭 사실일 필요까지는 없고, <strong>대안적 사실</strong>인 정도면 충분하다고 생각한다.</p>

<p>이 때 길이가 N인 수열 B가 A의 대안적 사실이라는 것은 다음을 의미한다.</p>

<ul>
	<li>B는 A를 임의의 순서로 섞은 수열이다. 즉, A와 B를 각각 정렬했을 때의 결과가 같다.</li>
	<li>임의의 정수 1 ≤ i&nbsp;≤ L에 대해 |A<sub>i</sub>&nbsp;- B<sub>i</sub>|&nbsp;≤ K이다. 이 때 K와 L은&nbsp;서현이가 생각하고 있는 어떤 음이 아닌 정수이다.</li>
</ul>

<p>또한 서현이는 기사에 적을 대안적 사실이 가장 <strong>위대</strong>하기를 바라고 있다. 어떤 수열 B가&nbsp;다른 수열 C보다 위대하다는 것은 두 수열이 i번째 항에서 처음으로 달라질 때 B<sub>i</sub>&nbsp;> C<sub>i</sub>임을 의미한다. 다시 말해, B가 C보다 사전순으로 뒤에 옴을 의미한다.</p>

<p>기사에 적을 내용을 고민하는 서현이를 위해 가장 위대한 대안적 사실을 찾아주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 양의 정수 N과 음이 아닌 정수 K, L이&nbsp;주어진다. (1&nbsp;≤ N&nbsp;≤ 200,000, 0&nbsp;≤ K&nbsp;≤ 10<sup>9</sup>, 0&nbsp;≤ L ≤ N)</p>

<p>둘째 줄에 길이 N의 수열 A가 공백으로 구분되어 주어진다. (1&nbsp;≤ A<sub>i</sub>&nbsp;≤ 10<sup>9</sup>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가장 수열 A의 가장 위대한 대안적 사실을 공백으로 구분하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3 5
7 6 1 9 4
','9 7 4 6 1
','DATA_STRUCTURE'),
                                                                                                                (7936,'BAEKJOON','https://www.acmicpc.net/problem/18837',18837,'가장 긴 증가하는 부분 수열 K','0.25초','512 MB',23,'<p>N개의 정수로 이루어진 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>에서, 가장 긴 증가하는 부분 수열(LIS)의 길이를 L이라고 하자. LIS는 하나 또는 그 이상 있을 수 있다. 모든&nbsp;LIS를 사전 순으로 정렬했을 때, K번째 오는 수열을 구해보자.</p>

<p>두 LIS A<sub>i<sub>1</sub></sub>, A<sub>i<sub>2</sub></sub>, ..., A<sub>i<sub>L</sub></sub>와 A<sub>j<sub>1</sub></sub>, A<sub>j<sub>2</sub></sub>, ..., A<sub>j<sub>L</sub></sub>이 있을 때, i<sub>k</sub> ≠ j<sub>k</sub>를 만족하는 k가 하나라도 존재하면 다른 LIS이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 주어진다. 둘째 줄에 공백으로 구분된 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이&nbsp;주어진다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>K번째 LIS를 공백으로 구분해서 출력한다. K번째 LIS가 없을 때는 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 1
1 4 2 3 5
','1 2 3 5
','DATA_STRUCTURE'),
                                                                                                                (7937,'BAEKJOON','https://www.acmicpc.net/problem/18838',18838,'가장 긴 증가하는 부분 수열 k','0.25초','512 MB',22,'<p>N개의 정수로 이루어진 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>에서, 가장 긴 증가하는 부분 수열(LIS)의 길이를 L이라고 하자. LIS는 하나 또는 그 이상 있을 수 있다. 모든&nbsp;LIS를 사전 순으로 정렬했을 때, K번째 오는 수열을 구해보자.</p>

<p>두 LIS A<sub>i<sub>1</sub></sub>, A<sub>i<sub>2</sub></sub>, ..., A<sub>i<sub>L</sub></sub>와 A<sub>j<sub>1</sub></sub>, A<sub>j<sub>2</sub></sub>, ..., A<sub>j<sub>L</sub></sub>이 있을 때, i<sub>k</sub> ≠ j<sub>k</sub>를 만족하는 k가 하나라도 존재하면 다른 LIS이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 주어진다. 둘째 줄에 공백으로 구분된 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이&nbsp;주어진다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>K번째 LIS를 공백으로 구분해서 출력한다. K번째 LIS가 없을 때는 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 1
1 4 2 3 5
','1 2 3 5
','DATA_STRUCTURE'),
                                                                                                                (7939,'BAEKJOON','https://www.acmicpc.net/problem/18859',18859,'부모님께 큰절 하고','2초','1024 MB',17,'<p><strong><em>Agent</em></strong> 욱제는 훈련소로 떠나기 전, 부모님께 큰절을 올렸다. 어릴 적,&nbsp;욱제의 부모님은 욱제에게&nbsp;말하곤 했다.</p>

<p style="text-align: center;"><em>"욱제야, 꼭 기억하렴. <strong>Agent</strong>의 큰절은 <strong>예술적</strong>이어야 한단다."</em></p>

<p>하지만, 오늘 부모님은 욱제에게 크게 실망했다. 욱제의 큰절이 예술적이지 않다고 생각했기 때문이다. 욱제의 큰절이 예술적일 조건은 다음과 같다.</p>

<p><meta charset="utf-8"></p>

<ol dir="ltr">
	<li>욱제의 큰절은 길이 N의 정수열 a<sub>1</sub>, …, a<sub>N</sub>으로 나타내어진다.</li>
	<li>욱제의 큰절이 예술적이려면, 이 정수열이 일정하게 감소했다가 일정하게 증가하는 수열이어야 한다. 즉,&nbsp;인덱스 2 ≤&nbsp;i ≤ N - 1가 존재해, a<sub>1</sub>, …, a<sub>i</sub>는 공차 x < 0의 등차수열이고, a<sub>i</sub>, …, a<sub>N</sub>은 공차 y >&nbsp;0의 등차수열이다.</li>
</ol>

<p dir="ltr">당신은 욱제의 큰절을 나타내는 수열을 보고 욱제의 큰절이 예술적인지 평가해야 한다.</p>

<p dir="ltr">하지만 아뿔싸! 축구 선수&nbsp;<a href="https://www.acmicpc.net/user/messi">메시</a>가 이 수열을 섞어버렸다. 순서 없이 섞인 수열을 보고 원래 욱제의 큰절이 예술적이었을 수 있을지 알아보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 길이 N이 주어진다.</p>

<p><meta charset="utf-8"></p>

<p dir="ltr">둘째 줄에 욱제의 큰절을 나타내는 수열 a<sub>1</sub>, …, a<sub>N</sub>을 순서 없이 섞은 수열이 공백을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><meta charset="utf-8">입력 수열을 재배열하여 예술적인 큰절을 나타내는 수열을 만들 수 있으면 <code>Yes</code>를, 아니면 <code>No</code>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
8 2 4 6 5
','Yes
','DATA_STRUCTURE'),
                                                                                                                (7941,'BAEKJOON','https://www.acmicpc.net/problem/18932',18932,'트리와 쿼리 16','8초','512 MB',27,'<p>N개의 정점으로 이루어진 포레스트가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있다.&nbsp;초기 포레스트에 간선은 없다.</p>

<p>아래의&nbsp;쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 u v</code>: 두 정점 $u$, $v$ 를 잇는 간선을 포레스트에 추가하라. 이 쿼리가 호출되기 이전에, 포레스트&nbsp;상에서 $u$와 $v$를 잇는 경로가 없음이 보장된다.&nbsp;</li>
	<li><code>2 u k</code>: $dist(u, v)$ 를 두 정점 $u, v$ 간의 최단 경로의 길이라고 정의하자. 만약 두 정점이 연결되어 있지 않다면 값은 $\infty$ 이다. $dist(u, v) = k$ 인 정점 $v$ 의 개수를 반환하라.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 두 정수 $N, Q$ 가 주어진다. ($1 \le N \le 100\,000, 1 \le Q \le 200\,000$)</p>

<p>이후 $Q$ 개의 줄에 세 정수로 쿼리의 정보 $t_i, a_i, b_i$ 가 주어진다. ($1 \le t_i \le 2, 0 \le a_i, b_i < n$)</p>

<p>$last$ 라는 추가 변수를 생각하자. 이 변수는 초기에 0이라는 값을 가진다.</p>

<ul>
	<li>$t_i = 1$ 일 경우, 쿼리의 인자 $u_i, v_i$는 다음과 같이 정의된다: $u_i = ((a_i + last) \mod n) + 1, v_i = ((b_i + last) \mod n) + 1$&nbsp;</li>
	<li>$t_i = 2$ 일 경우, 쿼리의 인자 $u_i, k_i$ 는 다음과 같이 정의된다: $u_i = ((a_i + last) \mod n) + 1, k_i = ((b_i + last) \mod n)$ 이 쿼리에 대한 답을 계산한 후, $last$ 를 해당 쿼리의 답으로 갱신한다.&nbsp;</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$t_i = 2$ 형태의 쿼리의 답을 한 줄씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 9
1 0 6
1 4 3
1 0 5
1 1 2
1 3 1
1 4 5
2 2 3
2 2 1
2 0 0
','1
2
1
','DATA_STRUCTURE'),
                                                                                                                (7942,'BAEKJOON','https://www.acmicpc.net/problem/18933',18933,'최소 스패닝 트리와 쿼리','5초(추가시간없음)','256 MB',27,'<p>$Path_i$는 $i$ 개의 정점을 가진 방향 그래프로, 모든 $1 \le j < i$ 에 대해 $j \rightarrow j + 1$ 로 가는 간선이 존재한다.</p>

<p>가중치 있는 방향 그래프 $G_1$ 과 방향 그래프 $G_2$ 의 텐서 곱 (tensor product) $G_1 \times G_2$ 는 다음과 같이 정의된다:</p>

<ul>
	<li>정점 집합은 $\{(u, v)|u \in G_1, v \in G_2\}$ 의 형태다. 정점 집합의 크기는 $|G_1| \times |G_2|$ 이다.</li>
	<li>두 정점 $(u_1, v_1), (u_2, v_2)$ 를 잇는 <strong>무방향 간선</strong>이 존재한다는 것은, $G_1$ 에 $u_1 \rightarrow u_2$ 방향의 간선, $G_2$ 에 $v_1 \rightarrow v_2$ 방향의 간선이 있음을 뜻한다.&nbsp;</li>
	<li>간선의 가중치는, $G_1$에서 두 정점 $u_1 \rightarrow u_2$를 잇는 간선의 가중치와 동일하다.&nbsp;</li>
</ul>

<p>$N$ 개의 정점과 $M$ 개의 간선을 가진 방향 그래프 $G$ 가 입력으로 주어진다. 각 간선에는 양의 정수 가중치가 부여되어 있다. $G \times Path_i$ 라는 그래프를 생각하자. 이 그래프는 무방향이고 각 간선에 양의 정수 가중치가 부여되어 있다. 모든 $2 \le i \le Q + 1$에 대해, $G \times Path_i$ 의 최소 스패닝 트리의 간선 가중치 합을 출력하라. <strong>쿼리로 들어오는 모든 $G \times Path_i$ 에 대해 스패닝 트리가 항상 존재하게끔 입력이 주어짐이 보장된다.</strong></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 세 정수 $N, Q, M$ 이 주어진다. ($1 \le N, Q \le 100\,000, 1 \le M \le 200\,000$)</p>

<p>이후 $M$ 개의 줄에 세 개의 정수&nbsp;$u_i, v_i, w_i$ 가 주어진다. $u_i \rightarrow v_i$ 방향의 가중치 $w_i$ 의 간선이 존재한다는 뜻이다. ($1 \le u_i, v_i \le N, 1 \le w_i \le 30$)&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$Q$ 개의 줄을 출력하라. 이 중 $i$ 번째 줄에는 $G \times Path_{i + 1}$ 에서의 문제의 정답을 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 4 8
3 4 1
1 1 3
1 3 2
4 2 4
4 4 2
2 2 3
1 2 2
1 4 3
','16
23
30
37
','DATA_STRUCTURE'),
                                                                                                                (7946,'BAEKJOON','https://www.acmicpc.net/problem/18938',18938,'돌 술래잡기 게임','1초','512 MB',25,'<p>Yuto와 Platina가 돌 술래잡기 게임을 하려고 한다. 게임은 2차원 좌표평면 상에서 진행하며,&nbsp;특이하게도 x좌표와 y좌표가 모두 10<sup>9</sup>&nbsp;이하인 부분만 게임판으로&nbsp;사용한다.</p>

<p>게임판 위에는 흰 돌 1개와 검은 돌 <em>N</em>개가 있다. 처음에 흰 돌은 (0, 0)에 존재하며,&nbsp;<em>N</em>개의 검은 돌 중 <em>i</em>번째 돌은 (<em>x<sub>i</sub></em>, <em>y<sub>i</sub></em>)에 위치해 있다.</p>

<p>Yuto는 자신의 차례에 흰 돌이 (<em>x</em>, <em>y</em>)에 위치해 있으면 (<em>x</em>+1, <em>y</em>)또는 (<em>x</em>, <em>y</em>+1)로 흰 돌을 한 칸 움직인다.</p>

<p>Platina는 자신의 차례에 원하는 검은 돌 하나를 골라 (<em>x</em>, <em>y</em>)에 위치해 있으면 (<em>x</em>-1, <em>y</em>)또는 (<em>x</em>, <em>y</em>-1)로 이동시킨다.</p>

<p>Yuto가 먼저 시작하여 번갈아 턴을 진행하면서 흰 돌이 게임판을 탈출하면 Yuto의 승리, 그 전에&nbsp;흰 돌과 검은 돌이 같은 곳에 위치하게 되면 Platina의 승리이다.</p>

<p>둘은 완벽하게 게임을 진행할 수 있지만, 판의 크기가 너무 큰 나머지 누가 이길지 미리 알고싶다. 게임에서 누가 승리할지 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째&nbsp;줄에는 검은 돌의 개수 <em>N</em>이 주어지며, 그 다음 <em>N</em>개의 줄에 걸쳐 <em>i</em>번째 검은 돌의 위치 <em>x<sub>i</sub></em>와 <em>y<sub>i</sub></em>가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>게임에서&nbsp;승리하게 될 사람을 출력한다. 이름의 첫글자는 대문자임에 유의하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
0 1
','Yuto
','DATA_STRUCTURE'),
                                                                                                                (7948,'BAEKJOON','https://www.acmicpc.net/problem/18941',18941,'평면그래프와 게임','1초','256 MB',24,'<p>A젖소와 D젖소가 평면그래프 게임을 한다. 이 게임은 처음에 <em>N</em>개의 정점과 <em>M</em>개의 간선으로 이루어진 평면그래프에서 진행된다.&nbsp;</p>

<p>이 때 게임은 주어진 수에 따라&nbsp;두 가지 행동을 <em>Q</em>번 진행한다.&nbsp;</p>

<ul>
	<li>
	<p><code>1 u v</code>&nbsp;: 정점 <em>u</em>와 정점 <em>v</em>를 잇고 있던 간선이 있다면 그 간선을 삭제한다.&nbsp;</p>
	</li>
	<li>
	<p><code>2 u v</code>&nbsp;: 정점 <em>u</em>와 정점 <em>v</em>가 같은 컴포넌트에 속해 있는지 확인한다. 두 정점이 같은 컴포넌트에 속해 있으면 A젖소, 그렇지 않으면 D젖소의 승리이다.</p>
	</li>
</ul>

<p>원래는 2번 행동마다 어떤 젖소가 이길지 알아내면&nbsp;되는 거였으나...&nbsp;자신이 많이 이기지 못할걸 알아버린 험악한 D젖소는 화가 났다.</p>

<p>그래서 주어지는 모든 행동에서 주어지는 수를 다음과 같은 규칙으로 (<em>u</em>, <em>v</em>)에서 (<em>u</em>, <em>v</em>)으로&nbsp;바꿔버리려고 한다.</p>

<p>어떤 행동이 있기 전까지의 모든 2번 행동 중 A젖소가 이긴 횟수를 <em>a</em>라고 했을 때 <em>u</em><sup><em></em>&nbsp;</sup>= (<em>u&nbsp;</em>- 1 + <em>X</em>&nbsp;× <em>a</em>) mod&nbsp;<em>N</em> + 1이고, <em>v<sup></sup></em>&nbsp;= (<em>v&nbsp;</em>- 1 + <em>Y</em> ×&nbsp;<em>a</em>) mod&nbsp;<em>N</em> + 1이다. (단, <em>x</em>&nbsp;mod <em>y</em>는 <em>x</em>를 <em>y</em>로 나눈 나머지를 의미한다.)</p>

<p>이제 D젖소는 만족했다. 2번 행동을 할 때마다 어떤 젖소가 이기게 될지 알아보자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 다섯 개의 양의 정수 <em>N</em>, <em>M</em>, <em>Q</em>, <em>X</em>, <em>Y</em>가 주어진다.</p>

<p>1+<em>i</em>번째&nbsp;줄에는 <em>i</em>번&nbsp;정점의 좌표 <em>x</em><sub><em>i</em></sub>와&nbsp;<em>y<sub>i</sub></em>가 주어진다.</p>

<p><em>N</em>+1+<em>j</em>번째&nbsp;줄에는 각 간선의 양 끝점 <em>a<sub>j</sub></em>, <em>b<sub>j</sub></em>&nbsp;가 주어진다. 이는 <em>j</em>번째 간선이&nbsp;<em>a<sub>j</sub></em>번 정점과 <em>b<sub>j</sub></em>번 정점을 양 끝점으로 갖는 선분 모양의 간선임을 의미한다.</p>

<p><em>N</em>+<em>M</em>+2번째 줄부터 <em>Q</em>개의 줄에는 각 줄마다 하게 될 행동을 의미하는 세 정수가&nbsp;주어진다.&nbsp;실제로는 <em>u</em>, <em>v</em>을 이용하여 행동을 처리해야 함에 유의하라.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 행동을 할 때마다 A젖소가 이기게 된다면 A를, D젖소가 이기게 된다면 D를 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 5 6 1 2
0 0
0 2
-3 0
-2 -2
1 -1
4 0
1 4
1 6
3 4
4 5
5 6
1 5 6
2 2 4
1 5 6
2 1 3
1 6 4
2 6 4
','D
A
D
','DATA_STRUCTURE'),
                                                                                                                (7949,'BAEKJOON','https://www.acmicpc.net/problem/18943',18943,'지역 꾸미기 게임','8초','1024 MB',28,'<p>Whiteking은 지역 꾸미기 게임을 하려고 한다. 그가 꾸미려는 지역은 단위 격자가&nbsp;1 × 1 정사각형 타일로 표현되는 <em>N</em> × <em>N</em> 격자판 형태이며, 가장 왼쪽 위 타일의 좌표가 (1, 1)이고, 가장 오른쪽 아래 타일의 좌표는 (<em>N</em>, <em>N</em>)이다. 이 때 타일의 좌표란 타일의 오른쪽 아래 꼭짓점의 좌표를 말한다.&nbsp;이로부터 (<em>x</em>,&nbsp;<em>y</em>)에 위치한 타일은 [<em>x-1</em>,&nbsp;<em>x</em>]×[<em>y-1</em>,&nbsp;<em>y</em>]에 해당하는 정사각형 영역을 차지함을 알 수 있다. 각&nbsp;타일은 고유한 아름다움 값을 가지는데,&nbsp;초기에&nbsp;모든 타일의 아름다움 값은 0이다.</p>

<p>지역 꾸미기 게임은 다음 세 가지 행동을 통해 점수를 얻는 게임이다.</p>

<ol>
	<li>가로 또는 세로로 직선을 그어 격자판을 서로 다른 구역으로 분할한다. 처음에는 <em>N</em> ×&nbsp;<em>N</em> 크기의 구역 한 개만 존재하며, 만약 가로와 세로로 직선을 한 번씩 긋는다면 구역은 네 개로 나뉘어질 것이다.</li>
	<li>타일을 하나 선택해 해당 타일이 속한 구역을 꾸민다. 이 결과 꾸며진 구역에 속한 모든 타일의 아름다움은 <em>X</em>만큼 증가한다.</li>
	<li>격자판에 포함되는 직사각형을 하나 선택해 그 안에 속한 타일 중 가장 아름다운 타일의 아름다움만큼 점수를 획득한다.</li>
</ol>

<p>Whiteking은 자신이 3번 행동을 할 때마다 얻게 될 점수를 미리 알고 싶다. 따라서 그는 자신이 할 행동을 다음과 같은 쿼리로 표현해 여러분에게 알려줄 것이다.</p>

<ul>
	<li><code>1 a&nbsp;b</code>&nbsp;: <em>a</em>가 0이면 <em>x=b</em>, <em>a</em>가 1이면 <em>y=b</em>로 표현되는&nbsp;직선을 긋는다.</li>
	<li><code>2 a b&nbsp;X</code>&nbsp;: (<em>a</em>, <em>b</em>)에 위치한 타일을 선택해 2번 행동을 한다.</li>
	<li><code>3 a b c d</code>&nbsp;: 가장 왼쪽 위 타일의 좌표가 (<em>a</em>, <em>b</em>)이고 가장 오른쪽 아래 타일의 좌표가 (<em>c</em>, <em>d</em>)인 직사각형을 선택하여 3번 행동을 한다.</li>
</ul>

<p>Whiteking을 위해 3번 쿼리가 주어질 때마다 얻을 수 있는 점수를 구해보자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는&nbsp;두 양의 정수 <em>N</em>, <em>Q</em>가 주어진다.</p>

<p>둘째 줄부터 <em>Q</em>개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리가 들어올 때마다 그 시점에서 Whiteking이 얻을 수 있는 최대 점수를 출력해라.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 7
3 1 1 3 3
2 1 3 -3
3 1 1 3 3
1 0 1
2 1 1 4
3 2 2 3 3
3 1 1 3 3
','0
-3
-3
1
','DATA_STRUCTURE'),
                                                                                                                (7950,'BAEKJOON','https://www.acmicpc.net/problem/18945',18945,'조작된 ㄱ 폭탄 게임','1초','256 MB',28,'<p>Ahgus 와 Bagus는 ㄱ 폭탄 게임을 하려고 한다.</p>

<p>ㄱ폭탄 게임은 <em>N</em>개의 게임판에서 진행된다. <em>i</em>번째 게임판은 가로와 세로의 길이가 각각 <em>R<sub>i</sub></em>, <em>C<sub>i</sub></em>이고 1×1&nbsp;정사각형 칸으로 이루어진 직사각형 모양이다.</p>

<p>게임판의 각 칸에는 ㄱ 폭탄이 하나씩 놓여 있으며, 폭탄에는 총 세 개의 모양 A, B, C가 존재한다. A 폭탄은 Ahgus만 선택할 수 있고, B 폭탄은 Bagus만 선택할 수 있으며, C 폭탄은 누구도 선택할 수 없다.</p>

<p>ㄱ 폭탄은 터질 때 자신의 왼쪽과 아래쪽 칸의 폭탄을 점화한다. 점화된 폭탄은 곧 폭발하고, 그 왼쪽과 아래쪽에 있는 폭탄을 다시 점화하게 된다. 예를 들어 게임판의 가장 오른쪽 위 칸의 폭탄을 터뜨리면 모든 칸의 폭탄이 터지게 된다. 이렇게 연쇄적인 과정 끝에 더 이상 폭발하는 폭탄이 발생하지 않으면 해당 플레이어의 턴이 끝난다.</p>

<p>모든 게임은 Ahgus부터 시작하며 두 사람이 순서대로 한 턴씩 진행하고, 각 사람은 자신의 턴에 남아있는 폭탄 중 하나를 선택해 터뜨린다. 이때 자신의 턴에 터트릴 수 있는 폭탄이 더 이상 남아있지 않는 사람이 패배하게 된다.</p>

<p>두 사람은 게임에서 이기기 위해 몇몇 폭탄을 바꿔치기했고, 각 게임판에서 A와 B중 한 종류 이상의 폭탄은 단 한 개만 존재하게 되었다.</p>

<p>이를 지켜보던 연금술사 stonejjun이 나타나 총 <em>T</em>판의 게임을 진행할 것을 제안했다. 그는 각 게임마다 <em>K</em>번 게임판을 선택해 A 폭탄은 B 폭탄으로, B 폭탄은 A 폭탄으로 바꿔치기하고, 두 정수 <em>U</em>와 <em>V</em>에 대해 번호가 <em>U</em> 이상 <em>V</em> 이하인 게임판만을 사용할 수 있도록 나머지 게임판을 숨길 것이다.</p>

<p>그의 횡포에 화가 난 Ahgus와 Bagus는 게임을 하지 않고 승자를 결정하려고 한다. 만약 두 사람 모두 이기기 위한 최선의 선택을 할 경우, 각 게임마다 누가 이기게 될지 구해보자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 게임판의 수 <em>N</em>이 주어진다.</p>

<p>그 후 각 <em>N</em>개의 게임판에 대해서 한 줄에 두 양의 정수 <em>R<sub>i</sub></em>, <em>C<sub>i</sub></em>가 주어진다.</p>

<p>그 아래 세로&nbsp;<em>R<sub>i</sub></em>, 가로&nbsp;<em>C<sub>i</sub></em>&nbsp;개의 문자로 <em>i</em>번째 게임판이 주어진다. 게임판은 가장 왼쪽 위의 칸부터 주어진다.</p>

<p>그 다음 줄에는 둘이 진행할 게임의 수 <em>T</em>가 주어진다.</p>

<p>이후 <em>T</em>개의 줄에 걸쳐 세 양의 정수 <em>K</em>, <em>U</em>, <em>V</em> 가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>T판의 각 게임별로 이기게 될 사람의 이름 Ahgus 또는 Bagus를 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 1
A
2 2
AB
AA
1 3
ACB
2 4
CCAC
BAAA
1 1
B
5
2 2 3
5 1 1
4 1 5
2 1 3
5 5 5
','Bagus
Ahgus
Bagus
Ahgus
Bagus
','DATA_STRUCTURE'),
                                                                                                                (7976,'BAEKJOON','https://www.acmicpc.net/problem/19089',19089,'파일 합치기 4','1초','512 MB',29,'<p>소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.</p>

<p>예를 들어, C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.</p>

<p>소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 200,000)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
4
40 30 30 50
15
1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
','300
864
','DATA_STRUCTURE'),
                                                                                                                (7989,'BAEKJOON','https://www.acmicpc.net/problem/19242',19242,'행렬 합','2초(하단참고)','256 MB',19,'<p>N행 M열로 이루어질 정수 행렬 A와 정수 x가 주어진다.&nbsp;행렬 A의 모든 부분행렬 중 그 합이 x를 넘지 않는 (즉, x 이하인) 부분행렬의 개수를 구하고 싶다. 예를 들어 N = M = 2 이고 x = 5, 그리고 A가 아래와 같은 예를 생각해보자.</p>

<pre>1 2
3 4</pre>

<p>이 경우, 1x1 크기의 총 네 개의 부분행렬은 모두 그 원소의 합이 x = 5 이하이다. 1 과 3을 포함한 2x1 크기의 부분행렬과 1과 2를 포함한 1x2 크기의 부분행렬도 각각 원소의 합이 1+3 = 4 그리고 1+2 = 3으로 x 이하이므로 조건을 만족한다. 다른 부분행렬은 원소의 총 합이 5를 초과하므로, 이 경우 답은 6이 된다.</p>

<p>다른 예로, N = 2, M = 3, x = 0 이며 A가 아래와 같은 행렬인 경우를 생각해보자.</p>

<pre>0 -1 -2
-3 -4 -5</pre>

<p>이 경우, A의 모든 부분행렬의 원소 총 합이 0 이하이므로 답은 18이 된다.</p>

<p>N, M, x 그리고 A를 입력으로 받아, 원소의 총 합이 x이하인 부분행렬의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T가 주어진다.</p>

<p>각 테스트 케이스 첫 줄에는 N, M, x 가 공백으로 구분되어 주어진다.</p>

<p>다음 N줄에 걸쳐 각 줄에 M개의 정수가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>상기한대로 A의 부분행렬 중 원소의 총 합이 x이하인 부분행렬의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
2 2 5
1 2
3 4
2 3 0
0 -1 -2
-3 -4 -5
4 1 3
1
2
1
2
3 3 1
10 10 10
10 -100 10
10 10 10
','6
18
7
16
','DATA_STRUCTURE'),
                                                                                                                (8029,'BAEKJOON','https://www.acmicpc.net/problem/19550',19550,'빛의 전사 크리퓨어','1초(추가시간없음)','1024 MB',21,'<p>여기는 평화로운 알고리즘 나라. 알고리즘 나라의 외곽에는 원 모양의 울타리가 쳐져 있다.</p>

<p>원 둘레에는 같은 간격으로 $L$개의 기둥이 세워져 있고, 각 기둥은 $0$번부터 $L-1$번까지 시계방향 순으로 번호가 부여된 상태이다. 즉 $0$번 기둥의 시계방향에는 $1$번 기둥이 이웃해 있고, 반시계방향으로 $L-1$번 기둥이 이웃해 있다. ($L$은 홀수)</p>

<p>편의상 $0$번 기둥이 12시 방향에 위치하도록 회전시킨 상태로 생각하자.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3e1a3aa4-68ae-4ca0-a53d-5d009882047a/-/preview/" style="height: 279px; width: 280px;"></p>

<p>알고리즘 나라에는 나라의 수호자 크리퓨어가 살고 있다. 그 어떤 악인도 크리퓨어를 보게 되면 “<code>그저 빛...</code>” 을 외치며 마음이 깨끗하게 정화된다. 때문에 이 마을에서는 그를 빛의 전사 <span style="color:#e74c3c;">크</span><span style="color:#e67e22;">리</span><span style="color:#3498db;">퓨</span><span style="color:#1abc9c;">어</span>라고 부르고, :fan: 클럽 등을 운영하며 그를 찬양하고 있다.</p>

<p>오늘은 알고리즘 나라에서 UCPC 2020 본선 대회가 열리는 날. 평화롭게 UCPC 대회를 진행하던 어느 순간, 사악한 악당 pichulia가 알고리즘 나라를 습격했다! 평소 알고리즘 나라에 악감정이 있던 pichulia는 기둥간에 $N$개의 고무줄을 연결하는 장난을 쳤다. pichulia가 설치한 $N$개의 고무줄 중 하나라도 남아 있으면 <span style="color:#e74c3c;">출력 초과</span>를 받게 되므로, 이들을 모두 끊어내야 한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/22e928b4-d912-48ac-a7e0-6e041e30e309/-/preview/" style="width: 280px; height: 279px;"></p>

<p>알고리즘 나라의 수호자 크리퓨어는 이러한 장난을 그냥 두고 볼 수 없었다. 따라서 크리퓨어의 필살기인 <span style="color:rgb(255, 0, 98);">루비빔</span>을 발사해서 모든 고무줄을 끊어내고자 한다.</p>

<p>크리퓨어의 위치는 원의 중심에 있으며, 원의 중심에서 이동하지 않고 고정된 상태로 루비빔을 발사한다. 루비빔은 원의 중심에서 시작하는 반직선 형태로 표현할 수 있다. 이 반직선과 교차하면 빔에 맞은 것으로 취급되고, 빔에 한 번이라도 맞은 고무줄은 끊어진다. 고무줄을 고정시킨 기둥에 빔을 맞은 경우도 고무줄이 끊어진다. 빔의 두께와 고무줄의 두께는 무시할 수 있을 정도로 얇다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/83373a8a-d01b-4738-8ad7-a7aa91131943/-/preview/" style="width: 280px; height: 284px;"></p>

<p>루비빔은 한 번 발사하는데 생각보다 많은 체력을 요구한다. 따라서 루비빔을 최소한으로 발사하는 것이 좋다.</p>

<p>고무줄을 모두 끊어내기 위해 필요한 루비빔 발사 횟수의 최소값을 구해서 <span style="color:#e74c3c;">크</span><span style="color:#e67e22;">리</span><span style="color:#3498db;">퓨</span><span style="color:#1abc9c;">어</span>에게 알려주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 $2$개의 정수 $N$과 $L$이 공백을 사이에 두고 주어진다. $N$은 고무줄의 개수이고 $L$은 원에 있는 기둥의 개수이다.<br>
($1\leq N\leq 10^5$, $3\leq L\leq 10^9$, $L$ 은 홀수)</p>

<p>그 후 두 번째 줄부터 $N+1$번째 줄까지 $N$줄에 걸쳐서 고무줄의 정보를 나타내는 $2$개의 정수 $s$, $e$가 공백을 사이에 두고 주어진다. 이는 $s$번 기둥과 $e$번 기둥을 연결하는 고무줄을 설치했음을 의미한다. ($0\leq s,e\leq L-1$, $s\neq e$) 두 개 이상의 고무줄이 서로 교차할 수 있다.</p>

<p>$L$은 홀수이므로, 원의 중심을 지나는 고무줄은 존재하지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$N$개의 고무줄을 모두 끊어내기 위해 필요한 루비빔의 최소 발사 횟수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 17
3 16
1 6
10 5
8 13
','2
','DATA_STRUCTURE'),
                                                                                                                (8026,'BAEKJOON','https://www.acmicpc.net/problem/19566',19566,'수열의 구간 평균','1초','256 MB',14,'<p>길이가 $N$인 수열 $A_1, A_2, \cdots, A_N$이 주어진다. 구간에 있는 모든 수들의 평균이 정확히 $K$인 구간의 개수를 구해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기&nbsp;$N$과 우리가 원하는 평균&nbsp;$K$가&nbsp;주어진다. ($1 \le N \le 200,000$, $-10^9&nbsp;\le K&nbsp;\le 10^9$)</p>

<p>둘째 줄에는 수열 $A_1,&nbsp;A_2, \cdots,&nbsp;A_N$이 주어진다.&nbsp;($1 \le i \le N$, $-10^9&nbsp;\le A_i&nbsp;\le 10^9$)</p>

<p>입력에 주어지는 모든 수들은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>구간에 존재하는 모든 수의 평균이 $K$인 구간의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2
1 3 2 2
','6
','DATA_STRUCTURE'),
                                                                                                                (8030,'BAEKJOON','https://www.acmicpc.net/problem/19580',19580,'마스크가 필요해','3초(추가시간없음)','1024 MB',16,'<p>코로나19가 발생하고 나서 마스크의 필요성이 증가하기 시작했다. 마스크가 없으면 생활을 하는데 어려움이 있기 때문에 마스크를 항상 구비하고 있어야 한다.</p>

<p>마스크의 수요가 증가함에 따라&nbsp;일정했던 마스크의 가격이 상점마다 달라지게 되었다. 마스크의 가격이 제각각이기&nbsp;때문에 A도시의 시민들이 전부 마스크를 갖기가 어려워지기 시작했다. A도시의 공무원인 당신은 이 사태를 해결하기 위해서 상점의 주인들에게 마스크의 가격을 일정하게 해달라고 했지만, 상점 주인들은 당연히 무시했다.</p>

<p>상점 주인들을 설득시키는 것은 어렵다고 생각해서 당신은 최대한 많은 시민들이 마스크를 가질 수 있게 하는 것으로 계획을 변경했다. 당신은 A도시의 각 시민이 마스크에 소비할 수 있는 금액의 범위와&nbsp;A도시의 상점에서 팔고 있는 마스크의 가격 및 개수를 알아냈다. 각 시민은 최대 1개의 마스크만 살 수 있다. 이 정보를 바탕으로 최대한 많은 시민들이 마스크를 얻을 수 있게 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 A도시의 시민&nbsp;수인 <em>N</em>과 A도시의 상점 수인 <em>M</em>이&nbsp;주어진다. (1&nbsp;≤ <em>N</em>,&nbsp;<em>M</em>&nbsp;≤ 500,000)</p>

<p>두 번째 줄부터 <em>N</em> + 1번째 줄까지는 A도시의 각 시민이 마스크에 소비할 수 있는 돈의 범위인 <em>L<sub>i</sub></em>, <em>R<sub>i</sub></em>가&nbsp;주어진다. 즉 <em>i</em>번째 A도시 시민이 살 수 있는 마스크의 가격은 <em>L<sub>i</sub></em> 이상 <em>R<sub>i</sub></em> 이하이다.&nbsp;(1&nbsp;≤ <em>L<sub>i</sub></em>&nbsp;≤ <em>R<sub>i</sub></em>&nbsp;≤ 10<sup>18</sup>)</p>

<p><em>N</em> + 2번째 줄부터 <em>N</em> + <em>M</em> + 1번째 줄까지는 A도시의 각&nbsp;상점이 판매하고 있는 마스크의 가격인 <em>P<sub>j</sub></em>와 마스크의 개수인 <em>X<sub>j</sub></em>가 주어진다. (1&nbsp;≤ <em>P<sub>j</sub></em>&nbsp;≤ 10<sup>18</sup>, 1&nbsp;≤ <em>X<sub>j</sub></em>&nbsp;≤ 1,000)</p>

<p>모든 <em>L<sub>i</sub></em>, <em>R<sub>i</sub></em>, <em>P<sub>j</sub></em>, <em>X<sub>j</sub></em>는 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가능한 한 많은 시민이 마스크를 샀을 때, 마스크를 산 시민의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 1
1 2
1 3
1 4
1 5
1 6
1 5
','5
','DATA_STRUCTURE'),
                                                                                                                (8035,'BAEKJOON','https://www.acmicpc.net/problem/19593',19593,'다도해','1초(추가시간없음)','256 MB',12,'<p>당신은 N개의 작은 섬으로 이루어진 다도해에 다리를 건설하여 임의의 한 섬에서 임의의 다른 섬으로 도달 가능하게 하고 싶다. 현재는 아무 다리도 없는 상태이다.</p>

<p>섬은 0번 부터 N-1번까지 번호가 붙어있다.</p>

<p>당신은 아래와 같은 알고리즘에 따라 다리를 건설하기로 했다.</p>

<ul>
	<li>세 개의 양의&nbsp;정수 Seed, A, B 를 고른다. 이후, E[ i ], X[ i ], Y[ i ] 를 아래와 같이 정의한다.
	<ul>
		<li>E[ 1 ] = Seed % N<sup>2&nbsp;</sup>&nbsp;그리고 E[ i ] = (E[ i-1 ] * A + B) % N<sup>2</sup> (i >&nbsp;1). (각각의 E[i] 값은 어느 두 섬을 연결하는 다리를 지을지 결정한다.)</li>
		<li>X[ i ] = E[ i ] / N&nbsp;그리고 Y[ i ] = E[ i ] % N (i ≥ 1).</li>
		<li>위 두 수식에서&nbsp;"%" 는 정수 나머지 연산을 나타내는 Modulo 이며, "/"은 정수 나눗셈 연산이다.</li>
	</ul>
	</li>
	<li>오늘부터 1일 후 (즉, 내일)&nbsp;X[ 1&nbsp;] 번 섬과 Y[ 1&nbsp;]번 섬을 연결하는 다리를 건설한다. 만약 X[ 1&nbsp;] = Y[ 1&nbsp;]이면 이 날은 건설은 하지 않고 논다.</li>
	<li>오늘 부터 i일 후, X[ i&nbsp;] 번 섬과 Y[ i&nbsp;] 번 섬을 연결하는 다리를 건설한다. 만약 X[ i ] = Y[ i ] 이거나 이미 두 섬을 잇는 다리가 있다면, 이 날은 건설은 하지 않고 논다.</li>
</ul>

<p>위 알고리즘에 따라 다리를 건설 할 때, 당신은 오늘 부터 몇 일이 지난 후 (M일 후) 목적을 달성할지 궁금하다.</p>

<p>예를 들어 N = 4, Seed = 2020, A = 2, B = 3 인 경우를 생각해보자.&nbsp;</p>

<ul>
	<li>E[ 1 ] = 2020 % 16 = 4, X[ 1 ] = 4 / 4 = 1, Y[ 1 ] = 4 % 4 = 0. 따라서 (1번섬, 0번섬) 을 잇는 다리를 건설한다.</li>
	<li>E[ 2 ] = (4 * 2 + 3) % 16 = 11, X[ 2 ] = 11 / 4 = 2, Y[ 2 ] = 11 % 4 = 3. 따라서 (2번섬, 3번섬)을 잇는 다리를 건설한다.</li>
	<li>E[ 3 ] = (11 * 2 + 3) % 16 = 9, X[ 3 ] = 9 / 4 = 2, Y[ 3 ] = 9 % 4 = 1. 따라서 (2번섬, 1번섬)을 잇는 다리를 건설한다.</li>
	<li>세 번째 다리를 건설한 후 임의의 한 섬에서 다른 섬으로 도달할 수 있으므로 이 때 M = 3이다.</li>
</ul>

<p>다른 예로, N = 4, Seed = 2020, A = 3, B = 4 인 경우를 생각해보자.</p>

<ul>
	<li>E[ 1 ] = 2020 % 16 = 4, X[ 1 ] = 4 / 4 = 1, Y[ 1 ] = 4 % 4 = 0. 따라서 (1번섬, 0번섬) 을 잇는 다리를 건설한다.</li>
	<li>E[ 2 ] = (4 * 3&nbsp;+ 4) % 16 = 0, X[ 2 ] = 0&nbsp;/ 4&nbsp;= 0, Y[ 2 ] = 0 % 4 = 0.&nbsp;X,Y&nbsp;값이 같으므로 다리를 건설하지 않는다.</li>
	<li>E[ 3 ] = (0&nbsp;* 3&nbsp;+ 4) % 16 = 4, X[ 3 ] = 4 / 4 = 1, Y[ 3 ] = 4 % 4 = 0. 이미 다리가 있으므로 다리를 건설하지 않는다.</li>
	<li>이 경우, (1번섬, 0번섬)을 잇는 다리 이외에 다른 다리를 건설하지 못한다. 따라서 이 때 위 조건을 만족하는 M은 존재하지 않는다.</li>
</ul>

<p>입력으로 N, Seed, A, B가 주어졌을 때, 위 조건을 만족하는 M값을 구하여 출력한다. 만약 조건을 만족하는 M값이 없다면 0을 출력한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T가 주어진다.</p>

<p>각 테스트 케이스는 네 개의 정수가 공백으로 구분되어 주어지는데, 순서대로 N, Seed, A, B 이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>조건을 만족하는 M이 존재하면 그 중 최소값을 출력하고, 존재하지 않으면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
4 2020 2 3
4 2020 3 4
4 2020 9 7
5 2020 4 7
','3
0
6
5
','DATA_STRUCTURE'),
                                                                                                                (8037,'BAEKJOON','https://www.acmicpc.net/problem/19598',19598,'최소 회의실 개수','2초','256 MB',11,'<p>서준이는 아빠로부터 N개의 회의를 모두 진행할 수 있는 최소 회의실 개수를 구하라는 미션을 받았다. 각 회의는 시작 시간과 끝나는 시간이 주어지고 한 회의실에서 동시에 두 개 이상의 회의가 진행될 수 없다.&nbsp;단, 회의는 한번 시작되면&nbsp;중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작 시간은&nbsp;끝나는 시간보다 항상 작다. N이 너무 커서 괴로워 하는 우리 서준이를 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 배열의 크기&nbsp;N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지&nbsp;공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 2<sup>31</sup>?1보다 작거나 같은 자연수 또는 0이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소 회의실 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
0 40
15 30
5 10
','2
','DATA_STRUCTURE'),
                                                                                                                (8047,'BAEKJOON','https://www.acmicpc.net/problem/19638',19638,'센티와 마법의 뿅망치','1초','1024 MB',10,'<p>센티는 마법 도구들을 지니고 여행을 떠나는 것이 취미인 악당이다.</p>

<p>거인의 나라에 도착한 센티는 자신보다 키가 크거나 같은 거인들이 있다는 사실이 마음에 들지 않았다.</p>

<p>센티가 꺼내 들은 마법 도구는 바로 마법의 뿅망치로, 이&nbsp;뿅망치에 맞은&nbsp;사람의 키가&nbsp;? 뿅망치에&nbsp;맞은 사람의 키 / 2 ?로 변하는 마법 도구이다. 단, 키가 1인 경우 더 줄어들 수가 없어 뿅망치의 영향을 받지 않는다.</p>

<p>하지만 마법의 뿅망치는 횟수 제한이 있다. 그래서 센티는 마법의 뿅망치를 효율적으로 사용하기 위한 전략을 수립했다. 바로 매번 가장 키가 큰 거인&nbsp;가운데&nbsp;하나를&nbsp;때리는 것이다.</p>

<p>과연 센티가&nbsp;수립한 전략에 맞게 마법의 뿅망치를 이용한다면 거인의 나라의 모든 거인이 센티보다 키가 작도록 할 수 있을까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 센티를 제외한 거인의 나라의 인구수&nbsp;<em>N</em>&nbsp;(1 ≤&nbsp;<em>N</em>&nbsp;≤ 10<sup>5</sup>)과 센티의 키를 나타내는 정수&nbsp;<em>H<sub>centi</sub></em>&nbsp;(1 ≤&nbsp;<em>H<sub>centi&nbsp;</sub></em>≤ 2 × 10<sup>9</sup>), 마법의 뿅망치의 횟수 제한&nbsp;<em>T</em>&nbsp;(1 ≤&nbsp;<em>T</em>&nbsp;≤ 10<sup>5</sup>)가 빈칸을 사이에 두고 주어진다.&nbsp;</p>

<p>두 번째 줄부터 <em>N</em>개의 줄에 각 거인의 키를 나타내는 정수&nbsp;<em>H</em> (1 ≤&nbsp;<em>H</em> ≤ 2 × 10<sup>9</sup>)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>마법의 뿅망치를 센티의 전략대로 이용하여 거인의 나라의 모든 거인이 센티보다 키가 작도록 할 수 있는 경우, 첫 번째 줄에 <span style="color:#e74c3c;"><code><span style="background-color:#ecf0f1;">YES</span></code></span>를 출력하고, 두 번째 줄에 마법의 뿅망치를 최소로 사용한 횟수를 출력한다.</p>

<p>마법의 뿅망치를 센티의 전략대로 남은 횟수 전부 이용하고도 거인의 나라에서 센티보다 키가 크거나 같은 거인이 있는 경우, 첫 번째 줄에 <span style="color:#e74c3c;"><code><span style="background-color:#ecf0f1;">NO</span></code></span>를 출력하고, 두 번째 줄에 마법의 뿅망치 사용 이후 거인의 나라에서 키가 가장 큰 거인의 키를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1 10 1
20
','NO
10
','DATA_STRUCTURE'),
                                                                                                                (8051,'BAEKJOON','https://www.acmicpc.net/problem/19640',19640,'화장실의 규칙','1초','1024 MB',12,'<p>데카는 회사의 화장실을 이용하려고 했다.&nbsp;하지만 수도 시설 고장으로 회사 내의 모든 화장실 사용이 금지됐고, 사원들은 단 하나의 임시 화장실을 이용해야 했다.&nbsp;</p>

<p>임시 화장실의 앞에 데카를 포함한&nbsp;<em>N</em>명의 사원이 대기하고 있다.&nbsp;데카는&nbsp;<em>N</em>명의 줄에서&nbsp;<em>K&nbsp;</em>+ 1번째로 줄을 섰다. 즉, 데카보다 먼저 도착한 사람이&nbsp;<em>K</em>명이 있다.&nbsp;줄이 길어지자 사장은 <em>M</em>개의 줄로 나눠서 대기하라 하였다.</p>

<p><em>N</em>명의 사원은 순서대로&nbsp;<em>M</em>개의 줄로 나눠 섰다. 기존 줄의 1번째 사원은 1번째 줄에, 2번째 사원은 2번째 줄에, ...&nbsp;<em>M</em>번째 사원은&nbsp;<em>M</em>번째 줄에, 그리고&nbsp;<em>M&nbsp;</em>+ 1번째 사원은 1번째 줄의 뒤에 서는 방식이다.&nbsp;</p>

<p><em>M</em>개의 줄로 나눠 선 것을 본 사장은 매우 흡족해하며 자리를 떠났다.</p>

<p><em>M</em>개의 줄의 사원들은 암묵적으로 다음의 규칙에 따라 화장실을 이용하기로 하였다.</p>

<ul>
	<li>선두란, 어떤 줄에서 가장 먼저 와서, 가장 앞에 선 사람을 말한다.</li>
	<li><em>M</em>개의 줄의 선두 중&nbsp;근무 일수&nbsp;<em>D<sub>i</sub></em>가 가장 높은 선두가 화장실을 이용한다.</li>
	<li><em>M</em>개의 줄의 선두 중 근무 일수 <em>D<sub>i</sub></em>가 가장 높은 선두가 둘 이상인 경우, 해당 선두들 중 화장실이 급한 정도&nbsp;<em>H<sub>i</sub></em>가 가장 높은 선두가 화장실을 이용한다.</li>
	<li><em>M</em>개의 줄의 선두 중 근무 일수 <em>D<sub>i</sub></em>가 가장 높은 선두가 둘 이상이며, 해당 선두들의 화장실이 급한 정도&nbsp;<em>H<sub>i</sub></em>도 모두 같다면, 해당 선두 중 줄의 번호가 가장 낮은 줄에 선 선두가 화장실을 이용한다.</li>
</ul>

<p>과연 몇 명의 사원이 화장실을 이용하고 나서야 데카의 차례가 올까? 매우 초조해지기 시작한 데카를 대신해 계산해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 임시 화장실에 대기하고 있는 사원의 수&nbsp;<em>N</em>&nbsp;(1 ≤&nbsp;<em>N</em>&nbsp;≤ 10<sup>5</sup>), 사장이 지시한 새로운 줄의 수&nbsp;<em>M</em>&nbsp;(2 ≤&nbsp;<em>M</em>&nbsp;≤ 10<sup>5</sup>), 데카가 화장실에 도착했을 때 자신의 앞에 서 있던 사원의 수&nbsp;<em>K</em>&nbsp;(0 ≤&nbsp;<em>K</em>&nbsp;≤&nbsp;<em>N</em>&nbsp;? 1)가 빈칸을 사이에 두고 주어진다.</p>

<p>두 번째 줄부터 각 <em>N</em>개의 줄에 임시 화장실에 <em>i</em>번째로 줄을 섰던 사원의 근무 일수 <em>D<sub>i</sub></em>&nbsp;(0 ≤&nbsp;<em>D<sub>i</sub></em>&nbsp;≤ 36,500), 화장실이 급한 정도를 나타내는 정수 <em>H<sub>i</sub></em> (0 ≤&nbsp;<em>H<sub>i</sub></em>&nbsp;≤ 10<sup>8</sup>)가 가장 먼저 도착한 사원부터 빈칸을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>데카가 화장실을 이용하기까지 몇 명의 사원이 화장실을 이용할 것인지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/7b7be1a5-a1a9-4330-85a7-91164bf0570d/-/preview/"></p>

<p>위와&nbsp;같이 줄을 선 경우를 생각해보자.&nbsp;(<em>x</em>, <em>y</em>) 는 사원의 근무 일수가 <em>x</em>, 화장실이 급한 정도가 <em>y</em>임을 나타낸다.&nbsp;[<em>x</em>, <em>y</em>]는 해당 사원이 데카임을 의미한다. 즉, 위의 그림에서 데카는 3번 사원이다.</p>

<p>이 경우 대기 중인 사원의 수&nbsp;<em>N</em>은 6이다. 데카의 앞에는 두 명이 있으므로&nbsp;<em>K</em>는 2다. 이때 사장이 3개의 줄로 나눠 설 것을 지시한다면,</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/d1028b32-1684-4fe8-882c-8677b788f4e8/-/preview/"></p>

<p>와 같이 나눠 설 수 있다. 이때 데카는 줄 번호 3의 선두다.</p>

<p>이제 화장실을 어떤 선두들이 이용하는지 알아보자.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/2931a1f5-cbe8-41cd-b112-f956a5fc6a13/-/preview/"></p>

<p>이 경우 근무 일수가 가장 높은 줄 번호 1의 선두가 화장실을 이용한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/60bac6e5-5722-4190-98f6-e7ab0d6c818e/-/preview/"></p>

<p>줄 번호 1, 2의 선두가 근무 일수는 1,500으로 같지만, 화장실이 급한 정도는 줄 번호 2의 선두가 더 높기 때문에 줄 번호 2의 선두가 화장실을 이용한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/cf759fc8-a704-4d23-b333-c9563b0e1efa/-/preview/"></p>

<p>줄 번호 1, 2의 선두가 근무 일수도 1,500으로 같고, 화장실이 급한 정도도 100으로 같지만, 줄 번호는 1이 더 낮기 때문에 줄 번호 1의 선두가 화장실을 이용한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/988f1a9a-8ecf-4fc4-8b10-ebac3ce25582/-/preview/"></p>

<p>줄 번호 2의 선두가 근무 일수가 제일 높기 때문에 화장실을 이용한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/56c00d17-dca3-4ec8-82f4-6ee76d17ab01/-/preview/"></p>

<p>줄 번호 3의 선두가 근무 일수가 제일 높으며, 이 사원이 데카이므로 줄에 서 있던 인원 중 데카보다 먼저 화장실을 이용한 사원의 수 4를 출력하면 정답이다.</p>

				</div>
				</div>','6 3 2
3000 100
1500 200
1000 500
1500 100
1500 100
1500 100
','4
','DATA_STRUCTURE'),
                                                                                                                (8049,'BAEKJOON','https://www.acmicpc.net/problem/19644',19644,'좀비 떼가 기관총 진지에도 오다니','1초','1024 MB',13,'<p>킬로와 헥토는 좀비 떼로부터 탄약고를 사수하는 데에 성공했다. 포상 휴가나 조기 전역을 기대했으나 좀비 사태로 인해 계엄령이 선포되면서 오히려 전역이 연기되고 기관총 진지에 배치되었다.</p>

<p>전역이 연기된 킬로와 헥토에게 좀비 떼가 다가오기 시작했다.</p>

<p>기관총 진지 앞쪽 길의 거리는&nbsp;<em>L</em> m이며, 진지로부터 <em>i</em> m 떨어진 곳에 있는 좀비의 체력은&nbsp;<em>Z<sub>i</sub></em>이다.&nbsp;체력이 0 이하가 된 좀비는 영구적으로 죽는다.</p>

<p>기관총 진지에서 킬로와 헥토는 좀비가 1 m 이동할 때 기관총 또는 수평 세열 지향성 지뢰를 한 번 사용할 수 있다. 수평 세열 지향성 지뢰를 격발하는 경우 후폭풍을 피하기 위해 킬로와 헥토는 기관총 진지 밑으로 숨어야 한다. 즉, 수평 세열 지향성 지뢰 격발과 기관총 사격을 동시에 할 수는 없다.</p>

<ul>
	<li>기관총</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/fe32a3a9-5f9c-4b34-9d12-a968c00b6f49/-/preview/" style="width: 375px; height: 93.3333px;"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3c44c5e1-4270-4a75-b4ba-cb059831e552/-/preview/" style="width: 370.833px; height: 93.3333px;"></p>

<p>유효 사거리는 진지 앞으로부터&nbsp;<em>M<sub>L</sub></em> m이다. 유효 사거리 내의 각 1 m 마다 좀비의 체력을&nbsp;<em>M<sub>K</sub></em>만큼 낮춘다.&nbsp;</p>

<p>기관총 탄약은 엄청나게 많이 있으므로 신경쓰지 않아도 된다. 총열 교체나 장전, 총기 이상&nbsp;등을&nbsp;고려할&nbsp;필요 없이 계속 사격할 수 있다고 가정한다.</p>

<ul>
	<li>수평 세열 지향성 지뢰</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/228ad3ee-f06a-4d2c-a62f-adecc51a86f0/-/preview/" style="width: 370px; height: 91.6667px;"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/2edc08ef-04c2-4f16-901f-ae2bd3988512/-/preview/" style="width: 370.833px; height: 92.5px;"></p>

<p>유효 사거리는 진지 앞으로부터 1 m이다. 하지만 진지 바로 앞 1 m의 좀비는&nbsp;체력과 상관없이 제압할 수 있다.</p>

<p>수평 세열 지향성 지뢰는&nbsp;<em>C<sub>ammo</sub></em>개 있다.&nbsp;</p>

<p>기관총 진지라곤 하나 콘크리트로 지어진 토치카가 아니라 사대로 구축한 임시 진지이기 때문에 1 m 떨어진 길 위의 좀비를 제압하지 못한다면 사망한다.&nbsp;</p>

<p>과연 킬로와 헥토는 살아남을 수 있을까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 기관총 진지 앞쪽 길의 거리를 나타내는 정수&nbsp;<em>L</em>&nbsp;(1 ≤&nbsp;<em>L</em>&nbsp;≤ 3 × 10<sup>6</sup>)이 주어진다.&nbsp;</p>

<p>두 번째 줄에는 기관총의 유효 사거리를 나타내는 정수&nbsp;<em>M<sub>L</sub></em> (1 ≤&nbsp;<em>M<sub>L</sub></em>&nbsp;≤ 3 × 10<sup>6</sup>)과 각 1 m 당 살상력을 나타내는 정수&nbsp;<em>M<sub>K</sub></em> (1 ≤&nbsp;<em>M<sub>K</sub></em>&nbsp;≤ 100)가 빈칸을 사이에 두고 주어진다.</p>

<p>세 번째 줄에는 수평 세열 지향성 지뢰의 개수&nbsp;<em>C<sub>ammo</sub></em> (0&nbsp;≤&nbsp;<em>C<sub>ammo</sub></em>&nbsp;≤ 3 × 10<sup>6</sup>)가 주어진다.</p>

<p>네 번째 줄부터&nbsp;<em>L</em>개의 줄에 걸쳐서 정수가 하나씩 주어진다. 이 때 <em>i</em>&nbsp;(1 ≤&nbsp;<em>i</em> ≤ <em>L</em>)번째 정수는 기관총 진지에서 <em>i</em> m 떨어진 곳의 좀비의 체력&nbsp;<em>Z<sub>i</sub></em> (0 ≤&nbsp;<em>Z<sub>i</sub></em>&nbsp;≤ 3 × 10<sup>8</sup>)이다.&nbsp;<em>Z<sub>i</sub></em>가 0인 경우 <em>i</em> m 떨어진 곳에&nbsp;좀비가 없다는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>킬로와 헥토가 살아남을 수 있다면 <span style="color:#e74c3c;"><code><span style="background-color:#ecf0f1;">YES</span></code></span>, 살아남을 수 없다면 <span style="color:#e74c3c;"><code><span style="background-color:#ecf0f1;">NO</span></code></span>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
2 2
0
1
','YES
','DATA_STRUCTURE'),
                                                                                                                (8050,'BAEKJOON','https://www.acmicpc.net/problem/19651',19651,'수열과 쿼리 39','2초','512 MB',21,'<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li>1 i j x y : A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>에 초항이 x이고 공차가 y인 등차수열을 더한다. (1 ≤ i ≤ j ≤ N, -100,000 ≤ x, y ≤ 100,000)</li>
	<li>2 i j : i ≤ l < r ≤ j이면서 A<sub>l</sub>, A<sub>l+1</sub>, ..., A<sub>r</sub>이 등차수열인 가장 긴 연속 부분 수열의 길이를 출력한다. (1 ≤ i < j ≤ N)</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (-100,000 ≤ A<sub>i</sub> ≤ 100,000)</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p>

<p>모든 입력은 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 4 5
4
2 1 5
1 3 4 1 1
2 1 5
2 3 5
','5
3
2
','DATA_STRUCTURE'),
                                                                                                                (8036,'BAEKJOON','https://www.acmicpc.net/problem/19700',19700,'수업','1초','1024 MB',15,'<p>숭실대학교의 권욱제 교수는 새로운 강의를 준비하고 있다. 강의하기 귀찮은 권욱제 교수는 팀플 과제를 던져주고 대충 발표를 들으면서 한 학기 수업을 치우려고 한다. 그래서 수강생 $N$명을 몇 개의 팀으로 나누려고 한다. 그러나, 수강생들의 자존심이 세다. $i$번째 수강생은 팀원들 중 자신보다 키가 큰 사람이 $k_i$명 이상이면 강의실을 박차고 나갈 거라고 했다.</p>

<p>마음이 여린 권욱제 교수는 모든 수강생의 요구를 만족하도록 모든 수강생을 각각 하나의 팀에 넣으려 한다. 최소 몇 개의 팀을 만들어야 할까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 학생의 수 $N$이 주어진다.</p>

<p>이후 $N$개의 줄에 각 학생의 키 $h_i$와 최소 등수 $k_i$가 주어진다.</p>

<p>학생들의 키는 모두 다르다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>만들어야 하는 팀의 개수의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
172 1
161 2
188 4
154 2
180 1
','3
','DATA_STRUCTURE'),
                                                                                                                (8053,'BAEKJOON','https://www.acmicpc.net/problem/19848',19848,'빈 문자열 만들기','1초(추가시간없음)','1024 MB',19,'<p>0과 1로만 이루어져 있으며, 0의 개수와 1의 개수가 동일한 문자열 <span style="font-style: italic;">S</span>가 주어진다. 당신은 <span style="font-style: italic;">S</span>에 다음과 같은 작업을 여러 번 수행할 수 있다:</p>

<p><span style="font-style: italic;">S</span>의 길이 2<span style="font-style: italic;">k</span>인 연속한 부분문자열이 앞 <span style="font-style: italic;">k</span>개 문자가 모두 동일하고, 또한 뒤 <span style="font-style: italic;">k</span>개 문자가 서로 동일하며, 0과 1을 모두 포함할 때, 그 부분문자열을 제거할 수 있다.</p>

<p>예를 들어, <span style="font-style: italic;">S</span> = “0111000011”인 경우, <span style="font-style: italic;">S</span>의 2번째 문자부터 7번째 문자까지인 “111000”을 제거하는 것이 가능하다. 이 작업 후에는 제거된 부분의 앞부분과 뒷부분이 연결되어 <span style="font-style: italic;">S</span> = “0011”이 된다. 그러면 이제 한 번의 작업을 통해 “0011”을 제거할 수 있으므로 초기 <span style="font-style: italic;">S</span> = “0111000011”는 두 번의 작업을 통해 빈 문자열로 만들 수 있다.</p>

<p>여러분의 목표는 최소 횟수의 작업을 통해 <span style="font-style: italic;">S</span>를 빈 문자열로 만드는 것이다. 최소 횟수의 작업으로 <span style="font-style: italic;">S</span>를 빈 문자열로 만드는 과정을 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 0과 1로만 이루어진 문자열 <span style="font-style: italic;">S</span>가 주어진다. <span style="font-style: italic;">S</span>에 포함된 0의 개수와 1의 개수는 동일하다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>작업들을 통해 <span style="font-style: italic;">S</span>를 빈 문자열로 만드는 것이 불가능하다면 첫 줄에 <code>-1</code>을 출력한다.</p>

<p>그렇지 않은 경우, 첫 줄에 필요한 작업의 최소 횟수 <span style="font-style: italic;">K</span>를 출력한다. 그 다음 <span style="font-style: italic;">K</span>줄에 걸쳐 수행한 작업에 대한 정보를 출력한다.</p>

<p><span style="font-style: italic;">K</span>개 줄 중 <span style="font-style: italic;">i</span>번째 줄에는 두 정수 <span style="font-style: italic;">b</span><sub><span style="font-style: italic;">i</span></sub>와 <span style="font-style: italic;">e</span><sub><span style="font-style: italic;">i</span></sub>를 공백을 사이에 두고 출력한다. 이는 <span style="font-style: italic;">i</span>번째 작업에서 <span style="font-style: italic;">S</span>의 <span style="font-style: italic;">b</span><sub><span style="font-style: italic;">i</span></sub>번째 문자부터 <span style="font-style: italic;">e</span><sub><span style="font-style: italic;">i</span></sub>번째 문자로 이루어진 문자열을 제거하였음을 뜻한다.</p>

<p>최소 횟수의 작업으로 문자열을 지우는 방법이 여러 가지인 경우에는 그 중 아무 것이나 출력해도 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','0101110100
','4
2 3
4 5
3 6
1 2
','DATA_STRUCTURE'),
                                                                                                                (8062,'BAEKJOON','https://www.acmicpc.net/problem/19851',19851,'버거운 버거','3초(추가시간없음)','1024 MB',21,'<p>키파는 <span style="font-style: italic;">버거</span>운 직장에서 벗어나 새로운 직업에 도전하고자 햄<span style="font-style: italic;">버거</span>집을 차렸다. 키파는 케이크를 여러 차례 만들면서 빵은 좀 구워 봤지만 햄버거를 만드는 것은 처음이었기 때문에, 위아래의 구분이 있는 빵을 적당히 구워서 햄버거 패티로 햄버거가 들어간 탄수화물 폭탄의 <strong>버거운 버거</strong>를 만들어 팔기로 했다.</p>

<p style="margin-top: 15px;"><img alt="burgerish-burger" src="https://upload.acmicpc.net/de1597d0-0fc2-404e-90cc-ef970d35d1cc/-/preview/" style="display: block; margin-left: auto; margin-right: auto; width: 347.5px; max-width: 500px; height: 160.833px;"></p>

<p style="margin-bottom: 15px; text-align: center;">버거운 버거의 예시.</p>

<p>버거운 버거의 엄밀한 정의는 다음과 같다.</p>

<ul>
	<li>속이 위로 온 빵 X 위에 속이 아래로 온 빵 Y를 올린 것은 버거운 버거이다. 이때 X를 Y의 <strong>대응하는 쌍</strong>, Y를 X의 <strong>대응하는 쌍</strong>이라 정의하자.</li>
	<li>속이 위로 온 빵 X 위에 버거운 버거를 올리고, 그 위에 속이 아래로 온 빵 Y를 올린 것은 버거운 버거이다. 마찬가지로 이때 X를 Y의 <strong>대응하는 쌍</strong>, Y를 X의 <strong>대응하는 쌍</strong>이라 정의하자.</li>
	<li>버거운 버거 위에 버거운 버거를 올린 것은 버거운 버거이다.</li>
	<li>위 세 규칙으로 만들 수 없는 것은 버거운 버거가 아니다.</li>
</ul>

<p>키파는 총 <span style="font-style: italic;">N</span>개의 빵 굽는 기계를 일렬로 세워 두고 동시에 다루고 있다. 하나의 기계는 빵을 하나만 구울 수 있다. 가장 왼쪽의 것부터 오른쪽으로 순서대로 1부터 번호를 붙이자. 키파가 가게를 운영하는 도중에 다음 둘 중 하나의 상황이 <span style="font-style: italic;">Q</span>번 발생할 수 있다.</p>

<ul>
	<li><span style="font-style: italic;">a</span>번 기계부터 <span style="font-style: italic;">b</span>번 기계까지의 빵이 곧 타려고 하기 때문에, 각각 뒤집어 줘야 한다.</li>
	<li>손님이 <span style="font-style: italic;">a</span>번 기계부터 <span style="font-style: italic;">b</span>번 기계까지의 빵을 차곡차곡 쌓아 주기를 원한다. 즉, 이 과정 중 <strong>빵을 뒤집어 쌓으면 안 되고</strong>, 가장 아래에 <span style="font-style: italic;">a</span>번 기계에서 나온 빵, 그 위에 (<span style="font-style: italic;">a</span>+1)번 기계에서 나온 빵, 이렇게 하여 가장 위에 <span style="font-style: italic;">b</span>번 기계에서 나온 빵이 <strong>순서대로</strong> 쌓여야 한다. 키파는 기계에 빵이 없으면 재료가 다 떨어진 것처럼 보인다고 생각했기 때문에, 한 주문이 끝난 이후 그 주문을 받기 이전의 상태대로 빵의 위아래를 맞춰서 채워 둔다.</li>
</ul>

<p>그러나 손님들이 햄버거를 만들기를 원하는 빵을 쌓았을 때, 어떤 빵은 대응하는 쌍이 존재하지 않아 버거운 버거로서 실격일 수 있다. 키파는 각 손님의 주문대로 빵을 쌓은 뒤, 이 빵을 버거운 버거로 만들기 위해 쌓아둔 빵의 순서를 유지하면서 미리 구워 둔 빵을 최소한으로 집어넣고자 한다. 키파는 손님들의 건강에 관심이 많기 때문에 각 주문마다 버거운 버거의 높이, 즉 버거운 버거에 들어간 빵의 개수를 알고자 한다. 이를 구하는 프로그램을 작성해서 키파를 도와 주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 양의 정수 <span style="font-style: italic;">N</span>이 주어진다.</p>

<p>둘째 줄에 길이가 <span style="font-style: italic;">N</span>이고 <code>(</code>와 <code>)</code>로만 구성된 문자열이 주어진다. 모든 1 ≤ <span style="font-style: italic;">i</span> ≤ <span style="font-style: italic;">N</span>에 대해 <span style="font-style: italic;">i</span>번째 문자가 <code>(</code>인 경우 속이 위로 온 빵이 <span style="font-style: italic;">i</span>번 기계에, <code>)</code>인 경우 속이 아래로 온 빵이 <span style="font-style: italic;">i</span>번 기계에 들어 있다는 의미이다.</p>

<p>셋째 줄에 양의 정수 <span style="font-style: italic;">Q</span>가 주어진다.</p>

<p>넷째 줄부터 <span style="font-style: italic;">Q</span>개의 줄에 세 개의 양의 정수 <span style="font-style: italic;">t</span>, <span style="font-style: italic;">a</span>, <span style="font-style: italic;">b</span>로 상황이 주어진다. <span style="font-style: italic;">t</span>는 2 이하이며, 1 ≤ <span style="font-style: italic;">a</span> ≤ <span style="font-style: italic;">b</span> ≤ <span style="font-style: italic;">N</span>이다.</p>

<p><span style="font-style: italic;">t</span> = 1인 경우 <span style="font-style: italic;">a</span>번 기계부터 <span style="font-style: italic;">b</span>번 기계까지의 빵을 뒤집어 줘야 함을 의미한다.</p>

<p><span style="font-style: italic;">t</span> = 2인 경우 <span style="font-style: italic;">a</span>번 기계부터 <span style="font-style: italic;">b</span>번 기계까지의 빵을 꺼내 버거운 버거로 만들어 달라는 주문이 들어왔음을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 주문(<span style="font-style: italic;">t</span> = 2)마다 버거운 버거의 높이를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
(()(
5
1 2 3
2 1 4
1 1 4
1 2 2
2 3 4
','6
4
','DATA_STRUCTURE'),
                                                                                                                (8055,'BAEKJOON','https://www.acmicpc.net/problem/19852',19852,'공정한 회의','2초(추가시간없음)','1024 MB',22,'<p>먼 미래, SNUPS는 알고리즘 교육 열풍에 힘입어 총 $N$명의 회원이 존재하는 큰 동아리가 되었다. 모든 서로 다른 두 회원 사이에는 친밀한 정도를 나타내는 “친밀 거리”를 정의할 수 있다. $i$번 회원과 $j$번 회원 사이의 친밀 거리는 정수 $C(i,j)$로 나타내며, 값이 작을수록 더 친밀함을 의미한다. 친밀 거리 $C(i,j)$는 모든 $1\le i, j\le N, i\ne j$에 대해 $1\le C(i,j)\le 10^7$, $C(i,j)=C(j,i)$를 만족한다.</p>

<p>SNUPS는 모든 회원의 의견을 모두 반영하면서도 효율적으로 동아리를 운영하기 위해, 안건이 발생할 때마다 $N$명의 회원 중 랜덤하게 뽑힌 세 명만이 회의를 진행하는 시스템을 도입했다. 하지만 이 시스템 하에서는 뽑힌 세 명 중 친한 두 명이 연합하면 나머지 한 명의 의견이 제대로 반영되지 않는 문제가 발생했다. 구체적으로, 회의를 위해 뽑힌 서로 다른 세 회원이 각각 $i, j, k$번 회원이라고 할 때 $C(i,j) < C(j,k)$이고 $C(i,j) < C(i,k)$이면 $k$번 회원의 의견이 반영되지 못하고, 이러한 경우 회의가 <strong>불공정</strong>하다고 한다.</p>

<p>제연이는 어떤 세 명이 회의를 진행하더라도 불공정한 경우가 생기지 않게끔 하고 싶다. 다행히도 SNUPS는 커질 대로 커져, $M$쌍의 회원을 제외하고는 아직 서로 모르는 상태이다. 이미 서로 아는 회원들 사이의 친밀 거리를 바꿀 수는 없지만, 서로 모르는 회원들 간의 친밀 거리를 원하는 대로 조정하는 것은 인간 심리에 통달한 제연이에게는 무척 간단한 일이다. 물론 최종적으로 정해진 친밀 거리는 $1\le i, j\le N, i\ne j$에 대해 $1\le C(i,j)\le 10^7$, $C(i,j)=C(j,i)$를 만족하는 정수여야 한다.</p>

<p>만약 이러한 계획이 실현 가능하다면, 친밀한 SNUPS를 위해 $\sum_{i=1}^{N}{\sum_{j=i+1}^{N}{C(i,j)}}$를 최소로 만들려고 한다. SNUPS의 밝은 미래를 위해 제연이의 계획이 실현 가능한지 판단하고, 가능하다면 $\sum_{i=1}^{N}{\sum_{j=i+1}^{N}{C(i,j)}}$의 최솟값을 구하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에는 회원의 수 $N$, 이미 서로를 알고 있는 관계의 수 $M$이 주어진다.</p>

<p>둘째 줄부터 $M$개의 줄에 걸쳐 회원들의 관계에 대한 정보가 주어진다. $i+1$번째 줄에는 세 개의 정수 $A_{i}, B_{i}, D_{i}$가 공백을 사이에 두고 주어지며, $A_{i}$번 회원과 $B_{i}$번 회원이 이미 알고 있는 관계이며 이들의 친밀 거리는 $D_{i}$임을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 제연이의 계획이 가능하지 않다면 <code>-1</code>을, 가능하다면 $\sum_{i=1}^{N}\sum_{j = i+1}^{N} C(i,j)$의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2
1 2 5
2 4 3
','14
','DATA_STRUCTURE'),
                                                                                                                (8058,'BAEKJOON','https://www.acmicpc.net/problem/19854',19854,'직선형 분자 만들기','5초(추가시간없음)','1024 MB',26,'<p>레프는 화학실험 시간에 실험 재료로 분자를 받았다. 분자를 구성하는 원자는 총 <span style="font-style: italic;">N</span>개로 1번부터 <span style="font-style: italic;">N</span>번까지 서로 다른 번호가 붙어 있고, 두 원자를 연결하는 총 <span style="font-style: italic;">M</span>개의 서로 다른 화학 결합이 존재한다. 각 결합은 서로 다른 두 원자를 연결한다. 즉, 분자는 방향성이 없는 그래프로 생각할 수 있다. 실제 화학에서의 예시와 다르게, 분자가 꼭 연결되어 있거나, 2개 이상의 원자로 이루어져 있거나, 4개 이하의 다른 원자와 연결되어 있지는 <strong>않을 수 있음</strong>에 주의하라.</p>

<p>레프는 실험을 위해 최첨단 기계를 사용할 것이다. 레프가 기계에 두 정수 1 ≤ <span style="font-style: italic;">L</span> ≤ <span style="font-style: italic;">R</span> ≤ <span style="font-style: italic;">N</span>을 입력하면, 기계는 번호가 <span style="font-style: italic;">L</span> 이상 <span style="font-style: italic;">R</span> 이하인 원자를 <strong>제외한 다른 모든 원자</strong>를 제거한다. <span style="font-style: italic;">x</span>번 원자를 제거한다는 것은, <span style="font-style: italic;">x</span>번 원자 및 <span style="font-style: italic;">x</span>번 원자와 연결된 화학 결합을 모두 제거하는 것을 말한다.</p>

<p>레프는 이렇게 만든 분자를 보고서에 적어야 하는데, 보고서에 적을 분자는 <strong>직선형</strong>이어야 한다. 즉, 직선 위에 분자를 구성하는 원자들을 적당히 재배치하여 인접한 원자들끼리는 모두 화학 결합으로 이어져 있고, 인접하지 않은 원자들끼리는 결합이 없도록 할 수 있어야 한다.</p>

<p>숙련된 화학도인 레프는 이런 분자는 얼마든지 많이 만들 수 있지만, 보고서 추가 점수를 받기 위해 만들 수 있는 직선형 분자가 총 몇 가지인지도 적어 내려고 한다. 즉, 레프는 직선형 분자를 만들기 위해 실험 기계에 입력할 수 있는 정수 쌍 (<span style="font-style: italic;">L</span>, <span style="font-style: italic;">R</span>)의 개수를 알고 싶다. 레프를 위해 가능한 분자의 개수를 구하는 프로그램을 작성해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫째 줄에는 두 정수 <span style="font-style: italic;">N</span>, <span style="font-style: italic;">M</span>이 공백을 사이에 두고 주어진다. 분자에 포함되는 원자의 개수가 <span style="font-style: italic;">N</span>개이고, 화학 결합의 개수가 <span style="font-style: italic;">M</span>개임을 의미한다.</p>

<p>둘째 줄부터 <span style="font-style: italic;">M</span>개의 줄에 걸쳐 화학 결합에 대한 정보가 주어진다. (<span style="font-style: italic;">i&nbsp;</span>+ 1)번째 줄에는 두 정수 <span style="font-style: italic;">A</span><sub><span style="font-style: italic;">i</span></sub>, <span style="font-style: italic;">B</span><sub><span style="font-style: italic;">i</span></sub>가 공백을 사이에 두고 주어지는데, 이는 <span style="font-style: italic;">A</span><sub><span style="font-style: italic;">i</span></sub>번 원자와 <span style="font-style: italic;">B</span><sub><span style="font-style: italic;">i</span></sub>번 원자를 잇는 화학 결합이 존재한다는 의미이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 실험 기계에 입력할 수 있는 정수 쌍의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
1 2
2 3
3 1
','5
','DATA_STRUCTURE'),
                                                                                                                (8056,'BAEKJOON','https://www.acmicpc.net/problem/19856',19856,'계주 코스 정하기','2초(추가시간없음)','1024 MB',26,'<p>승현이는 한 학교에서 선생님으로 근무하고 있다. 이번에 운동회를 담당하게 된 승현이는 릴레이 계주의 코스 중 하나를 어떻게 만들지 고심 중이다.</p>

<p>이 코스는 <span style="font-style: italic;">N</span>행 <span style="font-style: italic;">M</span>열의 구역으로 나뉜 공간에서 치러질 것이며, 위에서부터 <span style="font-style: italic;">i</span>번째 행, 왼쪽에서부터 <span style="font-style: italic;">j</span>번째 열의 구역은 (<span style="font-style: italic;">i</span>, <span style="font-style: italic;">j</span>)로 표현된다. 승현이는 1열의 한 구역을 시작 지점으로, <span style="font-style: italic;">M</span>열의 한 구역을 도착 지점으로 하는 코스를 만들고자 한다. 이때, 도착 지점은 시작 지점보다 위쪽 구역은 아니어야 한다. 즉, 코스가 구역 (<span style="font-style: italic;">S</span>, 1)에서 시작하여 (<span style="font-style: italic;">T</span>, <span style="font-style: italic;">M</span>)에서 끝난다고 할 때, 1 ≤ <span style="font-style: italic;">S</span> ≤ <span style="font-style: italic;">T</span> ≤ <span style="font-style: italic;">N</span>가 성립해야 한다. 따라서 가능한 시작 지점과 도착 지점의 후보는 <span style="display: inline-block; vertical-align: middle; letter-spacing: 0.1em; text-align: center; margin: 0 2px; line-height: 1.4;"><span style="display: block;"><span style="font-style: italic;">N</span>(<span style="font-style: italic;">N</span>+1)</span><span style="display: block; border-top: 1px solid black;">2</span></span>가지가 존재한다.</p>

<p>학생들은 최단 경로로 도착 지점에 도달하고 싶어 하기 때문에, 시작 지점에서 출발하여 오른쪽이나 아래쪽으로 인접한 구역으로 이동하는 것만을 반복하여 도착 지점에 도달하고자 할 것이다.</p>

<p>승현이네 학교의 전통은 릴레이 계주에서 바통 대신 선인장을 들고 달리는 것이다. 그러나 선인장은 추위에 약하기 때문에, 만약 학생이 선인장을 들고 기온이 0도 미만인 곳을 지나가게 된다면 선인장은 시들고 만다. 이 릴레이 경주는 선인장이 시들면 탈락 처리되기 때문에, 학생들은 기온이 0도 이상인 구역만 지나가야 한다.</p>

<p><span style="font-style: italic;">i</span>행의 구역은 북서풍의 영향으로 <span style="font-style: italic;">A</span><sub><span style="font-style: italic;">i</span></sub>도의 영향을 받고, <span style="font-style: italic;">j</span>열의 구역은 동남풍의 영향으로 <span style="font-style: italic;">B</span><sub><span style="font-style: italic;">j</span></sub>도의 영향을 받는다. 따라서, 구역 (<span style="font-style: italic;">i</span>, <span style="font-style: italic;">j</span>)의 기온은 (<span style="font-style: italic;">A</span><sub><span style="font-style: italic;">i&nbsp;</span></sub>+&nbsp;<span style="font-style: italic;">B</span><sub><span style="font-style: italic;">j</span></sub>)도이다.</p>

<p>시작 지점과 도착 지점이 정해졌을 때, 기온이 0도 이상인 구역만 지나면서 시작 지점부터 오른쪽 또는 아래쪽으로 인접한 구역으로 이동하는 것을 반복하여 도착 지점에 도달하는 것이 가능하다면 이 경우는 릴레이 계주 코스로 가능한 경우이다. 이때, 시작 지점과 도착 지점 역시 기온이 0도 이상이어야 한다.</p>

<p><span style="display: inline-block; vertical-align: middle; letter-spacing: 0.1em; text-align: center; margin: 0 2px; line-height: 1.4;"><span style="display: block;"><span style="font-style: italic;">N</span>(<span style="font-style: italic;">N</span>+1)</span><span style="display: block; border-top: 1px solid black;">2</span></span>가지의 총 후보 중, 가능한 시작 지점과 도착 지점 쌍의 경우의 수를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 두 정수 <span style="font-style: italic;">N</span>과 <span style="font-style: italic;">M</span>이 공백을 사이에 두고 주어진다.</p>

<p>둘째 줄에 <span style="font-style: italic;">N</span>개의 정수 <span style="font-style: italic;">A</span><sub>1</sub>, <span style="font-style: italic;">A</span><sub>2</sub>, …, <span style="font-style: italic;">A</span><sub><span style="font-style: italic;">N</span></sub>이 공백을 사이에 두고 주어진다.</p>

<p>셋째 줄에 <span style="font-style: italic;">M</span>개의 정수 <span style="font-style: italic;">B</span><sub>1</sub>, <span style="font-style: italic;">B</span><sub>2</sub>, …, <span style="font-style: italic;">B</span><sub><span style="font-style: italic;">M</span></sub>이 공백을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 가능한 코스의 개수, 즉 가능한 (시작 지점, 도착 지점) 쌍의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
-1 0 1
-1 0 1
','1
','DATA_STRUCTURE'),
                                                                                                                (8066,'BAEKJOON','https://www.acmicpc.net/problem/19955',19955,'침략전쟁','3초(추가시간없음)','512 MB',21,'<p>침략 전쟁은 <em>N&nbsp;</em>×&nbsp;<em>N</em>&nbsp;정사각형 모양의 격자판에서 이루어지는 온라인 게임이다. 격자판의 맨 왼쪽 위가 (1, 1)이고 맨 왼쪽 아래가 (N,1)이다.</p>

<p>격자판에는 여러&nbsp;국가가 있으며 서로의 영토를 공격하여 전투를 펼치고 자신의 영토를 확장한다.</p>

<p>두 국가 간의 전투는 전투단계에 일어난다. 전투는&nbsp;서로의 병사의 수만을 비교하여 승부를 가리며 병사의 수가 같다면 아무 일도 일어나지 않는다. 전투는 국가총력전을 벌이기 때문에 패배한 국가의&nbsp;수도를 제외한 다른 모든 영토들은 승리한 국가에 귀속된다. 또한 전투는 병사간의 1대1 교환으로 이루어지기 때문에, 패배한 국가의 병사는 모두 사망하고 승리한 국가의 병사는 ((승리국의 전투 전 병사의 수) - (패배국의 전투 전 병사의&nbsp;수))만큼 살아남는다. 수도를 잃지 않기 때문에 국가가 사라지는 일은 없다.</p>

<p>징집단계에 모든 국가는 보유한 영토 하나당 한 명의 병사가 늘어난다. (만약 3개의 영토를 보유한 국가가 있다면 그 국가는&nbsp;3명의 병사가 늘어나게 된다.)</p>

<p>확장단계에는 모든 국가가 자신의&nbsp;영토와 상하좌우로 인접한 영토 중 어느 국가도 소유하지 않은&nbsp;영토를 귀속시키는 자동전투가 일어난다. 만약 두 개 이상의 국가가 자동전투로 같은 영토를 귀속시키려 하면 병사의 수가 가장 많은 국가가 차지한다. 병사의 수마저&nbsp;같다면 번호가 더 작은 국가가 차지한다. (국가의 번호는 수도의 좌표가 (<i>A</i>&nbsp;, <i>B</i>)라고 했을 때&nbsp;(<em>A&nbsp;</em>×&nbsp;<em>N&nbsp;</em>+ <em>B</em>)이다.)</p>

<p><meta charset="utf-8"></p>

<p dir="ltr">침략전쟁의 하루는 다음과 같은&nbsp;순서로 진행된다.</p>

<ul dir="ltr">
	<li>첫 번째 단계는 전략단계로 각 나라들이 그날 어떠한 전략을 사용할지 구상하며 쉬어가는 단계이다.</li>
	<li>두 번째 단계는 전투단계로 국가 간의 전투가 이뤄진다.</li>
	<li>세 번째 단계는 징집단계로 국가별로 보유한 영토의 수만큼 병사의 수가 늘어난다.</li>
	<li>네 번째 단계는 확장단계로 자동전투가 일어난다.</li>
</ul>

<p dir="ltr">침략전쟁은 실시간으로 이루어지는 게임이기 때문에 두 가지 쿼리에 대한 처리를 해야 한다.</p>

<ul dir="ltr">
	<li>1 t <em>x<sub>a</sub>&nbsp;y<sub>a</sub>&nbsp;x<sub>b</sub>&nbsp;y</em><sub><em>b</em>&nbsp;</sub>: <em>t</em>일의 전투단계에 (<em>x<sub>a&nbsp;</sub>,&nbsp;y<sub>a</sub></em>) 좌표의 영토를 소유한 국가가 (<em>x<sub>b</sub><sub>&nbsp;</sub>,&nbsp;y<sub>b</sub></em>)좌표의 영토를&nbsp;소유한 국가를 공격한다. (두 국가가 같은 국가인&nbsp;경우 아무 일도 일어나지 않으며, (<em>x<sub>a&nbsp;</sub>,&nbsp;y<sub>a</sub></em>) 좌표의 영토를 소유한 국가와&nbsp;(<em>x<sub>b&nbsp;</sub>,&nbsp;y<sub>b</sub></em>) 좌표의 영토를 소유한 국가가 존재하는 경우만 입력으로 주어진다.)</li>
	<li>2 <em>t x<sub>c</sub> y<sub>c</sub></em>&nbsp;: <em>t</em>일의 전략단계에&nbsp;(<em>x<sub>c</sub> , y<sub>c</sub></em>) 좌표의 영토를 소유한&nbsp;국가의 병사의 수를 출력한다. ((<em>x<sub>c</sub> , y<sub>c</sub></em>) 좌표의 영토를 소유한 국가가 존재하는 경우만 입력으로 주어진다.)</li>
</ul>

<p>초기 국가의 정보가 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력한다.</p>

<p>게임은 0일의 징집단계부터 시작한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 격자판의 크기인 <em>N</em>, 초기 국가의 수 <em>M</em>, 쿼리의 수 <em>Q</em>가 주어진다.</p>

<p>둘째 줄부터 <em>M</em>개의 줄에 초기 국가의 정보가 주어진다. 국가의 정보는 3개의 정수 <em>x, y, k</em>로 이루어져 있다. 이는 국가의 수도가 (<em>x, y</em>)좌표의 영토에 존재하며 병사의 수가&nbsp;<em>k</em>명임을 의미한다.</p>

<p>초기 국가들은 수도 외에 영토를 갖고 있지 않는다.</p>

<p>다음 <em>Q</em>개의 줄에 위와 같은 형식의 쿼리가 주어진다.</p>

<p>최소 1번 이상의 2번 쿼리가 주어짐이 보장된다.</p>

<p>쿼리들의 순서는 날짜에 대해 오름차순임이 보장되며 같은 날짜에 여러 개의 쿼리가 들어오는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리가 주어질 때마다 해당 국가의 병사의 수를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 2 3
1 1 5
3 3 2
2 2 1 1
1 4 1 1 3 3
2 7 1 1
','9
33
','DATA_STRUCTURE'),
                                                                                                                (8065,'BAEKJOON','https://www.acmicpc.net/problem/20030',20030,'트리와 쿼리 17','2초(추가시간없음)','1024 MB',24,'<p>$N$개의 정점으로 이루어진 트리가 있다. 정점은 1번부터 $N$번까지 번호가 매겨져 있고, 1번 정점은 루트이다. 각 정점 $i$에는 정수 $A[i]$가 저장되어 있다. 가장 처음에 $A[i]$는 0이다.</p>

<p>다음과 같은 쿼리를 수행해야 한다.</p>

<ul>
	<li><code>1 u</code>: 정점 $u$를 루트로 하는 서브 트리의 모든 정점 $i$의 $A[i]$에 1을 더한다.</li>
	<li><code>2 u v</code>: 정점 $u$에서 정점 $v$로 가는 유일한 최단 경로에 있는 모든 정점 $i$의 $A[i]$에 1을 더한다. $u$와 $v$는 같을 수도 있다.</li>
</ul>

<p>각각의 쿼리를 수행한 후&nbsp;$\sum_{y = 1}^{N} A[y] \times dist(x, y)$ 의 값을 가장 작게 만드는 정점 $x$를 출력한다.&nbsp;$dist(x, y)$ 는 $x$에서&nbsp;$y$로 가는 경로에 존재하는 간선의 개수와 같다. 가능한 정점 x가 여러가지면, 루트에서 거리가 가장 가까운 정점을 출력한다. 그러한 정점은 항상 유일하다는 것을 증명할 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 $N$이 주어진다.&nbsp;($2 \le N \le 100\,000$)</p>

<p>다음 $N-1$개의 줄에는 트리의 간선이 주어진다. 각 줄은 공백으로 구분된 두 정수 $u$와 $v$가 주어지고, 정점 $u$와 정점 $v$를 연결하는 간선을 의미한다. ($1 \le u, v \le N, u \neq v$)</p>

<p>다음 줄에는 수행해야 하는 쿼리의 개수 $Q$가 주어진다. ($1 \le Q \le 100\,000$).</p>

<p>다음 $Q$개의 줄에는 쿼리가 한 줄에 하나씩 주어지며, 쿼리는 다음과 같은 형식이다.</p>

<ul>
	<li><code>1 u</code>&nbsp;($1 \le u \le N$)</li>
	<li><code>2 u v</code>&nbsp;($1 \le u, v \le N$)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>쿼리를 수행한 후 출력해야 하는 값을 Q개의 줄에 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1 6
1 7
7 3
3 2
7 5
5 4
4
1 2
1 4
1 6
2 6 7
','2
7
7
1
','DATA_STRUCTURE'),
                                                                                                                (8073,'BAEKJOON','https://www.acmicpc.net/problem/20040',20040,'사이클 게임','1초','512 MB',12,'<p>사이클 게임은 두 명의 플레이어가 차례대로 돌아가며 진행하는 게임으로, 선 플레이어가 홀수 번째 차례를, 후 플레이어가 짝수 번째 차례를 진행한다. 게임 시작 시 0 부터 <em>n</em> ? 1 까지 고유한 번호가 부여된 평면 상의 점 <em>n</em> 개가 주어지며, 이 중 어느 세 점도 일직선 위에 놓이지 않는다. 매 차례 마다 플레이어는 두 점을 선택해서 이를 연결하는 선분을 긋는데, 이전에 그린 선분을 다시 그을 수는 없지만 이미 그린 다른 선분과 교차하는 것은 가능하다. 게임을 진행하다가 처음으로 사이클을 완성하는 순간 게임이 종료된다. 사이클 <em>C</em>는 플레이어가 그린 선분들의 부분집합으로, 다음 조건을 만족한다.</p>

<blockquote>
<p><em>C</em>에 속한 임의의 선분의 한 끝점에서 출발하여 모든 선분을 한 번씩만 지나서 출발점으로 되돌아올 수 있다.</p>
</blockquote>

<p>문제는 선분을 여러 개 그리다 보면 사이클이 완성 되었는지의 여부를 판단하기 어려워 이미 사이클이 완성되었음에도 불구하고 게임을 계속 진행하게 될 수 있다는 것이다. 이 문제를 해결하기 위해서 게임의 진행 상황이 주어지면 몇 번째 차례에서 사이클이 완성되었는지, 혹은 아직 게임이 진행 중인지를 판단하는 프로그램을 작성하려 한다.</p>

<p>입력으로 점의 개수 <em>n</em>과 <em>m</em> 번째 차례까지의 게임 진행 상황이 주어지면 사이클이 완성 되었는지를 판단하고, 완성되었다면 몇 번째 차례에서 처음으로 사이클이 완성된 것인지를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 표준입력을 사용한다. 입력의 첫 번째 줄에는 점의 개수를 나타내는 정수 3 ≤ <em>n</em> ≤ 500,000 과 진행된 차례의 수를 나타내는 정수 3 ≤ <em>m</em> ≤ 1,000,000 이 주어진다. 게임에서 사용하는 <em>n</em>개의 점에는 0 부터 <em>n</em> ? 1 까지 고유한 번호가 부여되어 있으며, 이 중 어느 세 점도 일직선 위에 놓이지&nbsp;않는다. 이어지는 <em>m</em> 개의 입력 줄에는 각각 <em>i</em>번째 차례에 해당 플레이어가 선택한 두 점의 번호가 주어진다 (1 ≤ <em>i</em> ≤ <em>m</em>).</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 표준출력을 사용한다. 입력으로 주어진 케이스에 대해, <em>m</em> 번째 차례까지 게임을 진행한 상황에서 이미 게임이 종료되었다면 사이클이 처음으로 만들어진 차례의 번호를 양의 정수로 출력하고, <em>m</em> 번의 차례를 모두 처리한 이후에도 종료되지 않았다면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 5
0 1
1 2
2 3
5 4
0 4
','0
','DATA_STRUCTURE'),
                                                                                                                (8033,'BAEKJOON','https://www.acmicpc.net/problem/20052',20052,'괄호 문자열 ?','0.5초','512 MB',17,'<p>괄호 문자열은&nbsp;(와 )로 이루어진 문자열이고,&nbsp;올바른 괄호 문자열은 다음과 같이 정의된다.</p>

<ol>
	<li>빈 문자열은 올바른 괄호 문자열이다.</li>
	<li>S가 올바른 괄호 문자열일 때, (S)도 올바른 괄호 문자열이다.</li>
	<li>S와 T가 올바른 괄호 문자열이라면, ST도 올바른 괄호 문자열이다.</li>
	<li>모든 올바른 괄호 문자열은 위의 3개 규칙으로만 만들 수 있다.</li>
</ol>

<p>(와 )로 이루어진 괄호 문자열 S = s<sub>1</sub>s<sub>2</sub>...s<sub>N</sub>과 M개의 쿼리가 주어진다. 쿼리는 두 정수 i, j (1 ≤ i ≤ j ≤ N)로 이루어져 있고,&nbsp;쿼리가 의미하는 것은 다음과 같다.</p>

<ul>
	<li>S의 부분 문자열 S<sub>i</sub>S<sub>i+1</sub>...S<sub>j</sub>가 올바른 괄호 문자열이면 1, 아니면 0</li>
</ul>

<p>모든 쿼리를 수행하고, 쿼리의 결과를 누적한 값을 구해보자.</p>

<ul>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 문자열 S가 주어진다. 둘째 줄에 쿼리의 개수 M이 주어진다. 셋째 줄부터 M개의 줄에 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>쿼리의 결과를 누적한 값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','()()()()
8
1 8
2 7
3 6
2 8
1 5
5 8
2 4
4 8
','3
','DATA_STRUCTURE'),
                                                                                                                (8077,'BAEKJOON','https://www.acmicpc.net/problem/20131',20131,'트리 만들기','2초','1024 MB',16,'<p>정점이 <em>N</em>개가 있는 트리가 있고 각 정점들은 1부터 <em>N</em>까지 번호가 매겨있다. 해당 트리로부터 (<em>N</em>-2)개의 양의 정수로 이루어진 수열 하나를 다음과 같은 과정을 통해서 만들 것이다.</p>

<ol>
	<li>차수가 1인 정점들 중에서 번호가 가장 큰 정점을 하나 고른다. 해당 정점을 <em>x</em>라고 부르자.</li>
	<li>정점 <em>x</em>와 인접한 정점의 번호를 수열에 넣는다.</li>
	<li>정점 <em>x</em>와 인접한 간선들을 해당 트리에서 지운다.</li>
	<li>1번부터 3번까지의 과정을 총 (<em>N</em>-2) 번 진행한다.</li>
</ol>

<p>수열 {<em>a<sub>1</sub></em>, ... , <em>a<sub>N-2</sub></em>}가 주어졌을 때, 위의 과정을 통해서 이 수열을 만들 수 있는 트리를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>다음과 같이 입력이 주어진다.</p>

<div style="background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;"><em>N</em><br>
<em>a<sub>1</sub></em>&nbsp;. . .&nbsp;<em>a<sub>N-2</sub></em></div>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>해당 트리가 존재한다면 간선 (<em>N</em>-1) 개를 다음 규칙에 만족하게 출력한다.</p>

<ul data-indent="0" data-stringify-type="unordered-list">
	<li>각 간선은 <span class="marker"><em>a</em> <em>b</em></span> 형태로 출력해야 하며 <em>a</em> < <em>b</em>를 만족하여야 한다.</li>
	<li>간선을 사전 순으로 출력해야 한다. 즉, 임의의 두 간선 (<em>a<sub>1</sub></em>, <em>b<sub>1</sub></em>)과 (<em>a<sub>2</sub></em>, <em>b<sub>2</sub></em>)에 대해 <em>a<sub>1</sub></em> < <em>a<sub>2</sub></em>를 만족하거나&nbsp;<em>a<sub>1</sub></em> =&nbsp;<em>a<sub>2</sub></em>,&nbsp;<em>b<sub>1</sub></em> < <em>b<sub>2</sub></em>를 만족하는 경우&nbsp;(<em>a<sub>1</sub></em>, <em>b<sub>1</sub></em>) 간선을 (<em>a<sub>2</sub></em>, <em>b<sub>2</sub></em>) 간선보다 먼저 출력해야 한다.</li>
</ul>

<p>만약에 트리가 존재하지 않거나 2개 이상 존재하는 경우에는 <span style="color:#e74c3c;"><code>-1</code></span>을 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9
9 4 4 5 4 4 6
','1 6
2 4
3 5
4 5
4 6
4 7
4 9
8 9
','DATA_STRUCTURE'),
                                                                                                                (8078,'BAEKJOON','https://www.acmicpc.net/problem/20136',20136,'멀티탭 스케줄링 2','2초','512 MB',17,'<p>기숙사에서 살고 있는 준규는 한 개의 멀티탭을 이용하고 있다. 준규는&nbsp;키보드, 헤어드라이기, 핸드폰 충전기, 디지털 카메라 충전기 등 여러 개의 전기용품을 사용하면서 어쩔 수 없이 각종 전기용품의 플러그를 뺐다 꽂았다 하는 불편함을 겪고 있다. 그래서 준규는&nbsp;자신의 생활 패턴을 분석하여, 자기가 사용하고 있는 전기용품의 사용순서를 알아내었고, 이를 기반으로 플러그를 빼는 횟수를 최소화하는 방법을 고안하여 보다 쾌적한 생활환경을 만들려고 한다.</p>

<p>예를 들어 3 구(구멍이 세 개 달린) 멀티탭을 쓸 때, 전기용품의 사용 순서가 아래와 같이 주어진다면,&nbsp;</p>

<ol>
	<li>키보드</li>
	<li>헤어드라이기</li>
	<li>핸드폰 충전기</li>
	<li>디지털 카메라 충전기</li>
	<li>키보드</li>
	<li>헤어드라이기</li>
</ol>

<p>키보드, 헤어드라이기, 핸드폰 충전기의 플러그를 순서대로 멀티탭에 꽂은 다음 디지털 카메라 충전기 플러그를 꽂기 전에 핸드폰충전기 플러그를 빼는 것이 최적일 것이므로 플러그는 한 번만 빼면 된다.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 멀티탭 구멍의 개수 N (1 ≤ N ≤ 500,000)과 전기 용품의 총 사용횟수 K (1 ≤ K ≤ 500,000)가 정수로 주어진다.&nbsp;두 번째 줄에는 전기용품의 이름이 K 이하의 자연수로 사용 순서대로 주어진다. 각 줄의 모든 정수 사이는 공백문자로 구분되어 있다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>하나씩 플러그를 빼는 최소의 횟수를 출력하시오.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 7
2 3 2 3 1 2 7
','2
','DATA_STRUCTURE'),
                                                                                                                (8079,'BAEKJOON','https://www.acmicpc.net/problem/20148',20148,'트리와 쿼리 18','5초','512 MB',25,'<p><em>N</em>개의 정점으로 이루어진 트리가 있다. 정점은 1번부터 <em>N</em>번까지 번호가 매겨져 있고, <em>i</em>번 정점에는 정수 <em>A<sub>i</sub></em>가 저장되어 있다. 처음 상태에서&nbsp;<em>A<sub>i</sub></em>=0이다. (1 ≤ <em>i</em> ≤ <em>N</em>)&nbsp;</p>

<p>당신은 다음과 같은 쿼리를 총 <em>Q</em>번 수행해야 한다.</p>

<ul>
	<li><code>1 u v</code>: 트리의 루트를 정점 <em>u</em>라 하였을 때, 정점 <em>v</em>를 루트로 하는 서브트리의 모든 정점 <em>i</em>의 <em>A<sub>i</sub></em>에 1을 더한다.</li>
	<li><code>2 u v</code>: 정점 <em>u</em>에서 정점 <em>v</em>로 가는 유일한 경로에 있는 모든 정점 <em>i</em>의 <em>A<sub>i</sub></em>에 1을 더한다.</li>
	<li><code>3 v</code>: $\sum_{i&nbsp;= 1}^{N} A_i&nbsp;\times dist(v, i)$를 출력한다. $dist(x, y)$는 정점&nbsp;<em>x</em>에서 정점 <em>y</em>로 가는 경로에 있는 간선의 수를 의미한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 <em>N</em>이 주어진다. (1 ≤ <em>N</em> ≤&nbsp;200,000)</p>

<p>다음 <em>N</em>-1개 줄에 트리의 간선이 주어진다. 각 줄에는&nbsp;공백으로 구분된 두 수 <em>u</em>와 <em>v</em>가 주어지고, <em>u</em>와 <em>v</em>를 연결하는 간선이 있다는 것을 의미한다. (1 ≤ <em>u</em>, <em>v</em> ≤ <em>N</em>)</p>

<p>다음 줄에는 쿼리의 개수 <em>Q</em>가 주어진다. (1 ≤ <em>Q</em> ≤ 200,000)&nbsp;&nbsp;</p>

<p>다음 <em>Q</em>개의 줄에는 한 줄에 하나씩 다음과 같은 형식 중 하나로 쿼리가 주어진다.</p>

<ul>
	<li><code>1 u v</code>&nbsp;(1 ≤ <em>u</em>, <em>v</em> ≤ <em>N</em>)</li>
	<li><code>2 u v</code> (1 ≤ <em>u</em>, <em>v</em> ≤ <em>N</em>)</li>
	<li><code>3 v</code> (1 ≤ <em>v</em> ≤ <em>N</em>)</li>
</ul>

<p>3번 쿼리는 한 번 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 3번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4 2
2 5
1 5
1 3
5
2 2 4
3 4
2 1 5
2 5 5
3 2
','1
5
','DATA_STRUCTURE'),
                                                                                                                (8081,'BAEKJOON','https://www.acmicpc.net/problem/20150',20150,'선분 교차 4','1초','512 MB',21,'<p>2차원 좌표 평면 위의 선분 N개가 주어졌을 때, 교차하는 두 선분이 존재하는지 아닌지 구해보자. 한 선분의 끝 점이 다른 선분이나 끝 점 위에 있는 것도 교차하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 선분의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 선분의 양 끝 점 (x<sub>1</sub>, y<sub>1</sub>), (x<sub>2</sub>, y<sub>2</sub>)를 의미하는 네 정수 x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>교차하는 두 선분이 존재하면 1, 아니면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
1 1 5 5
1 5 5 1
','1
','DATA_STRUCTURE'),
                                                                                                                (8080,'BAEKJOON','https://www.acmicpc.net/problem/20151',20151,'선분 교차 5','1초','512 MB',22,'<p>2차원 좌표 평면 위의 선분 N개가 주어졌을 때, 교차하는 두 선분이 존재하는지 아닌지 구해보자. 한 선분의 끝 점이 다른 선분 위에 있는 것도 교차하는 것이다. 두 선분이 끝 점에서 만나는 것은 교차하는 것이 아니다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 선분의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 선분의 양 끝 점 (x<sub>1</sub>, y<sub>1</sub>), (x<sub>2</sub>, y<sub>2</sub>)를 의미하는 네 정수 x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>교차하는 두 선분이 존재하면 1, 아니면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
1 1 5 5
1 5 5 1
','1
','DATA_STRUCTURE'),
                                                                                                                (8083,'BAEKJOON','https://www.acmicpc.net/problem/20156',20156,'기왕 이렇게 된 거 암기왕이 되어라','2초','1024 MB',17,'<p>정훈이는 1등 상품이 어마어마한 암기왕을 뽑는 대회에 참여했다. 암기왕을 가리는 문제는 다음과 같은 초기 상태에서 <em>M</em>번의 라운드의 결과를 다 외워야 한다.</p>

<p>초기 상태에서 <em>N</em>명의 학생은 각자 멘토가 최대 한 명씩 존재한다. 어느 학생의 멘티들이 그 학생의 멘토가 될 수는 없다. 멘티의 멘티, 멘티의 멘티의 멘티 … 들도 역시 그 학생의 멘토가 될 수 없다. 멘토와 멘티는 서로 같은 스터디 그룹이다.</p>

<p>초기 상태에서 <em>M</em>번의 라운드를 거치게 된다. 라운드가 시작되면 학생 번호 <em>X</em>를 정하게 되는데 학생 <em>X</em>는 멘토와의 관계를 정리하고 자신의 멘티들을 데리고 새로운 스터디 그룹을 만들게 된다. 멘티의 멘티, 멘티의 멘티의 멘티… 들도 같이 데리고 나온다. 만약 멘토가 없다면 아무것도 하지 않는다. 그다음 라운드를 종료한다.</p>

<p><em>M</em>번의 라운드가 종료된 후&nbsp;<em>K</em>번의 다음과 같은 문제를 낸다.</p>

<ul>
	<li><em>A B C</em> : <em>A</em>번째&nbsp;라운드가 종료된 후 학생 <em>B</em>와 <em>C</em>는 같은 스터디 그룹인가?</li>
</ul>

<p><em>A</em>가 0이라면 초기 상태에서 <em>B</em>와 <em>C</em>가 같은 스터디 그룹인지 대답해야 한다.</p>

<p>정훈이 전 기록이 모든 문제 중 1개 빼고 정답이라 1등을 하려면 모든 문제에 정답을 말해야 한다. 정훈이는 긴장한 탓에 머리가 하얗게 되었다. 정훈이를 도와 <em>K</em>번의 모든 문제에 대한 답을 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 세 정수 <em>N</em> (1 ≤ <em>N</em> ≤ 100,000)과 <em>M</em> (0 ≤ <em>M</em> ≤ 100,000), K (1 ≤ <em>K</em> ≤ 100,000)이 주어진다.</p>

<p>다음 줄에 1번부터 <em>N</em>번 학생의 멘토 번호가 차례대로 주어진다. 만약 멘토가 없다면 -1이 주어진다.</p>

<p>그 다음 <em>M</em>개의 줄에 학생 번호 <em>X</em> (1 ≤ <em>X</em> ≤ <em>N</em>)가 정수로 주어진다.</p>

<p>그 다음 <em>K</em>개의 줄에 세 정수 <em>A</em> (0 ≤ <em>A</em> ≤ <em>M</em>), <em>B</em> (1 ≤ <em>B</em> ≤ <em>N</em>), <em>C</em> (1 ≤ <em>C</em> ≤ <em>N</em>)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>K</em>개의 각 질문에 대한 답을 한 줄에 하나씩 출력한다.</p>

<p>같은 스터디 그룹이라면 <code>Same Same;</code> 아니라면 <code>No;</code>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 1 2
3 1 -1
1
0 1 3
1 1 3
','Same Same;
No;
','DATA_STRUCTURE'),
                                                                                                                (8085,'BAEKJOON','https://www.acmicpc.net/problem/20166',20166,'문자열 지옥에 빠진 호석','1초','512 MB',12,'<p><em>하루 종일 내리는 비에 세상이 출렁이고 구름이 해를 먹어 밤인지 낮인지 모르는 어느 여름 날</em></p>

<p>잠 들기 싫어 버티던 호석이는 무거운 눈꺼풀에 패배했다. 정신을 차려보니 바닥에는 격자 모양의 타일이 가득한 세상이었고, 각 타일마다 알파벳 소문자가 하나씩 써있다더라. 두려움에 가득해 미친듯이 앞만 보고 달려 끝을 찾아 헤맸지만 이 세상은 끝이 없었고, 달리다 지쳐 바닥에 드러누우니 하늘에 이런 문구가 핏빛 구름으로 떠다니고 있었다.</p>

<ul>
	<li>이 세상은 <em>N</em>행 <em>M</em>열의 격자로 생겼으며,&nbsp;각 칸에&nbsp;알파벳이 써있고 환형으로 이어진다. 왼쪽 위를 (1, 1), 오른쪽 아래를 (<em>N</em>, <em>M</em>)이라고 하자.</li>
	<li>너는 아무 곳에서나 시작해서 상하좌우나 대각선 방향의 칸으로 한 칸씩 이동할 수 있다. 이 때, 이미 지나 왔던 칸들을 다시 방문하는 것은 허용한다.</li>
	<li>시작하는 격자의 알파벳을&nbsp;시작으로, 이동할 때마다 각 칸에 써진 알파벳을 이어 붙여서&nbsp;문자열을 만들 수 있다.</li>
	<li>이 곳의 신인 내가 좋아하는 문자열을 <em>K </em>개 알려줄 터이니, 각 문자열 마다 너가 만들 수 있는 경우의 수를 잘 대답해야 너의 세계로 돌아갈 것이다.</li>
	<li>경우의 수를 셀 때, 방문 순서가 다르면 다른 경우이다. 즉, (1,1)->(1,2) 로 가는 것과 (1,2)->(1,1) 을 가는 것은 서로 다른 경우이다.</li>
</ul>

<p>호석이는 하늘을 보고서 <em>"환형이 무엇인지는 알려달라!"&nbsp;</em>며 소리를 지르니 핏빛 구름이 흩어졌다가 모이며 아래와 같은 말을 그렸다.</p>

<ul>
	<li>너가 1행에서 위로 가면 <em>N&nbsp;</em>행으로 가게 되며 반대도 가능하다.</li>
	<li>너가 1열에서 왼쪽으로 가면&nbsp;<em>M</em>&nbsp;열로 가게 되며 반대도 가능하다.</li>
	<li>대각선 방향에 대해서도 동일한 규칙이 적용된다.</li>
	<li>하늘에 아래와 같은 그림을 구름으로 그려줄 터이니 이해해 돕도록 하여라.</li>
	<li>예를 들어서, 너가 (1, 1)에서 위로 가면 (<em>N</em>, 1)이고, 왼쪽으로 가면 (1, <em>M</em>)이며 왼쪽 위 대각선 방향으로 가면 (<em>N</em>, <em>M</em>)인 것이다.</li>
</ul>

<p><img alt="" src="https://upload.acmicpc.net/3701860f-0ca1-45a8-8f99-ad149d1f5771/-/preview/" style="height: 272.5px; width: 333.333px;"></p>

<p>세상을 이루는 격자의 정보와,&nbsp;<em>K</em>&nbsp;개의 문자열이 주어졌을 때, 호석이가 대답해야 하는 정답을 구해주도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫번째 줄에 격자의 크기 <em>N</em>, <em>M</em>과 신이 좋아하는 문자열의 개수&nbsp;<em>K </em>가 주어진다.</p>

<p>다음에&nbsp;<em>N</em>개의 줄에 걸쳐서 M개의 알파벳 소문자가 공백없이 주어진다. 여기서의 첫 번째 줄은 1행의 정보이며, <em>N</em> 번째 줄은 <em>N</em>행의 정보이다.</p>

<p>이어서 <em>K</em>개의 줄에 걸쳐서 신이 좋아하는 문자열이 주어진다. 모두 알파벳 소문자로 이루어져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>K</em>개의 줄에 걸쳐서, 신이 좋아하는 문자열을 만들 수 있는 경우의 수를 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3 2
aaa
aba
aaa
aa
bb
','56
0
','DATA_STRUCTURE'),
                                                                                                                (8086,'BAEKJOON','https://www.acmicpc.net/problem/20190',20190,'버블버블','2초','512 MB',20,'<p>여러분은 N개의 정수 A<sub>1</sub>, · · · , A<sub>N</sub>을 버블 정렬(bubble sort)를 이용하여 단조증가하도록 (감소하지 않는 순서가 되도록) 정렬하려고 한다. 주어진 정수들 중에는 같은 값이 있을 수 있다. 버블 정렬은 인접한 두 수를 교환하는 것만으로 정렬을 수행한다. 버블 정렬을 수행하는 동안 인접한 두 수를 몇 번 교환해야 하는지도 셀 수 있다. 예를 들어, 세 수 3, 2, 1이 주어졌다면, 첫 단계에서는 인접한 두 수를 교환하는 일을 두 번 해서 2, 1, 3을 만들고, 다음 단계에서는 2와 1을 교환해서 1, 2, 3을 만든다. 총 3번의 교환이 필요하다.</p>

<p>이제 이를 약간 변형한 문제를 풀어보자. 주어진 N개의 수 중 정확하게 한 개의 수를 다른 임의의 수로 바꿀 수 있다. 처음 주어진 수들은 모두 정수였지만, 바뀐 수는 실수의 어떤 값으로든 될 수 있다. 이렇게 하나의 수를 바꾼 다음, N개의 수를 단조증가하도록 버블 정렬을 수행할 때 교환 횟수가 최소가 되게 하려고 한다.</p>

<p>물론, 어떤 수를 바꾸느냐에 따라 필요한 최소 교환 횟수는 달라질 수 있다. 예를 들어, 위의 예 3, 2, 1에서 맨 마지막 수를 4로 바꾸면 (실제로는 3 이상인 어떤 수도 가능하다) 단 한 번 3과 2를 바꾸어서 오름차순으로 정렬된 2, 3, 4를 얻을 수 있다. 한편, 두 번째 수인 2를 바꾸는 경우 어떤 수로 바꾸더라도 최소한 두 번 교환을 해야 한다는 것을 알 수 있다.</p>

<p>1 이상 N 이하의 모든 i에 대해, A<sub>i</sub>를 바꾸었을 때 버블 정렬의 최소 교환 횟수를 모두 구하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 N이 주어진다. 두 번째 줄에 N개의 정렬할 수 A<sub>1</sub>, A<sub>2</sub>, · · · , A<sub>N</sub>이 공백 하나를 사이로 두고 주어진다. 이 수들은 모두 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 문제의 정답을 출력한다. i번째로 출력해야 할 수는, A<sub>i</sub>를 아무 실수로 바꿀 수 있을 때 N개의 수를 단조증가하도록 버블 정렬하기 위해 필요한 최소 교환 횟수이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
3 2 1
','1 2 1
','DATA_STRUCTURE'),
                                                                                                                (8087,'BAEKJOON','https://www.acmicpc.net/problem/20193',20193,'화려한 정사각형','5초','512 MB',22,'<p>평면에 N개의 점 P<sub>1</sub>(x<sub>1</sub>, y<sub>1</sub>), P<sub>2</sub>(x<sub>2</sub>, y<sub>2</sub>), . . . , P<sub>N</sub>(x<sub>N</sub>, y<sub>N</sub>)이 주어지며, 각각의 점들은 총 K개의 색깔 중 하나를 가지고 있다. 각 점의 색깔은 {1, 2, . . . , K} 중의 한 정수로 표현된다.</p>

<p>어떤 정사각형이 각 K개의 색깔에 대해 해당 색깔의 점을 하나 이상 포함하고 있다면, 이 정사각형을 <strong>화려한 정사각형</strong>이라고 부른다. 변의 길이를 최소로 하는 화려한 정사각형을 찾아서 그 변의 길이를 출력하는 프로그램을 작성하라.</p>

<p>단, 여기서 정사각형은 네 변이 모두 수평 혹은 수직인 것에 한정하며, 정사각형의 내부가 아닌 경계에 놓인 점들도 그 정사각형에 포함된다고 생각한다. 정사각형의 한 변의 길이가 0이 되어 점으로 나타나는 경우도 정사각형의 한 경우로 간주한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 두 정수 N과 K가 공백 하나를 사이로 두고 주어진다.</p>

<p>이후 N 개의 줄이 주어진다. 이 중 i 번째 줄에는 세 개의 정수 x<sub>i</sub>, y<sub>i</sub>, k<sub>i</sub>가 공백 하나 씩을 사이에 두고 주어지며, 입력으로 주어지는 각 점의 좌표 (x<sub>i</sub>, y<sub>i</sub>)와 그 점의 색깔 k<sub>i</sub>을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 문제의 정답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
4 2 1
5 3 1
5 4 2
4 5 2
3 8 2
','1
','DATA_STRUCTURE'),
                                                                                                                (8090,'BAEKJOON','https://www.acmicpc.net/problem/20209',20209,'스트레이트 스위치?게임','1.5초','512 MB',13,'<p>어느 나라에는, 여러 큐브와 연결된 스위치를 적절한 횟수만큼&nbsp;눌러&nbsp;모든 큐브 위에&nbsp;적힌&nbsp;숫자를 동일하게 만드는&nbsp;게임이 있다.</p>

<p>그중 스트레이트 스위치라는 게임이&nbsp;있다.</p>

<p>스트레이트 스위치&nbsp;게임은&nbsp;다음의 규칙을 따른다.</p>

<ul>
	<li>선분 위에 여러 개의 큐브가 일렬로 놓여 있고, 이 큐브&nbsp;중 특정&nbsp;큐브들과&nbsp;연결된&nbsp;스위치들이 여러 개 존재한다.</li>
	<li><u><strong><em>i</em>&nbsp;번 스위치</strong></u>를 한 번 누르면 해당 스위치와 연결된 모든 큐브 위의 숫자가 각각<u><strong>&nbsp;<em>i&nbsp;</em>만큼 증가</strong></u>한다.</li>
	<li>큐브 위의 숫자는 0, 1, 2, 3, 4만 존재할 수 있으며 스위치를 눌러 큐브 위의 숫자 K가 4를 초과하면 K를&nbsp;<strong>5로 나눈 나머지</strong>로 즉시 초기화된다.</li>
	<li>스위치를 한 번 누를 때, 반드시 단 한 개의 스위치만 누를 수 있다.</li>
	<li>같은 번호의 큐브가 한 스위치에 여러 번 연결되어있는 경우는 없다.</li>
	<li>각 스위치를 누를 수 있는 횟수의 제한은 없다.</li>
	<li>큐브 위에 쓰여 있는 모든 숫자가 동일해지는 순간, 게임은 종료된다.</li>
</ul>

<p>이 스트레이트 스위치&nbsp;게임의 국가 대표&nbsp;선수인 당신은 세계 대회에서&nbsp;우수한 성적을 거두기 위해 전략을 세워야 한다.</p>

<p>큐브의 개수와 현재 큐브&nbsp;위에 쓰여 있는 숫자들, 그리고&nbsp;스위치-큐브 간의&nbsp;연결 정보가 주어질 때</p>

<p>이 큐브들 위에&nbsp;쓰여 있는&nbsp;숫자를 모두 동일하게 만들기&nbsp;위해 눌러야 하는&nbsp;스위치의 최소 횟수를 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 큐브의 개수 N과 스위치의 개수 K가&nbsp;주어진다. (1&nbsp;≤ N, K ≤ 8)</p>

<p>두 번째 줄에는 현재&nbsp;N개의 큐브 위에&nbsp;쓰여 있는 숫자 a<sub>1&nbsp;</sub>a<sub>2&nbsp;</sub>a<sub>3</sub>&nbsp;... a<sub>N</sub>&nbsp;가 한 줄에 주어진다. (0 ≤ a<sub>i</sub>&nbsp;≤ 4)</p>

<p>세 번째 줄 부터&nbsp;K+3번째 줄에는, 1번&nbsp;스위치부터 K번 스위치까지&nbsp;각&nbsp;스위치에 연결된 큐브의&nbsp;개수(B<sub><span style="font-size: 10.8333px;">m</span></sub>)와, 연결된 큐브의 번호들(b<sub>j</sub>)이&nbsp;각&nbsp;줄 마다&nbsp;주어진다.&nbsp;(1&nbsp;≤&nbsp;B<sub>m</sub> ≤ 8,&nbsp;1&nbsp;≤ b<sub>j</sub>&nbsp;≤ N)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 큐브들 위에&nbsp;쓰여 있는&nbsp;숫자를 모두 동일하게 만들기&nbsp;위해 눌러야 하는&nbsp;스위치의 최소 횟수를 출력한다.</p>

<p>(단, 주어진 스위치들을&nbsp;아무리&nbsp;누르더라도 모든 큐브의 숫자를 동일하게 만들 수 없는 경우에는&nbsp;-1을 출력한다.)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2
0 1 0 1
2 1 3
3 1 2 3
','1
','DATA_STRUCTURE'),
                                                                                                                (8092,'BAEKJOON','https://www.acmicpc.net/problem/20212',20212,'나무는 쿼리를 싫어해~','1초','512 MB',19,'<p>세그먼트 나무, 머지소트 나무, PST, 스플레이 나무, 최소 신장 나무, r-b 나무 등등 나무는 수많은 문제들에 사용되어 왔다.</p>

<p>특히 쿼리 문제들은 나무를 너무 많이 사용하였다.</p>

<p>알고리즘 뉴비인 호민이는 쿼리 문제에서 수열의 범위를 늘리면 나무를 사용할 수 없을 거라 생각하고 수열의 범위를 10억으로 늘려버렸다!</p>

<p>문제를 풀어서 호민이를 혼내주자.</p>

<p>길이가 N인 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>&nbsp;이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li>1 i j k: A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>에 k를 더한다.</li>
	<li>2 i j k: k번째 1번 쿼리까지 적용되었을 때, A<sub>i</sub>, A<sub>i+1</sub>, ..., A<sub>j</sub>의 합을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 쿼리의 개수 N(2&nbsp;≤ N ≤ 50,000)이 주어진다.</p>

<p>둘째 줄부터 N개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. 1번 쿼리의 경우 1 ≤ i ≤ j ≤ 1,000,000,000, -100,000 ≤ k ≤ 100,000&nbsp;2번 쿼리의 경우 1 ≤ i ≤ j ≤ 1,000,000,000, 1&nbsp;≤ k ≤ 1번 쿼리의 개수 이다.</p>

<p>수열의 모든 항들의 초기값은 0이다.</p>

<p>1번 쿼리와 2번 쿼리는 각각 1개 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리가 주어질 때마다 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
1 1 10 1000
2 1 6 2
1 2 9 -40
2 6 10 3
2 3 11 1
1 4 11 400
','5800
6840
8000
','DATA_STRUCTURE'),
                                                                                                                (8096,'BAEKJOON','https://www.acmicpc.net/problem/20292',20292,'컨설팅','2초(추가시간없음)','1024 MB',12,'<p>Sogang ICPC Team에서는 학회원들을 돕기 위해 Sogang Program Consulting Team(이하 SPC Team)을 만들었다. SPC Team은 학회원들과 화목하게 지내게 될 날만을 상상하며 에러가 발생한 코드를 무료로 디버깅해주는 컨설팅을 바로 시작했다.</p>

<p>그러던 어느 날, 기세등등했던 SPC Team의 모두를 당황시킨 코드가 등장했다. 아무리 봐도 정상적인 코드인데, 원하는 데이터를 얻을 수 없었던 것이다. 하지만 포기를 모르는 SPC Team은 계속해서 디버깅을 시도한 끝에, 한 번에 여러 줄의 명령이 실행되고 있었다는 사실을 알게 되었다! 이 상황을 이해하기 위해 다음 예시를 살펴보자.</p>

<pre style="background: rgb(238, 238, 238); border: 1px solid rgb(204, 204, 204); padding: 5px 10px;"><code>1: WRITE A TO B
2: WRITE B TO C
3: READ B
4: READ C
5: EXIT</code></pre>

<p>위 코드는 문제가 된 학회원의 코드이다. 명령어가 순서대로 실행되면 전혀 문제가 없을 코드지만, 줄 1?4가 동시에 실행된다면 문제가 생긴다. 메모리 A에서 메모리 B로 데이터가 옮겨지지도 않았는데 두 번째 줄이 실행되면, 메모리 C에 무슨 데이터가 들어갈지 알 수 없다. 이러한 문제를 확인한 SPC Team은 다음과 같이 컨설팅을 해 주었다.</p>

<pre style="background: rgb(238, 238, 238); border: 1px solid rgb(204, 204, 204); padding: 5px 10px;">1: WRITE A TO B
2: WAIT
3: WRITE B TO C
4: WAIT
5: READ B
6: READ C
7: EXIT
</pre>

<p>위와 같이, 중간에 <code>WAIT</code>를 삽입하여 <code>WRITE A TO B</code>와 <code>WRITE B TO C</code>가 동시에 실행되는 것을 막아준다면, 메모리 C에 어떤 데이터가 들어갈지 명확해진다! 위 코드에 대한 컨설팅을 끝마친 SPC Team은 문제가 발생할 수 있는 경우를 다음과 같이 세 가지로 분류했다.</p>

<ul>
	<li>READ with WRITE
	<ul>
		<li><code>WRITE A TO B</code>와 <code>READ B</code>가 동시에 실행되면, 메모리 B의 데이터가 확실하지 않으므로 두 명령어 사이에 <code>WAIT</code>가 있어야 한다.</li>
		<li><code>WRITE A TO B</code>와 <code>WRITE B TO C</code>가 동시에 실행되면, 메모리 C의 데이터가 확실하지 않으므로 두 명령어 사이에 <code>WAIT</code>가 있어야 한다.</li>
	</ul>
	</li>
	<li>WRITE with WRITE
	<ul>
		<li><code>WRITE A TO C</code>와 <code>WRITE B TO C</code>가 동시에 실행되면, 메모리 C의 데이터가 확실하지 않으므로 두 명령어 사이에 <code>WAIT</code>가 있어야 한다.</li>
		<li><code>WRITE A TO B</code>와 다른&nbsp;<code>WRITE A&nbsp;TO B</code>가 동시에 실행되는 것은&nbsp;문제가 없지만, 프로그램의 안정성을 위해 두 명령어 사이에&nbsp;<code>WAIT</code>가 있어야 한다.</li>
	</ul>
	</li>
	<li>교착 상태
	<ul>
		<li><code>WRITE A TO B</code>와 <code>WRITE B TO A</code>가 동시에 실행되면, 메모리 A와 메모리 B의 값이 확실하지 않으므로 두 명령어 사이에 <code>WAIT</code>가 있어야 한다.</li>
	</ul>
	</li>
</ul>

<p>이 문제를 겪고 있는 학회원들이 지속적으로 SPC Team에 컨설팅 문의를 신청하고 있다. 반복되는 작업에 지친 SPC Team은 위와 같은 상황을 알아서 탐지하여 컨설팅해주는 프로그램을 만들고자 한다. 하지만 너무나도 바쁜 나머지, 유능한 프로그래머인 당신에게 프로그램의 제작을 의뢰했다. 너무나도 마음이 상냥한 당신은 이 의뢰를 거절할 수 없다!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력으로 최대 $10\ 000$줄의 명령어가 주어지며, WRITE문, READ문, EXIT문으로 구성된다. EXIT문은 마지막에 한 번만 주어진다.</p>

<p>각 명령어는 다음과 같이 정의되며, 메모리 이름은 $1$?$3$글자의 알파벳 대문자로 구성되어 있다.</p>

<ul>
	<li><span style="color:#e74c3c;"><code>WRITE A TO B</code></span>:&nbsp;메모리 A의 내용을 메모리 B로 옮긴다. 이 때, 메모리 A는 READ 상태가 된다.</li>
	<li><span style="color:#e74c3c;"><code>READ A</code></span>: 메모리 A의 데이터를 읽는다.</li>
	<li><span style="color:#e74c3c;"><code>EXIT</code></span>: 프로그램을 종료한다.</li>
</ul>

<p><code>WRITE A TO A</code>같이 동일한 메모리로 WRITE를 수행하는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>WAIT을 최소로 사용한 컨설팅 결과를 기존 명령어들의 순서를 유지하여 출력한다.</p>

<p>한 줄에 하나의 명령어만 출력해야 하며, 만약 그러한 컨설팅 결과가 여러 개라면 그 중 하나를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','WRITE A TO B
WRITE B TO C
READ B
READ C
EXIT
','WRITE A TO B
WAIT
WRITE B TO C
WAIT
READ B
READ C
EXIT
','DATA_STRUCTURE'),
                                                                                                                (8098,'BAEKJOON','https://www.acmicpc.net/problem/20295',20295,'사탕 배달','3초(추가시간없음)','1024 MB',18,'<p>윤제가 사는 마을에는 $N$개의 사탕 가게가 있다. 사탕 가게는 $1$번부터 $N$번까지 번호가 매겨져 있다. 각 가게에서는 다섯 가지 종류의 사탕 중 하나만을 판매한다. 또한 사탕 가게들을 잇는 도로 $N-1$개로 이루어진 도로망이 있다. 모든 도로는 지나는 데에 $1$의 시간이 필요하며, 도로망을 이용해 한 사탕 가게에서 다른 모든 사탕 가게로 이동할 수 있다.</p>

<p>윤제는 오늘 $M$명의 친구를 한 명씩 순서대로 만나기로 했는데, 각 친구를 만나러 가는 길에 만날 친구가 좋아하는 종류의 사탕을 사다 주어야 한다. 이에 실패하면 친구들은 화가 나 떠나버린다.</p>

<p>윤제는 친구들을 빠르게 만나기 위해 한 친구를 만나고 나서 곧장 다음 친구를 만나러 출발한다. 시간을 최대한 단축하기 위해 언제나 최단 경로로 이동하며, 그 경로를 지나는 도중에 만나는 사탕 가게에 들러서 사탕을 산다. 친구가 있는 곳에 있는 가게에서 사탕을 사는 것도 가능하다. 다만, 윤제는 주머니가 작아서 사탕을 한 개만 들고 다닐 수 있다. 즉 어떤 친구 A를 만나러 가는 길에 또 다른 친구 B를 위한 사탕을 미리 사는 것은 불가능하다.</p>

<p>윤제는 자신을 떠날 친구들을 미리 파악하기 위해 각 친구에게 사탕을 사다 줄 수 있는지를 알고 싶어 한다. 윤제는 시작 위치를 자유롭게 선택할 수 있다. 윤제를 도와 각 친구가 좋아하는 사탕을 사다 줄 수 있는지 알려주는 프로그램을 작성하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 사탕 가게의 개수를 나타내는 정수 $N$이 주어진다. ($1 \leq N&nbsp;\leq 100\ 000$)</p>

<p>둘째 줄에 각 사탕 가게에서 판매하는 사탕의 종류를 나타내는 $N$개의 정수가 공백으로 구분되어 주어진다. 사탕의 종류는 $1$과 $5$ 사이의 양의 정수로 표현된다.</p>

<p>셋째 줄부터 $N-1$개의 줄에 걸쳐 도로의 정보를 나타내는 $u, v$ 가 주어진다. 이는 $u$번 사탕 가게와 $v$번 사탕 가게를 잇는 양방향 도로가 존재한다는 의미이다. ($1 \leq u, v \leq N$, $u \neq v$)</p>

<p>다음 줄에 친구의 수를 나타내는 정수 $M$이 주어진다. ($1 \leq M \leq 100\ 000$)</p>

<p>다음 $M$개 줄에 걸쳐 각 친구가 서 있는 가게의 번호와 좋아하는 사탕의 종류가 약속 시간이 빠른 순으로 주어진다. 여러 명의 친구가 같은 가게 앞에 서 있을 수도 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>약속 시간이 빠른 순서대로, 각 친구가 좋아하는 종류의 사탕을 사다 줄 수 있다면 <span style="color:#e74c3c;"><code>PLAY</code></span>를, 아니라면 <span style="color:#e74c3c;"><code>CRY</code></span>를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 3 4 5
1 2
1 3
2 4
2 5
4
3 5
4 2
5 3
3 4
','PLAY
PLAY
CRY
CRY
','DATA_STRUCTURE'),
                                                                                                                (8099,'BAEKJOON','https://www.acmicpc.net/problem/20301',20301,'반전 요세푸스','1초(추가시간없음)','1024 MB',8,'<p>요세푸스 문제는 다음과 같다.</p>

<p>$1$번 사람 오른쪽에는 $2$번 사람이 앉아 있고, $2$번 사람 오른쪽에는 $3$번 사람이 앉아 있고, 계속하여 같은 방식으로 $N$명의 사람들이 원을 이루며 앉아 있다. $N$번 사람 오른쪽에는 $1$번 사람이 앉아 있다. 이제 $K$($\leq N$)번 사람을 우선 제거하고, 이후 직전 제거된 사람의 오른쪽의 $K$번째 사람을 계속 제거해 나간다. 모든 사람이 제거되었을 때, 제거된 사람의 순서는 어떻게 될까?</p>

<p>이 문제의 답을 <strong>($\boldsymbol{N}$, $\boldsymbol{K}$)?요세푸스 순열</strong>이라고 하며, ($7$, $3$)?요세푸스 순열은 $\left<3, 6, 2, 7, 5, 1, 4\right>$가 된다.</p>

<p>하지만 한 방향으로만 계속 돌아가는 건 너무 지루하다. 따라서 요세푸스 문제에 재미를 더하기 위해 $M$명의 사람이 제거될 때마다 원을 돌리는 방향을 계속해서 바꾸려고 한다. 이렇게 정의된 새로운 문제의 답을 <strong>($\boldsymbol{N}$, $\boldsymbol{K}$, $\boldsymbol{M}$)?반전 요세푸스 순열</strong>이라고 하며, ($7$, $3$, $4$)?반전 요세푸스 순열은 $\left<3, 6, 2, 7, \mathbf{1}, \mathbf{5}, \mathbf{4}\right>$가 된다.</p>

<p>$N$, $K$, $M$이 주어질 때, ($N$, $K$, $M$)?반전 요세푸스 순열을 계산해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 $N$, $K$, $M$이 주어진다. ($1 \leq N \leq 5\ 000$, $1 \leq K, M \leq N$)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>($N$, $K$, $M$)?반전 요세푸스 순열을 이루는 수들을 한 줄에 하나씩 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 3 4
','3
6
2
7
1
5
4
','DATA_STRUCTURE'),
                                                                                                                (8100,'BAEKJOON','https://www.acmicpc.net/problem/20303',20303,'할로윈의 양아치','1초','1024 MB',13,'<p>Trick or Treat!!</p>

<p>10월 31일 할로윈의 밤에는 거리의 여기저기서 아이들이 친구들과 모여 사탕을 받기 위해 돌아다닌다. 올해 할로윈에도 어김없이 많은 아이가 할로윈을 즐겼지만 단 한 사람, 일찍부터 잠에 빠진 스브러스는 할로윈 밤을 즐길 수가 없었다. 뒤늦게 일어나 사탕을 얻기 위해 혼자 돌아다녀 보지만 이미 사탕은 바닥나 하나도 얻을 수 없었다.</p>

<p>단단히 화가 난 스브러스는 거리를 돌아다니며 다른 아이들의 사탕을 빼앗기로 마음을 먹는다. 다른 아이들보다 몸집이 큰 스브러스에게 사탕을 빼앗는 건 어렵지 않다. 또한, 스브러스는 매우 공평한 사람이기 때문에 한 아이의 사탕을 뺏으면 그 아이 친구들의 사탕도 모조리 뺏어버린다. (친구의 친구는 친구다?!)</p>

<p>사탕을 빼앗긴 아이들은 거리에 주저앉아 울고 $K$명 이상의 아이들이 울기 시작하면 울음소리가 공명하여 온 집의 어른들이 거리로 나온다. 스브러스가 어른들에게 들키지 않고 최대로 뺏을 수 있는 사탕의 양을 구하여라.</p>

<p>스브러스는 혼자 모든 집을 돌아다녔기 때문에 다른 아이들이 받은 사탕의 양을 모두 알고 있다. 또한, 모든 아이는 스브러스를 피해 갈 수 없다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 $N$, $M$, $K$가 주어진다. $N$은 거리에 있는 아이들의 수, $M$은 아이들의 친구 관계 수, $K$는 울음소리가 공명하기 위한 최소 아이의 수이다. ($1 \leq N \leq 30\ 000$, $0 \leq M \leq 100\ 000$, $1 \leq K \leq \min\left\{N, 3\ 000\right\}$)</p>

<p>둘째 줄에는 아이들이 받은 사탕의 수를 나타내는 정수 $c_1, c_2, \cdots, c_N$이 주어진다. ($1 \leq c_i \leq 10\ 000$)</p>

<p>셋째 줄부터 $M$개 줄에 갈쳐 각각의 줄에 정수 $a$, $b$가 주어진다. 이는 $a$와 $b$가 친구임을 의미한다. 같은 친구 관계가 두 번 주어지는 경우는 없다. ($1 \leq a, b \leq N$, $a \neq b$)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>스브러스가 어른들에게 들키지 않고 아이들로부터 뺏을 수 있는 최대 사탕의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 6 6
9 15 4 4 1 5 19 14 20 5
1 3
2 5
4 9
6 2
7 8
6 10
','57
','DATA_STRUCTURE'),
                                                                                                                (8101,'BAEKJOON','https://www.acmicpc.net/problem/20311',20311,'화학 실험','1초','1024 MB',11,'<p>화학 실험을 하던 윤이는 일렬로 나열해 놓은 $N$개의 시험관에서 재밌는 특징을 발견했다. 그 특징은 모든 이웃한 시험관 쌍에 대해, 두 시험관에 들어 있는 시약의 색깔이 서로 다르다는 점이었다. 흥미롭다고 느낀 윤이는 실험보고서에 이 사실과 함께 각 색깔별 시약의 수를 적었다. 하지만 보고서를 채점하던 조교 원이는 윤이가 색깔별 시약의 수를 제대로 적었는지 의문이 들었다. 윤이의 보고서와 일치하도록 시험관을 배열할 수 있는지 판별하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 시험관의 개수 $N$과 색깔의 종류 수 $K$가 공백을 사이에 두고 주어진다.</p>

<p>두 번째 줄에 $K$개의 양의 정수 $c_i$가 공백을 사이에 두고 주어진다. 각 색깔에는 번호가 붙어 있으며, $c_i$는 $i$번 색깔의 시약이 담긴 시험관의 개수이다. $(1≤i≤K)$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>조건을 만족하는 시험관 배열을 만들 수 있으면, 시험관의 색깔 번호를 공백으로 구분하여 순서대로 출력한다. 답이 여러 개이면 아무 거나 출력한다.</p>

<p>조건을 만족하는 시험관 배열을 만들 수 없으면 $-1$을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 3
3 1 2
','1 2 3 1 3 1
','DATA_STRUCTURE'),
                                                                                                                (8104,'BAEKJOON','https://www.acmicpc.net/problem/20314',20314,'대홍수','1초','1024 MB',18,'<p>유니산맥에는 $N$개의 지역이 일렬로 늘어서 있고, 각 지역에는 주민이 살고 있다. 유니산맥의 길은 이웃한 지역 사이를 직선으로 잇는 길로만 구성되어 있다. 즉, 이웃하지 않은 지역을 이동하려면 사이에 있는 지역을 모두 거쳐야 한다. 유니산맥의 $i$번째 지역의 높이는 $h_i$미터이고, $i$번째 지역과 $i+1$번째 지역 사이를 이동하는 데 걸리는 시간은 $t_i$분이다. 모든 주민은 이웃한 두 지역 사이를 이동할 때&nbsp;일정한 속도로 이동하며, 이동하는 데 동일한 시간이 걸린다.</p>

<p>어느 날 유니산맥에 큰 홍수가 나기 시작했다. 다행히도 이는 예언된 사실이었고, 유니산맥의 각 지역은 방주를 준비해 두어서 모든 주민들을 살릴 수 있다고 한다. 각 방주는 충분히 커서 탑승 인원에 제한이 없다. 유니산맥 주민들은 정든 유니산맥의 땅을 조금이라도 더 오래 밟고 싶었기 때문에, 이동 중에 물에 잠기지 않고&nbsp;도달할 수 있는 가장 높은 지역에 있는 방주에 타려고 한다.</p>

<p>수면의 높이는 $0$미터에서 시작해서 $1$분에 $1$미터씩 일정한 속도로 차오른다. 주민이 이동하는 과정에서 수면의 높이보다 낮아지는 경우가 생기면 안 된다. 각 지역의 주민들이 도달할 수 있는 가장 높은 지역의 높이를 구하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 지역의 수 $N$이 주어진다.</p>

<p>두 번째 줄에 각 지역의 높이를 나타내는 $N$개의 정수 $h_i$가 주어진다.</p>

<p>세 번째 줄에 이웃한 지역 사이를 이동하는 데 걸리는 시간을 나타내는 $N-1$개의 정수 $t_i$가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄에 $N$개의 정수 $m_i$를 공백으로 구분하여 출력한다.</p>

<p>$m_i$는 $i$번째 지역의 주민이 물에 잠기지 않고 도달할 수 있는 가장 높은 지역의 높이이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
3 5 2 8 4 7 6 2 4 4
4 1 2 2 3 2 2 2 1
','5 8 8 8 8 8 7 7 7 4
','DATA_STRUCTURE'),
                                                                                                                (8105,'BAEKJOON','https://www.acmicpc.net/problem/20368',20368,'트리 위의 폴 가이즈','2초','1024 MB',21,'<p><em>N</em>개의 정점과 <em>N</em>-1개의 간선으로 구성되어 있으며, 어떤&nbsp;두 정점을 고르더라도&nbsp;두 정점을 잇는 유일한&nbsp;하나의 경로가 존재하는 그래프를 트리라고 한다.</p>

<p>준영이와 성민이는 게임 <code>폴&nbsp;가이즈(Fall&nbsp;Guys)</code>의&nbsp;우승을&nbsp;남겨두고 일대일 대결을 펼치게 되었다. 이 게임은 트리 형태의 게임판에서 진행되며, 준영이와 성민이가 각자 배정된 서로 다른 두 정점에 위치한&nbsp;채로 시작된다. 게임은 서로 턴을 번갈아가며&nbsp;진행된다. 자신의 턴이 오면, 자신이 위치한 정점과 인접한 정점으로 한 칸&nbsp;이동해야 한다.&nbsp;자신 혹은 상대방이 현재&nbsp;위치하거나, 과거에&nbsp;위치한 적이 있던 정점은 곧 게임 시스템에 의해 게임판의 바닥으로 떨어져 사라지기 때문에, 해당 정점으로는 이동할 수 없다. 만약, 이동할 수&nbsp;없는 플레이어가 존재하면 그 플레이어의&nbsp;턴은 무시하고&nbsp;건너뛴다. 두 플레이어가 모두 이동할 수&nbsp;없는 경우에는 게임이 종료된다. 각 플레이어는 한 칸 이동할 때마다 1점을 획득한다.</p>

<p>준영이와 성민이는&nbsp;(자신의 점수 - 상대방의 점수)를 최대화하는&nbsp;것이 목표이다. 준영이가 먼저 턴을 시작하고, 두 명 모두&nbsp;항상 최선의 전략으로 게임을 플레이한다고 할 때,&nbsp;게임이 끝난 뒤 (준영이의 점수 - 성민이의 점수)를 구하는 프로그램을 작성하시오.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/ab72c015-0f62-4cdd-aefb-23aaff61146b/-/preview/" style="height: 208.333px; width: 347.5px;"></p>

<p>위 그림은 예제 5를&nbsp;표현한&nbsp;것이다. 준영이는 노란색 정점들을, 성민이는 보라색 정점들을 밟는 것이 최선이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 게임판의 정점의 개수 <em>N</em> (2&nbsp;≤ <em>N</em> ≤ 200,000), 준영이가 배정된 정점 <em>P</em>, 성민이가 배정된 정점 <em>Q</em>&nbsp;(1 ≤ <em>P</em>, <em>Q</em>&nbsp;≤ <em>N</em>, <em>P</em>&nbsp;≠ <em>Q</em>)가&nbsp;주어진다.</p>

<p>둘째 줄부터&nbsp;<em>N</em>-1개의 줄에는&nbsp;두 정수 <em>A<sub>i</sub></em>, <em>B<sub>i</sub></em> (1 ≤ <em>A<sub>i</sub></em>, <em>B<sub>i</sub></em> ≤ <em>N</em>)가 주어진다. 이는&nbsp;정점 <em>A<sub>i</sub></em>와 <em>B<sub>i</sub></em>를 잇는 간선이 존재함을 의미한다.</p>

<p>주어지는 입력은 트리 형태이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>준영이와 성민이가&nbsp;(자신의 점수 - 상대방의 점수)를 최대화하는 방법으로 게임을 진행할 때, (준영이의 점수 - 성민이의 점수)를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 1 2
1 2
','0
','DATA_STRUCTURE'),
                                                                                                                (8103,'BAEKJOON','https://www.acmicpc.net/problem/20370',20370,'공정한 게임','1.5초','1024 MB',21,'<p>2107년, 신작 게임&nbsp;<code>레전드 오브 리그(LOL)</code>가 출시됐다. 인류는 이미 게임 분야에서 설자리가 없어졌기 때문에, 이 게임도 요즘 다른 게임들과 마찬가지로 로봇들만 플레이할 수 있다. 오늘은 두 로봇&nbsp;BOT_6584와 BOT_10과의 대결이 성사됐다. 이 게임에는 <em>N</em>개의 캐릭터가 존재하며, 각 플레이어가 <em>K</em>개의 캐릭터를 선택하여 경기를 펼친다.&nbsp;<em>N</em>개의 캐릭터에는 1부터 <em>N</em> 사이의 서로 다른&nbsp;정수 번호가 매겨져 있다. 캐릭터 <em>i&nbsp;</em>(1 ≤ <em>i</em> ≤ <em>N</em>)에 대해, BOT_6584는 <em>A<sub>i</sub></em>, BOT_10은&nbsp;<em>B<sub>i</sub></em> 만큼의 숙련도를 가진다.&nbsp;게임의 승패에는 캐릭터 숙련도가 결정적인&nbsp;역할을 하기&nbsp;때문에, 두 플레이어는 (자신이 고른 캐릭터들의 숙련도 합 - 상대방이 고른 캐릭터들의 숙련도 합)을 최대화하는 방향으로 캐릭터를 선택한다. BOT_6584는 이번 대결에서 캐릭터를 먼저 고르는 아이템을 사용했다. 따라서, BOT_6584가 먼저 K개의 서로 다른 캐릭터를 선택하고, BOT_10이 남은 N-K개의 캐릭터 중 K개를 선택하여 대결하게 된다.</p>

<p>이때.&nbsp;(BOT_6584가 고른 캐릭터들의 숙련도 합 - BOT_10이 고른 캐릭터들의 숙련도 합)을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 정수 <em>N&nbsp;</em>(2 x <em>K</em>&nbsp;≤ <em>N</em> ≤ 80,000), <em>K&nbsp;</em>(1 ≤ <em>K</em> ≤ 40,000)가 공백으로 구분되어 주어진다.</p>

<p>둘째 줄에는 <em>A<sub>i&nbsp;</sub></em>(1 ≤ <em>A<sub>i</sub></em> ≤ 10<sup>9</sup>)를 나타내는 <em>N</em>개의 정수가 순서대로&nbsp;공백으로 구분되어 주어진다.</p>

<p>셋째 줄에는 <em>B<sub>i&nbsp;</sub></em>(1 ≤ <em>B<sub>i</sub></em> ≤ 10<sup>9</sup>)를 나타내는 <em>N</em>개의 정수가 순서대로&nbsp;공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>두 로봇이&nbsp;(자신이 고른 캐릭터들의 숙련도 합 - 상대방이 고른 캐릭터들의 숙련도 합)을 최대화하는 방향으로 캐릭터를 선택할 때,&nbsp;(BOT_6584가 고른 캐릭터들의 숙련도 합 - BOT_10이 고른 캐릭터들의 숙련도 합)을 나타내는 정수를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 3
1 1 1 1 1 1 1
5 7 9 1 3 5 2
','-7
','DATA_STRUCTURE'),
                                                                                                                (8112,'BAEKJOON','https://www.acmicpc.net/problem/20418',20418,'역전의 제왕 (Hard)','3초','512 MB',19,'<p><u><strong>입력 제한 외 난이도에 따른 문제의 차이는 없다.</strong></u></p>

<p>코로나 시국에도 꺾이지 않은 여러분들의 학구열에 힘입어, 2020년 올해도 어김없이 아주대학교 프로그래밍 경시대회(Ajou Programming Contest, APC)가 열렸다!</p>

<p>올해 ANSI 회장이자 대회의 운영을 맡은 세훈에게는 한가지 고민이 있다. APC 에는 대회 종료 1시간 전부터 참가자들의 제출을 스코어보드에 반영하지 않는 <strong>프리징</strong>이라는 룰이 있고, 대회가 끝난 뒤 참가자들과 함께 스코어보드에 결과를 하나씩 반영하며 결과에 대한 기대와 분위기를 끌어올리는 <strong>언프리징</strong>시간이 준비되어있다. 하지만 코로나로 인해 대회가 온라인으로 진행되면서, 세훈이는 언프리징 시간이 참가자들에게 다소 무료하게 다가오진 않을까 걱정이 되었다. 고심 끝에 세훈이는 특별상 <strong>역전의 제왕</strong>을 기획했다! 세훈이는 역전의 제왕을 프리징을 녹이는 동안 가장 극적인 상황을 연출한 참가자에게 주고자 한다. 이를 평가하기 위해 역전 포인트를 계산하는데, 역전포인트를 이해하기 위해서는 몇가지 규칙을 자세히 알아둘 필요가 있다.</p>

<p>올해 APC의 순위는 아래 조건을 순서대로 적용했을 때, 상위에 있는 조건을 먼저 만족한 참가자가 더 높은 순위를 가진다.</p>

<ol>
	<li>
	<p>해결한 문제의 수가 더 많은 참가자</p>
	</li>
	<li>
	<p>패널티의 총합이 더 적은 참가자</p>
	</li>
	<li>
	<p>마지막 정답 제출 시간이 빠른 참가자</p>
	</li>
</ol>

<p>여기서 페널티는 문제마다 독립적으로 계산되며, 각 문제의 패널티는 <code> [처음 <span style="font-weight: bold; color: #009874;">맞았습니다!!</span> 를 받은 시간] + [해당 문제의 제출 횟수 - 1] x 20 </code> 공식에 따라 <strong>분단위</strong>로 계산된다. <span style="font-weight: bold; color: #009874;">맞았습니다!!</span>를 받기 전에는 패널티의 총합에 가산되지 않는다.</p>

<p>모든 참가자는 스코어보드를 통해 실시간으로 다른 참가자들의 등수와 제출한 문제 등을 확인할 수 있으며, 이는 참가자들이 문제를 푸는 순서를 결정하는 데 전략적으로 큰 도움이 될 수 있다.</p>

<p>스코어보드는 대회 종료 1시간 전부터 참가자들의 제출을 반영하지 않는 <strong>프리징</strong> 상태가 되며, 대회가 끝난 뒤 언프리징 시간에 프리징 상태동안 제출된 코드들의 결과를 아래의 규칙에 따라 하나씩 공개해 최종 순위를 결정한다.</p>

<ol>
	<li>
	<p>프리징 이전의 제출은 이미 스코어보드에 반영 되었으므로 프리징 이후 정답을 맞춘 문제들만 순위변동에 영향을 준다.</p>
	</li>
	<li>
	<p>프리징 상태에서 가장 마지막 순위 참가자의 제출부터 공개한다.</p>
	</li>
	<li>
	<p>프리징 이후 한 참가자가 제출한 문제가 여러개일 경우 문제의 번호가 가장 빠른 제출부터 공개된다.</p>
	</li>
	<li>
	<p>3번에 의해 순위에 변동이 생길 경우 즉시 스코어보드에 반영되어 순위가 변경 되며, 다시 가장 마지막 순위 참가자의 제출이 공개된다.</p>
	</li>
	<li>
	<p>가장 마지막 순위 참가자의 제출이 모두 공개되면 그 순위가 확정되며, 확정되지 않은 가장 마지막 순위 참가자의 제출이 공개된다.</p>
	</li>
	<li>
	<p>모든 참가자의 제출이 모두 공개되면 스코어보드 및 최종순위가 결정된다.</p>
	</li>
</ol>

<p>역전 포인트는 다음과 같이 계산된다.</p>

<ol>
	<li>
	<p>프리징을 녹이는 중 순위가 오르는 참가자는 올라간 순위만큼 역전 포인트를 얻는다.</p>
	</li>
	<li>
	<p>다른 참가자에 의해 순위가 하락해도 역전 포인트는 변하지 않는다.</p>
	</li>
	<li>
	<p>역전 포인트를 가장 많이 쌓은 참가자에게 역전의 제왕이 수여된다.</p>
	</li>
	<li>
	<p>역전 포인트가 동일한 참가자가 존재할 경우 가장 순위가 높은 참가자에게 역전의 제왕이 수여된다.</p>
	</li>
</ol>

<p>세훈이는 역전의 제왕을 받게될 참가자를 자동으로 구하는 프로그램을 당신에게 의뢰했다.</p>

<p>세훈이를 위해 대회 중 제출된 제출이력을 입력하면 역전의 제왕을 알려주는 프로그램을 작성해주자!</p>

<p>채점 서버의 건강을 위해 각 참가자가 대회 중 가능한 제출 횟수는 <strong>100회</strong>로 제한되며, 모든 참가자들은 프리징 이전에 한문제 이상 맞았다고 가정한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫번째 줄에는 참가자들의 수 <em>N</em> (1 ≤ <em>N</em> ≤ 50,000), 대회 중 제출된 참가자들의 제출이력의 수 <em>M</em> (<em>N</em> ≤ <em>M</em> ≤ 13×<em>N</em>)이 주어진다.</p>

<p>두번째 줄부터 <em>M</em> 줄에 걸쳐 참가자들의 제출이력이 주어진다. 제출이력은 문제의 단순화를 위해 <span style="font-weight: bold; color: #009874;">맞았습니다!!</span>를 받은 제출만을 입력받는다.</p>

<p>제출이력은 제출시간, 참가자 번호 <em>id</em> (1 ≤ <em>id</em> ≤ N), 문제번호 <em>p</em> (1 ≤ <em>p</em> ≤ 13), 제출횟수 <em>s</em> (1 ≤ <em>s</em> ≤ 100) 순으로 주어진다. 각 참가자의 제출 횟수는 총 <strong>100회</strong>를 넘지 않는다. 제출시간은 <em>hh:mm</em> 형식으로 주어지며, 스코어보드는 03:00를 지난 후 부터 프리징 된다. (00:00 < <em>hh:mm</em> ≤ 04:00)</p>

<p>제출이력은 제출한 시간 순서대로 주어지며,<strong> 두 제출이 같은 시, 분에 제출 되더라도 먼저 등장한 이력이 더 빠른 제출이다.</strong></p>

<p>단,&nbsp;&nbsp;같은 참가자가 동일한 문제를 여러번 맞추는&nbsp;경우는 존재하지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>역전포인트를 가장 많이 쌓아 역전의 제왕을 수상한 참가자 번호를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 7
00:38 1 4 3
01:16 2 2 1
02:01 3 1 2
03:00 1 2 3
03:04 2 3 2
03:18 2 1 1
03:54 1 3 6
','2
','DATA_STRUCTURE'),
                                                                                                                (8109,'BAEKJOON','https://www.acmicpc.net/problem/20441',20441,'??니가 싫어 싫어 너무 싫어 싫어 오지 마 내게 찝쩍대지마?? - 2','1초','1024 MB',19,'<blockquote>
<p>??니가 싫어 싫어 너무 싫어 싫어 오지마 내게 찝쩍대지마?? - 유자, 모기송 中</p>
</blockquote>

<p>어느 날 소민이는 자신의 방 창문 방충망에&nbsp;구멍이 뚫려있다는 사실을 알게 되었다. 모기가 방에 들어오는 게 싫은 소민이는 방충망을 보수하려고 한다.&nbsp;하지만 소민이는 하나의 방충망 보수 스티커만 갖고 있다. 방충망 보수 스티커는 가로와 세로의 길이가 같은 정사각형이다. 소민이는 이 한 장의 스티커로 최대한 많은 구멍을 빈틈없이&nbsp;가리고 싶어 한다.</p>

<p>예를 들어 굵은 테두리의&nbsp;직사각형들에&nbsp;구멍이 뚫려있다고 하자. 빨간색&nbsp;정사각형 크기의&nbsp;방충망 보수 스티커가 있을 때 빈틈없이 최대로 막을 수 있는 구멍은 4개가 된다. 빈틈없이 최대한 많은 구멍을 막을 수 있는 방충망 보수 스티커의 위치는 유일하지 않을 수 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/6d26e0cf-6b9a-46a1-88fb-fa8d605f30f6/-/preview/" style="height: 500px;"></p>

<p>방충망 보수&nbsp;스티커를 잘 붙였을 때 빈틈없이&nbsp;최대로 막을 수 있는&nbsp;구멍의 개수를 알아보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 방충망 보수 스티커의 한 변의 길이&nbsp;<em>L</em>이 주어진다. <em>L</em>은&nbsp;정수이다. (1&nbsp;≤&nbsp;<em>L</em> ≤ 1,000,000)</p>

<p>둘째 줄에 구멍의 개수 <em>K</em>가 주어진다. (1&nbsp;≤ <i>K</i>&nbsp;≤ 100,000)</p>

<p>다음 <em>K</em>개의 줄에 구멍의 위치 좌표 (<em>y<sub>1</sub>, x<sub>1</sub>, y<sub>2</sub>, x<sub>2</sub></em>)가 한 줄에 하나씩 주어진다.&nbsp;(0&nbsp;≤&nbsp;<em>y<sub>1</sub>&nbsp;</em>< <em>y<sub>2</sub>&nbsp;</em>≤ 1,000,000, 0&nbsp;≤ <em>x<sub>1</sub>&nbsp;</em><&nbsp;<em>x<sub>2</sub>&nbsp;</em>≤ 1,000,000)</p>

<p>(<em>y1, x1, y2, x2</em>)를 (<em>y1, x1</em>)은 구멍의 왼쪽 아래 좌표, (<em>y2, x2</em>)은 구멍의 오른쪽 위 좌표로 정의한다. 주어지는 좌표는 모두 정수이다.</p>

<p>구멍은 일부 또는 전체가 겹쳐서 존재하지 않는다. 또한 연속된 구멍을 하나의 구멍으로 보지 않고 독립된 구멍으로 본다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 방충망 보수 스티커로 빈틈없이 막을 수 있는 구멍의 최대 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
7
1 1 3 4
3 4 5 8
7 3 9 5
7 6 8 8
9 6 13 8
10 3 12 4
12 2 14 4
','4
','DATA_STRUCTURE'),
                                                                                                                (8116,'BAEKJOON','https://www.acmicpc.net/problem/20530',20530,'양분','1초','1536 MB',15,'<p><strong>나무 $T$는 양분을 먹고 자란다.</strong></p>

<p>원래 나무는 정점 $N$개와 간선 $N-1$개로 구성되어야 하지만, 양분을 너무 많이 먹어버린 나머지 나무 $T$는 $N$개의 간선을 갖게 되었다. 더 이상 트리가 아니기 때문에 $T$는 꿈의 무대인&nbsp;트리와 쿼리에 등장하지 못한다. 슬퍼하고 있는 $T$를 위해 정휘는 새로운 문제를 만들어 주었다.</p>

<p>$N$개의 정점과 $N$개의 간선으로 이루어진 연결 그래프 $T$가 주어진다. 정점은 1번부터 $N$번까지 번호가 매겨져 있고, 간선도 1번부터 $N$번까지 번호가 매겨져 있다. 아래 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li>$u \ v$ : $u$번 정점에서 $v$번 정점으로 가는 단순&nbsp;경로의 수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 자연수 $N$, $Q$가 주어진다. 주어지는 그래프의 정점과 간선의 개수가 $N$개이며 쿼리가 $Q$개 주어진다는 것을 의미한다.</p>

<p>둘째 줄부터 $N$개의 줄에는 $i$번 간선이 연결하는 두 정점 번호 $a$, $b$가 주어진다.</p>

<p>다음 $Q$개 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<section id="output">
<p>각각의 쿼리마다 한 줄에 하나씩 결과를 출력한다.</p>
</section>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 2
1 2
1 3
2 4
2 5
3 6
3 7
2 3
2 4
4 5
','1
1
','DATA_STRUCTURE'),
                                                                                                                (8117,'BAEKJOON','https://www.acmicpc.net/problem/20533',20533,'상금 분배','1.5초','1536 MB',20,'<p>준겸이는 $2^0$명은 금상, $2^1$명은 은상, $2^2$명은 동상으로 총 7명에게 상금을 주는 <code>Bye, Bye 2021</code>&nbsp;대회를 열었다. 준겸이에게는 $N$개의 상품권이 있으며, 상품권 $i&nbsp;(1 ≤ i ≤ N)$는 $A_i$ 원으로 교환될 수 있다. 수상자에게는 상금으로 각각 하나의 상품권만 지급하려고 한다. 준겸이는 상금이 불균형해질 것을 우려해 아래와 같은 조건을 만족하는 상금 구성을 찾으려고 한다.</p>

<p>순서대로 1등에게 지급할&nbsp;상금을 $P_1$, 2등을 $P_2$, 3등을 $P_3$, ..., 7등을 $P_7$ 라고 하자.</p>

<ul>
	<li>$P_1 \ge&nbsp;P_2 \ge&nbsp;P_3&nbsp;\ge P_4&nbsp;\ge P_5&nbsp;\ge P_6&nbsp;\ge P_7$</li>
	<li>$P_1&nbsp;< P_2&nbsp;+ P_3&nbsp;< P_4&nbsp;+ P_5&nbsp;+ P_6&nbsp;+ P_7$</li>
</ul>

<p>준겸이가 가지고 있는 $N$개의 상품권이 주어졌을 때, 이런 조건을 만족하는 상금 분배가&nbsp;가능한&nbsp;지 알려주는 프로그램을 작성해보자. 만약, 조건을 만족하는 상금 분배가 불가능하다면 <code>-1</code>을, 그렇지 않다면&nbsp;가능한&nbsp;모든 경우의 상금의 총합 중에서 <strong>최댓값</strong>을 출력해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 $N(7 \le&nbsp;N \le&nbsp;500\,000)$이 주어진다.</p>

<p>둘째 줄에는 $N$개의 정수 $A_i (1 \le&nbsp;A_i \le&nbsp;2 \times&nbsp;10^8)$가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>조건을 만족하는 상금 분배가 불가능하다면 <code>-1</code>을, 그렇지 않다면&nbsp;가능한&nbsp;모든 경우의 상금의 총합 중에서 최댓값을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1 2 3 4 5 6 7
','-1
','DATA_STRUCTURE'),
                                                                                                                (8121,'BAEKJOON','https://www.acmicpc.net/problem/20534',20534,'PCB 설계','1초','1536 MB',24,'<p>동규는 단면 PCB 회로를 설계하려고 한다. PCB 회로는 부품을 장착하는 곳인 패드와, 패드를 잇는 도선으로 구성된다. 회로를 그릴 PCB는 무한한 2차원 평면, 패드는 평면 위의 점, 도선은 평면 위에서&nbsp;이어진 선분들로&nbsp;생각할 수 있다.</p>

<p>동규가 설계하려는 회로에는 $2N$개의 패드가 수평 방향으로 나열되어 있다. 왼쪽에서 $i$번째에 위치한 패드의 좌표는 $(i-1, 0)$이다. 패드마다 $1$번부터 $N$번까지의 번호 중 하나가 붙어 있으며, 같은 번호를 가진 패드는 각각 두 개씩 존재한다.</p>

<p>동규는 <strong>번호가 같은 패드 쌍</strong>들을 <strong>서로 만나지 않는 도선</strong>들로 이어야 한다. 각 도선은 $x$축 또는 $y$축에 평행한 하나 이상의 선분이 차례로 이어져 있는 모양이고, 자기 자신과 교차하지 않아야 한다. 또한 도선을 구성하는 각 선분은 길이가 양의 정수여야 한다.</p>

<p>패드의 번호가 순서대로 주어졌을 때, 회로를 설계하는 프로그램을 작성하시오.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/79f3f829-d724-4807-9508-803b4e9db47b/" style="max-width: 100%; width: 333.333px; height: 202.5px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 $N$이 주어진다. $(1 ≤ N ≤ 1,000)$</p>

<p>두 번째 줄에 패드의 번호를 나타내는 $2N$개의 정수가 순서대로 주어진다. $i$번째 정수는 왼쪽에서 $i$번째에 위치한 패드의 번호이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>회로 설계가 불가능하다면 <samp>NO</samp>를 출력한다.</p>

<p>회로 설계가 가능하다면 첫 줄에 <samp>YES</samp>를 출력한 다음, 회로를 나타내는 $N$개의 줄을 출력한다. $i$번째 줄에는 $i$번 패드 둘을 잇는 도선을 출력한다. 도선의 시작점은 둘 중 왼쪽에 있는 패드, 끝점은 오른쪽에 있는 패드이며, 도선을 출력하는 형식은 다음과 같다.</p>

<ul>
	<li>도선을 구성하는 선분의 개수를 출력한다.</li>
	<li>도선을 구성하는 선분을 순서대로 그리는 과정을 다음과 같이 출력한다. 시작점 또는 이전 선분을 그리고 난 뒤의 위치에서 시작해서, 다음 선분을 어느 방향으로 그릴지와 어느 길이만큼 그릴지를 각각 출력한다. 끝점에 도달할 때까지 반복한다. 방향을 나타내는 문자는 <samp>U,&nbsp;D, L, R</samp> 중 하나이며, 각각 위, 아래, 왼쪽, 오른쪽을 나타낸다.</li>
</ul>

<p>또한 구성된 회로는 다음 조건을 만족해야 한다. 회로 설계가 가능하다면 아래 조건을 만족하는 회로가 존재함이 보장된다.</p>

<ul>
	<li>각 도선을 구성하는 선분의 개수는 $10$개 이하여야 한다.</li>
	<li>도선을 구성하는 선분의 끝점들은 $x, y$ 좌표의 절댓값이 $10,000$ 이하인 정수여야 한다.</li>
</ul>

<p>가능한 회로가 여러 가지라면 아무거나 하나만 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2 3 4 1 2 3 4
','YES
3 U 1 R 4 D 1
5 D 1 L 2 U 3 R 6 D 2
5 D 2 R 6 U 3 L 2 D 1
3 D 1 R 4 U 1
','DATA_STRUCTURE'),
                                                                                                                (8120,'BAEKJOON','https://www.acmicpc.net/problem/20535',20535,'최소 공통 조상과 쿼리','5초','1536 MB',21,'<p>$N$개의 정점으로 이루어져 있는 트리 $T$가 주어졌을 때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li>$K \ V_1 \ V_2 \ \cdots \ V_K$ : $1 \leq i <&nbsp;j \leq K$인 모든 $(i, j)$ 쌍에 대해 $V_i$번&nbsp;정점과&nbsp;$V_j$번&nbsp;정점의 LCA의 레벨의 합을 출력한다.</li>
</ul>

<p>$T$의 루트 정점은 1번 정점이다.&nbsp;루트 정점의 레벨은 0이며, 다른 정점의 레벨은 (부모 정점의 레벨) + 1로 정의한다.</p>

<p>두 정점 $u, v$의 LCA는 $u, v$의 공통 조상 중 가장 가까운 정점(최소 공통 조상)을 의미한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 $N$과 쿼리의 개수 $Q$가 주어진다.</p>

<p>둘째 줄에는 $2, 3, \cdots, N$번 정점의 부모 정점을 나타내는 자연수 $P_2, P_3, \cdots, P_N$이 주어진다.</p>

<p>다음 $Q$개의 줄에는 쿼리를 나타내는 $K \ V_1 \ V_2 \ \cdots \ V_K$가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 한 줄에 하나씩 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','16 4
1 2 3 4 3 1 7 8 9 7 11 12 1 14 15
2 4 5
2 10 13
3 4 6 16
4 4 10 6 13
','3
1
2
3
','DATA_STRUCTURE'),
                                                                                                                (8124,'BAEKJOON','https://www.acmicpc.net/problem/20550',20550,'구간 합 구하기 K','6초(하단참고)','512 MB',18,'<p>1~<i>N </i>범위의 정수&nbsp;<em>D</em><sub>1</sub>, <em>D</em><sub>2</sub>, ... , <em>D<sub>K</sub></em>&nbsp;에 대해 정수 <em>V</em>[<em>D</em><sub>1</sub>, <em>D</em><sub>2</sub>, ... , <em>D<sub>K</sub></em>]가 배정되어 있다.</p>

<p><em>V</em>에 대해 Q개의 쿼리를 처리할 것이고, 쿼리는 2가지 쿼리가 존재한다.</p>

<ul>
	<li><strong>1 <em>S</em><sub>1&nbsp;</sub><em>E</em><sub>1&nbsp;</sub><em>S</em><sub>2&nbsp;</sub><em>E</em><sub>2&nbsp;</sub>...&nbsp;<em>S<sub>K</sub><sub>&nbsp;</sub>E</em></strong><sub><em><strong>K</strong></em>&nbsp;</sub>: 1이상 <em>K</em>이하를 만족하는&nbsp;모든 정수&nbsp;<em>i</em>에 대해서, <em>A<sub>i</sub></em>&nbsp;값이 <em>S<sub>i</sub></em>&nbsp;이상이면서 <em>E</em><sub><em>i</em>&nbsp;</sub>이하를 모두 만족하는&nbsp;<em>V</em>[<em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, ... , <em>A<sub>K</sub></em>]들의 합을 출력한다.</li>
	<li><strong>2 <em>B</em><sub>1&nbsp;</sub><em>B</em><sub>2</sub>&nbsp;... <em>B<sub>k</sub>&nbsp;X</em></strong> :&nbsp;<em>V</em>[<em>B</em><sub>1</sub>,&nbsp;<em>B</em><sub>2</sub>,&nbsp;... ,&nbsp;<em>B<sub>k</sub></em>]를&nbsp;<em>X</em>로 변경한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p><em>N</em>, <em>K</em>, <em>Q</em>가 공백을 사이에 두고 한 줄에 주어진다.</p>

<p>2번째 줄에는 <em>V</em>에 배정되어있는 정수 <em>N<sup>K</sup></em>개가&nbsp;주어진다. 2번째 줄의&nbsp;<em>i</em>번째 수는&nbsp;<em>V</em>[<em>i&nbsp;</em>//&nbsp;<em>N<sup>K</sup></em><sup>-1</sup><em><sup>&nbsp;</sup></em>%&nbsp;<em>N&nbsp;</em>+ 1,&nbsp;<em>i </em>//&nbsp;<em>N<sup>K</sup></em><sup>-2</sup><em><sup>&nbsp;</sup></em>%&nbsp;<em>N&nbsp;</em>+ 1<em>, ...,&nbsp;i&nbsp;</em>//&nbsp;<em>N<sup>K</sup></em><sup>-</sup><em><sup>K&nbsp;</sup></em>%&nbsp;<em>N&nbsp;</em>+ 1]을 나타낸다. 2번째 줄의 제일 처음 나오는 수는 0번째 수이다. 즉,&nbsp;<em>i</em>는 0부터 시작한다. //연산자는 몫 연산자를 의미하고 %연산자는 나머지 연산자를 의미하며 //, %, + 세 연산자의 연산자&nbsp;우선순위는 같다.</p>

<p>그 다음 <i>Q</i>개의 줄에는 위에 설명된 2개중 하나의 쿼리가 한 줄에 하나씩 주어진다. (1번 쿼리는 최소 한 개 이상 주어진다)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1번 쿼리가 주어졌을 때, 쿼리에 대한 올바른 값을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','20 1 3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 20
2 1 10
1 1 20
','20
29
','DATA_STRUCTURE'),
                                                                                                                (8123,'BAEKJOON','https://www.acmicpc.net/problem/20551',20551,'Sort 마스터 배지훈의 후계자','2초','512 MB',7,'<p>지훈이는 Sort 마스터다. 오랫동안 Sort 마스터 자리를 지켜온 지훈이는 이제 마스터 자리를 후계자에게 물려주려고 한다. 수많은 제자들 중에 후계자를 고르기 위해서 지훈이는 제자들에게 문제를 준비했다. 먼저 제자들에게 $N$개의 원소를 가진 배열$A$를 주고, $A$의 원소들이 오름차순으로 정렬된 배열$B$를 만들게 한다. 그다음 $M$개의 질문을 한다. 각 질문에는 정수 $D$가 주어진다. 제자들은 주어진 정수$D$가 $B$에서 가장 먼저 등장한 위치를 출력하면 된다. 단, $D$가 $B$에 존재하지 않는 경우에는 -1를 출력한다. Sort 마스터의 자리를 너무나도 물려받고 싶은 창국이를 위해 지훈이의 문제를 풀 수 있는 프로그램을 만들어 주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 배열$A$의 원소의 개수 $N$과 질문의 개수 $M$이 공백으로 구분되어 주어진다.</p>

<p>다음 줄부터 $N$줄에 걸쳐 정수 $A_0, A_1, ... , A_{N-1}$이 주어진다.</p>

<p>다음 줄부터 $M$줄에 걸쳐 정수&nbsp;$D$가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$M$개의 질문에 대해서 주어진&nbsp;$D$가 $B$에서 처음으로 등장한 위치를 출력한다. 단, 존재하지 않는다면 -1를 출력한다. (배열에서 가장 앞의 원소의 위치는 0이다.)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
9
0
-1
3
2
-1
10
5
9
0
','0
-1
-1
4
1
','DATA_STRUCTURE'),
                                                                                                                (8125,'BAEKJOON','https://www.acmicpc.net/problem/20556',20556,'둥둥섬 다리 재정비하기','3초','1024 MB',21,'<p>라이언은 Secret Forest에 오기 전, 둥둥섬의 왕위 계승자였다. 이 이야기는 라이언이 아직 둥둥섬에 살고 있었을 때의 이야기이다.</p>

<p>둥둥섬은 $N$개의 작은 섬들이 $N-1$개의 다리를 통해 이어진 트리 구조를 이루는데, 둥둥섬의 다리는 모두 지나가는 데에 필요한 시간이 2이다.</p>

<p>라이언은 왕위 계승 후의 일에 대한 공부가 되도록 둥둥섬의 다리들을 재정비하는 사업을 지도하게 되었다. 다리를 재정비하면 지나가는 데에 필요한 시간이 1로 줄어들게 된다.</p>

<p>라이언이 다리 재정비 계획을 세우던 중, 둥둥섬의 수도를 이전한다는 소식을 듣게 되었다. 수도는 둥둥섬의 중심이므로, 라이언은 다리를 재정비할 때 다른 모든 섬들에서 수도까지 가는 데에 걸리는 시간의 합을 최소로 하고 싶다.</p>

<p>라이언은 아직 재정비할 다리의 수를 결정하지 못한 데다가 새로운 수도의 위치를 아직 전달받지 못했다고 한다. 라이언을 도와 수도와 재정비할 다리의 수가 주어질 때마다 적절히 다리들을 재정비했을 때 다른 모든 섬들에서 수도까지 가는 데에 걸리는 시간의 합의 최솟값을 구해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 섬의 수 $N$과 쿼리의 수 $Q$가 주어진다. $(1 \leq N,Q \leq 300\,000)$</p>

<p>이후 $N-1$개의 줄에 걸쳐 다리들이 연결하는 두 섬 $u$와 $v$가 공백으로 구분되어 주어진다. $(1 \leq u,v \leq N)$</p>

<p>이후 $Q$개의 줄에 걸쳐 쿼리가 주어진다. $u$와 $a$가 공백으로 구분되어 주어진다. 이는 수도를 $u$로 하고 $a$개의 다리를 재정비한다는 뜻이다. $(1 \leq u \leq N, 0 \leq a \leq N-1)$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 쿼리의 답을 순서대로 줄바꿈으로 구분하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 5
10 3
9 4
7 8
4 6
3 6
6 2
2 8
8 5
1 5
4 2
1 5
3 4
6 3
2 7
','37
40
31
27
21
','DATA_STRUCTURE'),
                                                                                                                (8127,'BAEKJOON','https://www.acmicpc.net/problem/20559',20559,'정기 모임 2','3초','1024 MB',22,'<p>정점이 $N$개인 트리가 주어진다. 각 정점은 1번부터 $N$번까지 차례대로 번호가 부여되어 있다. $i$번째 간선은 $A_i$번 정점과 $B_i$번 정점을 연결하며, 가중치는 $C_i$다. $(1 \leq i < N)$</p>

<p>트리에서 두 정점 사이의 거리는 그 둘을 잇는 최단경로 상의 간선의 가중치의 최댓값으로 정의한다. 단, 같은 두 정점 사이의 거리는 0으로 정의한다.</p>

<p>트리에 사는 사람들이 $N$개의 모임을 개최하려 한다. $i$번째 모임에는 1 이상 $i$ 이하의 번호를 가진 정점에 사는 사람들이 참석한다. 올해에는 코로나바이러스 전파 상황을 고려해 모임을 $X$개의 장소에서 각자 모인 후, 인터넷으로 진행하기로 했다. 각 모임은 트리 상의 서로 다른 $X$개의 정점 $v_1,\cdots,v_X$에서 이루어진다. 모임마다 고르는 정점은 독립적이다. 정점들이 정해지면 각 사람은 $v_1, \cdots, v_X$ 중 필요한 이동 거리가 최소인 정점 중 하나를 골라 이동하게 된다.</p>

<p>코로나바이러스 전파 상황에 따라 $X$의 값을 $1$부터 $K$까지의 값 중 하나로 정하기로 하였다. 모임을 미리 준비하기 위해 각 모임에 대해, $X$의 값이 $1$일 때부터 $K$일 때까지 사람들이 이동하는 거리의 최댓값의 최솟값의 합을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 트리의 정점 개수를 의미하는 정수 $N$과 정수 $K$가 사이에 공백을 두고 주어진다. $(1 \leq K \leq N \leq 300\,000)$</p>

<p>두번째 줄부터 $(N-1)$개의 줄에 걸쳐, 트리의 간선에 대한 정보가 주어진다. $(i+1)$번째 줄에는 세 개의 정수 $A_i,B_i,C_i$가 사이에 공백을 두고 주어진다. $(1 \leq i <N)$. 이는 $A_i$번 정점과 $B_i$번 정점을 연결하는 가중치 $C_i$의 간선이 존재함을 의미한다. $(1 \leq A_i,B_i,C_i \leq N)$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄부터 $N$개의 줄에 걸쳐, 답을 차례대로 출력한다. $i$번째 줄에는 $i$번째 모임에 대한 답을 출력한다 $(1 \leq i \leq N)$.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 4
5 1 2
1 6 4
6 2 1
2 8 9
8 3 5
3 4 8
4 10 9
10 9 8
9 7 7
','0
4
13
21
23
23
30
31
33
34
','DATA_STRUCTURE'),
                                                                                                                (8129,'BAEKJOON','https://www.acmicpc.net/problem/20561',20561,'과제 해결하기','2.5초','1024 MB',27,'<p>오늘 송죽학사에 $N$개의 과제가 올라올 예정이다. 종영이와 친구들은 그다지 과제를 하고 싶지 않으므로 과제들을 분담해서 해결하기로 했다.</p>

<p>과제 $i$는 시각 $L_i$에 올라와 시각 $R_i$까지 제출할 수 있는데, 학생들의 학습능력이 그다지 뛰어나지 않아 제출이 가능한 시간 내내 그 과제를 해결해야 한다. 또 한 학생이 동시에 두 과제를 해결할 수 없으므로 두 과제 $i$와 $j$를 한 학생이 해결하려면 $R_i < L_j$ 또는 $R_j < L_i$를 만족해야 한다. 또 학생들은 과제에 그다지 큰 관심이 없으므로 한 학생당 최대 두 개의 과제를 해결할 것이다.</p>

<p>$M$명의 학생이 최대한 많은 과제를 해결하고자 할 때, 학생들 각각이 해결해야 할 과제를 정해주자. 가능한 경우가 여럿 있을 경우 어떤 방법을 선택하여도 좋다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 정수 $N$과 $M$이 주어진다. $(1 \leq M \leq N \leq 300\,000)$</p>

<p>이후 $N$개의 줄에 걸쳐 정수 $L_i$와 $R_i$가 주어진다. $(1 \leq L_i < R_i \leq 10^9)$</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$N$개의 수를 공백으로 구분하여 출력한다. $i$번째 수로는 과제 $i$를 해결할 학생을 출력한다. 과제 $i$를 해결할 학생이 없다면 대신 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 5
9 10
7 9
3 4
9 10
2 6
8 9
5 8
','3 2 2 5 5 4 1
','DATA_STRUCTURE'),
                                                                                                                (8128,'BAEKJOON','https://www.acmicpc.net/problem/20564',20564,'트리와 쿼리 19','5초','512 MB',22,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고,&nbsp;모든 정점의 색은 검정색 또는 흰색이다.</p>

<p>아래의 쿼리를 처리하는 프로그램을 작성하시오.</p>

<ul>
	<li>X : X번 정점의 색을 바꾼다.&nbsp;(흰색 -> 검정색, 검정색 -> 흰색) 이후 서로 다른 모든 흰색 정점 쌍 (a,b)에 대해 LCA(최소 공통 조상)레벨의 합을 출력한다.</li>
</ul>

<p>루트 정점은 1번 정점이다.&nbsp;루트 정점의 레벨은 0이며, 다른 정점의 레벨은 (부모 정점의 레벨) + 1로 정의한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 갯수 N과 쿼리의 갯수 Q가 주어진다.</p>

<p>뚤째 줄에는 1, 2, ?, N번 정점의 색을 나타내는 정수 t<sub>1</sub>, t<sub>2</sub>, ?, t<sub>N</sub>이 주어진다. 1 ≤ i ≤ N인 자연수 i에 대해 t<sub>i&nbsp;</sub>= 0인 경우 검정색이고 t<sub>i&nbsp;</sub>= 1인 경우 흰색이다.</p>

<p>셋째 줄에는&nbsp;2, 3, ?, N번 정점의 부모 정점을 나타내는 자연수&nbsp;P<sub>2</sub>, P<sub>3</sub>, ?, P<sub>N</sub>이 주어진다.</p>

<p>다음 Q개의 줄에는 쿼리를 나타내는 X가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫번째 줄에는 초기 상태의 정답을 출력한다.</p>

<p>두번째 줄부터 Q개의 줄에 걸쳐 각 쿼리의 정답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
1 0 0 1 1
1 1 3 2
5
3
5
4
2
','0
0
1
1
0
1
','DATA_STRUCTURE'),
                                                                                                                (8138,'BAEKJOON','https://www.acmicpc.net/problem/20654',20654,'음료수는 사드세요 제발','3초','1024 MB',22,'<p>재현이는 여러 액체를 섞어서 음료수를 만드는 취미가 생겼다.</p>

<p>마트에서는 $0, 1, \ldots, n - 1$ 의 번호가 붙어 있는 $n$ 개의 액체를 판다. $i$ 번 액체는 맛이 $d_i$이고, 가격이 1리터당 $p_i$ 이다. 재현이가 만드는 음료수 한 병에는 $i$ 번 액체를 $l_i$ 리터 이하로만 사용해야 한다. (이 수칙을 어길 시에는 건강이 매우 위험해질 수도 있다.)</p>

<p>재현이의 음료를 마시면 건강과 문제 풀이 실력을 맞바꿀 수 있다는 기괴한 소문이 돌면서, $m$ 명의 사람들이 음료수 한 병을 마시기 위해 재현이의 집을 찾아왔다. 이 중 $j$ 번 사람은, 음료수 한 병을 만드는 데 든 액체의 가격이 $g_j$ 이하이며, 양이 $L_j$ 리터 이상이기를 원한다. 이 조건 하에서, $j$ 번 사람은 음료수의 맛을 최대화하고 싶다: 이 때, 음료수의 맛은, 음료수를 이루는 액체들의 맛 중 최솟값이다.&nbsp;</p>

<p>각 사람에 대해서, 이 사람이 마시게 될 음료수의 맛을 출력하라. 만약 음료수를 대접할 수 없다면, -1을 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 두 정수 $n, m$ ($1 \le n, m \le 100\,000$) 이 주어진다.</p>

<p>이후 $n$ 개의 줄에 세 정수 $d_i, p_i, l_i$ 가 주어진다. ($1 \le d_i, p_i, l_i \le 10^5$)</p>

<p>이후 $m$ 개의 줄에 두 정수 $g_i, L_i$ 가 주어진다. ($1 \le g_i, L_i \le 10^{18}$)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$m$ 개의 줄에 정답을 출력하라. $i$ 번째 줄에는 $i$ 번 사람이 마시게 될 음료수의 맛을 출력하라. 만약 음료수를 대접할 수 없다면, -1을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 4
1 3 5
2 1 3
3 2 5
6 3
5 3
10 10
20 10
','3
2
-1
1
','DATA_STRUCTURE'),
                                                                                                                (8141,'BAEKJOON','https://www.acmicpc.net/problem/20666',20666,'인물이와 정수','1초','512 MB',13,'<p>인물이와&nbsp;정수는&nbsp;친한&nbsp;친구이다. 어느 날&nbsp;인물이가&nbsp;하는&nbsp;게임에&nbsp;관심이&nbsp;생긴&nbsp;정수는&nbsp;게임에&nbsp;대해&nbsp;이것저것&nbsp;물어보았다.</p>

<p>게임에는&nbsp;<em>N</em>마리의&nbsp;몬스터가&nbsp;있고,&nbsp;<em>M</em>마리의&nbsp;몬스터를&nbsp;잡으면&nbsp;이&nbsp;게임을&nbsp;클리어하게&nbsp;된다. 몬스터는&nbsp;한&nbsp;번에&nbsp;하나씩만&nbsp;잡을&nbsp;수&nbsp;있다.</p>

<p>각각의&nbsp;몬스터를&nbsp;잡으면&nbsp;그&nbsp;몬스터가&nbsp;주는&nbsp;아이템을&nbsp;얻을&nbsp;수&nbsp;있다. 즉&nbsp;a번&nbsp;몬스터를&nbsp;잡으면&nbsp;a번&nbsp;아이템을&nbsp;얻을&nbsp;수&nbsp;있고,&nbsp;a번&nbsp;아이템을&nbsp;다른&nbsp;경로로&nbsp;얻을&nbsp;수&nbsp;있는&nbsp;방법은&nbsp;없다.</p>

<p>게임을&nbsp;많이&nbsp;했던&nbsp;인물이는&nbsp;각&nbsp;몬스터들을&nbsp;한 번씩&nbsp;잡아서&nbsp;모든&nbsp;아이템을&nbsp;갖고&nbsp;있다. 그래서&nbsp;인물이는&nbsp;각&nbsp;몬스터의&nbsp;난이도가 <em>C<sub>i</sub></em>라고&nbsp;했지만,&nbsp;정수는&nbsp;게임을&nbsp;처음&nbsp;해서&nbsp;아이템이&nbsp;없기&nbsp;때문에&nbsp;그보다&nbsp;더&nbsp;어려워질&nbsp;수&nbsp;있다.</p>

<p>인물이는&nbsp;정수에게&nbsp;권장&nbsp;아이템에&nbsp;관한&nbsp;팁&nbsp;<em>p</em>개를&nbsp;알려주었다.&nbsp;팁은&nbsp;<em>a,&nbsp;b,&nbsp;t</em>의&nbsp;형태를&nbsp;갖고&nbsp;있고,&nbsp;<em>a</em>&nbsp;아이템&nbsp;없이&nbsp;<em>b</em>&nbsp;몬스터를&nbsp;잡을&nbsp;경우&nbsp;<em>t</em>&nbsp;만큼&nbsp;어려워진다는&nbsp;것을&nbsp;말한다.</p>

<p>정수는&nbsp;게임을&nbsp;하면서&nbsp;만나는&nbsp;몬스터의&nbsp;최대&nbsp;난이도를&nbsp;이&nbsp;게임의&nbsp;난이도라고&nbsp;생각한다. 인물이는&nbsp;정수가&nbsp;게임을&nbsp;너무&nbsp;어렵게&nbsp;느끼지&nbsp;않도록&nbsp;몬스터를&nbsp;잡는&nbsp;순서를&nbsp;잘&nbsp;정해주었다. 정수가&nbsp;게임을&nbsp;클리어할&nbsp;때&nbsp;느끼는&nbsp;난이도를&nbsp;최대한&nbsp;줄여보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째&nbsp;줄에 두 정수 <em>N</em>,<em> M&nbsp;</em>이 공백으로 구분되어&nbsp;주어진다. (1 ≤&nbsp;<em>N</em>&nbsp;≤ 100,000, 1 ≤&nbsp;<em>M</em>&nbsp;≤&nbsp;<em>N</em>)</p>

<p>두 번째 줄에 <em>N</em> 개의 정수 <em>C<sub>1</sub>, C<sub>2</sub>, ... , C<sub>N</sub></em>&nbsp;가 공백으로 구분되어 주어진다. <em>C<sub>i&nbsp;</sub></em>는 인물이에게&nbsp;<em>i</em>&nbsp;번째 몬스터의 난이도를 말한다. (1 ≤ <i>C<sub>i</sub></i>&nbsp;≤ 1,000,000,000)</p>

<p>세 번째 줄에 정수가 받은&nbsp;팁의 개수 <em>p</em>&nbsp;가 주어진다. (0 ≤ <i>p</i>&nbsp;≤ 300,000)</p>

<p>다음 <i>p</i>&nbsp;줄에 걸쳐 <em>a, b, t</em> 가 주어진다. <em>a</em> 아이템이 없어 <em>b</em> 몬스터를 잡을 때 <em>t</em> 만큼 난이도가 올라가게 된다. (1 ≤ <i>a, b</i>&nbsp;≤ <em>N</em>, 1 ≤ <em>t</em> ≤ 1,000,000,000)</p>

<p>두 팁의 a, b가 같은 경우는 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>정수가 게임을 클리어할 때 느끼는 난이도의 최소값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
2 1 5 6 3
0
','3
','DATA_STRUCTURE'),
                                                                                                                (8148,'BAEKJOON','https://www.acmicpc.net/problem/20671',20671,'요새 파괴','1초','512 MB',19,'<p><em>N</em>개의&nbsp;블럭들이&nbsp;쌓여&nbsp;요새를&nbsp;만든다.&nbsp;각각의&nbsp;블럭은 서로 겹치지 않게&nbsp;<em>H</em>층에서 <em>L</em>칸에서 <em>R</em>칸까지의 구간을&nbsp;차지한다. 1층의 블럭을 제외한 다른 블럭들은 항상 아래층에 어떤 블럭이 존재한다. 이때 위에&nbsp;쌓여&nbsp;있는&nbsp;블럭은&nbsp;아래에&nbsp;있는&nbsp;블럭의&nbsp;구간&nbsp;안에&nbsp;전부&nbsp;포함된다. 즉, 임의의 i 번 블럭의 위에 쌓이는 모든 j번 블럭에 대해서 <em>L<sub>i</sub>&nbsp;≤&nbsp;L<sub>j</sub>&nbsp;≤&nbsp;R<sub>j</sub>&nbsp;≤&nbsp;R<sub>i</sub></em>가&nbsp;성립한다.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/0372705b-c2bd-4d22-9cf8-bec21fe70483/-/preview/" style="height: 162.5px; width: 337.5px;"></p>

<p>이러한&nbsp;요새를&nbsp;파괴하기&nbsp;위해&nbsp;미사일&nbsp;폭격이&nbsp;<em>K</em>번&nbsp;이루어졌다. 각&nbsp;폭격은&nbsp;위치&nbsp;<em>X</em>에&nbsp;위력&nbsp;<em>P</em>인&nbsp;미사일이&nbsp;발사되었고,&nbsp;요새의 <em>X</em> 위치에&nbsp;있는&nbsp;블럭&nbsp;중&nbsp;위에서부터&nbsp;최대&nbsp;<em>P</em>개의&nbsp;블럭을&nbsp;파괴한다. 이때&nbsp;블럭이&nbsp;제거되는&nbsp;과정에서&nbsp;아래에&nbsp;깔려&nbsp;있던&nbsp;블럭이&nbsp;제거되는&nbsp;경우&nbsp;위에&nbsp;있는&nbsp;블럭은&nbsp;피해&nbsp;없이&nbsp;그대로&nbsp;아래로&nbsp;내려온다.</p>

<p>다음&nbsp;그림은&nbsp;위치&nbsp;<em>X</em>=5에&nbsp;위력&nbsp;<em>P</em>=1인&nbsp;미사일이&nbsp;발사되는&nbsp;모습이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/69de5526-77b6-4a19-a7a0-42399452a783/-/preview/" style="width: 335px; height: 85px;"><br>
&nbsp;</p>

<p>폭격된&nbsp;순서대로&nbsp;각&nbsp;폭격에&nbsp;대하여&nbsp;파괴된&nbsp;블럭의&nbsp;개수를&nbsp;구하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫&nbsp;줄에&nbsp;블럭의&nbsp;개수&nbsp;<em>N</em>이&nbsp;주어진다. (1&nbsp;≤&nbsp;<em>N</em>&nbsp;≤&nbsp;100,000)</p>

<p>다음&nbsp;<em>N</em>줄에&nbsp;걸쳐 요새를 이루고 있는 블럭의&nbsp;정보&nbsp;<em>H</em>,&nbsp;<em>L</em>, <i>R</i>가 주어진다. (1&nbsp;≤&nbsp;<em>H</em>&nbsp;≤&nbsp;<em>N,&nbsp;</em>1 ≤ <i>L</i>&nbsp;≤ <i>R</i>&nbsp;≤&nbsp;1,000,000,000)</p>

<p>다음&nbsp;줄에&nbsp;폭격의&nbsp;횟수&nbsp;<em>Q</em>가&nbsp;주어진다. (1&nbsp;≤&nbsp;<em>Q</em>&nbsp;≤&nbsp;100,000)</p>

<p>다음&nbsp;<em>Q</em>줄에&nbsp;걸쳐&nbsp;폭격의&nbsp;위치&nbsp;<em>X</em>와&nbsp;위력&nbsp;<em>P</em>가&nbsp;주어진다. (1&nbsp;≤&nbsp;<em>X</em>&nbsp;≤&nbsp;1,000,000,000, 1&nbsp;≤&nbsp;<em>P</em>&nbsp;≤&nbsp;<em>N</em>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>폭격된&nbsp;순서대로&nbsp;각&nbsp;폭격에&nbsp;대하여&nbsp;파괴된&nbsp;블럭의&nbsp;개수를&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
4 10 11
3 9 11
3 7 8
2 7 11
1 1 12
3 3 4
2 2 5
4
5 1
11 2
10 3
9 4
','1 2 2 0
','DATA_STRUCTURE'),
                                                                                                                (8140,'BAEKJOON','https://www.acmicpc.net/problem/20916',20916,'안녕 2020 안녕 2021','1.5초(추가시간없음)(하단참고)','512 MB',10,'<p>2020년을 보내고 2021년을 맞이하는 기념으로 Albert는 재미있는 문제를 풀기로 했다. 양의 정수 중 첫 네 숫자가 "2020"이며 마지막 네 숫자가 "2021"이면&nbsp;"<strong>안녕한 정수</strong>" 라고 정의 하자. 가령 202021 이나 20202021은 "안녕한 정수" 이며, 2020021 이나 2020221 은 안녕한 정수가 아니다.</p>

<p>Albert는 n개의 정수 A[1], A[2], ..., A[n]중 두 수를 골라 더했을 때 그 합이 "안녕한 정수"가 되는 쌍의 개수를 알고 싶다. 즉, 1 ≤ i < j ≤ n 을 만족하는 (i, j) 쌍 중 A[i] + A[j]가 안녕한 정수인 쌍의 개수를 알고 싶다. 예를 들어 A = [101010, 101010, 101011, 101011], 즉 n = 4개의 정수가 있다고 하자. 이 경우 A[1] + A[3] = A[1] + A[4] = A[2] + A[3] = A[2] + A[4] = 202021 이므로 총 4개의 쌍이 존재한다 ((1, 3), (1, 4), (2, 3), (2, 4)).</p>

<p>입력으로 n개의 정수가 주어졌을 때, 합이 안녕한 정수가 되도록 하는 쌍의 개수를 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T가 주어진다. 각 테스트 케이스는 두 줄로 구성된다.</p>

<p>첫 줄에 정수의 개수 n이 주어진다. 다음 줄에 n개의 정수가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해 합이 안녕한 정수가 되는 쌍의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
4
101010 101010 101011 101011
5
100000 100000 100000 101011 101011
4
202021 0 1 202020
','4
0
2
','DATA_STRUCTURE'),
                                                                                                                (8122,'BAEKJOON','https://www.acmicpc.net/problem/20919',20919,'XOR 자료구조','2초','512 MB',18,'<p>Albert는 최근 (2진수) XOR 연산과 자료구조에 흠뻑 빠져있다.</p>

<p>Albert는 XOR에 관련된 여러 가지 연산을 효율적으로 할 수 있는 자료 구조를 만들고 싶다.&nbsp;</p>

<p>처음에는 n개의 정수를 포함한 집합 S0을 이용하여 자료 구조를 초기화 하며, 그 이후 q개의 연산을 수행하여 옳은 답을 출력해야한다.</p>

<p>각 연산은 아래 다섯 가지 중 하나이며, 일부 연산은 자료 구조에 저장된 정수 집합에 새로운 정수를 추가하거나 정수를 지우기도 한다 (따라서 그 이후의 연산은 영향을 받게 된다).</p>

<ol>
	<li>find_min(v): 현재 자료 구조에 저장된 정수 집합이 S라면, (v XOR s) 값이 최소가 되는 S의 원소&nbsp;s를 찾아 (v XOR s) 값을 출력한다. S는 변경되지 않는다.</li>
	<li>find_max(v): 현재 자료 구조에 저장된 정수 집합이 S라면, (v XOR s) 값이 최대가&nbsp;되는 S의 원소&nbsp;s를 찾아 (v XOR s) 값을 출력한다. S는 변경되지 않는다.</li>
	<li>add(v): 현재 자료 구조에 저장된 정수 집합 S에 v를 추가한다. 추가한 후, S에 저장된 고유한 정수의 개수를 출력한다.</li>
	<li>remove_min(): 현재 자료 구조에 저장된 정수 집합 S의 원소 중 가장 작은 수를 출력한 후, 이를 삭제한다. 만약 가장 작은 수가 여럿이라면 모두 삭제한다.</li>
	<li>remove_max(): 현재 자료 구조에 저장된 정수 집합 S의 원소 중 가장 큰&nbsp;수를 출력한 후, 이를 삭제한다. 만약 가장 큰 수가 여럿이라면 모두 삭제한다.</li>
</ol>

<p>예를 들어, S0 = {1,1, 3, 3} 이고 아래와 같은 순서로 총 q = 7개의 연산을 적용한다고 해보자.</p>

<ol>
	<li>find_min(2): (1 XOR 2) = 3 이고 (2 XOR 3) = 1 이므로 1을 출력해야한다. 연산 적용 후, S는 바뀌지 않으므로 S = {1, 1, 3, 3} 이다.</li>
	<li>find_max(2): (1 XOR 2) = 3 이고 (2 XOR 3) = 1 이므로 3을 출력해야한다. 연산 적용 후, S는 바뀌지 않으므로 S = {1, 1, 3, 3} 이다.</li>
	<li>add(2): S에 새로운 원소를 추가하여 S = {1, 1, 2, 3, 3}이 된다. 중복을 제외하면 총 3개의 고유한 정수가 있으므로 3을 출력한다.</li>
	<li>remove_min(): S의 원소 중 가장 작은 수는 1이므로 1을 출력하고, 모두 삭제한다. 연산 적용 후, S = {2, 3, 3} 이다.</li>
	<li>remove_max(): S의 원소 중 가장 큰 수는 3이므로 3을 출력하고, 모두 삭제한다. 연산 적용 후, S = {2} 이다.</li>
	<li>find_min(2): (2 XOR 2) = 0 이므로 0을 출력해야한다.</li>
	<li>find_max(2): (2 XOR 2) = 0 이므로 0을 출력해야한다.</li>
</ol>

<p>위의 예제의 경우, 올바른 결과는 (연산 적용 순서대로) [1, 3, 3, 1, 3, 0, 0]이 된다.</p>

<p>입력으로 n, S0, q, 그리고 q개의 연산을 받아 총 q개의 정수 (각 연산을 적용한 후 얻은 결과)를 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T가 주어진다.</p>

<p>각 테스트 케이스의 첫 줄에는 n과 q가 공백으로 구분 되어 주어진다.</p>

<p>둘째 줄에는 집합 S0에 포함된&nbsp;n개의 정수가 공백으로 주어진다.</p>

<p>다음 q줄에 걸쳐 각 줄에 하나의 연산이 주어진다.</p>

<p>각 줄에는 1개 혹은 2개의 정수가 (공백으로 구분되어) 주어지는데, 첫 수는 연산의 종류를 나타내며 {1, 2, 3, 4, 5} 중 하나이다.</p>

<p>문제 본문에 설명된바와 같이, 1은 find_min, 2는 find_max, 3은 add, 4는 remove_min, 그리고 5는 remove_max 연산을 나타낸다.</p>

<p>연산 1-3의 경우에만 같은 줄에 두 번째 정수 "v"가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각&nbsp;연산을 적용한 후 자료 구조가 출력해야하는 올바른 값을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
4 7
1 1 3 3
1 2
2 2
3 2
4
5
1 2
2 2
10 11
1 3 5 7 9 2 4 6 8 10
1 6
1 8
2 6
2 8
3 10
4
5
1 2
1 17
2 2
2 17
5 11
2 5 8 13 17
1 6
1 8
2 6
2 8
3 10
4
5
1 2
1 17
2 2
2 17
','1
3
3
1
3
0
0
0
0
15
15
10
1
10
0
18
11
25
3
0
23
25
6
2
17
7
20
15
28
','DATA_STRUCTURE'),
                                                                                                                (8168,'BAEKJOON','https://www.acmicpc.net/problem/20923',20923,'숫자 할리갈리 게임','1초(추가시간없음)','1024 MB',10,'<p>인간이 가장 심심함을 느낀다는 오후 1시 22분, 도도와 수연이는 숫자 할리 갈리 게임을 하려 한다. 숫자 할리 갈리 게임의 규칙은 다음과 같다.</p>

<p style="text-align: center;"><strong>[숫자 할리 갈리 게임의 규칙]</strong></p>

<ol>
	<li>도도와 수연이는 각각 $N$장의 카드로 이루어진 덱을 배분받는다. 게임 시작 시 그라운드는 비어있는 상태이다.
	<ul>
		<li>덱은 숫자가 보이지 않게 카드를 뒤집어 쌓아 놓은 카드 더미를 의미한다. 도도와 수연이는 자신의 덱을 가지고 게임을 진행하게 된다.</li>
		<li>그라운드는 카드를 내려놓게 되는 땅을 의미한다. 그라운드에 카드를 내려놓을 때는 자신의 그라운드에 카드를 내려놓으며, 그라운드에 카드 더미가 존재할 경우 카드 더미 위에 카드를 내려놓는 방식으로 게임을 진행한다.</li>
	</ul>
	</li>
	<li>도도를 시작으로 도도와 수연이가 차례대로 자신이 가진 덱에서 가장 위에 위치한 카드를 그라운드에 숫자가 보이도록 내려놓는다.</li>
	<li>종을 치는 사람이 그라운드에 나와 있는 카드 더미를 모두 가져간다. 종을 치는 조건은 다음과 같다.
	<ul>
		<li>그라운드에 나와 있는 각각의 카드 더미에서 가장 위에 위치한 카드의 숫자 합이 5가 되는 순간 수연이가 종을 친다. 단, 어느 쪽의 그라운드도 비어있으면 안된다.</li>
		<li>그라운드에 나와 있는 각각의 카드 더미 중 가장 위에 위치한 카드의 숫자가 5가 나오는 순간 도도가 종을 친다.</li>
	</ul>
	</li>
	<li>종을 쳤다면, 상대방의 그라운드에 있는 카드 더미를 뒤집어 자신의 덱 아래로 그대로 합친 후 자신의 그라운드에 있는 카드 더미 역시 뒤집어 자신의 덱 아래로 그대로 가져와 합친다.
	<ul>
		<li>종을 쳐서 그라운드에 있는 카드 더미를 가져가는 행위는 게임의 진행 순서에 영향을 미치지 않는다.</li>
	</ul>
	</li>
</ol>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/22dc1ff3-6e90-4441-b84f-6544eb329eeb/-/preview/" style="height: 165px; width: 347.5px;"></p>

<ol start="5">
	<li>한 명이 2-4번까지의 과정을 진행하는 것을 1번 진행한 것으로 보며 다음과 같은 방법으로 게임의 승패가 결정된다.
	<ol>
		<li>게임 진행 도중 자신의 덱에 있는 카드의 수가 0개가 되면 상대방이 승리한 것으로 본다.</li>
		<li>$M$번 진행한 후 자신의 덱에 더 많은 카드를 지닌 사람이 승리한다.</li>
		<li>$M$번 진행 후 각자의 덱에 있는 카드의 개수가 같다면 비긴 것으로 본다.</li>
	</ol>
	</li>
</ol>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3e2fe162-2931-457c-808f-1f84551e7061/-/preview/" style="height: 119.167px; width: 347.5px;"></p>

<p>게임을 $M$번 진행한 후 승리한 사람은 누구일까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 도도와 수연이가 가지는 카드의 개수 $N$($ 1 \leq N \leq 30\,000$)과 게임 진행 횟수 $M$($ 1 \leq M \leq 2\,500\,000$)이 주어진다.</p>

<p>둘째 줄부터 $N$개의 줄에는 띄어쓰기로 구분하여 도도와 수연이가 가진 덱의 맨 아래에 위치한 카드에 적혀 있는 수부터 맨 위에 위치한 카드에 적힌 수까지 차례대로 주어진다. (각각의 카드는 $1$ 이상 $5$ 이하의 자연수가 적혀있다.)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>게임을 이긴 사람이 도도라면 <span style="color:#e74c3c;"><code>do</code></span>를 출력하고 게임을 이긴 사람이 수연이라면 <code><span style="color:#e74c3c;">su</span></code>를 출력한다. 비겼을 경우, <span style="color:#e74c3c;"><code>dosu</code></span>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 12
1 2
2 2
1 2
2 3
3 1
2 2
2 5
2 1
5 1
2 3
','do
','DATA_STRUCTURE'),
                                                                                                                (8163,'BAEKJOON','https://www.acmicpc.net/problem/20930',20930,'우주 정거장','2.5초(추가시간없음)','1024 MB',16,'<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/cfb1ae7b-df61-4bed-b49c-4f844f722c51/-/preview/" style="width: 336.667px; height: 248.333px;"></p>

<p>우주 정거장은 한 개의 선분으로 구성되어 있으며, 좌표 평면상에 $N$개의 우주 정거장이 있다. 각 우주 정거장은 $1$번부터 $N$번까지 번호가 붙어 있다.</p>

<p>비행선은 무조건 우주 정거장에서만 출발할 수 있으며 이동하면서 만나는 우주 정거장에서만 멈출 수 있다. 경계도 우주 정거장에 포함된다.&nbsp;비행선이 움직이는 방법은 3가지다.</p>

<ul>
	<li>x축과&nbsp;평행한 방향으로&nbsp;이동.</li>
	<li>y축과&nbsp;평행한 방향으로&nbsp;이동.</li>
	<li>우주 정거장 내에서 이동.</li>
</ul>

<p>서로 다른 두 정거장이 주어졌을 때, 두 정거장 사이를 오갈 수 있는지에 대해서 알아보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 우주 정거장 개수 $N$과 질문의 개수 $Q$가 주어진다. ($2 \le&nbsp;N \le&nbsp;200\,000$, $1 \le&nbsp;Q \le&nbsp;200\,000$)</p>

<p>다음 $N$개의 줄에는 $i$번&nbsp;우주 정거장의 양 끝점을 나타내는 $x_{i,1}$, $y_{i,1}$, $x_{i,2}$, $y_{i,2}$가 주어진다. 모든 좌표의 절댓값은 $10^9$ 이하의 정수값이다.</p>

<p>다음 $Q$개의 줄에 서로 다른 우주 정거장의 번호 두 개가&nbsp;주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$Q$개의 줄을 출력한다. 각 줄에는 주어진 순서대로 질문에 대한 대답이 출력되어야 한다. 질문에 주어진 두 정거장 사이를 오갈 수 있는 경우 대답은 <span style="color:#e74c3c;"><code>1</code></span>, 그렇지 않은 경우 대답은 <code><span style="color:#e74c3c;">0</span></code>이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
5 5 1 1
4 7 6 7
7 2 9 0
1 2
1 3
2 3
','1
1
1
','DATA_STRUCTURE'),
                                                                                                                (8165,'BAEKJOON','https://www.acmicpc.net/problem/20931',20931,'혹 떼러 갔다 혹 붙여 온다','2초(추가시간없음)','1024 MB',17,'<p style="text-align: center;"><em>"혹 떼러 갔다 혹 붙여 온다 : 애드-혹"</em></p>

<p>혹부리 영감은 얼굴에 달린&nbsp;커다란 혹을 떼고 싶어 도깨비를 찾아갔지만, 장난을 좋아하는 도깨비는 오히려 혹을 더 붙이려고 한다.&nbsp;편의상 모든 혹은 선분으로 간주하며, <strong>최초에 혹부리 영감에게는 길이가 무한히 긴 $0$번 혹 한 개</strong>가 달려있다. 도깨비는 항상 모든 혹의 연결관계가&nbsp;<strong>트리</strong> 구조를 이루도록 혹을 붙인다. 즉, $0$번 혹을 제외한 모든 혹의 윗부분은, 오직 정확히 하나의 혹의 아래에 닿아있다.</p>

<p>도깨비는 혹을 붙이면서, 혹부리 영감에게 "이 혹에서 이만큼 위에는 무슨 혹이 있을까~요?" 라는 문제를&nbsp;낸다. 이 문제를&nbsp;전부 맞힌다면 마지막엔 모든 혹을 떼어주기로 약속하였다. 문제를 푸는 것에는 자신이 없는 혹부리 영감을 대신하여 여러분이 답을 알려주자.&nbsp;</p>

<p>혹을 어떻게 붙일지 미리 예측하는 것을 막기 위해, 도깨비가 특이한 방법을 사용하여 혹을 붙일 위치를 정하는 것을 주의하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 도깨비의 행동의 횟수 $Q$ ($1 \le Q \le 150\,000$)가 주어진다.</p>

<p>$Q$개의 줄에 걸쳐, 도깨비가 하는 행동이 순서대로 "<strong><code>query</code></strong> $x$ $L$" 또는 "<strong><code>ad-hoc</code></strong> $k$ $L$" 의 형식으로 주어진다. 도깨비가 <strong>행동을 하려는 시점</strong>에서&nbsp;혹부리 영감에게 <strong>달려있는 혹의 개수를 $M$개</strong>라고 하자.</p>

<ul>
	<li>"<strong><code>query</code></strong> $x$ $L$" : $x$번 혹의 아래쪽 끝에서 시작해, 혹을 따라 $L$만큼 거슬러 올라갔을 때 어떤 혹이 있는지 대답해야 한다. 그 지점이 두 혹의 경계라면, 위쪽 혹의 번호를 답한다. 이때의 답이 지금부터의 <code><strong>"마지막 정답"</strong></code>이 된다. ($0 \le x < M$, $1 \le L \le 10^{18}$)</li>
	<li>"<strong><code>ad-hoc</code></strong> $k$ $L$" : &nbsp;$x = (k +$<code><strong>"마지막 정답"</strong></code>$) \mod M$ 을 계산한 후, 길이가 $L$인 $M$번 혹을 새로 만들어, $M$번 혹의 윗부분이&nbsp;$x$번 혹의 아래에 닿도록&nbsp;붙인다. $M$번 혹을 붙일 때에는 $x$번 혹 이외의 다른 혹에는 닿지 않게 한다. 아직 한 번도 <strong><code>query</code></strong>가 주어지지 않았다면, <code><strong>"마지막 정답"</strong></code>은 $0$으로 간주한다. 도깨비가 하는 모든&nbsp;<strong><code>ad-hoc</code></strong>에서 주어지는 모든 $L$의 합은 $10^{18}$ 이하이다. ($0 \le k<M$)</li>
</ul>

<p>항상 하나 이상의 <strong><code>query</code></strong>가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든&nbsp;<strong><code>query</code></strong>의 답을 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
ad-hoc 0 5
query 1 3
ad-hoc 0 3
query 2 2
ad-hoc 1 2
query 3 2
','1
2
0
','DATA_STRUCTURE'),
                                                                                                                (8160,'BAEKJOON','https://www.acmicpc.net/problem/20933',20933,'마스크펑크 2077','1초(추가시간없음)','1024 MB',17,'<p>때는 2077년, 끝나지 않는 전염병의 확산으로 모든 가정에서 가내수공업으로 마스크를 만들 수 있게 된다. 하지만 개개인의 기술력에 차이가 있어서, 마스크의 생산 비용이 집마다 달랐다.</p>

<p>$N$개의 집이 직선상에 순서대로 놓여 있는 서강 마을에서, $i$번째 집의 가정은 마스크를 만드는데 $c_i$만큼의 비용이 필요하며, $i$번째 집과 $i+1$번째 집 사이를 이동할 때 $t_i$분의 시간이 걸린다.</p>

<p>서강 마을의 주민들은 자신들이 $m$분 이내에 얻을 수 있는 가장 싼 마스크가 얼마인지에 대해 문의 전화를 걸곤 한다. 시청에서 전화 업무를 담당하고 있는 주현이는 이 문의 전화들에 대응하는 것에 골머리를 앓고 있다. 왜냐하면, 유동적으로 변하는 도로 교통 상황으로 인해서 이동 시간을 그때그때 계산해야 하기 때문이다!</p>

<p>주현이는 당신에게 주민들의 문의 전화에 대한 답변을 계산해주는 프로그램을 제작해달라고 부탁했다. 거절하는 법을 모르는 당신은 이 부탁을 들어줄 수밖에 없다!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 서강 마을에 있는 집의 개수인 $N$이 주어진다. ($2 \le N \le 100\,000$)</p>

<p>둘째 줄에 각 가정의 마스크 생산 비용인 $c_1$, $c_2$, $...$, $c_N$이 공백으로 구분되어 주어진다. ($1 \le c_i \le 10\,000$)</p>

<p>셋째 줄에 초기 이동 시간 $t_1$, $t_2$, $...$, $t_{N-1}$이 공백으로 구분되어 주어진다. ($1 \le t_i \le 10\,000$)</p>

<p>넷째 줄에 주현이가 해야할 업무의 개수 $Q$가 주어진다. ($1 \le Q \le 50\,000$)</p>

<p>다섯째 줄부터 $Q$개의 줄에 걸쳐, 다음 두 가지 유형 중 하나의 업무가 한 줄에 하나씩 순서대로 주어진다.</p>

<ul>
	<li><code><strong>UPDATE</strong></code> $x$ $t$ : $x$번째 집과 $x+1$번째 집 사이의 이동 시간을 $t$분으로 갱신한다. ($1 \le x \le N - 1$, $1 \le t \le 10\,000$)</li>
	<li><code><strong>CALL</strong></code> $x$ $m$ : $x$번째 집이 $m$분 이내에 얻을 수 있는 가장 싼 마스크의 가격을 출력한다. ($1 \le x \le N$, $1 \le m \le 1\,000\,000$)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><code><strong>CALL</strong></code> 업무에 대한 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
10 17 8 2 16
2 5 10 6
5
CALL 2 4
CALL 2 5
UPDATE 2 20
CALL 2 18
CALL 2 30
','10
8
10
2
','DATA_STRUCTURE'),
                                                                                                                (8184,'BAEKJOON','https://www.acmicpc.net/problem/20945',20945,'의자 게임','3초(추가시간없음)','1024 MB',18,'<p>드디어 HI-ARC의 첫 MT가 시작되었다. HI-ARC의 운영진들은 재밌는 의자 게임을 준비하였다. 방 안에는 $1$번, $2$번, $\dots$, $N$번 의자가 순서대로 놓여있다. 즉, 가장 오른쪽에 있는 $N$번 의자를 제외하면, $i$번 의자의 오른쪽에는 $i+1$번 의자가 있다. 각 의자에는 $N$명의 참가자가 앉아있으며, 모든 참가자는&nbsp;$1$ 이상 $N$ 이하의 정수인 등번호를 부여받았다. 등번호는 같을 수도 있다.</p>

<p>게임은 우승자가 나오기 전까지 다음의 순서대로 규칙에 따라 진행된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/2ff2651c-af9a-477b-a429-22202adac880/-/preview/" style="height: 159.167px; width: 333.333px; margin: 10px;"><img alt="" src="https://upload.acmicpc.net/f88f3ab6-64f1-4c95-a5b3-d54c798b4796/-/preview/" style="height: 193.333px; width: 333.333px; margin: 10px;"></p>

<ol>
	<li>각 참가자는&nbsp;자신의 오른쪽에 있는 의자로 이동한다. 단, 가장 오른쪽 의자에 앉아있는&nbsp;참가자는 $1$번 의자로 이동한다.</li>
	<li>연속되게 앉아있는 $K$명의 참가자들이 다음 조건을 만족하면, 그 참가자들이 게임에서 공동 우승한다: 그 참가자들끼리 자리를 재배열해, 자신의 등번호와 의자의 번호를 똑같이 만들 수 있다. 우승자가 없다면, 다시 규칙 1번으로 돌아간다.</li>
</ol>

<p>하지만 이럴 수가!&nbsp;게임이 진행되던 도중, 운영진들은 이 게임이 영원히 끝나지 않을 수도 있다는 것을 깨달았다. 운영진들은 참가자를 슬쩍 추가하여 이 문제를 해결하려 한다. 규칙 2번에서 규칙 1번으로 돌아가기 전, 원한다면 아래의 방식대로 참가자를 한 명 추가할 수 있다.</p>

<ul>
	<li>현재 $X$개의 의자가 있다면, $X+1$번 의자를 $X$번 의자의 오른쪽에 추가하고, 거기에 새로운 참가자가 앉는다. 이 참가자의 등번호는 운영진이 원하는 양의 정수로&nbsp;정할 수 있다.</li>
</ul>

<p>운영진들은 게임의 흥을 깨지 않기 위해 최소한의 참가자만을 추가하고 싶다. 게임이 언젠가는 끝나게 하기 위해서, 운영진들은 최소 몇 명의 참가자를&nbsp;추가해야 할까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>다음과 같이 입력이 주어진다.</p>

<div style="background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;">
<p>$N\ K$</p>

<p>$a_1\ a_2\,\dots\ a_N$ &nbsp;</p>
</div>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>게임이 유한한 시간 내에 끝나기 위해서 추가해야 하는 최소 인원수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
3 1 2
','0
','DATA_STRUCTURE'),
                                                                                                                (8161,'BAEKJOON','https://www.acmicpc.net/problem/20955',20955,'민서의 응급 수술','1초','1024 MB',12,'<p>민서는 강원대학교 컴퓨터공학과의 신임 교수이다. 그녀가 저술한 효율적인 택배 배달을 위한 최적 경로 설계에 관한 연구 논문은 아직도 널리 인용되고 있다. 오늘도 열심히 강의를 하던 민서는 놀라 자빠질 수밖에 없었다. 한 학생이 꾸벅꾸벅 졸다가 책상에 머리를 아주 세게 박았기 때문이다. 한시라도 수술이 시급한 상황, 민서는 의사가 되어 수술을 집도하기로 결심하였다.</p>

<p>사람의 뇌는 수백억 개의 뉴런으로 구성되며, 각 뉴런은 시냅스를 통하여 연결된다. 민서의 진찰 결과, 학생은 뇌 속의 일부 뉴런의 연결이 끊어져 잠이 든 것으로 확인되었다. 끊어진 시냅스만 복구된다면 학생은 잠에서 깨어나겠지만, 알다시피 민서는 컴퓨터공학과 교수이다.</p>

<p>민서는 끊어진 시냅스를 복구하는 대신 뇌 속의 모든 뉴런을 하나의 트리 형태로 연결해보고자 한다. 여기서 트리란 사이클이 존재하지 않는 연결 그래프를 의미한다.</p>

<p>민서는 손기술이 뛰어나기 때문에 다음과 같은 연산을 무한히 수행할 수 있다. 연결되지 않은 두 뉴런을 연결하거나 이미 연결된 두 뉴런의 연결을 끊는다.</p>

<p>뉴런의 연결 정보가 주어졌을 때, 모든 뉴런을 하나의 트리 형태로 연결하기 위하여 필요한 최소 연산 횟수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 뉴런의 개수 N과 시냅스의 개수 M이 주어진다.</p>

<p>이후 M개의 줄에 걸쳐 시냅스로 연결된 두 뉴런의 번호 u, v가 주어진다.</p>

<p>모든 입력은 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 모든 뉴런을 트리 형태로 연결하기 위하여 필요한 최소 연산 횟수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>입력의 양이 방대하므로 빠른 입력을 사용할 것을 권장한다.</p>

				</div>
				</div>','4 2
1 2
3 4
','1
','DATA_STRUCTURE'),
                                                                                                                (8164,'BAEKJOON','https://www.acmicpc.net/problem/20956',20956,'아이스크림 도둑 지호','1초','1024 MB',12,'<p>지호는 매일 아이스크림 가게에 방문한다. 아이스크림을 먹던 지호는 놀라 자빠질 수밖에 없었다. 실수로 민트초코 맛을 먹었기 때문이다. 대다수의 사람은 치약 맛이 난다는 이유로 민트초코를 싫어한다. 아이스크림으로 이를 닦는다는 발상은 누가 한 것인지 궁금할 뿐이다. 아무튼 매번 아이스크림을 사 먹는 것이 지겨워진 지호는 이제부터 아이스크림을 훔쳐 먹기로 결심하였다.</p>

<p>아이스크림 가게에는 다양한 맛의 아이스크림 N개가 한 줄로 배치되어 있다. 아이스크림에는 번호가 매겨져 있는데, 가장 왼쪽 아이스크림이 1번, 그 오른쪽은 2번, ..., 가장 오른쪽 아이스크림은 N번이다. 지호는 항상 양이 가장 많은 아이스크림을 선택하여 전부 먹는다. 양이 가장 많은 아이스크림이 여러 개라면 가장 왼쪽에 있는 것을 먹는다.</p>

<p>지호는 대다수의 사람과 마찬가지로 민트초코 맛을 싫어한다. 다행히 지호는 아이스크림의 양이 주어질 때 아이스크림의 맛을 알 수 있다. 지호의 판별법에 따르면, 아이스크림의 양이 7의 배수라면 민트초코 맛이고, 그렇지 않다면 민트초코 맛이 아니라고 한다.</p>

<p>지호는 민트초코를 싫어한다는 사실을 명심하라. 민트초코 맛 아이스크림을 먹은 지호는 크게 분노하여 남아 있는 아이스크림의 순서를 좌우로 뒤집는다. 즉, K개의 아이스크림이 있다면 i번째 아이스크림과 (K - i + 1)번째 아이스크림의 위치를 뒤바꾼다. (1 ≤ i ≤ ?K / 2?)</p>

<p>지호는 N개의 아이스크림 중 M개의 아이스크림을 먹으려 한다. 아이스크림의 양이 주어졌을 때, 지호가 먹은 아이스크림의 번호를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 전체 아이스크림의 개수 N과 지호가 먹을 아이스크림의 개수 M이 주어진다.</p>

<p>두 번째 줄에 N개의 정수 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때 A<sub>i</sub>는 i번 아이스크림의 양을 의미한다.</p>

<p>모든 입력은 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>M개의 줄에 걸쳐 i(1 ≤ i ≤ M)번째 줄에는 지호가 i번째로 먹은 아이스크림의 번호를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>입력과 출력의 양이 방대하므로 빠른 입출력을 사용할 것을 권장한다.</p>

				</div>
				</div>','5 4
7 6 8 6 5
','3
1
4
2
','DATA_STRUCTURE'),
                                                                                                                (8186,'BAEKJOON','https://www.acmicpc.net/problem/21276',21276,'계보 복원가 호석','1초','512 MB',14,'<p>석호촌에는 <em>N</em> 명의 사람이 살고 있다. 굉장히 활발한&nbsp;성격인 석호촌 사람들은 옆 집 상도 아버님, 뒷집 하은 할머님 , 강 건너 유리 어머님 등 모두가 한 가족처럼 살아가고 있다.</p>

<p>그러던 어느 날, 유구한 역사를 지닌 석호촌의 도서관에 화재가&nbsp;나서 계보들이 모두 불타고 말았다. 그래도 계보는 있어야 하지 않겠느냐는 마을 어르신인 대일 촌장님의 의견에 따라 석호촌 사람들은 계보 복원가 호석에게 의뢰를 맡기기로 했다.</p>

<p>적어도 현재를 함께 살아가는 <em>N</em> 명의 계보는 복원하고 싶은 호석이는 조사를 통해서 각자가 기억하는 조상들의 이름들을 구해냈다. 다행히도 석호촌의 맑은 정기 덕분에 기억력이 굉장히 좋은 주민들은<strong> 모든 조상을 완벽하게 기억하고 있다.</strong>&nbsp;또한, 각 가문은 한 명의 시조를 root로 하는 트리 형태를 띈다는 것도 알아냈다. 이 때 "조상"이란, "자신의 부모"와 "부모의 조상"을 모두 합친 것을 의미한다.</p>

<p>이를 기반으로 몇 개의 가문이 존재했는 지, 각 가문에 대한 정보를 출력하는 프로그램을 작성해서 호석이를 도와주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫번째 줄에 석호촌에 살고 있는 사람의 수 <em>N</em> 이 주어진다. 두번째 줄에는 현재 살고 있는 사람들의 이름이 차례대로 주어진다. 모든 이름은 길이&nbsp;1 이상 6 이하의 알파벳 소문자로 이뤄지며, 중복된 이름은 존재하지 않는다.</p>

<p>세번째 줄에는 기억하는 정보의 개수 <em>M</em> 이 주어진다. 이어지는 <em>M</em>개의 줄에는 "<em>X&nbsp;Y</em>" 꼴로 기억들이 주어지는데, 이는 곧 <em>X</em>의 조상 중에 <em>Y</em>가 있다는 것을 의미하며 같은 정보가 중복되어 주어지지 않는다. 입력에 모순이 있는 경우는 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫번째 줄에는 가문의 개수 <em>K</em> 를 출력하라. 두 번째 줄에는 각 가문의 시조들의 이름을 공백으로 구분하여 사전순으로 출력하라.</p>

<p>세번째 줄부터는 이름의 사전순 대로 사람의 이름과&nbsp;자식의 수, 그리고 사전순으로 자식들의 이름을 공백으로 구분하여&nbsp;출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
daeil sangdo yuri hoseok minji doha haeun
7
hoseok sangdo
yuri minji
hoseok daeil
daeil sangdo
haeun doha
doha minji
haeun minji
','2
minji sangdo
daeil 1 hoseok
doha 1 haeun
haeun 0
hoseok 0
minji 2 doha yuri
sangdo 1 daeil
yuri 0
','DATA_STRUCTURE'),
                                                                                                                (8192,'BAEKJOON','https://www.acmicpc.net/problem/21279',21279,'광부 호석','1초','512 MB',16,'<p><em>N</em> 개의 광물이 있다. i 번째&nbsp;광물은&nbsp;(<em>X<sub>i&nbsp;</sub></em>, <em>Y<sub>i</sub>&nbsp;</em>)에 있으며&nbsp;캐내는 비용은 1이고, 이것의 아름다운 정도는&nbsp;<em>V<sub>i</sub></em> 이다.</p>

<p>호석이는 지금 (0, 0)에 있다. 타고난 광부인 호석이는 시그니쳐&nbsp;스킬인 "광산 뒤집기"를&nbsp;쓰려고 한다. 이 스킬을 쓰면&nbsp;자신이 있는 위치를 꼭지점으로 하며, 원하는 높이 <em>H(H ≥ 0)</em>, 너비 <em>W(W ≥ 0)</em> 인 직사각형 영역 안에 있는 모든 광물을 캘 수 있다. 영역의 테두리에 존재하는 광물도 캐야한다.</p>

<p>주의할 점은, 직사각형 영역 안에 들어오는 광물은 무조건 캐야 하며, 영역에 속한 광물들의 캐내는 비용의 총합이 현재 가진 돈 <em>C</em> 보다 크면 파산을 하게 된다.</p>

<p>호석이가 파산하면 광물을 못 캐고, 이로 인해 상상을 초월하는 나비효과가 발생해서&nbsp;한국의 취직율이 떨어진다!!!!!!! 대신 호석이가 얻을 수 있는 광물들의 아름다운 정도의 합이&nbsp;높아질수록 한국의 취직율은 올라간다!!!!!!!! 모두의 행복을 위해서 호석이가 파산하지 않고 얻을 수 있는 광물들의 아름다운 정도를 최대화하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 광물의 개수 <em>N</em> 과 호석이가 가진 돈 <em>C</em> 가 주어진다.</p>

<p>이어서 N개의 줄에 걸쳐서, i번째&nbsp;줄에 3개의&nbsp;정수 <em>X<sub>i&nbsp;</sub></em>, <em>Y<sub>i&nbsp;</sub></em>, <em>V<sub>i</sub></em> 가 주어진다. 각 숫자는 i 번째 광물이 위치한&nbsp;X, Y 좌표와 아름다운 정도를 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>호석이가 파산하지 않으면서 얻을 수 있는 광물들의 아름다운 정도의 합의 최댓값을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
1 10 10
2 4 1
3 8 10
4 5 5
5 7 6
','21
','DATA_STRUCTURE'),
                                                                                                                (8193,'BAEKJOON','https://www.acmicpc.net/problem/21323',21323,'챔피언 (Hard)','2초','1024 MB',20,'<p><strong>입력 조건 외 챔피언 (Easy)와의 차이는 없다.</strong></p>

<p>민겸이는 세계적인 격투기 선수 육성 회사의 회장이다. 민겸이는 격투기 선수의 영입을 위해 세계 격투기 챔피언십을 관람하기로 했다. 세계 격투기 챔피언십의 규칙은 아래와 같다.</p>

<p>격투기 선수는 <em>N</em>명이고, 일렬로 서 있다. 선수들은 각각 전투력을 가지고 있다. 격투기 선수들은 양쪽으로 이웃한 두 명의 선수들 중 한 명에게 싸움을 걸어 격투를 벌인다. 이 때, 전투력이 높은 격투기 선수가 승리한다. 격투에서 승리한 선수는 자신감이 붙어 전투력이 1&nbsp;증가한다. 패배한 선수는 경기장을 빠져나가며 패배한 선수의 양 옆으로 이웃한 선수가 서로 이웃하게 된다. 전투력이 같은 두 선수가 격투를 벌이면 결판이 나지 않기 때문에 격투가 취소된다. 또한, 두 명의 선수가 격투를 하고 있을 때, 다른 선수들은 모두 그 시합을 지켜보느라 바쁘기 때문에 격투를 하지 않는다. 격투를 0회 이상 진행하여 마지막에 유일한 선수가 남는다면, 그 선수는 챔피언이 된다.</p>

<p>민겸이는 돈이 아주 많기 때문에, 세계 격투기 챔피언십에서 챔피언이 될 가능성이 있는 선수들을 모두 영입하려고 한다. 격투기 선수들의 전투력이 주어졌을 때, 민겸이가 영입해야 할 격투기 선수들을 민겸이에게 알려주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 두 줄로 주어진다.</p>

<p>첫 번째 줄에는 격투기 선수의 수 <em>N</em>(1 ≤ <em>N</em> ≤ 200,000)이 주어진다.</p>

<p>두 번째 줄에는 1번부터 <em>N</em>번까지 각&nbsp;격투기 선수의&nbsp;전투력 <em>a<sub>1</sub></em>, <em>a<sub>2</sub></em>, …, <em>a<sub>N</sub></em>(1&nbsp;≤ <em>a<sub>i</sub></em>&nbsp;≤ 10<sup>9</sup>, 1&nbsp;≤ <em>i</em>&nbsp;≤ <em>N</em>)이 정수로 순서대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>챔피언이 될 수 있는 격투기 선수들의 번호를 공백으로 구분하여 오름차순으로 출력한다. 각 선수들의 번호는 1부터&nbsp;<em>N</em>까지이다.</p>

<p>만약 아무도 챔피언이 될 수 없다면,&nbsp;-1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3 1 3 4
','1 3 4
','DATA_STRUCTURE'),
                                                                                                                (8224,'BAEKJOON','https://www.acmicpc.net/problem/21396',21396,'이진수 더하기','1초(추가시간없음)(하단참고)','512 MB',9,'<p>Albert는 최근 2진수에 대해 배워 열심히 2진수 덧셈을 연습하고 있다. 하지만 아직 익숙치 않아서 "받아 올림"을 깜빡하곤 한다.</p>

<p>예를 들어 3 + 5의 경우 2진수로 표현하면 11<sub>(2)</sub> + 101<sub>(2)</sub> = 1000<sub>(2)</sub> (10진수 8) 이 되어야 한다.</p>

<p>하지만 2진수로 표현한 두 수를 더할 때&nbsp;받아&nbsp;올림을 하지 않으면&nbsp;11<sub>(2)</sub> + 101<sub>(2)</sub> = 110<sub>(2)</sub>&nbsp;(10진수 6)이 된다. 구체적으로, 2<sup>0</sup>에 해당하는 가장 아래 자리를 더하면 1+1 = 0 이 되고 (올림이 발생하지만 Albert는 이를 무시한다), 2<sup>1</sup>에 해당하는 자리의 수를 더하면 1+0 = 1, 마지막으로 2<sup>2</sup>에 해당하는 자리의 수를 더하면 0+1 = 1이 되어 결과적으로 110<sub>(2)</sub> = 6을 얻는다.</p>

<p>Albert는 받아 올림이 없는 2진수 덧셈이 재밌다고 생각되어 아래와 같은 문제를 풀어보기로 했다.</p>

<p>n개의 정수 v[1], v[2],..., v[n]가 주어졌을 때 S(i, j)는 받아 올림 없이 2진수 덧셈으로 v[i] + v[j]를 계산한 값이라고 하자.</p>

<p>Albert는 임의의 정수 x에 대해&nbsp;1 ≤ i < j ≤ n 과 S(i, j) = x 를 만족하는 쌍 (i, j)의 개수를 세고 싶다.</p>

<p>예를 들어 n = 4, v = [3 7 5 6] 그리고 x = 4 라 하자.</p>

<ul>
	<li>S(1, 2) = 3 + 7&nbsp;= 4</li>
	<li>S(1, 3) = 3 + 5 = 6</li>
	<li>S(1, 4) = 3 + 6 = 5</li>
	<li>S(2, 3) = 7 + 5 = 2</li>
	<li>S(2, 4) = 7 + 6 = 1</li>
	<li>S(3, 4) = 5 + 6 = 3</li>
</ul>

<p>이 경우 조건을 만족하는 쌍은 (i, j) = (1, 2)가 유일하다.</p>

<p>입력으로 n, x, 그리고 n개의 정수 v[1], ..., v[n]이 주어졌을 때, Albert를 도와 조건을 만족하는 쌍의 개수를 세어보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T가 주어진다.</p>

<p>각 테스트 케이스는 두 줄에 걸쳐 주어지는데 첫 줄에 n과 x가 공백으로 구분 되어 주어진다.</p>

<p>둘째 줄에는 n개의 정수가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해 조건을 만족하는 쌍의 개수를 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
4 0
2 2 3 3
4 1
2 3 3 2
4 4
3 7 5 6
','2
4
1
','DATA_STRUCTURE'),
                                                                                                                (8222,'BAEKJOON','https://www.acmicpc.net/problem/21399',21399,'장난감 묶음 할인','1초(하단참고)','512 MB',16,'<p>Albert는 그 동안 모은 n개의 오래된 장난감을 모두 팔아버리기로 했다. 편의상 장난감은 0부터 n-1까지 번호가 붙어있고, i번 장난감의 판매가격은 v[i] 이다. Albert는&nbsp;한 명의 구매자에게 모든 장난감을 팔아버리고 새로운 장난감을 사고 싶어 하는데, 마침 Alice가 소식을 듣고 모든 장난감을 구매하기로 했다. Alice가 모든 장난감을 사는 대신, 아래와 같은 "묶음&nbsp;할인"을 받을 수 있도록 요청했다:</p>

<ul>
	<li>Alice가 임의로 i번 장난감부터 i+(3k-1)번까지 <em>연속한</em>&nbsp;3k개의 장난감을 묶어서 구입하면, 3k개의 장난감 중 가장 비싼 k개의 가격만큼 할인 해준다 (Alice는 이를 "k-묶음 할인" 이라 부른다).</li>
	<li>단, 하나의 장난감은 최대 한 번만 "묶음"에 속할 수 있고, 각 묶음은 반드시 연속한 번호로 구성된 3k개의 장난감 이어야 한다.</li>
	<li>Alice는 묶음 할인을 여러 번 받을 수 있고, 각 묶음에 포함된 장난감의 개수는 제각기 다를 수 있다 (3의 배수이기만 하면 된다).</li>
	<li>Alice가 원하는 만큼&nbsp;임의로 k-묶음 할인을 적용하여 할인된 가격에 장난감을 산 후, 만약 더 이상 묶음 할인을 받을 수 없게 되면 남은 장난감들은 각각의&nbsp;판매 가격에 구매하기로 했다.</li>
</ul>

<p>항상 Alice의 술수에 손해를 보는 Albert이지만,&nbsp;장난감을 모두 팔기위해 Alice의 제안을 승낙하는 대신 조건을 하나 추가했다. n개의 장난감 중 번호가 3의 배수인 것 중 하나를 Albert가 임의로 고르면 Alice는 해당 장난감은 판매 가격 그대로 사야하며, 대신 나머지 장난감들에 대해 원하는대로 묶음 할인을 적용할 수 있게 했다. Alice도 잠시 고민을 한 후, 제안을 받아들이기로 했다.</p>

<p>예를 들어, n&nbsp;= 7이고 v = [1 2 3 100 10 20 30] 이라고 하자.</p>

<ul>
	<li>Albert가 먼저 임의로 0번, 3번, 6번 장난감 중 하나를 골라 Alice에게 팔 수 있다.</li>
	<li>만약 0번 장난감을 (가격 1에) 판다면, Alice는 (1번,2번,3번)을 묶어 (2+3)을 지불하고 (4번,5번,6번)을 묶어 (10+20)을 지불하여 총 36을 지불하고 장난감을 모두 살 수 있다.</li>
	<li>만약 3번 장난감을 (가격 100에) 판다면, Alice는 0-2번과 4-6번 장난감을 각각 묶어 총 100 + (1 + 2) + (10 + 20) = 133을 지불하고 장난감을 모두 살 수 있다.</li>
	<li>만약 6번 장난감을 (가격 30에) 판다면, Alice는 0번부터 5번 모두를 묶어 총 30 + (1+2+3+10) = 46을 지불하고 장난감을 모두 살 수 있다.</li>
</ul>

<p>모든 경우를 따져보면, Albert는 당연히 3번 장난감을 팔아야 하고, 이 때 Alice도 최선을 다해 최소한의 가격을 지불하려 한다면 133을 지불하게 된다.</p>

<p>Alice는 항상 꼼꼼하게 모든 경우를 따져보기 때문에, Albert는 당신에게 도움을 요청했다.</p>

<p>입력으로 n과 v가 주어졌을 때, Albert가 어떤 장난감 하나를 임의로 골라 Alice에 팔아야 최대한 많은 돈을 받을 수 있는지 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T가 주어진다.</p>

<p>각 테스트 케이스는 두 줄에 걸쳐 주어진다.</p>

<p>테스트 케이스의 첫 줄에 n이 주어지며 (장난감의 수) 둘째 줄에 n개의 정수가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스의 정답을 나타내는 정수 두 개를 공백으로 구분하여 각 줄에 출력한다.</p>

<p>첫 수는 Albert가 처음 팔아야하는 장난감의 번호이고 (0이상 n-1이하), 두 번째 수는 이 때 Alice가 지불해야하는 총 금액이다.</p>

<p>총 금액이 같은 답이 여럿 존재하는 경우, 장난감의 번호가 가장 작은 경우를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
4
5 1 3 2
4
10 8 5 7
7
1 2 3 100 10 20 30
7
1000 1000 1000 1000 1000 1000 1000
','0 8
0 22
3 133
0 5000
','DATA_STRUCTURE'),
                                                                                                                (8257,'BAEKJOON','https://www.acmicpc.net/problem/21725',21725,'더치페이','1초','1536 MB',18,'<p>$n$명의 친구들이 인덱스국에 여행을 떠난다. 인덱스국은 굉장히 넓고, 친구들은 각자 가보고 싶은 위치가 다르다. 따라 맨 처음에는 모두 1인 그룹으로 각자 여행을 하다가, 일정이 지나면서 그룹끼리 합류하여 마지막에는 하나의 그룹으로 뭉쳐서 다같이 여행을 마무리하기로 했다.</p>

<p>여행을 하는 데 지출은 필수적이다. 이 친구들은 각자 $2 \times 10^{18}$원씩을 가지고 있어서, 여행 동안에 돈을 그다지 계획적으로 쓰지는 않았다. 그래서 여행이 모두 끝난 후, 각자가 원래 부담했어야 할 몫을 정산하는 것이 무척 성가시게 되었다.</p>

<p>여행할 때 지출은 그룹 단위로 이루어지며, 여행할 때는 그룹원 중 한 명이 모두 계산한다. 여행이 모두 끝나고 정산할 때는 지출 당시의 모든 그룹원이 모두 공평하게 같은 금액만큼 부담한다. 금액은 원화로 계산하며, 각 지출은 당시 그룹원의 수로 나누어 떨어진다.</p>

<p>정산은 한 명이 다른 한 명에게 돈을 전송하는 송금을 통해 이루어진다. 매 지출마다 각자의 부담금을 계산하여 여행할 때 돈을 냈던 사람에게 송금을 하는 것은 매우 귀찮기 때문에, 친구들은 지출들을 모두 한꺼번에 정산해 $n$번 이하의 송금으로 모든 정산을 할 수 있는지 궁금해졌다.</p>

<p>그룹이 합류한 기록과 모든 지출의 기록이 시간 순서대로 주어진다. 여행이 모두 끝난 후, $n$번 이하의 송금으로 모든 지출을 정산할 수 없다면 <code>-1</code>, 정산할 수 있다면 송금 횟수와 송금에 대한 정보를 출력하도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에 정수 $n, m$이 주어진다. $n$은 여행을 한 친구들의 수, $m$은 그룹의 합류 및 지출 기록의 총 개수이다. 각 친구들은 $1$번부터 $n$번까지의 번호로 표현한다.</p>

<p>이후 $m$개의 줄에 걸쳐 각 기록을 나타내는 수들이 한 줄에 하나씩 주어진다.</p>

<p>두 그룹이 합류한 기록은 <em>1 x y</em>와 같이 주어진다. 이는 <em>x</em>가 속한 그룹과 <em>y</em>가 속한 그룹이 합류했다는 것을 의미한다. <em>x</em>와 <em>y</em>가 이미 같은 그룹에 속해 있는 경우는 없다.</p>

<p>지출이 발생한 기록은 <em>2 x c</em>와 같이 주어진다. 이는 <em>x</em>가 현재 그룹원들을 위해 총 <em>c</em>원을 지출했다는 의미이다. <em>c</em>는 <em>x</em>가 속한 그룹의 그룹원의 수로 나누어 떨어진다.</p>

<p>기록들이 모두 처리된 시점에 모든 학생이 한 그룹에 속해 있음이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 조건을 만족하는 송금 방법이 존재하지 않으면 <code>-1</code>, 존재하면 송금의 총 횟수 $k$를 출력하라. (단, $0 \le k \le n$)</p>

<p>그 다음 $k$개 줄 각각에는 송금에 대한 정보를 조건에 맞게 출력하라. 여러 방법이 존재하면 그 중 아무거나 출력해도 좋고, 송금 또한 아무 순서로나 출력해도 괜찮다.</p>

<p>송금에 대한 정보는 <em>x y c</em>와 같이 나타내도록 하자. 이는 <em>x</em>가 <em>y</em>에게 <em>c</em>원을 보낸다는 의미이다. <em>x</em>와 <em>y</em>의 순서에 유의하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5
1 2 3
2 1 7
2 3 42
1 2 1
2 1 30
','3
2 3 21
2 1 10
3 1 10
','DATA_STRUCTURE'),
                                                                                                                (8259,'BAEKJOON','https://www.acmicpc.net/problem/21730',21730,'불순 분자 만들기','2초','1536 MB',22,'<p>화학과 대학원생 탐레프는 $n$개의 원자를 갖는 트리 모양의 분자를 만들었다. 그런데 몇개의 <strong>불순 전자</strong>들이 분자를 <strong>불순 분자</strong>로 만들기 위해 이리저리 돌아다니며 선전을 하고 있는 것이 발각되고 말았다. 탐레프는 불순 전자들을 저지하기 위해 $m$개의 전자 현미경을 놓아 전자들을 감시하려고 한다.</p>

<p>각 전자 현미경은 두 원자 사이의 유일한 최단경로 위에 있는 원자들을 감시할 수 있다. 특별히 $i$번 전자 현미경은 $s_{i}$번 원자와 $e_{i}$번 원자 사이의 경로에 있는 원자들을 감시할 수 있다. 최단 경로는 양 끝점을 포함한다.</p>

<p>불순 전자들은 두 원자 사이를 옮겨 다닐 때 최단 경로로 이동한다. 한 불순 전자가 이동할 때, 그 전자와 경로가 겹치는 현미경의 감시 실적이 $1$ 오른다. 현미경은 전자를 붙잡을 수는 없다는 것에 주의하자.</p>

<p>탐레프는 불순 전자들이 자주 이동하는 경로를 찾기 위해 수시로 전자 현미경의 실적들을 조회한다. 전자가 이동하거나 실적을 조회하는 쿼리 $q$개를 처리하는 프로그램을 작성하여 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 원자 개수 $n$, 전자 현미경의 수 $m$, 쿼리의 개수 $q$가 공백으로 구분되어 주어진다.</p>

<p>둘째 줄부터 $n-1$개의 줄에 걸쳐 분자 구조가 주어진다. $i+1$번째 줄에는 두 정수 $u_{i}, v_{i}$가 주어지며, 이는 $i$번째 결합선이 $u_{i}$번 원자와 $v_{i}$번 원자를 연결한다는 것을 의미한다.</p>

<p>$n+1$번째 줄부터 $m$개의 줄에 걸쳐 전자 현미경이 감시하는 경로의 양 끝 원자 번호가 주어진다. $n + i$번째 줄에는 $s_{i}, e_{i}$가 공백으로 구분되어 주어진다.</p>

<p>$n + m + 1$번째 줄부터 $q$개의 줄에 걸쳐 아래 두 종류의 쿼리가 주어진다.</p>

<ul>
	<li><code>1 x y</code>: 전자 하나가 $x$번 원자에서 $y$번 원자로 이동한다. ($1 \le x, y \le n$, $x \neq y$)</li>
	<li><code>2 k</code>: $k$번 전자 현미경의 현재 실적을 출력한다. ($1 \le k \le m$)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 2번 쿼리에 대해, 각 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 3 5
1 3
4 5
7 1
6 1
3 4
2 3
6 3
7 5
2 4
1 7 4
2 1
1 2 6
2 3
2 2
','1
2
2
','DATA_STRUCTURE'),
                                                                                                                (8261,'BAEKJOON','https://www.acmicpc.net/problem/21733',21733,'2차원 점과 쿼리','2초','1536 MB',22,'<p>2차원 평면 위에 정수점들의 중복집합(multiset)인 $U$와 $V$가 있다.</p>

<p>두 중복집합 $U, V$가 주어졌을 때, 다음의 값 $D(U, V)$를 생각할 수 있다.</p>

<p>$$D(U, V) = \min_{u \in U, v \in V} \left( \max (u_x+v_x, u_y+v_y)\right)$$</p>

<p>처음에 $U$와 $V$는 모두 비어 있다. 편의상 $U$ 또는 $V$가 비어 있는 경우 $D(U,V)$값은 $-1$로 정의하도록 하자. 이제 쿼리를 통해 $U$와 $V$에 정수점이 자유롭게 추가되거나 제거된다. 변화가 일어날 때 마다 $D(U,V)$를 계산하는 프로그램을 작성하도록 하자.</p>

<p>중복집합에 점을 추가하는 쿼리는 <em>1 s x y</em> 와 같이 주어진다. $s=1$인 경우에는 $U$에, $s=2$인 경우에는 $V$에 점 $(x,y)$를&nbsp;추가하라는 의미이다.</p>

<p>중복집합에 점을 제거하는 쿼리는 <em>2 s x y</em> 와 같이 주어진다. $s=1$인 경우에는 $U$에서, $s=2$인 경우에는 $V$에서 점 $(x,y)$를&nbsp;제거하라는 의미이다.</p>

<p>$U$와 $V$는 각각 중복집합이므로, 점이 추가될 때 이미 존재하는 점이 추가될 수도 있다.</p>

<p>$U$와 $V$에서 점을 제거할 때 이미 동일한 좌표를 가지는 점이 여러 개 존재하는 경우, 그 중 하나만 없애는 것으로 처리한다. 존재하지 않는 점을 제거하는 쿼리는 주어지지 않는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에 쿼리의 개수를 나타내는 $q$가 주어진다.</p>

<p>이후 $q$개의 줄에 걸쳐 쿼리를 나타내는 정수 <em>r s x y</em>가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$q$개 줄에 각 쿼리를 실행한 직후의 $D(U,V)$값을 출력한다.</p>

<p>두 집합 중 하나라도 비어 있는 경우 $D(U,V) = -1$임에 유의하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
1 1 100 100
1 2 30 130
1 1 120 170
2 1 100 100
1 2 70 100
2 1 120 170
','-1
230
230
300
270
-1
','DATA_STRUCTURE'),
                                                                                                                (8263,'BAEKJOON','https://www.acmicpc.net/problem/21773',21773,'가희와 프로세스 1','1초','512 MB',11,'<p>가희는 스케쥴러를 구현하라는 과제를 받았습니다. 스케쥴러가 <strong>실행시킬 프로세스를 선택하는 기준</strong>은 아래와 같습니다.</p>

<ul>
	<li>우선 순위 값이 제일 큰&nbsp;프로세스</li>
	<li>우선 순위 값이 제일 큰&nbsp;프로세스가 여러 개라면, <em>id</em>가 가장 작은 프로세스</li>
</ul>

<p>가희가 만든 스케쥴러는 다음 알고리즘으로 실행됩니다.</p>

<ol>
	<li>실행시킬 프로세스를 기준에 따라 선택합니다. 선택된 프로세스의 <em>id</em>를 <em>id<sub>s</sub></em>라 합니다. <em>id</em><sub><em>s</em></sub>를 실행시킵니다.</li>
	<li>1초가 지난 후, 프로세스 <em>id</em>가 <em>id<sub>s</sub></em>인 프로세스를 제외한 <strong>나머지 프로세스들의 우선 순위가 1 상승합니다.</strong>&nbsp;<br>
	프로세스 <em>id</em>가 <em>id<sub>s&nbsp;</sub></em>인 프로세스의&nbsp;<strong>실행을 마치는 데 필요한 시간은&nbsp;1 감소</strong>합니다.</li>
	<li>실행 시간이 남은 프로세스가 있다면 1로 돌아가고, 그렇지 않으면 종료합니다.</li>
</ol>

<p>동시에 실행되는 프로세스는 1개이고, 1초일 때 가희가 만든 스케쥴러는&nbsp;최초로 선택한 프로세스를 실행시키는 작업을 합니다.</p>

<p>가희는 1초일 때 부터 <em>T</em>초일 때 까지, 스케쥴러가 선택한 프로세스의 <em>id</em>를 알고 싶습니다. 가희를 도와주세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 <em>T</em>, <em>n</em>이 주어집니다.</p>

<p>두 번째 줄 부터 n+1번째 줄까지 다음과 같은 형식으로 주어집니다.</p>

<p><em>A<sub>i</sub> B<sub>i</sub> C<sub>i</sub></em></p>

<p>이것은 i번째 process의 <em>id</em>가 <em>A<sub>i</sub></em>이고, 프로세스 <em>id</em>가 실행을 마치는 데 필요한 시간이 <em>B<sub>i</sub></em>초이고, 초기 우선 순위가 <em>C<sub>i</sub></em>임을 의미합니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>T개의 정수를 T개의 줄에 출력합니다.</p>

<p>i번째 줄에는 <strong>가희가 만든 스케쥴러가 <em>i</em>초가 되었을 때 선택한 프로세스의 <em>id</em>를 출력</strong>해 주세요.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8 2
1 5 1
2 5 1
','1
2
1
2
1
2
1
2
','DATA_STRUCTURE'),
                                                                                                                (8266,'BAEKJOON','https://www.acmicpc.net/problem/21775',21775,'가희와 자원 놀이','2초','512 MB',11,'<p>가희와 친구들은 자원&nbsp;놀이를 하고 있습니다.</p>

<p>이 놀이는 <em>T</em>개의 연산 카드와, 1 부터&nbsp;2×10<sup>9</sup>&nbsp;이하의 자연수가 한 장에 하나씩 순서대로 적혀져 있는 2×10<sup>9</sup>개의 자원 카드를 이용합니다.</p>

<p>자원 놀이에서 사용하는 연산 카드의 종류는 3가지입니다.</p>

<ul>
	<li>next
	<ul>
		<li>아무 일도 일어나지 않고 이 카드를&nbsp;버립니다.</li>
	</ul>
	</li>
	<li>acquire <em>n</em>
	<ul>
		<li>자연수 <em>n</em>이 적혀진 자원 카드를 획득하려고 시도합니다.<br>
		만약 자연수 n이 적혀진 자원 카드가 공용 공간에 있다면 자신의 공간으로 자원 카드를 가져온 다음에, acquire n 카드를 버립니다.<br>
		그렇지 않고, 자원 카드가 다른 누군가의 공간에 있는 경우에는 이 카드를 버리지 않고 돌아오는 자신의 다음 차례에 재사용합니다.</li>
	</ul>
	</li>
	<li>release <em>n</em>
	<ul>
		<li>자연수 <i>n</i>이 적혀진 자원 카드를 공용 공간에 반납하고, 이 카드를 버립니다.</li>
	</ul>
	</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/43755b39-8d58-4132-a673-e2b1887af875/-/preview/" style="width: 350.833px; height: 297.5px;"></p>

<p style="text-align: center;"><strong>[그림 1]</strong> 자원 게임의 초기 상태</p>

<p style="text-align: center;">모든 유저들은 자원 카드와 연산 카드를 들고 있지 않습니다.</p>

<p>게임의 규칙은 아래와 같습니다.</p>

<ul>
	<li>처음에 <strong>모든 자원 카드들과 연산 카드들은&nbsp;공용 공간에 놓여져 있습니다.</strong></li>
	<li>각 턴을 수행하는 사람은 1명입니다.</li>
	<li>자신의 턴이 돌아오면 다음의 행동을 수행합니다.
	<ul>
		<li>연산 카드를 들고 있지 않은 경우
		<ul>
			<li>더미의 맨 위에 있는 연산 카드를 뽑고, 해당 카드에 있는 연산을 즉시 수행합니다.</li>
		</ul>
		</li>
		<li>연산 카드를 들고 있는 경우
		<ul>
			<li>들고 있는 연산 카드에 있는 연산을 즉시 수행합니다.</li>
		</ul>
		</li>
	</ul>
	</li>
</ul>

<p>처음 연산 카드 더미에 있던 연산 카드가 <i>T</i>개 주어지고, <em>T</em> 턴동안 각 턴을 수행한 사람의 번호가 주어집니다.</p>

<p><em>T&nbsp;</em>턴동안 수행된 연산 카드의 <em>id</em>를&nbsp;알려주세요. <strong>처음 더미에 있는 연산 카드의 갯수와 턴 수는&nbsp;같습니다.</strong></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 자원 놀이에 참가하는 사람&nbsp;수 <em>N</em>과 턴 수&nbsp;<em>T</em>가 주어집니다.</p>

<p>두 번째 줄에 각&nbsp;턴을&nbsp;수행한 사람 번호가 <em>T</em>개 주어집니다.</p>

<p>세 번째 줄 부터 <em>2+T</em>번째 줄까지, 더미의 맨 위에 있는 카드부터, 더미에 있는 연산 카드의 <em>id</em>와 연산 카드에 적혀져 있는 연산이&nbsp;공백으로 구분되어 주어집니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>T</em>턴에 걸쳐서, 각 턴에 수행된 연산 카드의 <em>id</em>를 한 줄에 하나씩 출력해 주세요.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2 10
1 1 2 2 1 1 2 2 2 2
1 next
2 acquire 1
3 acquire 1
4 next
5 release 1
6 release 1
7 next
8 acquire 1
9 next
10 next
','1
2
3
3
4
5
3
6
7
8
','DATA_STRUCTURE'),
                                                                                                                (8265,'BAEKJOON','https://www.acmicpc.net/problem/21778',21778,'가희와 프로세스 2','3.5초','512 MB',16,'<p>가희는 스케쥴러를 구현하라는 과제를 받았습니다. 스케쥴러가 <strong>실행시킬 프로세스를 선택하는 기준</strong>은 아래와 같습니다.</p>

<ul>
	<li>우선 순위 값이 제일 큰&nbsp;프로세스</li>
	<li>우선 순위 값이 제일 큰&nbsp;프로세스가 여러 개라면, <em>id</em>가 가장 작은 프로세스</li>
</ul>

<p>가희가 만든 스케쥴러는 다음 알고리즘으로 실행됩니다.</p>

<ol>
	<li>실행시킬 프로세스를 기준에 따라 선택합니다. 선택된 프로세스의 <em>id</em>를 <em>id<sub>s</sub></em>라 합니다. <em>id</em><sub><em>s</em></sub>를 실행시킵니다.</li>
	<li>1초가 지난 후, 프로세스 <em>id</em>가 <em>id<sub>s</sub></em>인 프로세스를 제외한 <strong>나머지 프로세스들의 우선 순위가 1 상승합니다.</strong>&nbsp;프로세스 <em>id</em>가 <em>id<sub>s&nbsp;</sub></em>인 프로세스의 실행을 마치는 데 필요한 시간은&nbsp;1 감소합니다.</li>
	<li>실행 시간이 남은 프로세스가 있다면 1로 돌아가고, 그렇지 않으면 종료합니다.</li>
</ol>

<p>동시에 실행되는 프로세스는 1개이고, 1초일 때 가희가 만든 스케쥴러는&nbsp;최초로 선택한 프로세스를 실행시키는 작업을 합니다.</p>

<p>가희는 <em>t</em>초일 때, 스케쥴러가 어떤 프로세스를 선택하는지 알고 싶습니다. 가희를 도와주세요.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 <i>Q</i>, <em>n</em>이 주어집니다.</p>

<p>두 번째 줄 부터 n+1번째 줄까지 프로세스에 대한 정보 <em>A<sub>i</sub></em>, <em>B<sub>i</sub></em>, <em>C<sub>i</sub></em>가 공백으로 구분되어 주어집니다.</p>

<p>이것은 i번째 process의 <em>id</em>가 <em>A<sub>i</sub></em>이고, 프로세스 <em>id</em>가 실행을 마치는 데 필요한 시간이 <em>B<sub>i</sub></em>초이고, 초기 우선 순위가 <em>C<sub>i</sub></em>임을 의미합니다.</p>

<p><em>n+2</em>번째 줄부터 <em>n+1+Q</em>번째 줄까지 문제 <em>Q</em>개에 대한 정보가 아래와 같이 주어집니다.</p>

<p><em>T<sub>c</sub></em></p>

<p><em>T<sub>c</sub></em>는 <em>T<sub>c</sub> </em>초일 때, 가희가 만든 스케쥴러가 선택한 프로세스 <em>id</em>&nbsp;값이&nbsp;어떤 것인지 묻는 문제를&nbsp;의미합니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>문제에 대한 답을 <em>Q</em>개의 줄에 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
1 5 1
2 5 1
1
3
5
7
10
','1
1
1
1
2
','DATA_STRUCTURE'),
                                                                                                                (8275,'BAEKJOON','https://www.acmicpc.net/problem/21939',21939,'문제 추천 시스템 Version 1','1초','512 MB',12,'<p>tony9402는 최근 깃헙에 코딩테스트 대비 문제를 직접 뽑아서 "<strong>문제 번호</strong>,<strong> 난이도</strong>"로&nbsp;정리해놨다.</p>

<p>깃헙을 이용하여 공부하시는 분들을 위해 새로운 기능을 추가해보려고 한다.</p>

<p>만들려고 하는 명령어는 총 3가지가 있다. 아래 표는 각 명령어에 대한 설명이다.</p>

<table class="table table-bordered">
	<tbody>
		<tr>
			<td><strong>recommend $x$</strong></td>
			<td>
			<p>$x$가 1인 경우 추천 문제 리스트에서 가장 어려운 문제의 번호를 출력한다.</p>

			<p>만약 가장 어려운 문제가 여러 개라면 문제 번호가 큰 것으로 출력한다.</p>

			<p>$x$가 -1인 경우 추천 문제 리스트에서 가장 쉬운 문제의 번호를 출력한다.</p>

			<p>만약 가장 쉬운 문제가 여러 개라면 문제 번호가 작은 것으로 출력한다.</p>
			</td>
		</tr>
		<tr>
			<td><strong>add $P$ $L$</strong></td>
			<td>추천 문제 리스트에 난이도가 $L$인 문제 번호 $P$를 추가한다. (추천 문제 리스트에 없는 문제 번호 $P$만 입력으로 주어진다. 이전에 추천 문제 리스트에 있던 문제 번호가 다른 난이도로 다시 들어 올 수 있다.)</td>
		</tr>
		<tr>
			<td><strong>solved $P$</strong></td>
			<td>추천 문제 리스트에서 문제 번호 $P$를 제거한다. (추천 문제 리스트에 있는 문제 번호 $P$만 입력으로 주어진다.)</td>
		</tr>
	</tbody>
</table>

<p>명령어 <strong>recommend</strong>는 추천 문제 리스트에 문제가 하나 이상 있을 때만 주어진다.</p>

<p>명령어 <strong>solved</strong>는 추천 문제 리스트에 문제 번호가 하나 이상 있을 때만 주어진다.</p>

<p>위 명령어들을 수행하는 추천 시스템을 만들어보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 추천 문제 리스트에 있는 문제의 개수 $N$ 가 주어진다.</p>

<p>두 번째 줄부터 $N + 1$ 줄까지 문제 번호 $P$와 난이도 $L$가 공백으로 구분되어 주어진다.</p>

<p>$N + 2$줄은 입력될 명령문의 개수 $M$이 주어진다.</p>

<p>그 다음줄부터 $M$개의 위에서 설명한&nbsp;명령문이 입력된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><strong>recommend 명령이 주어질 </strong>때마다 문제 번호를 한 줄씩 출력한다. 최소 한번의 recommend 명령어가 들어온다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1000 1
1001 2
19998 78
2667 37
2042 55
8
add 1402 59
recommend 1
solved 1000
solved 19998
recommend 1
recommend -1
solved 1001
recommend -1
','19998
1402
1001
2667
','DATA_STRUCTURE'),
                                                                                                                (8281,'BAEKJOON','https://www.acmicpc.net/problem/21944',21944,'문제 추천 시스템 Version 2','1초','512 MB',14,'<p>tony9402는 최근 깃헙에 코딩테스트 대비 문제를 직접 뽑아서 "<strong>문제 번호</strong>,<strong> 난이도</strong>,<strong> 알고리즘 분류</strong>"로&nbsp;정리해놨다.</p>

<p>깃헙을 이용하여 공부하시는 분들을 위해 새로운 기능을 추가해보려고 한다.</p>

<p>만들려고 하는 명령어는 총 3가지가 있다. 아래 표는 각 명령어에 대한 설명이다.</p>

<table border="1" cellpadding="1" cellspacing="1" class="table table-bordered">
	<tbody>
		<tr>
			<td><strong>recommend $G$ $x$</strong></td>
			<td>
			<p>$x$가 1인 경우 추천 문제 리스트에서 알고리즘 분류가 $G$인 문제 중 가장 어려운 문제&nbsp;번호를 출력한다.</p>

			<p>조건을 만족하는 문제가 여러 개라면 그 중 <strong>문제 번호가 큰 것으로 출력</strong>한다.</p>

			<p>$x$가 -1인 경우 추천 문제 리스트에서 알고리즘 분류가 $G$인 문제 중 가장 쉬운 문제 번호를 출력한다.</p>

			<p>조건을 만족하는 문제가 여러 개라면 그 중 <strong>문제 번호가 작은 것으로 출력</strong>한다.</p>

			<p>해당 명령어는 해당 그룹 $G$에 문제 번호가 한 개 이상이 있을 경우에만 주어진다.</p>
			</td>
		</tr>
		<tr>
			<td><strong>recommend2 $x$&nbsp;</strong></td>
			<td>
			<p>$x$가 1인 경우 추천 문제 리스트에서 알고리즘 분류 상관없이 가장 어려운 문제 번호를 출력한다.</p>

			<p>조건을 만족하는 문제가 여러 개라면 그 중 <strong>문제 번호가 큰 것으로 출력</strong>한다.</p>

			<p>$x$가 -1인 경우 추천 문제 리스트에서 알고리즘 분류 상관없이&nbsp;가장 쉬운 문제 번호를 출력한다.</p>

			<p>조건을 만족하는 문제가 여러 개라면 그 중 <strong>문제 번호가 작은 것으로 출력</strong>한다.</p>
			</td>
		</tr>
		<tr>
			<td><strong>recommend3 $x$ $L$</strong></td>
			<td>
			<p>$x$가 1인 경우 추천 문제 리스트에서 알고리즘 분류 상관없이 난이도 $L$보다 크거나 같은 문제 중 가장 쉬운&nbsp;문제 번호를 출력한다.</p>

			<p>조건을 만족하는 문제가 여러 개라면 그 중 <strong>문제 번호가 작은 것으로 출력</strong>한다. 만약 조건을 만족하는 문제 번호가 없다면 <strong>-1을 출력</strong>한다.</p>

			<p>$x$가 -1인 경우 추천 문제 리스트에서 알고리즘 분류 상관없이 난이도 $L$보다 작은 문제 중 가장 어려운 문제 번호를 출력한다.</p>

			<p>조건을 만족하는 문제가 여러 개라면 그 중 <strong>문제 번호가 큰 것으로 출력</strong>한다. 만약 조건을 만족하는 문제 번호가 없다면 <strong>-1을 출력</strong>한다.</p>
			</td>
		</tr>
		<tr>
			<td><strong>add $P$ $L$ $G$</strong></td>
			<td>추천 문제 리스트에 난이도가 $L$이고 알고리즘 분류가 $G$인 문제 번호 $P$를 추가한다. (추천 문제 리스트에 없는 문제 번호 $P$만 입력으로 주어진다. 이전에 추천 문제 리스트에 있던 문제 번호가 다른 난이도와 다른 알고리즘 분류로 다시 들어 올 수 있다.)</td>
		</tr>
		<tr>
			<td><strong>solved $P$</strong></td>
			<td>추천 문제 리스트에서 문제 번호 $P$를 제거한다. (추천 문제 리스트에 있는 문제 번호 $P$만 입력으로 주어진다.)</td>
		</tr>
	</tbody>
</table>

<p>명령어 <strong>recommend</strong>, <strong>recommend2</strong>,<strong> recommend3</strong>는 추천 문제 리스트에 문제가 하나 이상 있을 때만 주어진다.</p>

<p>명령어 <strong>solved</strong>는 추천 문제 리스트에 문제 번호가 하나 이상 있을 때만 주어진다.</p>

<p>위 명령어들을 수행하는 추천 시스템을 만들어보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 추천 문제 리스트에 있는 문제의 개수 $N$가 주어진다.</p>

<p>두 번째 줄부터 $N + 1$ 줄까지 문제 번호 $P$와 난이도 $L$, 알고리즘 분류 $G$가 공백으로 구분되어 주어진다.</p>

<p>$N + 2$줄은 입력될 명령문의 개수 $M$이 주어진다.</p>

<p>그 다음줄부터 $M$개의 위에서 설명한&nbsp;명령문이 입력된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><strong>recommend</strong>,&nbsp;<strong>recommend2</strong>,<strong> recommend3 명령이 주어질</strong>&nbsp;때마다 문제 번호를 한 줄씩 출력한다. 주어지는 recommend,&nbsp;recommend2, recommend3 명령어의 총 개수는 최소 1개 이상이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1000 1 1
1001 2 1
19998 78 2
2667 37 3
2042 55 3
12
add 1402 59 1
recommend 1 1
recommend2 1
recommend3 1 50
recommend3 -1 50
solved 1000
solved 2667
recommend 2 1
recommend 1 -1
recommend2 -1
solved 1001
recommend 1 -1
','1402
19998
2042
2667
19998
1001
1001
1402
','DATA_STRUCTURE'),
                                                                                                                (8286,'BAEKJOON','https://www.acmicpc.net/problem/21982',21982,'상자 빌리기','3초(하단참고)','512 MB',16,'<p>Albert는 높이가 서로 다른&nbsp;n개의 상자를 갖고 있는데 각 상자는&nbsp;직육면체 모양이다. 편의상 0번부터 n-1번까지 번호가 붙어있다. i번째 상자의 높이는 H[i]이고 밑면의 넓이는 W[i]&nbsp;이다. 이 때, i번째 상자의 부피는 H[i] × W[i] 이다 (여기서 W[i]는 밑면의 "넓이"를 나타낸다). Albert는 언제나 상자를 높이 순으로 정렬해두기 때문에 H[0] < H[1] < ... < H[n-1]을 만족한다.</p>

<p>Alice는 Albert에게 상자 두 개를 빌리기로 했는데 Albert는 왠지 순순히&nbsp;빌려주고 싶지 않아서 아래와 같은 조건을 달았다.</p>

<ul>
	<li>조건:&nbsp;Alice가 빌리는&nbsp;상자 두 개의 높이 차이는 X를 넘을 수 없다 (즉, i번째 상자와 j번째 상자를 고른다면 | H[i] - H[j] | ≤ X 를 만족해야한다).</li>
</ul>

<p>Alice는 흔쾌히 승낙했고, 물건을 옮길 때 사용해야 하기 때문에 두 상자의 부피의 합이 최대가 되는 한 쌍의 상자를 고르기로 했다.</p>

<p>예를 들어 n = 3, H = [3, 5, 8], W = [8, 16, 6], X = 3이라 하자.</p>

<ul>
	<li>각 상자의 부피는 순서대로 24, 80, 48이다.</li>
	<li>Albert가 제시한 조건을 만족하는 (i, j)쌍은 (0, 1)과 (1, 2)가 있다.</li>
	<li>두 가지 방법 중 1번 상자와 2번 상자를 빌리면 부피의 합이 80 + 48 = 128이 된다.</li>
	<li>같은 예에서 만약 X = 1이라면 Albert가 제시한 조건을 만족하는 쌍이 존재하지 않는다 (출력 항목 참고).</li>
</ul>

<p>다른 예로, n = 4, H = [3, 10, 18, 20], W = [8, 11, 9, 3], X = 7이라 하자.</p>

<ul>
	<li>각 상자의 부피는 순서대로 24, 110, 162, 60이다.</li>
	<li>Albert가 제시한 조건을 만족하는 (i, j)쌍은 (0, 1)과 (2, 3)이 있다.</li>
	<li>두 가지 방법 중 2번 상자와 3번 상자를 빌리면 부피의 합이 162 + 60 = 222이 된다.</li>
	<li>같은 예에서 만약 X = 8이라면 1번과 2번 상자를 빌려 부피의 합이 272가 되도록 할 수 있다.</li>
</ul>

<p>입력으로 n, X, 그리고 H[0] ... H[n-1], W[0] ... W[n-1] 이 주어졌을 때,&nbsp; Alice를 도와 Albert가 제시한 조건을 어기지 않으면서 부피의 합이 최대가 되는 한 쌍의 상자를 골라보자. 단, 이 문제의 경우 n이 크기 때문에 상자의 높이와 밑면&nbsp;넓이가 직접 주어지지 않고, 이를 생성하는 방법이 입력으로 주어진다 (입력 항목 참고).</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T가 주어진다.</p>

<p>각 테스트 케이스는 세&nbsp;줄에 걸쳐 주어진다.</p>

<p>첫 줄에 n과 X가 공백으로 구분되어 주어진다. 두 번째 줄에 네 개의 정수 h<sub>s</sub>, h<sub>a</sub>, h<sub>b</sub>, h<sub>c</sub> 가 공백으로 구분되어 주어진다. 세 번째 줄에 네 개의 정수 w<sub>s</sub>, w<sub>a</sub>, w<sub>b</sub>, w<sub>c</sub> 가 공백으로 구분되어 주어진다.</p>

<p>이를 이용해 H[i]와 W[i]를 구하기 위해 아래 공식을 이용한다 (0 ≤ i ≤ n-1 임에 유의하자): ("%"는 통상 프로그래밍 언어에서 쓰이는 정수 나눗셈 연산의 나머지를 구하는 연산이다 (modulo))</p>

<ul>
	<li>i = 0 일 때:
	<ul>
		<li>H[i] = (h<sub>s</sub> % h<sub>c</sub>) + 1</li>
		<li>W[i] = (w<sub>s</sub> % w<sub>c</sub>) + 1</li>
	</ul>
	</li>
	<li>1 ≤&nbsp;i ≤&nbsp;n-1&nbsp;인 i에 대하여:
	<ul>
		<li>H[i] = H[i-1] + 1 + ( (H[i-1] * h<sub>a</sub>&nbsp; + h<sub>b</sub>) % h<sub>c</sub>)</li>
		<li>W[i] = (W[i-1] * w<sub>a</sub> + w<sub>b</sub>) % w<sub>c</sub> + 1</li>
	</ul>
	</li>
</ul>

<p>위의 연산시 integer overflow를 피하기 위해 64-bit 정수 타입을 사용하는 것을 권장한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대하여 Alice가 상자 한 쌍을 빌릴 수 없다면 -1을 출력한다. 빌릴 수 있다면, 가능한 모든 쌍 중 부피의 합의 최대값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>아래 표에 제공된 각 언어별 예제 코드는&nbsp;H[0 ... n-1]과 W[0 ... n-1]를&nbsp;생성하는 코드이다.&nbsp;아래 코드를 그대로 사용하여도 되고, 이를 직접 구현해도 된다. 출제진이&nbsp;의도한 해법은&nbsp;아래 코드를 사용하며&nbsp;제한 시간 내에 정답을 구한다.</p>

<table border="1" cellpadding="1" cellspacing="1" class="table table-bordered">
	<tbody>
		<tr>
			<td>C/C++</td>
			<td>Java</td>
			<td>Pypy3</td>
		</tr>
		<tr>
			<td>
			<pre>int n, x;
long long hs, ha, hb, hc,
&nbsp;         ws, wa, wb, wc;
// stdin에서 입력을 받는다.

long long H[n], W[n];

H[0] = hs % hc + 1;
W[0] = ws % wc + 1;
for(int i = 1; i <= n-1; i++) {
&nbsp; H[i] = H[i-1] + 1
&nbsp;      + (H[i-1] * ha + hb) % hc;
&nbsp; W[i] = (W[i-1] * wa + wb) % wc + 1;
}
</pre>
			</td>
			<td>
			<pre>int n, x;
long hs, ha, hb, hc,
&nbsp; &nbsp;  ws, wa, wb, wc;
// stdin에서 입력을 받는다.

long[] H = new long[n], W = new long[n];

H[0] = hs % hc + 1;
W[0] = ws % wc + 1;
for(int i = 1; i <= n-1; i++) {
&nbsp; H[i] = H[i-1] + 1
&nbsp;      + (H[i-1] * ha + hb) % hc;
&nbsp; W[i] = (W[i-1] * wa + wb) % wc + 1;
}
</pre>
			</td>
			<td>
			<pre>n,x = # stdin에서 입력을 받는다.
hs,ha,hb,hc = # stdin에서 입력을 받는다.
ws,wa,wb,wc = # stdin에서 입력을 받는다.

H, W = [0 for i in range(n)], [0 for i in range(n)]

H[0] = hs % hc + 1
W[0] = ws % wc + 1
for i in range(1, n):
&nbsp; H[i] = H[i-1] + 1 + (H[i-1] * ha + hb) % hc
&nbsp; W[i] = (W[i-1] * wa + wb) % wc + 1
</pre>
			</td>
		</tr>
	</tbody>
</table>

				</div>
				</div>','7
3 1
2 3 7 5
7 3 8 17
3 3
2 3 7 5
7 3 8 17
4 7
2 3 7 10
7 3 8 11
4 8
2 3 7 10
7 3 8 11
10 20
1 17 31 23
7 4 8 41
6 1000000000
123456 1 1 180001
654321 1000000000 1 180161
6 1000000000
123456 1 1 180001
2021 1000000000 1 180161
','-1
128
222
272
6311
182109717128
178794695372
','DATA_STRUCTURE'),
                                                                                                                (8289,'BAEKJOON','https://www.acmicpc.net/problem/22027',22027,'통신망','2.5초','1024 MB',29,'<p>통신망은 $N$개의 컴퓨터와 $M$개의 회선으로 구성된다.&nbsp;컴퓨터는 $1$번부터 $N$번까지 번호가 붙어 있다. 하나의 회선은 서로 다른 $2$개의 컴퓨터가 양방향으로 통신할 수 있도록 한다. 통신망의 어떤 두 컴퓨터도 하나 이상의 회선을 이용해서 통신이 가능하면 통신망은 <strong>연결되어 있다</strong>고 한다. 통신이 불가능한 컴퓨터의 쌍이 존재하는 경우 통신망은 <strong>끊어져 있다</strong>고 한다.</p>

<p>통신망의 한 회선 $c$의 <strong>위험도</strong>는 다음과 같이 정의된다.</p>

<ul>
	<li>통신망의 각 컴퓨터 $i$에 대해서, 컴퓨터 $i$를 제거했을 때 남은 통신망이 끊어져 있는 경우 컴퓨터 $i$를 <strong>위험한 컴퓨터</strong>라고 한다.</li>
	<li>초기 통신망에서 $c$를 제거했을 때, 위험한 컴퓨터의 개수를 $c$의 위험도로 정의한다.</li>
</ul>

<p>통신망을 입력으로 받아 각 회선의 위험도를 계산하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 정수 $N$과 $M$이 주어진다.&nbsp;($2 \le N \le 250\,000$, $1 \le M \le 1\,000\,000$)</p>

<p>다음 $M$개의 줄에는 회선의 정보가 주어진다. $i$번째 줄에는 $x_i$, $y_i$가 있고, $i$번 회선은 $x_i$번 컴퓨터와 $y_i$번 컴퓨터가 회선으로 연결되어 있음을 의미한다. ($1 \le x_i, y_i \le N, x_i \neq y_i$).&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$M$개의 줄을 출력한다. $i$번째 줄에는 $i$번 회선의 위험도를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
1 5
5 2
2 3
2 4
2 5
','4
2
4
4
2
','DATA_STRUCTURE'),
                                                                                                                (8301,'BAEKJOON','https://www.acmicpc.net/problem/22028',22028,'렉','8초','1024 MB',24,'<p>오래된 컴퓨터에서 그림판을 사용하고 있다. 그림판의 화면은 픽셀이라 부르는 칸을 가진 격자 모양이다. 가장 왼쪽 아래 픽셀의 좌표를 $(1, 1)$로 하고, 오른쪽으로 $a$번째 위쪽으로 $b$번째 픽셀의 좌표를 $(a, b)$로 한다. 초기 화면에는 수직, 수평 변을 가진 &nbsp;$N$개의 직사각형들이 그려져 있다. 직사각형은 이 구역안에 포함된 픽셀들로 표현된다.&nbsp;</p>

<p>$N$개의 직사각형에 $M$개의 이동 명령이 수행될 것이다. 직사각형의 이동은 동, 서, 남, 북의 4방향과 북동, 북서, 남동, 남서(수평축과 45도 방향) 4방향으로 이루어진다. 또한 이동 거리 $d$가 주어진다. 다시 말해서, 이동 명령은 방향과 거리로 주어진다. 구체적으로, 직사각형의 가장 왼쪽, 아래 모서리 픽셀의 좌표가 $(a, b)$라 하면, 동, 북, 서, 남 방향으로 거리 $d$만큼의 이동은 모서리가 각각 $(a+d, b)$, $(a, b+d)$, $(a-d, b)$, $(a, b-d)$가 된다. 또한 북동, 북서, 남서, 남동 방향으로 거리 $d$만큼의 이동은 각각 $(a+d, b+d)$, $(a-d, b+d)$, $(a-d, b-d)$, $(a+d, b-d)$가 된다 (<strong>그림 1</strong>).</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/b36746bc-261a-42ad-b9da-31ee71f0a13e/-/preview/" style="width: 275px; height: 291px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" src="https://upload.acmicpc.net/0f8bb03a-bfcb-42f5-90d9-2c653c7b750b/-/preview/" style="width: 270px; height: 290px;"></p>

<p style="text-align: center;"><strong>그림 1</strong></p>

<p>화면에서 직사각형 $R$의 거리 $d$만큼 이동은 초기 위치를 포함해서 $R$이 거리 1 만큼 이동할 때마다 $R$의 모습을 순서대로 빠르게 나타냄으로서 구현된다. 하지만 우리의 컴퓨터는 아주 오래 되어서 $R$의 이동 시 렉이 심하게 걸린다. 결과적으로 $R$의 이동에서 그리게 되는 모든 $R$의 모습이 화면에 그대로 남아있게 된다. 따라서 $R$이 거리 $d$만큼 이동하면, $d$개의 직사각형들이 새롭게 화면에 만들어진다. 예를 들어, 아래 <strong>그림 2</strong>에서 직사각형이 북동방향으로 거리 3만큼 이동하면, 3개의 직사각형들이 만들어져서 총 4개의 직사각형이 화면 위에 남게 된다. 물론, 이동 후에는 북동 방향 끝에 있는 직사각형이 $R$ 이 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/063e17e2-6bf0-477c-ab69-9b752c6edead/-/preview/" style="width: 140px; height: 158px;"></p>

<p style="text-align: center;"><strong>그림 2</strong></p>

<p>$M$개의 이동 명령을 수행한 후 $Q$개의 질의가 주어질 것이다. 각 질의는 평면 상의 픽셀 $p$로 주어진다. 질의에 대한 대답으로 픽셀 $p$를 포함하는 직사각형들의 개수를 출력한다. &nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 공백으로 구분된 세 정수 $N$, $M$, $Q$가 주어진다.</p>

<p>다음 $N$개의 줄에는 공백으로 구분된 네 개의 정수&nbsp;$x_1$, $y_1$, $x_2$, $y_2$가 주어지며, 직사각형의 가장 왼쪽 아래 픽셀의 좌표가&nbsp;$(x_1, y_1)$, 가장 오른쪽 위 픽셀의 좌표가&nbsp;$(x_2, y_2)$임을 의미한다. 직사각형은 $1$부터 $N$의 정수로 나타내며, $1$번 직사각형부터 순서대로 주어진다.</p>

<p>다음 $M$개의 줄에는 공백으로 구분된 세 개의 정수&nbsp;$v_i$, $x_i$, $d_i$가 주어진다. $x_i$번째 직사각형이 $v_i$ 방향으로 $d_i$만큼 이동함을 나타낸다. $v_i$의 값은 다음과 같다.</p>

<ul>
	<li>0: $(+1, 0)$</li>
	<li>1: $(+1, +1)$&nbsp;</li>
	<li>2: $(0, +1)$</li>
	<li>3: $(-1, +1)$&nbsp;</li>
	<li>4: $(-1, 0)$</li>
	<li>5: $(-1, -1)$&nbsp;</li>
	<li>6: $(0, -1)$</li>
	<li>7: $(+1, -1)$&nbsp;</li>
</ul>

<p>다음 $Q$개의 줄에는 공백으로 구분된 두 정수 $x$, $y$가 주어지며, 질의에 해당하는 평면 상의 픽셀 $p$의 좌표 $(x, y)$를 나타낸다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 질의마다 질의의 픽셀 $p$를 포함하는 직사각형들의 개수를 출력한다. $i$번째 줄에는 $i$번 질의의 결과를 출력해야 한다. ($0 ≤ i ≤ Q-1$)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1 8 3
2 1 2 1
0 1 1
1 1 1
2 1 1
3 1 1
4 1 1
5 1 1
6 1 1
7 1 1
1 1
2 1
4 2
','0
2
1
','DATA_STRUCTURE'),
                                                                                                                (8293,'BAEKJOON','https://www.acmicpc.net/problem/22030',22030,'총 쏘기','5초','1024 MB',30,'<p>두 명이 같이 하는 인터넷 슈팅 게임이 있다. 이 게임은 폐허가 된 도시에서 빌딩들을 부수는 게임이다. 게임에서 바닥인 수평선 위에 $N$개의 빌딩이 왼쪽에서 오른쪽으로 서 있다. 빌딩은 왼쪽에서 오른쪽으로 순서대로 1부터 $N$의 정수로 나타낸다. 각 빌딩의 바닥으로부터의 높이는 수열 $A_i$ $(1 \le i \le N)$로 나타내고, $1$부터 $N$까지의 서로 다른 정수로 주어진다.&nbsp;</p>

<p>두 명의 플레이어는 모든 빌딩보다 왼쪽의 같은 위치에 있다. 시간 $i$($\ge 1$)에 두 명의 플레이어는 동시에 각 한발씩 총을 발사하고, 총알은 발사한 위치에서 수평으로 오른쪽으로 날아간다. 두 총알의 속도는 동일하다. 플레이어는 총알의 발사 높이를 바닥으로부터의 거리 $H$로 결정한다. $H$는 $1$이상 $N+1$이하의 정수이다. 두 플레이어는 동일한 발사 높이를 선택할 수 있다.&nbsp;</p>

<p>플레이어의 총알 발사 높이가 $H$인 경우, $A_i \ge H$를 만족하는 파괴되지 않은 가장 왼쪽의 빌딩이 이 총알로 파괴된다. 이 조건을 만족하는 빌딩이 없다면, 아무 일도 일어나지 않는다. 만약 두 플레이어가 발사한 총알에 대해 이 조건을 만족하는 빌딩이 동일하다면, (두 총알의 속도는 동일하기 때문에) 이 하나의 빌딩만 파괴된다. 특별히, 두 플레이어의 발사 높이가 같다면, 항상 하나의 빌딩만 파괴된다. 예를 들어, $A_1 = 2, A_2 = 1$이고, 처음에 두 플레이어가 모두 $H = 1$을 발사 높이로 결정하였다면, 이 두 총알로 빌딩 $1$만 파괴된다.&nbsp;</p>

<p>문제는 $N$개 빌딩들의 높이가 입력으로 주어질 때, 모든 빌딩을 파괴할 수 있는 최소 시간과 각 시간에 두 플레이어의 총알 발사 높이를 찾는 것이다. &nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 $N$이 주어진다.</p>

<p>다음 줄에는 $N$개의 공백으로 구분된 정수&nbsp;$A_1, A_2, \ldots, A_N$이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 두 플레이어가 모든 빌딩을 파괴하기 위한 최소 시간 $T$를 출력한다.</p>

<p>다음 $T$개의 줄에는 공백으로 구분된 두 정수를 한 줄에 하나씩 출력한다. 두 정수는 각각 첫 번째와 두 번째 플레이어의 총알 발사 높이를 나타낸다. 두 정수는 1보다 크거나 같고, $N+1$보다 작거나 같아야 하며, 두 정수가 서로 같아도 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2 4 3
','2
1 4
2 3
','DATA_STRUCTURE'),
                                                                                                                (8295,'BAEKJOON','https://www.acmicpc.net/problem/22031',22031,'회의실','1초','1024 MB',21,'<p>$K$개의 회의실이 있다. $N$개의 회의가 이 회의실들을 이용하려고 한다. 각 회의는 $1$부터 $N$까지 번호가 붙어 있다. 회의 $i$는 시작 시각 $s_i$, 끝나는 시각 $e_i$, 위약금 $w_i$로 표현된다.&nbsp;</p>

<p>이 회의실들은 매우 특이한 규칙에 따라 운영된다. 회의 $i$와 회의 $j$는 다음 조건 중 적어도 하나를 만족하면 <em>관련있는 회의</em>라고 부른다.&nbsp;</p>

<ol>
	<li>두 구간 $[s_i , e_i]$와 $[s_j , e_j]$의 공통된 구간이 존재할 때 (시작과 끝 시각만 겹치는 경우에도) $i$와 $j$는 관련있는 회의이다.&nbsp;</li>
	<li>두 구간 $[s_i , e_i]$와 $[s_j , e_j]$의 공통된 구간이 존재하지 않지만, 다른 회의 $c$가 $i$와 관련있고 $[s_c , e_c]$와 $[s_j , e_j]$의 공통된 구간이 존재할 때 (시작과 끝 시각만 겹치는 경우에도) $i$와 $j$는 관련있는 회의이다.</li>
</ol>

<p>회의들이 취소될 수 있어서 위의 정의는 취소되지 않은 회의들만 가지고 판단한다. 즉, 원래 관련있는 회의 관계였던 두 회의가, 일부 회의의 취소로 인해 관련있는 회의 관계가 아니게 될 수 있다.&nbsp;</p>

<p>취소되지 않은 회의는 회의실을 하나씩 할당받아야 한다. 관련있는 회의들은 모두가 반드시 <strong>서로 다른</strong> 회의실을 할당받아야 한다. 예를 들어 세 회의 $[1,3]$, $[3,5]$, $[5,7]$는, $[1, 3]$과 $[5, 7]$ 사이에 공통된 구간이 없음에도 불구하고, 두 개가 아닌 세 개의 회의실을 할당받아야 함에 유의하시오. 회의실이 $K$개밖에 없기 때문에 일부 회의들을 취소해야 할 수 있다. 회의 $i$를 취소하면 위약금 $w_i$를 내야 하므로, 가급적 취소할 회의를 잘 골라서 지급할 위약금의 합을 최소로 하고 싶다.&nbsp;</p>

<p>다음 그림은 5개의 회의 $[1, 4]$, $[3, 6]$, $[5, 8]$, $[7, 10]$, $[9, 12]$가 있고, 각 회의의 위약금이 차례로 1, 2, 5, 2, 1인 경우를 보이고 있다. 회의실이 2개 있다고 하자. 왼쪽의 예는 $[5, 8]$을 취소해서 조건을 만족시키는 경우이며, 이 경우 위약금은 $5$이다. 오른쪽의 예는 $[3, 6]$과 $[9, 12]$를 취소해서 조건을 만족시키는 경우이며, 이 경우 위약금은 $3$이다. 모든 경우를 고려해보면 최소의 위약금 합은 $3$임을 알 수 있다.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/31b3f58c-bb38-4754-b845-9d8c6b415d14/-/preview/" style="width: 370px; height: 88.3333px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 공백으로 구분된 두 정수 $N$, $K$가 주어진다.</p>

<p>다음 $N$개의 줄에는 공백으로 구분된 세 정수 $s_i$, $e_i$, $w_i$가 주어진다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>주어진 회의실의 수와 회의 정보를 바탕으로, 조건을 만족하게 하기 위해서 취소해야 할 회의들 중 가장 위약금의 합이 적은 경우를 찾고 그때의 위약금의 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 2
1 4 1
3 6 2
5 8 5
7 10 2
9 12 1
','3
','DATA_STRUCTURE'),
                                                                                                                (8299,'BAEKJOON','https://www.acmicpc.net/problem/22033',22033,'가로등','4초','1024 MB',28,'<p>일직선으로 된 도로를 따라 $N$개의 가로등이 세워져 있다. $i$번째 가로등의 초기 높이는 $A_i$이다$(1 \le i \le N)$. 가로등을 이용하여 전기줄을 설치하려고 한다.</p>

<p>$i$번 가로등과 $j( \gt i)$번 가로등 사이에 전기줄을 걸기 위해서는 다음 두 조건을 모두 만족해야 한다.</p>

<ul>
	<li>$A_i = A_j$ (두 가로등의 높이가 같다.)</li>
	<li>모든 $i < k < j$에 대하여, $A_k < A_i$이다. (두 가로등 사이에 있는 모든 가로등의 높이는 두 가로등보다 낮다.)</li>
</ul>

<p>일부 가로등은 관리자의 판단에 따라 높이가 조정되며, 높이가 조정된 가로등으로 인해 전기줄을 걸 수 있는 상황이 변경된다.&nbsp;</p>

<p>"$x$번째 가로등의 높이를 $h$로 변경"하는 높이 조정 작업은 총 $Q$번 행해진다. 가로등 높이 변경이 이루어질 때마다, 높이 조정 후 전기줄을 걸 수 있는 가로등 쌍의 개수를 계산하는 프로그램을 작성하고자 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 정수 $N$, $Q$가 주어진다.&nbsp;$2 \le N \le 100\,000, 1 \le Q \le 250\,000$</p>

<p>다음 줄에는 $N$개의 정수 $A_1, A_2, \ldots, A_N$가 주어진다. ($1 \le A_i \le 10^9$)</p>

<p>다음 $Q$개의 줄에는 두 정수 $x$, $h$가 주어지며, $A_x = h$를 나타낸다.&nbsp;($1 \le x \le N, 1 \le h \le 10^9$)&nbsp;조정 직전의 $x$번째 가로등의 높이는 $h$와 다름이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에&nbsp;초기에 설치된 가로등에 걸 수 있는 전기줄의 개수를 출력한다.</p>

<p>다음 $Q$개의 줄에는&nbsp;높이 조정 작업 각각에 대해, 높이 조정 후 가로등에 걸 수 있는 전기줄의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 2
4 2 2 2 4 6
4 6
6 4
','3
2
2
','DATA_STRUCTURE'),
                                                                                                                (8304,'BAEKJOON','https://www.acmicpc.net/problem/22232',22232,'가희와 파일 탐색기','1.5초','512 MB',8,'<p>가희는 <em>jo_test</em> 폴더에 들어와 있습니다.&nbsp;가희는 <em>jo_test</em>에 있는 파일 <em>N</em>개를&nbsp;아래 기준에 따라 정렬하려고 합니다.</p>

<ol>
	<li>파일명 (<em>FILENAME</em>) 사전순으로</li>
	<li>파일명 (<em>FILENAME</em>)이 같다면 가희가 설치한 OS에서 인식하는 확장자가 붙은 것이 먼저 나오게</li>
	<li>1과 2로도 순서를 결정할 수 없다면, 파일 확장자 (<em>EXTENSION</em>) 사전 순으로</li>
</ol>

<p>파일 <em>N</em>개를 문제에서 설명하는 정렬 기준에 따라 정렬해 주세요.&nbsp;사전순의 기준은 아스키 코드 순입니다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 jo_test 폴더에 있는 파일 개수 <em>N</em>과 가희가 설치한 OS에서 인식하는 파일 확장자의 개수 <em>M</em>이 공백으로 구분되어&nbsp;주어집니다.</p>

<p>2번째 줄부터 <em>N+1</em>번째 줄까지 <em>FILENAME</em>.<em>EXTENSION </em>형식의 문자열이 주어집니다. <strong>여기서 .은 온점을 의미합니다.</strong></p>

<p><em>FILENAME</em>은&nbsp;소문자와 숫자로만, <em>EXTENSION</em>은 소문자로만 이루어져 있습니다.</p>

<p>그 다음 줄 부터 <strong>가희가 설치한 OS에서 인식하는</strong> 파일 확장자 (<em>EXTENSION</em>)&nbsp;<em>M</em>개가&nbsp;주어집니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>기준에 따라 정렬된 결과를 출력해 주세요.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
abc.jpeg
abc.jpg
foo.yolo
bar.cpp
bar.maltise
jpg
cpp
maltise
','abc.jpg
abc.jpeg
bar.cpp
bar.maltise
foo.yolo
','DATA_STRUCTURE'),
                                                                                                                (8237,'BAEKJOON','https://www.acmicpc.net/problem/22234',22234,'가희와 은행','1.5초','512 MB',11,'<p>가희는 창구가 하나인 은행을 운영하고 있습니다. 가희의 은행이 영업을 시작했을 때,&nbsp;대기 줄에는 손님이&nbsp;<em>N</em>명&nbsp;있습니다.</p>

<p>&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/55e4fafb-f33c-4d0d-b275-dd9728c1ad7f/-/preview/" style="width: 366.667px; height: 109.167px;"></p>

<p style="text-align: center;"><strong>[그림 1] 카운터 직원과 <em>N</em>명의 손님</strong></p>

<p><em>x</em>번 손님에 대한 정보는 <em>x</em>번 손님의&nbsp;<em>id</em> 값인 <em>P<sub>x</sub></em>와 업무를 처리하는 데 필요한 시간인 <em>t<sub>x</sub></em>초로 정보가 주어지게 됩니다.</p>

<p>은행이 영업을 시작하고 난 후에 들어오는 손님은&nbsp;<em>M</em>명 있습니다. 이 손님들은 입력을 받은 순서대로 각각 <em>N+1</em>, <em>N+2</em>, ..., <em>N+M</em>번 손님이 됩니다.</p>

<p>이 손님들에 대한 정보는 <em>x</em>번 손님의&nbsp;<em>id</em> 값인 <em>P<sub>x</sub></em>와 업무를 처리하는 데 필요한 시간인 <em>t<sub>x</sub></em>초, 영업 시작 <em>c<sub>x</sub></em>초 후에 들어왔다는&nbsp;정보가 주어지게 됩니다.</p>

<p>손님은&nbsp;은행에 들어옴과 동시에, 대기 큐의 맨 뒤에 서게 됩니다. N+1번 손님이 은행을 영업을 시작하고&nbsp;c<sub>N+1</sub>초 후에 들어왔다고 생각해 보겠습니다.</p>

<p>&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/33a3c56a-04b0-4119-bef6-c2dbea337ba4/-/preview/" style="width: 348.333px; height: 75.8333px;"></p>

<p style="text-align: center;"><strong>[그림 2] 은행이 영업을 시작하고 c<sub>N+1</sub>초 후 상황</strong></p>

<p>N+1번 손님은 은행에 들어오자 마자 대기 큐의 맨 뒤에 줄을 서게 되므로, 영업을 시작하고 <em>c<sub>N+1</sub></em>초 후에 대기 큐의 상태는 위와 같습니다.</p>

<p>창구에 있는 직원과 고객들은 아래와 같은 알고리즘으로 업무를&nbsp;처리합니다.</p>

<ol>
	<li>대기 큐의 맨 앞에 있는 고객이 <em>x</em>번 손님이라고 하면, 창구에 있는 직원은

	<ul>
		<li><em>t<sub>x</sub></em>가 <em>T</em>보다 크다면, <em>x</em>번 손님의&nbsp;업무를 <em>T</em>초동안 처리합니다. 그 후, <em>x</em>번 손님의 업무가 끝나는 데 필요한 시간인 <em>t<sub>x</sub></em>는&nbsp;<em>T</em>만큼 감소합니다.</li>
		<li>그렇지 않으면, <em>x</em>번 손님의 업무를 <em>t<sub>x</sub></em>초 동안 처리합니다. 이후에, <em>x</em>번 손님의 업무가 끝나는 데 필요한 시간인 <em>t<sub>x</sub></em>는 은 0이 됩니다.</li>
	</ul>
	</li>
	<li>대기 큐의 맨 앞에 있는 고객인 <em>x</em>번 손님은
	<ul>
		<li>업무가 끝나는 데 필요한 시간인 <em>t<sub>x</sub></em>가&nbsp;0이 되었다면, 은행 바깥으로 나가게 됩니다.</li>
		<li>그렇지 않으면 대기 큐의 맨 뒤로 이동하게 됩니다. 만약에 이 때 도착한 손님이 있다면, 도착한 손님 뒤로 가게 됩니다.</li>
	</ul>
	</li>
	<li>대기 큐에 고객이 남았다면 1로 돌아갑니다.</li>
</ol>

<p>은행이&nbsp;영업을 시작할&nbsp;때 부터 창구에 있는 직원은 일을 시작합니다.</p>

<p>은행이 영업을 시작한 시점으로부터 0초가 지났을 때 부터 <em>W-1</em>초가 지날&nbsp;때 까지 창구에 있는 직원이&nbsp;어떤 고객의 업무를 처리하는지 알려주세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 <em>N</em>과&nbsp;<em>T</em>, <em>W</em>가 공백을 구분으로 해서 주어집니다.</p>

<p>두 번째 줄 부터 <em>N</em>개의 줄에는 0초일 때, 대기 큐의 앞에 있는 고객부터, <em>P<sub>x</sub></em>와 고객이 일을 처리하는 데 필요한 시간 <em>t<sub>x</sub></em>가 공백으로 구분되어 주어집니다.</p>

<p><em>N+2</em>번째 줄에는, 1초 이후에 은행에 들어온 고객 수 <em>M</em>이 주어집니다.</p>

<p><em>N+3</em>번째 줄부터 <i>M</i>개의 줄에 걸쳐서, <em>P<sub>x</sub></em>,&nbsp;<em>t<sub>x</sub></em>, <em>c<sub>x</sub></em>가 공백으로 구분되어 주어집니다. 입력된 순서대로 각각 <em>N+1</em>, ..., <em>N+M</em>번 고객입니다.</p>

<p>이는 고객 <em>id</em>가 <em>P<sub>x</sub></em>인 고객은 일을 처리하는 데 필요한 시간이 <em>t<sub>x</sub></em>초이고, 영업 시작 시간으로부터&nbsp;<em>c<sub>x</sub></em>초가 지났을 때&nbsp;은행에 들어왔다는 것을 의미합니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>i</em>번째 줄에는&nbsp;은행이 영업을 시작한 시점으로부터&nbsp;<em>i-1</em>초가 지났을&nbsp;때 은행 직원이 처리하고 있는 고객 <em>id</em>를 출력해 주세요.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1 5 7
1 6
1
3 1 5
','1
1
1
1
1
3
1
','DATA_STRUCTURE'),
                                                                                                                (8250,'BAEKJOON','https://www.acmicpc.net/problem/22239',22239,'가희와 읽기 쓰기 놀이 2','2.5초','512 MB',15,'<p>가희와 친구들은 읽기 쓰기&nbsp;놀이를 하고 있습니다. 읽기 쓰기 놀이는 빈 리스트를&nbsp;가지고 시작합니다.&nbsp;</p>

<p>놀이에서 사용하는 카드에 적혀져 있는 연산은 하나입니다.</p>

<ul>
	<li>add <em>c</em>

	<ul>
		<li>리스트 뒤에 수 c를&nbsp;추가합니다.&nbsp;</li>
	</ul>
	</li>
</ul>

<p>놀이의 규칙은 다음과 같습니다.</p>

<ul>
	<li>빈 리스트로 게임을 시작합니다.</li>
	<li>각 턴을 수행하는 사람은 1명입니다.</li>
	<li>턴을 수행하는 사람은 가지고 있는 <strong>카드에 적혀져 있는 연산을 수행하고 턴을 종료</strong>합니다.</li>
</ul>

<p>문자열 게임에 참가하는 사람은 <em>N</em>명이고, 카드는 1번 카드부터 <em>C</em>번 카드까지 총&nbsp;<i>C</i>장 있습니다.</p>

<p><em>N</em>개의 제약 조건이 주어졌을 때 제약 조건에 맞게 사람들이 카드를 내서 결과 (길이가 <em>C</em>인) 리스트를 만들 수 있을까요?</p>

<p>만들 수 있다면, 각 턴마다 어떤 사람이 카드를 냈는지 구해 주세요. 그렇지 않으면 -1을 출력해 주세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>1번째 줄에 <em>N</em>, <em>C</em>가 공백으로 구분되어 주어집니다.</p>

<p>2번째 줄에 게임의 결과인 리스트에 있는 수들이 주어집니다.&nbsp;<em>0</em>번째 인덱스에 있는 수부터 <em>C-1</em>번째 인덱스에 있는 수까지 공백으로 구분되어 주어집니다.</p>

<p>3번째 줄 부터 <em>N+2</em>번째 줄까지 1번 제약 조건부터 <em>N</em>번 제약 조건까지 제약 조건 <em>N</em>개가 주어집니다.</p>

<p>제약 조건이 주어질 때에는,&nbsp;내야 하는 카드의 개수와 어떤 순서로 카드를 내야 하는지가 주어집니다.</p>

<p>예를 들어 3번째 줄에 <em>3 2 4 5</em> 가 있다면, 1번&nbsp;사람이 <strong>2번 카드, 4번 카드, 5번 카드를 순서대로 내야 하는&nbsp;것</strong>을 의미합니다.</p>

<p><em>N+3</em>번째 줄부터 <em>N+C+2</em>번째 줄까지 1번 카드부터 <em>C</em>번 카드에 적혀져 있는 연산이&nbsp;주어집니다. 카드에 있는 연산은 하나입니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>제약 조건에 맞게 게임을 해서 결과 리스트를 만들 수 있다면, 각 턴마다 어떤 사람이 카드를 내야 하는지 <strong>공백으로 구분해서 출력</strong>해 주세요.</p>

<p>답이 여러 개인 경우에는 아무거나 출력하고, 그렇지 않으면&nbsp;-1을 출력해 주세요.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>결과 리스트가 [2, 1, 2, 2, 3, 4, 2, 3]으로 주어졌다고 생각해 보겠습니다.</p>

<p style="text-align: center;">&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/0fd36678-77f8-41f1-ad7e-4475ac808511/-/preview/"><br>
<strong>[그림 1] 유효한&nbsp;결과 리스트</strong></p>

<p>결과 리스트에서 두 번 이상 등장한 수는 2, 3입니다. 2가 등장한 횟수는 4번, 3이 등장한 횟수는 2번입니다.</p>

<p>결과 리스트에서 2번 이상 나오는 수가 나오는 횟수를 합하면 6입니다.</p>

<p>&nbsp;</p>

<p>아래는 결과 리스트가 [2, 1, 2, 2, 3, 3, 2, 3]인 경우입니다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/f640d377-eb75-434d-b267-ad77e34fb98a/-/preview/"><br>
<strong>[그림 2] 유효하지 않은 결과 리스트</strong></p>

<p>결과 리스트에서 2번 이상 나오는 수는 2, 3입니다. 2가 나온 횟수는 4번, 3이 나온 횟수는 3번으로, 이 둘을 합하면 7입니다.</p>

<p>7은 6보다 크므로,&nbsp;<strong>결과 리스트에 2번 이상 나오는 수가 나오는 횟수</strong>를 합하면&nbsp;최대 6번이라는 제한을 만족하지 않습니다.</p>

<p>이러한 입력은 주어지지 않습니다.</p>

				</div>
				</div>','2 3
1211 1225 1517
2 1 3
1 2
ADD 1211
ADD 1517
ADD 1225
','1 1 2
','DATA_STRUCTURE'),
                                                                                                                (8247,'BAEKJOON','https://www.acmicpc.net/problem/22252',22252,'정보 상인 호석','2초','512 MB',11,'<p>암흑가의 권력은 주먹과 정보에서 나온다. 주먹은 한 명에게 강하고, 정보는 세계를 가지고 놀 수 있기 때문에 호석이는 세상 모든 정보를 모으는 "정보 상인"이 되고 싶다. 정보 상인은 정보를 사고파는 사람을 의미한다.</p>

<p>호석이는 아직 상인계의 새싹이기 때문에, 초기 투자를 통해서 여러 명의 "정보 고릴라"들로부터 정보를 모으려고 한다. 정보 고릴라란 여기저기서 정보를 수집하는 사람들을 의미한다. 일단 정보를 긁어모으기 위해서 호석이는 여러 정보 고릴라들에게 정보를 구매하려고 한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3de1bd98-cafe-4e28-8ffc-0eeb2edcb0e2/-/preview/" style="height: 347.5px; width: 347.5px;"></p>

<p>암흑가의 연락망은 빼곡하기 때문에 누가 어떤 정보를 얻었는지에 대한 찌라시들이 수시로 퍼진다. 찌라시로 알 수 있는 것은, 어떤 이름을 가진 고릴라가 $C_1$, $C_2$, ..., $C_k$ 만큼의 가치가 있는 정보 k 개를 얻었다는 점이다.</p>

<p>호석이는 이를 바탕으로 임의의 시점에 특정 고릴라에게 정보를 몇 개 살 것인지를 정할 수 있다. 이때 가치 순으로 가장 비싼 정보들을 구매한다. 예를 들어 고릴라가 가진 정보가 10개이고, 호석이가 사고 싶은 정보 개수가 4개라면, 고릴라는 10개 중에서 가치 순으로 가장 비싼 4개를 팔 것이다. 한 번 거래한 정보는 호석이에게 더 이상 가치가 없기 때문에 고릴라도 그 정보를 파기한다.</p>

<p>당신은 암흑가의 주먹이며&nbsp;양대 산맥이 될 가능성이 있는 호석이를 주시하고 있다. 관찰하면서 얻은 정보는 총 $Q$ 개이다. 각 정보는 다음의 2가지 중 하나이다.</p>

<ul>
	<li>1 Name $k$ $C_1, C_2, ..., C_k$ : 이름이 [Name]인 고릴라가 $k$ 개의 정보를 얻었으며, 각 가치는 $C_1$ 부터 $C_k$ 이다.</li>
	<li>2 Name $b$ : 호석이가 이름이 [Name]인 고릴라에게 $b$ 개의 정보를 구매한다. 이때 고릴라가 가진 정보들 중 가장 비싼 $b$ 개를 구매하며, 고릴라가 가진 정보가 $b$개 이하이면&nbsp;가진 모든 정보를 구매한다.</li>
</ul>

<p>&nbsp;견제를 위해서 호석이가 가진 정보들의 가치 총합, 즉 호석이가 정보들을 구매하는 데에 쓴 돈의 총합을 구하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>고릴라들이 정보를 얻는 사건과 호석이가 거래하는 정보가 시간순으로&nbsp;주어진다. 첫 번째 줄에는 쿼리의 개수 $Q$ 가 주어진다.</p>

<p>이어서 $Q$ 개의 줄에 걸쳐서 각 줄에 쿼리가 주어진다. 쿼리는 1이나 2로 시작한다. 1로 시작하는 경우에는 정보를 얻은 정보 고릴라의 이름과 $k$ 가 주어지며 이어서 $k$ 개의 정보 가치 $C_1, ..., C_k$가&nbsp;자연수로 주어진다. 모든 $C_i$는 1 이상 100,000 이하이다.&nbsp;2로 시작하는 경우에는 호석이가 거래하려는 정보 고릴라의 이름과 구매하려는 정보의 개수 $b$가 주어진다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 쿼리가 종료되었을 때에 호석이가 얻게 되는 정보 가치의 총합을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1 Cpp 5 10 4 2 8 4
1 Java 2 8 2
2 Cpp 2
1 Cpp 2 10 3
2 Cpp 3
2 Java 1
2 Python 10
','44
','DATA_STRUCTURE'),
                                                                                                                (8254,'BAEKJOON','https://www.acmicpc.net/problem/22254',22254,'공정 컨설턴트 호석','1초','512 MB',13,'<p>거듭된 창업 성공을 이룬 류진국 사장은 이번에는 맞춤형 선물을 제작해주는 공장을 만들기로 했다. 현재 들어온 맞춤형 선물 주문은 총 $N$개이며, 각 맞춤형 선물마다 제작에 필요한 시간이 정해져있다. 주문의 번호는 $1$번부터 $N$번까지 매겨져 있으며, 다음과 같은 규칙에 맞게 공정이 이뤄진다.</p>

<ol>
	<li>공정 라인이 총 $K$개가 있다면 $1$번부터 $K$번까지의 번호가 존재한다.</li>
	<li>공정 라인의&nbsp;사용 시간은 배정된 맞춤형 선물들의 제작 시간의 총합이다.</li>
	<li>$i$번 선물은 $1$번 부터 $i-1$번 선물들이 배정된 이후에 사용 시간이 가장 적은 공정&nbsp;라인 중 하나에&nbsp;배정된다.</li>
</ol>

<p>모든 맞춤형 선물의 제작이 완료될 때까지 최대 $X$시간이 남아있는 상황인데, 아직 공정 라인의 개수 $K$가 정해져 있지 않다. 류진국 사장은 이 분야 최고 권위자, 공정 컨설턴트 호석에게 의뢰했다. 공정 컨설턴트 호석은 최소한의 비용을 쓰기 위해서 공정 라인의 개수를 최소화 시키고자 한다. 호석을 도와 필요한 최소 공정 라인 개수를 계산하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 맞춤형 선물 주문의 개수 $N$, 제작 완료까지 남은 시간 $X$가 공백으로 구분되어 주어진다.</p>

<p>두 번째 줄에는 $1$번부터 $N$번 선물이 필요한 공정&nbsp;시간이 순서대로 주어진다. 단위는 시간 이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 선물을 $X$시간 이내에 제작하기 위해 필요한 최소 공정 라인 개수를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 11
5 2 8 4 3 5
','3
','DATA_STRUCTURE'),
                                                                                                                (8278,'BAEKJOON','https://www.acmicpc.net/problem/22306',22306,'트리의 색깔과 쿼리 2','2초','256 MB',22,'<p>N개의 정점으로 구성된 트리가 있다. 각 정점은 1번부터 N번까지 번호가 매겨져있고, 1 이상 10만 이하의 자연수로 표현되는 색깔을 하나 갖고 있다. 루트는 1번 정점이고, 트리이기 때문에 임의의 서로 다른 두 정점을 잇는 경로는 반드시 한 개 존재한다.</p>

<p>정점 u와 v를 잇는 경로가 존재하면 u에서 v로 갈 수 있다고 하자.</p>

<p>여러분은 아래 두 가지 쿼리를 처리해야 한다.</p>

<ul>
	<li>1 a : 정점 a와 a의 부모 정점을 연결하는 간선을 제거한다. (해당 간선이 존재하는 경우에만 주어진다.)</li>
	<li>2 a : 정점 a에서 갈 수 있는 정점들만 보았을 때, 색깔의 종류의 개수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 정점의 개수 N(1 ≤ N ≤ 100,000)과 2번 쿼리의 개수 Q(1 ≤ Q ≤ 1,000,000)가 주어진다.</p>

<p>두 번째 줄에는 N-1개의 정수가 주어진다. i번째 수는 정점 i+1의 부모 정점을 의미한다.</p>

<p>세 번째 줄에는 N개의 정수가 주어진다. i번째 수는 정점 i의 색깔을 의미한다.</p>

<p>다음 N+Q-1개의 줄에는 여러분이 처리해야 할 쿼리가 주어지는데, 1번 쿼리는 N-1개, 2번 쿼리는 Q개 주어진다.</p>

<p>쿼리는 한 줄에 하나씩 쿼리의 종류를 나타내는 X(1 ≤ X ≤ 2)와 음이 아닌 정수 k가 주어진다. 쿼리에서 처리할 정점의 번호 a는 (k ? lst)이며, a는 1 이상 N 이하이다. ?는 배타적 논리합을 의미한다.&nbsp;lst는 가장 최근에 처리한 2번 쿼리의 결과를 의미하고,&nbsp;초깃값은 0이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q개의 2번 쿼리에 대한 답을 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 4
5 2 2 1
1 3 2 3 3
1 4
2 1
2 0
1 1
2 6
1 7
2 1
1 1
','3
3
2
2
','DATA_STRUCTURE');