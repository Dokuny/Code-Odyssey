INSERT INTO problem (problem_id,platform,href,no,title,runtime,memory,difficulty,content,input,output,type) VALUES
                                                                                                                (10504,'BAEKJOON','https://www.acmicpc.net/problem/1135',1135,'뉴스 전하기','2초','128 MB',14,'<p>민식이는 회사의 매니저이다. 그리고, 민식이는 회사의 중요한 뉴스를 모든 직원에게 빠르게 전달하려고 한다. 민식이의 회사는 트리 구조이다. 모든 직원은 정확하게 한 명의 직속 상사가 있다. 자기자신은 그들 자기 자신의 직접 또는 간접 상사가 아니고, 모든 직원은 민식이의 직접 또는 간접적인 부하이다.</p>

<p>민식이는 일단 자기 자신의 직속 부하에게 한 번에 한 사람씩 전화를 한다. 뉴스를 들은 후에, 각 부하는 그의 직속 부하에게 한 번에 한 사람씩 전화를 한다. 이 것은 모든 직원이 뉴스를 들을 때 까지 계속된다. 모든 사람은 자신의 직속 부하에게만 전화를 걸 수 있고, 전화는 정확하게 1분 걸린다. 이때 모든 직원이 소식을 듣는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.</p>

<p>오민식의 사원 번호는 0이고, 다른 사원의 번호는 1부터 시작한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 직원의 수 N이 주어진다. 둘째 줄에는 0번 직원부터 그들의 상사의 번호가 주어진다. 0번 직원 (오민식)은 상사가 없기 때문에 -1이고, 나머지 직원 i의 상사 번호는 i보다 작거나 같은 음이 아닌 정수이다. N은 50보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 모든 소식을 전하는데 걸리는 시간의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
-1 0 0
','2
','TREE'),
                                                                                                                (10509,'BAEKJOON','https://www.acmicpc.net/problem/1272',1272,'특별 노드','2초','128 MB',14,'<p>n(1<=n<=1,000)개의 정점을 가지고 있는 트리 T가 있다. T는 루트가 있는 트리이며, 각각의 노드에는 가중치 w(1<=w<=50,000)가 있다. 이때, 각 노드의 가중치는 부모 노드의 가중치보다 크다고 한다. T의 각 노드는 특별 노드와 일반 노드로 분류된다. 만약 어떤 노드가 특별 노드라면, 그 노드의 가중치는 원래의 가중치가 된다. 만약 어떤 노드 v가 특별 노드가 아니라면, 그 노드의 가중치는 그 노드의 가장 가까운 특별 노드인 부모 노드 u에 대해서 v의 가중치 - u의 가중치가 된다. 이해를 돕기 위해 아래의 그림을 보자</p>

<p><img alt="" src=https://www.acmicpc.net/upload/201004/picture.JPG" style="height:125px; width:261px"></p>

<p>왼쪽 그림은 원래의 트리이다. 원 안의 숫자는 노드의 번호이며, 원 옆의 숫자는 그 노드의 가중치이다. 오른쪽 그림은 1번, 2번 노드를 특별 노드로 했을 때, 다시 가중치가 계산된 트리이다.</p>

<p>문제는, 원래의 트리 T가 주어졌을 때, 다시 계산된 가중치의 합의 최소가 되도록 하는 특별 노드들을 찾는 것이다. 위의 예에서는 왼쪽 트리의 가중치의 합이 35이고, 오른쪽 트리의 가중치의 합은 19이다. 루트는 항상 특별 노드라고 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 노드의 수 n과 루트의 번호가 주어진다. 둘째 줄에는 1, 2, 3, , n번 노드의 가중치가 공백으로 구분되어 주어진다. 다음 n-1개의 줄에는 각 줄에 두 개의 정수로 주어진 트리 상에서 연결되어 있는 두 정점의 번호가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가중치의 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 1
2 4 5 3 6 7 8
1 2
1 3
1 4
2 5
2 6
6 7
','19
','TREE'),
                                                                                                                (10510,'BAEKJOON','https://www.acmicpc.net/problem/1595',1595,'북쪽나라의 도로','1초','128 MB',12,'<p>두 도시 사이에 도로를 만드는 일은&nbsp;매우 비싸다. 때문에 북쪽나라는 특정 도시를 두 번 이상 지나가지 않고서&nbsp;임의의 두 도시간을 이동하는 경로가 유일하도록 도로가 설계되어 있다.</p>

<p>또한 북쪽나라의 모든 도시는 다른 모든 도시로 이동할 수 있다고 한다. 이때, 거리가 가장 먼 두 도시 사이의 거리를 출력하는 것이 당신의 임무이다.</p>

<p>북쪽나라에는 최대 10,000개의 도시가 있을 수 있고, 도시는 1 부터 숫자로 이름이 매겨져 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러줄에 걸쳐 주어진다. 입력의 각 줄은 세 개의 양의 정수로 구성되어있는데, 각각은 차례대로 서로 다른 두 도시의 번호와 두 도시를 연결하는 도로의 길이를 의미한다. 모든 도로는 양방향으로 통행이&nbsp;가능하다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가장 거리가 먼 두 도시간의 거리를 나타내는 정수 하나를 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 1 6
1 4 5
6 3 9
2 6 8
6 1 7
','22
','TREE'),
                                                                                                                (10511,'BAEKJOON','https://www.acmicpc.net/problem/1623',1623,'신년 파티','2초','128 MB',15,'<p>주식회사 월드의 조직도는 루트가 있는 트리 형태의 구조를 가지고 있다. 즉, 사장님을 트리의 루트로 하며, 직원들은 자신의 직속상관 바로 밑에 매달려 있는 형태가 된다.</p>
<p>김진영 부사장은 2008년 설을 맞아 주식회사 월드의 신년 파티를 계획 중에 있다. 단, 만일 부하직원이 자신의 직속상관과 파티에 함께 오게 되면 분위기가 경직될 수 있으므로, 파티의 분위기를 위해 부하직원과 그 직속상관은 같이 초대될 수 없도록 하려고 한다.</p>
<p>예를 들어 최백준 과장이 오민식, 오영식 대리의 직속상관이라고 하자, 만일 최백준 과장을 파티에 초대하려 한다면 오민식, 오영식 두 대리는 파티에 초대할 수 없다. 마찬가지로 오민식, 오영식 대리 중 어느 한 명이라도 파티에 초대하려 한다면 최백준 과장 역시 파티에 초대될 수 없다.</p>
<p>각 직원들의 "날라리 기질"은 평소 인사과의 관찰을 통해 회사의 데이터베이스에 기록이 되어 있다고 한다. 신년 파티의 "날라리 분위기"란 파티 참가자들의 "날라리 기질"의 합으로 정해진다.</p>
<p>김진영 부사장은 위의 제한을 만족시키면서 이번 신년 파티의 "날라리 분위기"를 최대화하도록 참가자 목록을 작성하려고 한다. 단, 사장의 참석 여부가 아직 불투명한 상황이기 때문에 사장이 참석하는 경우와 그렇지 않은 경우 각각에 대해 모두 참가자 목록을 결정해 줄 프로그램을 작성해야 한다. 아무도 초대하지 않는 경우 "날라리 분위기"가 최대일 수도 있다는 점에 주의한다.</p>

					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 사장을 포함한 모든 직원의 수 N이 주어진다. (2≤N≤200,000) 사장은 1번이며, 다른 직원들은 2번부터 N번까지 차례로 번호가 매겨져 있다. 둘째 줄에는 사장을 포함한 모든 직원의 "날라리 기질"을 나타내는 N개의 정수가 빈 칸을 사이에 두고 1번 직원(사장)부터 N번 직원까지 순서대로 주어진다. 주어지는 정수는 절댓값이 10,000을 넘지 않는다. 셋째 줄에는 사장을 제외한 모든 직원의 직속 상관의 번호를 나타내는 N-1개의 정수가 빈 칸을 사이에 두고 2번 직원부터 N번 직원까지 순서대로 주어진다. 주어지는 수는 물론 N 이하의 자연수이며, 항상 루트가 있는 트리 형태의 구조를 갖도록 입력이 주어진다고 가정해도 좋다.</p>
					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에는 사장이 참석하는 경우와 그렇지 않은 경우의&nbsp; "날라리 분위기"의 최댓값을 빈 칸을 사이에 두고 순서대로 출력한다. 둘째 줄과 셋째 줄에는 각각 사장이 참석하는 경우와 그렇지 않은 경우의 참가자 번호를 빈 칸을 사이에 두고 증가하는 순서대로 출력한다. 각 줄의 끝에는 -1을 추가로 출력해서 끝을 표시하도록 한다.</p>
					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
-10 5 20 15 -5 10
1 1 2 2 1
','5 45
1 4 -1
3 4 6 -1
','TREE'),
                                                                                                                (10514,'BAEKJOON','https://www.acmicpc.net/problem/1634',1634,'완전 이진트리','5초','128 MB',14,'<p>‘k-레벨 완전 이진 트리’는 모든 노드의 분지수(차수)가 0이거나 혹은 2이고, 레벨 1에 있는 노드 수가 2^0, 레벨 2에 있는 노드수가 2^1, ... , 레벨 k에 있는 노드 수가 2^(k-1)이며, 총 노드 수는 2^k-1인 이진 트리를 말한다. 두 개의 k-레벨 완전 이진 트리 T1과 T2가 있고, 각 트리의 단말 노드들, 즉 레벨 k의 노드들에 대하여 L={1,2,...,N}에 속하는 서로 다른 정수들이 할당되어 있다. 다음 조건을 만족하는 L의 부분 집합 s를 찾는 프로그램을 작성하시오.</p>

<ul>
	<li>S에 속하는 모든 쌍의 정수 x, y에 대하여 T1과 T2에서 x가 할당된 노드와 y가 할당된 노드 사이의 거리가 서로 같다. 두 노드 사이의 거리는 두 노드를 잇는 경로가 지나는 에지의 수이다.</li>
	<li>S에 속한 원소의 수는 반드시 최대이어야 한다.</li>
</ul>

<p style="text-align: center;"><img alt="" src="/JudgeOnline/upload/201005/untitled.PNG" style="height: 153.333px; width: 391.667px;"></p>

<p>왼쪽 그림이 T1, 오른쪽 그림이 T2이다.</p>

<p>예를 들어, k = 4인 경우에 아래 그림과 같이 단말 노드에 정수가 할당된 두 트리 T1과 T2가 주어져 있다고 하자. 두 트리 T1과 T2의 단말 노드들에 할당된 수들을 왼쪽에서 오른쪽으로 차례대로 쓴 것이 각각 (4, 2, 1, 3, 6, 7, 5, 8)과 (2, 7, 4, 8, 3, 1, 6, 5)라고 하자. 이 경우에 구하고자 하는 답은 S = {1, 3, 7, 8}이다. 예를 들어, S에 속하는 한 쌍의 정수 3, 7에 대하여 T1과 T2에서 3이 할당된 노드와 7이 할당된 노드 사이의 거리가 6으로 서로 같다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫줄에 두 트리 T1과 T2의 레벨 k (1<=k<=12)가 주어진다. 둘째 줄에 T1의 단말 노드들에 할당된 수들이 왼쪽에서 오른쪽으로 차례로 주어진다. 셋째 줄에 T2의 단말 노드들에 할당된 수들이 왼쪽에서 오른쪽으로 차례로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 주어진 조건을 만족하는 최대 집합 에 속하는 원소의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
4 2 1 3 6 7 5 8
2 7 4 8 3 1 6 5
','4','TREE'),
                                                                                                                (10512,'BAEKJOON','https://www.acmicpc.net/problem/1646',1646,'피이보나치 트리','2초','128 MB',15,'<p>0번째와 1번째 피이보나치 트리는 단일 노드로 이루어져 있다. 1보다 큰 모든 i번째 피이보나치 트리는 다음과 같은 방법을 통해 만들 수 있다.</p>

<ol>
	<li>새로운 노드 r을 만든다. 이 노드는 i번째 피이보나치 트리의 루트가 된다.</li>
	<li>(i-1)번째와 (i-2)번째 피이보나치 트리를 만든다.</li>
	<li>(i-2)번째 피이보나치 트리를 노드 r의 왼쪽 부분 트리로 만든다.</li>
	<li>(i-1)번째 피이보나치 트리를 노드 r의 오른쪽 부분 트리로 만든다.</li>
</ol>

<p>피이보나치 트리의 정점의 개수는 정말 빠르게 증가한다. 예를 들어, 50번째 피이보나치 트리는 약 4×10<sup>10</sup>개의 정점을 가지고 있다.</p>

<p>피이보나치 트리의 정점에 번호를 매기는 순서는 트리를 전위순회할 때 방문하는 순서대로 번호를 매긴다.</p>

<p>예를 들어, 3번째 피이보나치 트리는 다음과 같다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/b1e27c79-a4fe-4bca-9b0c-7a9a100e4f7b/-/preview/"></p>

<p>N과 시작 위치와 도착 위치가 들어오면, N번째 피이보나치 트리에서 시작 위치에서 도착 위치로 가는 최단 경로를 구하는 프로그램을 작성하시오. 각 노드사이의 거리는 1이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 시작 위치와 도착 위치가 공백을 사이에 두고 주어진다. N은 50보다 작거나 같은 자연수 또는 0이다. 시작 위치와 도착 위치는 1,000,000,000보다 작거나 같으며, N번째 피이보나치 트리의 정점의 수보다 작거나 같은 자연수이다.&nbsp;시작 위치와 도착 위치는 서로 다른 수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 시작 위치부터 도착 위치로 가는 최단 경로를 찾는다. L은 왼쪽 자식으로 이동하는 것이고, R은 오른쪽 자식으로 이동하는 것이고, U는 부모로 이동하는 것이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 2 4
','URL
','TREE'),
                                                                                                                (10513,'BAEKJOON','https://www.acmicpc.net/problem/1693',1693,'트리 색칠하기','2초','256 MB',19,'<p>n개의 정점으로 이루어진 트리가 있다. 이 트리의 각 정점을 색칠하려고 한다. 색칠을 할 때에는 1, 2, 3, …, n번 색깔 중에 하나로 색칠하여야 한다. 각 색깔을 사용하여 한 개의 정점을 색칠할 때마다 1, 2, …, n의 비용이 든다. 즉, i번 색깔로 한 개의 정점을 색칠하면 i만큼의 비용이 든다는 것이다.</p>

<p>또한 정점에 색칠을 할 때에, 주어진 트리 상에서 인접해 있는 서로 다른 두 정점은 서로 다른 색깔로 칠해야 한다. 이를 만족하면서, 전체 정점을 색칠하는데 드는 총 비용을 최소화 하려 한다. 최소 비용을 계산하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 정점 및 색깔의 개수 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n-1개의 줄에는 각 줄에 두 개의 정수로 주어진 트리 상에서 연결되어 있는 두 정점의 번호가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소 비용을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
1 2
3 1
1 4
5 6
1 5
5 7
5 8
','11
','TREE'),
                                                                                                                (10515,'BAEKJOON','https://www.acmicpc.net/problem/1734',1734,'교통 체계','2초','512 MB',20,'<p>N개의 도시와, 서로 다른 두 도시를 잇는 E개의 도로로 이루어진 나라가 있다. 각 도시는 1번부터 N번까지 번호가 매겨져 있으며, 도로는 양방 통행 도로이다. 즉 i번 도시와 j번 도시 사이에 도로가 존재한다면 i번 도시에서 j번 도시로 이동할 수 있을 뿐더러 j번 도시에서 i번 도시로도 이동할 수 있다.</p>

<p>이 나라의 교통 체계는 매우 복잡해서, 이를 간소화하는 작업을 벌이려고 한다. 간소화를 위한 방법으로는 크게 두 가지가 있다. 두 도시를 연결하는 특정한 도로를 골라서 없애는 단순한 방법이 있고, 특정한 도시를 골라서 이 도시로 들어오거나 나가는 모든 도로를 없애는 방법이 있다.</p>

<p>이러한 교통 체계의 단순화는 면밀한 검토가 필요한 복잡한 작업이 된다. 따라서 몇 개의 질문을 만들어 놓고, 이 질문들에 대한 답을 구해낸 후 이를 토대로 단순화 작업을 벌이기로 하였다. 질문의 유형은 아래의 두 가지 중 하나를 따른다.</p>

<ol>
	<li>두 개의 도<span style="line-height:20.8px">시 A, B가 있고, 도시 G1과 도시 G2를 잇는 도로가 있다. 도시 G1과 도시 G2 사이의 도로를 없앤 후에도 도시 A에서 도시 B로 이동할 수 있는가?</span></li>
	<li><span style="line-height:1.6em">세 개의 도시 A, B, C가 있다. 도시 C로 들어오거나 나가는 모든 도로를 없앤 후에도 도시 A에서 도시 B로 이동할 수 있는가?</span></li>
</ol>

<p>이 나라의 현재 교통 체계에 대한 정보와 위의 유형에 해당되는 여러 개의 질문들이 주어졌을 때, 교통 체계의 단순화를 위해 주어진 질문들에 대한 답을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 도시의 개수 N과 도로의 개수 E가 주어진다. (2 ≤ N ≤ 100,000, 1 ≤ E ≤ 500,000) 이어서 E개의 줄에 걸쳐 각 줄에 N 이하의 서로 다른 두 자연수가 주어지는데, 이는 두 자연수를 번호로 하는 두 개의 도시 사이에 도로가 존재함을 의미한다. 같은 도로가 여러 번 입력으로 주어지지 않으며, 임의의 두 도시 사이에 항상 이동할 수 있는 경로가 하나 이상 존재하는 교통 체계만이 입력으로 주어진다.</p>

<p>다음 줄에는 질문의 개수 Q가 주어진다. (1 ≤ Q ≤ 300,000) 이어서 Q개의 줄에 걸쳐 질문에 대한 정보가 주어지는데, 각 줄의 첫 번째 자연수는 질문의 유형을 나타내는 1 또는 2이다. 질문이 유형 1에 해당하는 경우는 N 이하의 네 개의 자연수 A, B, G1, G2가 순서대로 주어진다. A와 B는 서로 다르며, G1과 G2 사이에 항상 도로가 존재하는 경우만이 입력으로 주어진다. 질문이 유형 2에 해당하는 경우는 N 이하의 서로 다른 자연수 A, B, C가 순서대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q개의 줄에 걸쳐 각 질문에 대한 답을 한 줄에 하나씩 yes나 no로 출력한다. 질문의 답이 "이동할 수 있다"이면 yes를, "이동할 수 없다"이면 no를 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','13 15
1 2
2 3
3 5
2 4
4 6
2 6
1 4
1 7
7 8
7 9
7 10
8 11
8 12
9 12
12 13
5
1 5 13 1 2
1 6 2 1 4
1 13 6 7 8
2 13 6 7
2 13 6 8
','yes
yes
yes
no
yes
','TREE'),
                                                                                                                (10516,'BAEKJOON','https://www.acmicpc.net/problem/1761',1761,'정점들의 거리','2초','128 MB',16,'<p>N(2 ≤ N ≤ 40,000)개의 정점으로 이루어진 트리가 주어지고 M(1 ≤ M ≤ 10,000)개의 두 노드 쌍을 입력받을 때 두 노드 사이의 거리를 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 노드의 개수 N이 입력되고 다음 N-1개의 줄에 트리 상에 연결된 두 점과 거리를 입력받는다. 그 다음 줄에 M이 주어지고, 다음 M개의 줄에 거리를 알고 싶은 노드 쌍이 한 줄에 한 쌍씩 입력된다. 두 점 사이의 거리는 10,000보다 작거나 같은 자연수이다.</p>

<p>정점은 1번부터 N번까지 번호가 매겨져 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>M개의 줄에 차례대로 입력받은 두 노드 사이의 거리를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1 6 13
6 3 9
3 5 7
4 1 3
2 4 20
4 7 2
3
1 6
1 4
2 6
','13
3
36
','TREE'),
                                                                                                                (10517,'BAEKJOON','https://www.acmicpc.net/problem/1772',1772,'정원 정리','2초','128 MB',19,'<p>정원을 정리하던 배상욱은 흉측할 정도로 난잡하게 자란 정원수 한 그루를 발견했다. 가지치기를 할 시기가 된 것이다.</p>
<p>정원수는 n개의 정점과 n-1개의 간선으로 구성된, 연결 그래프로 표현된다. 그래프 내의 정점은 정원수의 잎사귀라고 할 수 있으며, 각 간선은 정원수의 가지들이라고 생각하자.</p>
<p>상욱은 가지치기를 통해 정원수 내의 잎사귀 개수가 m이 되도록 만드는 것이다. 즉, 정원수를 나타내는 그래프 내에 m개의 정점만 남겨야 한다. 가지치기란, 정원수 그래프 내의 간선을 끊는 일이다. 특정한 간선을 끊어, 그래프가 두 부분으로 분리되면, 한 부분을 취하고 다른 부분은 버린다.</p>
<p>상욱은 그리 부지런한 사람이 아닌 관계로, 최소한의 가지치기를 이용해서 정원수를 정리하기를 바란다. 정원수의 모양이 주어지면, 어떻게 가지치기를 해야 최소한의 가위질로 작업을 마무리할 수 있을지 알아내는 프로그램을 작성하시오.</p>

					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n과 m이 주어진다. (1<=n<=150, 1<=m<=n) 이후 한 줄에 한 개씩, 정원수의 가지를 나타내는 정보가 주어진다. 이는 정원수 내의 잎사귀 번호 두 개로 이루어져 있으며, 두 잎사귀 사이를 연결하는 가지가 있다는 의미이다. 잎사귀 번호는 1이상 n이하의 정수이다.</p>
					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에, 최소한의 가지치기 횟수를 출력한다. 불가능한 경우에는 -1을 출력한다.</p>
					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예시의 경우, 1-4, 1-5 두 개의 간선을 제거하면 원하는 크기의 정원수를 얻을 수 있다.</p>
				</div>
				</div>','11 6
1 2
1 3
1 4
1 5
2 6
2 7
2 8
4 9
4 10
4 11
','2','TREE'),
                                                                                                                (10522,'BAEKJOON','https://www.acmicpc.net/problem/1805',1805,'나무수송','2초','128 MB',22,'<p>양항승 왕국은 거의 모든 지역이 강과 숲으로 이루어져 있다. 상류의 작은 강들은 모여서 큰 강이 되며, 그 강도 다른 강과 만나 더 커져 나중에는 하류로 가면 거대한 강 하나만이 남아 양항승 왕국 근처의 바다로 흘러간다.</p>

<p>양항승 왕국에는 나무꾼들이 사는 n개의 마을이 강변에 있다. 그런데 현재는 목공소가 강의 최하류인 양항승 왕국에 하나만 있기 때문에, 제각기 사는 곳에서 나무를 벤 나무꾼들은 통나무를 강에다 띄워서 그 목공소로 보낸다. 그래서 항승이는 &nbsp;통나무를 하류로 흘려보내는 물류비용을 줄이기 위해, 마을들 중 적당한 곳에 k개의 목공소를 더 짓기로 했다. 목공소가 더 생기면, 상류에서 흘러보낸 통나무들은 왕국까지 갈 필요 없이 처음으로 거치는 목공소에서 바로 처리를 할 수 있으며, 목공소가 있는 마을에서 생산된 통나무는 강을 거칠 필요조차 없어진다.</p>

<p>목공소를 세울 곳을 결정하기 위해, 왕의 신하들은 각 마을별로 연간 생산되는 통나무의 양을 조사해 두었다. 강물은 하류로 갈수록 합쳐지기만 하지 갈라지지는 않기 때문에, 각 마을에서 왕국까지 가는 경로는 오직 하나만 존재한다. 마을별로 강을 이용해 이웃 마을이나 현재의 최종 목적지인 왕국까지 가는 거리에 대한 자료 역시 있다. 이것을 토대로, 전국의 나무의 물류비용을 최소화하려면 어디에 목공소를 건설하면 좋을지 결정하는 프로그램을 작성하시오. 통나무 하나를 강으로 1km 거리만치 운반하는데 드는 비용은 1로 한다. 예를 들어 통나무 2개를 5km 운반하는데 드는 비용을 계산하면 2*5=10 이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 왕국을 제외한 마을의 수 n과 추가로 지으려고 하는 목공소의 수 k가 있다. (2≤n≤100, 1≤k≤50이고 k≤n) 마을들은 1부터 n까지 번호가 부여되어 있으며, 왕국의 번호는 0이다. 그 다음 각 n개의 각 줄마다 다음의 3개의 정수가 주어진다.</p>

<ul>
	<li>w<sub>i</sub>─마을 i에서 생산하는 나무의 개수</li>
	<li>v<sub>i</sub>─마을 i에서 하류쪽으로 가면 나오는 첫 번째 마을(혹은 왕국 본토)</li>
	<li>d<sub>i</sub>─마을 i에서 마을 v<sub>i</sub>까지의 거리</li>
</ul>

<p>총 운반비는 2000000000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>목공소를 최적의 위치에다 지었을 때, 마을 전역에서 생산되는 통나무를 "적당한 목공소가 있는 곳"까지 강으로 운반하는데 드는 총 비용의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p><img alt="" src="/JudgeOnline/upload/201006/temp1.png" style="height:177px; width:275px"></p>

<p>위의 그림에서 선분은 강을 뜻하고, 원으로 된 정점은 마을을 뜻한다. 선분 위의 숫자는 해당 구간의 거리이며, 원 안의 숫자는 마을 번호, 그리고 원 아래의 숫자는 그 마을에서 매년 생산되는 통나무의 수이다.</p>

<p>이 예제에서 목공소를 지어야 하는 최적의 위치 두 곳은 2번과 3번 마을이다. 이 경우 4번 마을의 통나무를 2번 마을로 보내는 비용 1×3과, 1번 마을의 통나무를 양항승 왕국으로 보내는 비용 1×1만이 필요하다.</p>

				</div>
				</div>','4 2
1 0 1
1 1 10
10 2 5
1 2 3
','4
','TREE'),
                                                                                                                (10521,'BAEKJOON','https://www.acmicpc.net/problem/1808',1808,'숌작업','2초','128 MB',13,'<p>루트가 있는 트리에서, 어떤 정점 V의 레벨이 L이라는 것은, 루트와 정점 V사이의 거리가 L이라는 것을 의미한다. 정점 U가 정점 V의 부모라는 것은 정점 U와 정점 V가 서로 연결되어 있고, U의 레벨이 L-1, V의 레벨이 L인 것을 의미한다.</p>

<p>다솜이는 루트가 있는 트리를 다음과 같은 작업을 몇 번을 수행하려고 한다.</p>

<p>다솜이는 다음과 같은 작업을 숌작업이라고 이름붙였다.</p>

<p>숌작업은 다음과 같다.</p>

<ol>
	<li>루트가 아닌 정점 V를 선택한다.</li>
	<li>V의 조상중 하나인 정점 U를 선택한다.</li>
	<li>V와 V의 부모를 이은 간선을 제거한다.</li>
	<li>U에서 V로 간선을 이은다. U는 V의 부모가 된다.</li>
</ol>

<p>숌작업은 독특해서 한번의 작업에 가격이 있다.</p>

<p>가격은 두 정점의 레벨 차이 - 1이다.</p>

<p>예를 들어, V의 레벨이 L1이고, U의 레벨이 L2이면, 숌작업의 가격은 L1-L2-1이다.</p>

<p>어떤 트리의 높이가 K라는 것은, K가 레벨인 정점이 몇 개 있고, K+1인 정점이 없다는 것을 의미한다. 어떤 트리와 숌작업을 이용해서 줄이려고 하는 높이 H가 주어졌을 때, 그 트리를 H보다 작거나 같은 높이로 숌작업을 통해서 줄이는 최소 가격을 출력하는 프로그램을 작성하시오. 숌작업은 여러 번 수행해도 된다.</p>

<p>&nbsp; 예를 들어, 다음과 같은 트리가 주어졌다. 이 트리의 높이를 1보다 작거나 같게 만들려고 한다.</p>

<p><img alt="" src="/JudgeOnline/upload/201006/tree1.png" style="height:133px; width:131px"></p>

<p>이 트리의 정점 2를 0의 자식으로 연결 하면, 총 비용은 2-0-1 = 1이 되고, 트리의 높이는 1이된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄부터 총 N-1개의 줄에 트리의 간선이 주어진다. 트리의 간선에 대한 정보는 a b 와 같이 주어지며, a는 b의 부모라는 뜻이다. 트리에 주어지는 정점은 0부터 N-1이고, 트리의 루트는 항상 0이다. 그리고, 마지막줄에 줄이려고 하는 높이 H가 주어진다. H는 1부터 N-1사이의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 트리의 높이를 H보다 작거나 같은 값으로 숌작업을 통하여 줄일 때 드는 비용의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
0 1
1 2
2 3
2 4
2
','1
','TREE'),
                                                                                                                (10518,'BAEKJOON','https://www.acmicpc.net/problem/1814',1814,'지붕 색칠하기','2초','128 MB',19,'<p>N개의 집들로 이루어진 작은 마을이 있다. 이 마을의 몇몇 집들 사이에는 길이 나 있는데, 이 길들을 잘 이용하면 임의의 집에서 출발하여 어느 집으로든 이동할 수 있다. 그러나 출발했던 집으로 되돌아오려 할 때, 이미 방문했던 집들 중 일부를 다시 방문하지 않고서는 방법이 없다.</p>

<p>이 마을을 새로 단장하면서 각 집들의 지붕을 색칠하기로 했는데, 서로를 연결하는 길을 사이에 두고 있는 두 개의 집은 다른 색깔의 지붕을 갖도록 하려 한다.</p>

<p>집들 사이에 나 있는 길들의 정보와, 색깔별로 페인트들의 가격이 주어졌을 때, 조건을 만족하면서 집들의 지붕을 색칠하기 위한 최소 비용을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에, 마을 내의 집들의 수 N이 주어진다. 이후 N-1개의 줄에, 집들을 잇는 길의 정보가 하나씩 주어진다. 각 줄은 1이상 N이하 범위에 있는, 서로 다른 두 자연수 A, B로 구성되는데, A번 집과 B번 집 사이에 길이 나 있다는 의미이다.</p>

<p>N+1번째 줄에는, 페인트 종류의 수 M이 주어진다.&nbsp;N+2번째 줄에 주어지는 M개의 자연수는, 각 페인트별로 한 집의 지붕을 칠하기 위한 비용이다. 이들은 모두 10,000 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에, 지붕의 색칠을 위한 최소 비용을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
4 2
3 1
1 4
5 6
1 5
5 7
5 8
5
2 8 7 1 4
','11
','TREE'),
                                                                                                                (10519,'BAEKJOON','https://www.acmicpc.net/problem/1836',1836,'트리의 가짓수 세기','2초','128 MB',17,'<p>다음과 같은 성질을 만족하는 서로 다른 이진트리의 가짓수를 세는 프로그램을 작성하라.</p>

<ol>
	<li>n개의 노드를 갖는다. (1&nbsp;≤ n＜200)</li>
	<li>각 노드의 차수는 0 혹은 2이다. 차수란, 각 노드의 자식노드 개수이다.</li>
	<li>높이는 k이다. (1＜k＜100) 높이란, 루트에서 단말노드에 이르는 임의의 가장 긴 경로 위에 존재하는 노드의 개수이다. 단말노드란 자식노드가 없는 노드이다.</li>
</ol>

<p>이때, 구하려는 가짓수가 몹시 큰 수일 수 있으므로 9901로 나눈 나머지만을 출력하도록 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n과 k가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>조건에 부합하는 서로 다른 이진트리의 가짓수를 9901로 나누어, 그 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
','2
','TREE'),
                                                                                                                (10520,'BAEKJOON','https://www.acmicpc.net/problem/1839',1839,'트리 모델 만들기','2초','128 MB',22,'<p>월드 장난감 회사는 노끈들을 이용해서 트리의 모형을 만들고자 한다. 이를 돕기 위한 프로그램을 작성하라.</p><p>트리 (tree)는 그래프 (graph)의 일종으로, 연결되어 있으며, 내부에 싸이클이 존재하지 않는 그래프이다. 그래프에서 버텍스 (vertex), 에지 (edge)라고 부르는 것을, 트리에 한해서는 각각 노드 (node)와 링크 (link)라고 부른다.</p><p>트리의 노드들은 노끈 위에 매인 매듭으로 표현되고, 각 매듭 사이를 연결하는 노끈이 트리의 링크들을 표현한다. 노드를 표현하는 매듭들은 그냥 한 개의 노끈 중간이나 끝부분을 묶은 것일 수도 있고, 여러 개의 노끈들이 한 점에서 뭉쳐 묶여 있는 부분일 수도 있다.</p><p>기술적인 문제 때문에, 생산 단가는 모델을 만드는 데 사용되는 노끈의 개수와, 사용된 노끈들 중 가장 긴 노끈의 길이에 의존한다. (각각의 링크들은 길이가 모두 1이다. 매듭을 만드는 데 소요되는 노끈의 길이는 무시한다.)</p><p>여러분이 할 일은 첫째, 트리의 구조가 주어지면 이를 만들기 위한 최소의 노끈 개수를 구하는 것이다. 둘째로는, 이와 같이 최소 개수의 노끈들을 이용하여 트리를 만들 때 사용되는 가장 긴 노끈 길이의 최솟값을 구하는 것이다.
				</p>
					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 노드의 개수를 나타내는 양의 정수 n이 주어진다. (2≤n≤10,000) 둘째 줄부터는 n-1개의 링크를 나타내는 두 개씩의 양의 정수가 주어진다. 각각은 링크가 연결 짓는 두 노드의 번호를 나타낸다. 노드의 번호는 1번부터 n번까지 빠짐없이 연속하여 붙어 있다.
					</p></div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 필요한 최소한의 노끈 개수와, 가장 긴 노끈 길이의 최솟값을 출력한다.
					</p></div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p><img width="356" height="229" src="/JudgeOnline/upload/201006/Screen shot 2010-06-11 at 4_52_18 PM.png" alt=""></p>
				</div>
				</div>','9
7 8
4 5
5 6
1 2
3 2
9 8
2 5
5 8','4 2
','TREE'),
                                                                                                                (10523,'BAEKJOON','https://www.acmicpc.net/problem/1868',1868,'보물찾기','2초','128 MB',26,'<p>n개의 방으로 이루어진 미로가 있다. 이 미로 내의 임의의 두 방 사이에는 반드시 하나의 경로가 존재하고, 그 경로는 유일하다.</p>

<p>이 방들 중 한 방에는 김주성 조교가 보물을 숨겨 놓았는데, 김진영 조교는 이 보물을 찾길 원한다. 그러기 위해서, 김진영 조교는 김주성 조교에게 특정한 방에 보물이 있는지 물어 본다. 친절한 김주성 조교는 김진영 조교가 옳은 방을 골랐으면 그렇다고 말해 주고, 옳은 방을 고르지 않았다면 그 방에 연결된 복도 중 어느 복도를 따라 가야만 보물을 찾을 수 있는지 말해 준다.</p>

<p>여러분이 할 일은 미로의 구조가 주어졌을 때 김진영 조교가 최악의 경우에 몇 번의 질문을 던져야 하는지 계산해 내는 것이다. 물론, 영리한 김진영 조교는 항상 최선의 질문을 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 50,000) 이후 n-1개의 줄에는 각각 두 개의 숫자가 주어진다. a와 b가 주어졌다면, a번 방과 b번 방 사이에 복도가 있어 왕래할 수 있다는 의미이다. 방의 번호는 1번부터 n번까지 연속해서 붙어 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 김진영 조교가 최선을 다하더라도, 최악의 경우 몇 번의 질문을 던져야 하는지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p><img alt="" height="118" src="/JudgeOnline/upload/201007/ff.PNG" width="211"></p>

<p>처음에 1번 방에 보물이 있는지 질문하면, 어떤 경우에도 두 번의 질문만으로 보물의 위치를 확정지을 수 있다. 처음에 2이나 3번 방에 보물이 있는지 질문해도 좋다. 그러나 처음에 4번이나 5번 방에 보물이 있는지 질문하는 것은 최악의 경우 세 번의 질문이 필요하도록 만든다.</p>

				</div>
				</div>','5
1 2
2 3
4 3
5 3
','2
','TREE'),
                                                                                                                (10530,'BAEKJOON','https://www.acmicpc.net/problem/1878',1878,'천칭 저울','1초','512 MB',15,'<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/53969aa7-dbe9-4fa8-8a8e-4ae69bbac348/-/preview/" style="width: 100px; height: 101px;"></p>

<p>그림과 같이 생긴 추가 있다. 각 추는 그에 붙여진 번호와 같은 무게를 갖고 있으며, 1번부터 n번까지 번호가 붙은 추가 각각 한 개씩의 있다고 하자. 다음과 같은 규칙을 만족시키면서, 천칭저울에 추를 매달려고 한다.</p>

<ol>
	<li>임의의 추의 왼쪽에는 그 추보다 가벼운 추만 달 수 있고, 오른쪽에는 그 추보다 무거운 추만 달 수 있다.</li>
	<li>천칭저울의 좌우에 달린 추의 모양은 기둥을 중심으로 대칭을 이루어야 한다. 추가 홀수개 주어지는 경우에는, 그 중 하나의 추를 쓰지 않는다.</li>
	<li>깊이 d에 추를 매다는 조건은 깊이 d-1에 추들이 모두 차있을 경우뿐이다. 즉, 추의 깊이가 최소가 되도록 추를 배치한다.</li>
	<li>동일한 깊이에 추를 매달 경우, 큰 저울을 중심으로 왼쪽 모양에서는 해당 깊이의 왼쪽부터 추를 매달고 큰 저울을 중심으로 오른쪽 모양에서는 해당 깊이의 오른쪽부터 추를 매단다.</li>
	<li>추를 모두 매단 후에는, 천칭저울이 평형을 이루어야 한다. (천칭저울은 양쪽에 매달린 추들의 무게 합이 서로 같을 경우에 평형을 이룬다고 하자.)</li>
</ol>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 n이 주어진다. (2 ≤ N ≤ 100,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 천칭저울 왼쪽의 추들을 출력하고, 둘째 줄에 천칭저울 오른쪽의 추들을 출력한다. 양쪽 추들이 이루는 모양을 루트가 있는 트리로 생각하고, 각 트리를 프리오더 (pre-order)로 운행한 결과를 출력하면 된다. 불가능한 경우에는 첫째 줄에 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/4fbbfa1c-0440-44e7-9784-635d91ed1d1c/-/preview/" style="width: 500px; height: 271px;"></p>

				</div>
				</div>','9
','8 2 1 9
4 3 6 7
','TREE'),
                                                                                                                (10525,'BAEKJOON','https://www.acmicpc.net/problem/1921',1921,'트리와 쿼리 20','5초','512 MB',29,'<p>$N$개의 정점으로 이루어진 포레스트가 있다. 정점은 $1$부터 $N$까지 번호가 매겨져 있으며, 간선은 없다. 모든 정점 $v$는&nbsp;정수 $X_v$를 가지고 있고, 초기값은 $X_v = 1$이다.</p>

<p>아래의 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li>1 $a$ $b$ $c$: 정점 $a$와 $b$를 가중치가 $c$인 간선으로 연결한다. 쿼리의 수행 결과가 포레스트인 경우만 입력으로 주어진다.</li>
	<li>2 $a$ $b$: 정점 $a$와 $b$를 연결하는 간선을 제거한다. 두 정점 사이에 간선이 있는 경우만 입력으로 주어진다.</li>
	<li>3 $a$: $X_a$를 $1-X_a$로 변경한다. 그 다음 $a$가 포함된 트리에서 다음을 구한다.
	<ul>
		<li>트리의 정점을 $v_1, v_2, \dots, v_k$라고 하자. 이때&nbsp;$\min_{1 \le i \le k}{\left\{ \sum_{1 \le j \le k}{dist(v_i, v_j) \times X_{v_j}} \right\}}$를 구해 출력한다. $dist(v_i, v_j)$는 $v_i$에서&nbsp;$v_j$로 가는 경로에 있는 모든 간선의 가중치를 더한 값이다.</li>
	</ul>
	</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 $N$, 쿼리의 개수 $Q$가 주어진다. 둘째 줄부터 Q개의 줄에 쿼리가 한 줄에 하나씩 주어진다.</p>

<p>입력으로 주어지는 쿼리의 정점 번호(1, 2번 쿼리의 $a$, $b$, 3번 쿼리의 $a$)는 암호화 되어 있어 쿼리를 수행하기 전에 해독해야 한다. 입력으로 주어진 정점 번호가 $x$이고, 이전 3번 쿼리에서 구한 값이 $S$인 경우 해독한 정점의 번호는 $(x-1+S) \bmod {n} + 1$ 이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리에서 구한 값을 한 줄에 하나씩 쿼리가 주어진 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 7
1 1 2 3
1 3 1 1
3 1
2 1 3
3 1
1 2 1 2
3 2
','4
0
0
','TREE'),
                                                                                                                (10526,'BAEKJOON','https://www.acmicpc.net/problem/1949',1949,'우수 마을','2초','128 MB',14,'<p>N개의 마을로 이루어진 나라가 있다. 편의상 마을에는 1부터 N까지 번호가 붙어 있다고 하자. 이 나라는 트리(Tree) 구조로 이루어져 있다. 즉 마을과 마을 사이를 직접 잇는 N-1개의 길이 있으며, 각 길은 방향성이 없어서 A번 마을에서 B번 마을로 갈 수 있다면 B번 마을에서 A번 마을로 갈 수 있다. 또, 모든 마을은 연결되어 있다. 두 마을 사이에 직접 잇는 길이 있을 때, 두 마을이 인접해 있다고 한다.</p>

<p>이 나라의 주민들에게 성취감을 높여 주기 위해, 다음 세 가지 조건을 만족하면서 N개의 마을 중 몇 개의 마을을 우수 마을로 선정하려고 한다.</p>

<ol>
	<li>우수 마을로 선정된 마을 주민 수의 총 합을 최대로 해야 한다.</li>
	<li>마을 사이의 충돌을 방지하기 위해서, 만일 두 마을이 인접해 있으면 두 마을을 모두 우수 마을로 선정할 수는 없다. 즉 우수 마을끼리는 서로 인접해 있을 수 없다.</li>
	<li>선정되지 못한 마을에 경각심을 불러일으키기 위해서, 우수 마을로 선정되지 못한 마을은 적어도 하나의 우수 마을과는 인접해 있어야 한다.</li>
</ol>

<p>각 마을 주민 수와 마을 사이의 길에 대한 정보가 주어졌을 때, 주어진 조건을 만족하도록 우수 마을을 선정하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수 N이 주어진다. (1 ≤ N ≤ 10,000) 둘째 줄에는 마을 주민 수를 나타내는 N개의 자연수가 빈칸을 사이에 두고 주어진다. 1번 마을부터 N번 마을까지 순서대로 주어지며, 주민 수는 10,000 이하이다. 셋째 줄부터 N-1개 줄에 걸쳐서 인접한 두 마을의 번호가 빈칸을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 우수 마을의 주민 수의 총 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1000 3000 4000 1000 2000 2000 7000
1 2
2 3
4 3
4 5
6 2
6 7
','14000
','TREE'),
                                                                                                                (10535,'BAEKJOON','https://www.acmicpc.net/problem/1967',1967,'트리의 지름','2초','128 MB',12,'<p>트리(tree)는 사이클이 없는 무방향 그래프이다. 트리에서는 어떤 두 노드를 선택해도 둘 사이에 경로가 항상 하나만 존재하게 된다. 트리에서 어떤 두 노드를 선택해서 양쪽으로 쫙 당길 때, 가장 길게 늘어나는 경우가 있을 것이다. 이럴 때 트리의 모든 노드들은 이 두 노드를 지름의 끝 점으로 하는 원 안에 들어가게 된다.</p>

<p><img alt="" height="123" src="/JudgeOnline/upload/201007/ttrrtrtr.png" width="310"></p>

<p>이런 두 노드 사이의 경로의 길이를 트리의 지름이라고 한다. 정확히 정의하자면 트리에 존재하는 모든 경로들 중에서 가장 긴 것의 길이를 말한다.</p>

<p>입력으로 루트가 있는 트리를 가중치가 있는 간선들로 줄 때, 트리의 지름을 구해서 출력하는 프로그램을 작성하시오. 아래와 같은 트리가 주어진다면 트리의 지름은 45가 된다.</p>

<p><img alt="" height="152" src="/JudgeOnline/upload/201007/tttttt.png" width="312"></p>

<p>트리의 노드는 1부터 n까지 번호가 매겨져 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>파일의 첫 번째 줄은 노드의 개수 n(1 ≤ n ≤ 10,000)이다. 둘째 줄부터 n-1개의 줄에 각 간선에 대한 정보가 들어온다. 간선에 대한 정보는 세 개의 정수로 이루어져 있다. 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호를 나타내고, 두 번째 정수는 자식 노드를, 세 번째 정수는 간선의 가중치를 나타낸다. 간선에 대한 정보는 부모 노드의 번호가 작은 것이 먼저 입력되고, 부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. 루트 노드의 번호는 항상 1이라고 가정하며, 간선의 가중치는 100보다 크지 않은 양의 정수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 트리의 지름을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12
1 2 3
1 3 2
2 4 5
3 5 11
3 6 9
4 7 1
4 8 7
5 9 15
5 10 4
6 11 6
6 12 10
','45
','TREE'),
                                                                                                                (10534,'BAEKJOON','https://www.acmicpc.net/problem/1991',1991,'트리 순회','2초','128 MB',10,'<p>이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오.</p>

<p style="text-align: center;"><img alt="" src="/JudgeOnline/upload/201007/trtr.png" style="height:220px; width:265px"></p>

<p>예를 들어 위와 같은 이진 트리가 입력되면,</p>

<ul>
	<li>전위 순회한 결과 : ABDCEFG // (루트) (왼쪽 자식) (오른쪽 자식)</li>
	<li>중위 순회한 결과 : DBAECFG // (왼쪽 자식) (루트) (오른쪽 자식)</li>
	<li>후위 순회한 결과 : DBEGFCA // (왼쪽 자식) (오른쪽 자식) (루트)</li>
</ul>

<p>가 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 이진 트리의 노드의 개수 N(1 ≤ N ≤ 26)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 노드와 그의 왼쪽 자식 노드, 오른쪽 자식 노드가 주어진다. 노드의 이름은 A부터 차례대로 알파벳 대문자로 매겨지며, 항상 A가 루트 노드가 된다. 자식 노드가 없는 경우에는 .으로 표현한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 전위 순회, 둘째 줄에 중위 순회, 셋째 줄에 후위 순회한 결과를 출력한다. 각 줄에 N개의 알파벳을 공백 없이 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
A B C
B D .
C E F
E . .
F . G
D . .
G . .
','ABDCEFG
DBAECFG
DBEGFCA
','TREE'),
                                                                                                                (10528,'BAEKJOON','https://www.acmicpc.net/problem/2047',2047,'미로','2초','128 MB',17,'<p>유명한 영웅 백준은 퀘스트를 받아 혼자 모험을 하는 중에&nbsp;미로를 발견하였다. 미로 주변으로 길이 없으므로&nbsp;백준은 반드시 미로를 통과해야&nbsp;한다.</p>

<p>백준은 이 미로를 잘 모르기&nbsp;때문에 길이 나누어지면&nbsp;그 중 무작위로 길을 택해 그쪽으로 이동할 것이다. 또한 백준은 완벽한 기억력을 가졌기 때문에 같은 길을 두&nbsp;번 들어서는 일은 없고 더 이상&nbsp;길이 없을 거라고 확신했을 때만 왔던 길을 돌아갈 것이다.&nbsp;즉, 왔던 길을&nbsp;돌아가기 전까지 안 가본&nbsp;길은 다 둘러볼&nbsp;것이다.</p>

<p>백준의 동료인 당신은 백준이 떠나고&nbsp;뒤늦게 미로의 정보를 가지고 있는 지도를 발견하고는&nbsp;백준이 미로를 탈출하는데 얼마나 걸릴지&nbsp;궁금해서 걸음의 기댓값을 구하고자&nbsp;한다.&nbsp;당신은 미로를 잘 살펴본 결과 미로는 같은 지점으로 돌아오는 사이클이 없고 2×2 이상의 공간이 없다는 것을 알았다. 미로에는&nbsp;입구와 출구가 각각 하나만 있고 길&nbsp;옆에 출구가 있더라도 길이 나누어져&nbsp;있다고&nbsp;가정한다.</p>

<p>아래의&nbsp;간단한 지도의 예를 보자.</p>

<pre>##s###
#....#
#t####</pre>

<p>입구는&nbsp;"s"로 표시되어 있고 출구는&nbsp;"t"로 표시되어 있다.&nbsp;</p>

<p>입구에서&nbsp;남쪽으로 1칸 이동했을 때 길이 갈라지는데&nbsp;여기서 서쪽을 선택하고 2칸 이동하면 출구를 찾을 수 있다. 반면&nbsp;동쪽을 선택했을 시 4칸 이동하여&nbsp;다시&nbsp;돌아오고 남은길이 서쪽밖에 없으므로&nbsp;서쪽으로&nbsp;2칸 이동하면 출구를 찾을 수 있다.</p>

<p>따라서 백준이 입구에서&nbsp;출구까지 나가는데 걸음의 기댓값은 <span style="line-height:1.6em">\(&nbsp;1 + \frac{1}{2} \cdot&nbsp;(4 + 2) + \frac{1}{2}&nbsp;\cdot&nbsp;2&nbsp;= 5 \)&nbsp;이다.</span></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<ul>
	<li>첫째 줄에는 테스트 케이스의 개수 n (0 < n ≤ 100) 이 주어진다.</li>
	<li>각 테스트 케이스에 대해서
	<ul>
		<li>첫째&nbsp;줄에는 미로의 크기를 나타내는 두 정수 3 ≤&nbsp;h, w ≤&nbsp;96&nbsp;가 주어진다.&nbsp;</li>
		<li>다음&nbsp;줄부터 h번에 걸쳐 문자가 w개 주어진다.
		<ul>
			<li>#은&nbsp;벽이다.</li>
			<li>s와 t는 각각 입구와 출구다.</li>
			<li>.은 길이다.</li>
		</ul>
		</li>
		<li>미로의 경계는 입구와 출구를 제외하고 전부 벽이다.</li>
		<li>입구와 출구는 항상 미로의 경계에 있다.</li>
	</ul>
	</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>i번째 테스트 케이스에 대해 i번째 줄에 걸음의 기댓값을 반올림하여 둘째&nbsp;자리까지 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
3 6
##s###
#....#
#t####
','5.00
','TREE'),
                                                                                                                (10531,'BAEKJOON','https://www.acmicpc.net/problem/2058',2058,'원자의 에너지','2초','128 MB',13,'<p>잘 알려져 있듯, 각각의 원자들은 어떤 특정한 에너지 상태(혹은 에너지 준위)에 놓일 수 있다. 각각의 상태는 그 상태에서 그 원자가 갖는 에너지로 나타낼 수 있다. 어떤 원자가 높은 에너지 상태에서 낮은 에너지 상태로 변할 때, 두 상태의 에너지 차이만큼의 에너지를 갖는 양성자가 방출된다. 역으로, 낮은 에너지 상태에서 높은 에너지 상태로 변하기 위해서는, 두 상태의 에너지 차이만큼의 에너지를 갖는 양성자가 필요하다.</p>

<p>과학자들은 오랜 연구를 통해서 원자의 각 에너지 상태에서의 에너지를 알아낼 수 있었다. 또한, 하나의 양성자가 가질 수 있는 에너지의 종류들도 모두 알아낼 수 있었다. 또한 이 문제에서 다루게 될 원자의 경우에는, 에너지 상태가 변할 때 오직 한 개의 양성자만이 출입할 수 있음을 알게 되었다. 또한 원자가 어떤 특정 에너지 상태(A)에서 다른 에너지 상태(B)로 변할 수 있는 방법은 한 가지 뿐이고, 이 방법을 역으로 적용(양성자를 받아들인 경우는 양성자를 내쏘고, 양성자를 내쏘는 경우는 양성자를 받아들임)하면 B에서 A로도 상태가 변할 수 있음을 알게 되었다. 물론, A → B → C → B → C → D 와 같은 경우처럼 같은 상태를 반복하는 경우는 고려하지 않는다.</p>

<p>예를 들어 세 개의 에너지 상태를 갖는 원자가, 각 상태에서 2, 4, 6만큼의 에너지를 갖는다고 하자. 또한 실험을 통해서, 양성자가 가질 수 있는 에너지가 2, 3임을 알게 되었다고 하자. 이 경우 원자는 양성자를 받아들이며 2 → 4 → 6의 상태로 변할 수 있고, 반대로 양성자를 내쏘며 6 → 4 → 2의 상태로 변할 수도 있다.</p>

<p>과학자들은 이러한 원자를 가지고 실험을 시작했다. 우선 실험을 위해서 몇 개(제한 없음)의 원자와 몇 개(제한 없음)의 양성자를 준비하고, 이 양성자들을 이용하여 각 원자의 에너지 상태를 조절한다. 에너지 상태가 다 조절된 후에는 이 원자들을 컨테이너 안에 집어넣고 관찰을 하게 된다. 이때, 컨테이너 안에 들어간 원자들이 서로 같은 에너지 상태에 있거나, 어떤 한 개의 원자가 한 개의 양성자를 받아들이거나 내쏘아서 다른 원자와 같은 에너지 상태에 도달할 수 있다면, 이 경우는 실험에서 위험이 발생할 수 있다. 따라서 이러한 경우는 허용되지 않는데, 그러면서도 컨테이너 안의 원자들의 에너지들의 총 합이 최대가 되도록 하려 한다.</p>

<p>원자의 각 에너지 상태에서의 에너지와 양성자가 가질 수 있는 에너지가 주어졌을 때, 컨테이너 안의 원자들의 에너지들의 총 합의 최대를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 정수 N(1 ≤ N ≤ 200), M(1 ≤ M ≤ 200)이 주어진다. 다음 N개의 줄에는 원자의 각 에너지 상태에서의 에너지가 주어진다. 물론 두 상태에서의 에너지가 같은 경우는 없다. 다음 M개의 줄에는 양성자가 가질 수 있는 에너지가 주어진다. 각 에너지는 1,000,000이하의 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 2
2
4
6
2
3
','8
','TREE'),
                                                                                                                (10533,'BAEKJOON','https://www.acmicpc.net/problem/2132',2132,'나무 위의 벌레','2초','128 MB',13,'<p>전산학(Computer science)에서 트리란 사이클이 없는 그래프를 말한다. 트리(Tree)라는 이름이 의미하듯, 이러한 구조는 나무의 모습에서 유래한다. 즉, 트리의 각 간선(edge)들이 나무의 가지를 나타내고, 각 정점(node)들은 가지가 갈라지는 지점을 의미한다. 또한 트리의 루트는 나무의 뿌리를 의미한다. 이러한 구조는 일반적인 나무의 구조에 해당하지만, 트리 자체의 성질에 주목하면 실제 나무와는 다소 다른 구조가 되기도 한다.</p>

<p>우리가 생각하려는 나무는 루트가 없는 트리이다. 이때 트리의 각각의 간선은 나무의 가지에 해당하고, 트리의 각 정점은 나무 위에서 열매가 매달려있는 지점을 의미한다. 각각의 정점에는 몇 개의 열매가 매달려 있다. 물론 열매 없이 가지가 갈라지는 경우도 있으므로, 이러한 경우는 그 노드에 0개의 열매가 매달려 있다고 생각하기로 하자.</p>

<p>이러한 나무 위에 한 마리의 벌레가 있다. 이 벌레는 임의의 정점에서 이동하기 시작한다. 벌레가 한 정점에 있을 때에는, 그 정점에 있는 열매들을 먹을 수 있다. 열매들을 다 먹은 후에는 가지를 따라서 다른 정점으로 이동한다. 만약 이동할 수 있는 가지가 여러 개 있다면 그 중 하나를 임의로 선택하지만, 한 번 지났던 가지는 다시 지날 수 없다. 벌레의 이동은 더 이상 이동할 수 있는 정점이 없을 때에 끝난다.</p>

<p>나무의 모양이 주어졌을 때, 벌레가 최대로 먹을 수 있는 열매의 수와 이때 어느 정점에서 이동을 시작해야 하는지를 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 트리의 정점의 개수를 나타내는 정수 n(1 ≤ n ≤ 10,000)이 주어진다. 다음 줄에는 차례로 1번, 2번, …, n번 정점에 매달려 있는 열매의 개수가 주어진다. 다음 n-1개의 줄에는 트리의 각 간선을 나타내는 서로 다른 두 자연수 A, B(1 ≤ A, B ≤ n)가 주어진다. 이는 트리의 A번 정점과 B번 정점이 연결되어 있음을 의미한다. 나무에 매달려 있는 열매의 총 개수는 2<sup>31</sup>-1 (2,147,483,647)개를 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 벌레가 먹을 수 있는 열매의 최대 개수와, 이때 이동을 시작할 정점의 번호를 출력한다. 답이 여러 개 있을 경우에는 정점의 번호가 가장 작은 경우를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2 3
1 2
2 3
','6 1
','TREE'),
                                                                                                                (10529,'BAEKJOON','https://www.acmicpc.net/problem/2197',2197,'분해 반응','2초','128 MB',19,'<p>N(1 ≤ N ≤ 150)개의 원자로 구성된 분자가 있다. 각각의 원자들은 1부터 N까지의 번호가 붙어 있으며, 모든 원자들이 하나의 분자로 모두 연결되어 있다. 화학 실험을 할 때 결합 반응과 분해 반응에 대한 실험을 쉽게 하기 위해서, 원자들을 총 N-1 개의 결합만을 하고 있다.</p>

<p>실험을 하던 도중에 M개의 원자로 구성된 분자가 필요해졌다. 이 분자의 원자들의 종류는 상관이 없고, 단지 M개의 원자로 구성되어 있기만 하면 된다. 물론 이 역시 M개의 원자들이 하나의 분자로 모두 연결되어 있어야 한다. 이를 위해서, 주어진 분자의 몇 개의 결합을 해제하는 분해 반응을 거쳐야 한다.</p>

<p>한 번의 반응을 거치면 오직 한 개의 결합만이 해제된다. 이를 통해 하나의 분자를 두 개의 분자로 나눌 수 있다. 이제 이 두 개의 분자들 중 하나를 택해서 M개의 원자로 구성된 분자를 얻을 때까지 계속 분해 반응을 진행한다. 이러한 분해 반응을 진행하다 보면 물질의 안정성이 깨질 수도 있기 때문에, 당신은 최소 회수의 분해 반응을 이용하려 한다.</p>

<p>원자들의 연결 상태가 주어졌을 때, M개의 원자로 구성된 분자를 얻어내기 위한 최소 분해 반응 회수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 두 정수 N, M(1 ≤ M ≤ N)이 주어진다. 다음 N-1개의 줄에는 원자들의 연결 상태를 나타내는 서로 다른 두 정수 A, B(1 ≤ A, B ≤ N)가 주어진다. 이는 A번 원자와 B번 원자가 결합을 이루고 있다는 의미이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 답을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>1번 원자와 3번 원자의 결합을 해제할 경우 1, 2, 6, 7, 8번 원자로 구성된 분자를 얻는다.</p>

				</div>
				</div>','8 5
1 2
6 1
7 6
8 6
1 3
5 3
4 3
','1
','TREE'),
                                                                                                                (10538,'BAEKJOON','https://www.acmicpc.net/problem/2213',2213,'트리의 독립집합','2초','128 MB',15,'<p>그래프 G(V, E)에서 정점의 부분 집합 S에 속한 모든 정점쌍이 서로 인접하지 않으면 (정점쌍을 잇는 간선이&nbsp;없으면) S를 독립 집합(independent set)이라고 한다. 독립 집합의 크기는 정점에 가중치가 주어져 있지 않을 경우는 독립 집합에 속한 정점의 수를 말하고, 정점에 가중치가 주어져 있으면 독립 집합에 속한 정점의 가중치의 합으로 정의한다. 독립 집합이 공집합일 때 그 크기는 0이라고 하자. 크기가 최대인 독립 집합을 최대 독립 집합이라고 한다.</p>

<p>문제는 일반적인 그래프가 아니라 트리(연결되어 있고 사이클이 없는 그래프)와 각 정점의 가중치가 양의 정수로 주어져 있을 때, 최대 독립 집합을 구하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 트리의 정점의 수 n이 주어진다. n은 10,000이하인 양의 정수이다. 1부터 n사이의 정수가 트리의 정점이라고 가정한다. 둘째 줄에는 n개의 정수 w<sub>1</sub>, w<sub>2</sub>, ..., w<sub>n</sub>이 주어지는데, w<sub>i</sub>는 정점 i의 가중치이다(1 ≤ i ≤ n). 셋째 줄부터 마지막 줄까지는 간선의&nbsp;리스트가 주어지는데, 한 줄에 하나의 간선을&nbsp;나타낸다. 간선은&nbsp;정점의 쌍으로 주어진다. 입력되는 정수들 사이에는&nbsp;빈 칸이 하나 있다. 가중치들의 값은 10,000을 넘지 않는 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최대 독립집합의 크기를 출력한다. 둘째 줄에는 최대 독립집합에 속하는 정점을 오름차순으로 출력한다. 최대 독립 집합이 하나 이상일 경우에는 하나만 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
10 30 40 10 20 20 70
1 2
2 3
4 3
4 5
6 2
6 7
','140
1 3 5 7
','TREE'),
                                                                                                                (10540,'BAEKJOON','https://www.acmicpc.net/problem/2250',2250,'트리의 높이와 너비','2초','128 MB',14,'<p>이진트리를 다음의 규칙에 따라 행과 열에 번호가 붙어있는 격자 모양의 틀 속에 그리려고 한다. 이때 다음의 규칙에 따라 그리려고 한다.</p>

<ol>
	<li>이진트리에서 같은 레벨(level)에 있는 노드는 같은 행에 위치한다.</li>
	<li>한 열에는 한 노드만 존재한다.</li>
	<li>임의의 노드의 왼쪽 부트리(left subtree)에 있는 노드들은 해당 노드보다 왼쪽의 열에 위치하고, 오른쪽 부트리(right subtree)에 있는 노드들은 해당 노드보다 오른쪽의 열에 위치한다.</li>
	<li>노드가 배치된 가장 왼쪽 열과 오른쪽 열 사이엔 아무 노드도 없이 비어있는 열은 없다.</li>
</ol>

<p>이와 같은 규칙에 따라 이진트리를 그릴 때 각 레벨의 너비는 그 레벨에 할당된 노드 중 가장 오른쪽에 위치한 노드의 열 번호에서 가장 왼쪽에 위치한 노드의 열 번호를 뺀 값 더하기 1로 정의한다. 트리의 레벨은 가장 위쪽에 있는 루트 노드가 1이고 아래로 1씩 증가한다.</p>

<p>아래 그림은 어떤 이진트리를 위의 규칙에 따라 그려 본 것이다. 첫 번째 레벨의 너비는 1, 두 번째 레벨의 너비는 13, 3번째, 4번째 레벨의 너비는 각각 18이고, 5번째 레벨의 너비는 13이며, 그리고 6번째 레벨의 너비는 12이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/4e4aaa17-dc1d-4af9-a36a-3144259fb7d2/-/preview/" style="width: 339.167px; height: 122.5px;"></p>

<p>우리는 주어진 이진트리를 위의 규칙에 따라 그릴 때에 너비가 가장 넓은 레벨과 그 레벨의 너비를 계산하려고 한다. 위의 그림의 예에서 너비가 가장 넓은 레벨은 3번째와 4번째로 그 너비는 18이다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때는 번호가 작은 레벨을 답으로 한다. 그러므로 이 예에 대한 답은 레벨은 3이고, 너비는 18이다.</p>

<p>임의의 이진트리가 입력으로 주어질 때 너비가 가장 넓은 레벨과 그 레벨의 너비를 출력하는 프로그램을 작성하시오</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 노드의 개수를 나타내는 정수 N(1 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 각 줄마다 노드 번호와 해당 노드의 왼쪽 자식 노드와 오른쪽 자식 노드의 번호가 순서대로 주어진다. 노드들의 번호는 1부터 N까지이며, 자식이 없는 경우에는 자식 노드의 번호에 -1이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 너비가 가장 넓은 레벨과 그 레벨의 너비를 순서대로 출력한다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때에는 번호가 작은 레벨을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>실제 기출문제의 문제 제목은 "이진트리의 너비" 이다.</p>

				</div>
				</div>','19
1 2 3
2 4 5
3 6 7
4 8 -1
5 9 10
6 11 12
7 13 -1
8 -1 -1
9 14 15
10 -1 -1
11 16 -1
12 -1 -1
13 17 -1
14 -1 -1
15 18 -1
16 -1 -1
17 -1 19
18 -1 -1
19 -1 -1
','3 18
','TREE'),
                                                                                                                (10539,'BAEKJOON','https://www.acmicpc.net/problem/2263',2263,'트리의 순회','5초','128 MB',15,'<p>n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 줄에는 인오더를 나타내는 n개의 자연수가 주어지고, 그 다음 줄에는 같은 식으로 포스트오더가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 프리오더를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2 3
1 3 2
','2 1 3
','TREE'),
                                                                                                                (10536,'BAEKJOON','https://www.acmicpc.net/problem/2275',2275,'트리의 높이 줄이기','2초','128 MB',15,'<p>N(1 ≤ N ≤ 10,000)개의 정점을 갖는 루트 있는 트리(Rooted Tree)를 생각해 보자. 각각의 간선에는 음 아닌 정수로 가중치가 있다. 이 트리의 높이는 루트에서 가장 멀리 떨어져 있는 정점까지의 거리를 의미한다.</p>

<p>이 트리의 간선의 가중치를 1씩 줄일 때마다 1만큼의 비용이 든다. 쉽게 생각하면, 가중치가 x인 간선의 가중치를 y(x ≥ y ≥ 0)로 줄일 때, x - y만큼의 비용이 든다는 의미이다. 문제를 쉽게 하기 위해서 음 아닌 정수에서 음 아닌 정수로 줄이는 경우만 생각하기로 하자.</p>

<p>우리는 몇 개의 간선의 가중치를 적절히 줄여서, 이 트리의 높이를 H(0 ≤ H ≤ 150,000, H는 정수)로 만들려고 한다. 이때, 최소의 비용을 들여서 높이를 H로 만드는 것이 목적이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 N과 H가 주어진다. 다음 N개의 줄에는 1번 정점부터 N번 정점까지 차례로, 각 정점의 부모 정점과, 그 정점에서 부모 정점까지의 거리(간선의 가중치)가 주어진다. 루트의 경우에는 부모 정점과 비용 대신에 0 두 개가 주어진다. 가중치는 음이 아닌 정수이고, 각 간선의 가중치의 총 합은 1,000,000,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최소 비용을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 1
0 0
1 1
2 1
2 1
1 2
','2
','TREE'),
                                                                                                                (10537,'BAEKJOON','https://www.acmicpc.net/problem/2329',2329,'장애물 설계','2초','128 MB',18,'<p>동규 체육관에서 장애물 경기장을 설계하고 있다. 경기장에는 높이가 서로 다른 m개의 장애물이 일렬로 서 있다. 각각의 장애물에는 두 개의 받침대가 있다. 경기장을 설계할 때에는 장애물 옆에 다른 장애물을 놓을 수 있다. 또, 장애물의 두 받침대 사이를 가른 다음, 그 사이에 다른 장애물들을 끼워 넣을 수 있다. 이때 끼워 넣는 장애물들은 반드시 사이를 가른 원래 장애물보다 높이가 높아야 한다.</p>

<p style="text-align: center;"><img alt="" src="/JudgeOnline/upload/201011/dd.PNG" style="height:75px; width:378px"></p>

<p>그림의 왼쪽은 장애물의 한 예이고, 오른쪽은 이런 장애물들을 이용하여 만든 경기장의 한 예이다. 이와 같이 경기장을 설계한 뒤, 왼쪽 땅에서부터 시작하여 오른쪽 땅에 도달할 때까지 경기를 하게 된다. 경기를 하는 도중 높이가 낮은 장애물(혹은 땅)에서 높이가 높은 장애물로 이동할 때마다 경기장의 난이도가 1씩 증가한다. 오른쪽 경기장의 경우에는, 맨 처음 땅에서 첫 번째 장애물로 이동할 때, 첫 번째 장애물에서 두 번째 장애물로 이동할 때, 두 번째 장애물에서 세 번째 장애물로 이동할 때, 그리고 마지막 장애물로 이동할 때를 계산하여, 난이도가 4가 된다. 그 외의 경우에는 높이가 높은 곳에서 낮은 곳으로 이동하는 경우이므로 난이도에 계산되지 않는다.</p>

<p>우리가 만들 장애물 경기장의 난이도 k가 주어졌을 때, m개의 장애물로 만들 수 있는 경기장의 개수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 m(0 ≤ m ≤ 50), k(0 ≤ k ≤ 128)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 경기장의 개수를 출력한다. 이 값은 10진수 100자리를 넘지 않는다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 2
','8
','TREE'),
                                                                                                                (10507,'BAEKJOON','https://www.acmicpc.net/problem/2337',2337,'트리 자르기','2초','128 MB',19,'<p>트리는 사이클이 없는 연결된 그래프이다. 그렇기 때문에, 트리에서 임의의 한 간선을 자르면 두 개의 트리로 나뉘게 된다.</p>

<p>크기(트리의 정점의 개수)가 n인 트리의 간선을 자르는 과정을 반복하여, 크기가 m인 트리를 얻어내려 한다. 이때 잘라야 하는 간선의 최소 개수를 구해 내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n(1 ≤ n ≤ 150), m(1 ≤ m ≤ n)이 주어진다. 다음 n-1개의 줄에는 트리의 각 간선에 대한 정보를 나타내는 두 정수 A, B가 주어진다. 이는 A번 정점과 B번 정점이 연결되어 있다는 의미이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 잘라야 하는 간선의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8 5
1 2
6 1
7 6
8 6
1 3
5 3
4 3
','1
','TREE'),
                                                                                                                (10541,'BAEKJOON','https://www.acmicpc.net/problem/2376',2376,'단말 정점들의 거리','2초','128 MB',16,'<p>n개의 단말 정점을 갖는 루트가 있는 이진 트리(Rooted binary tree)가 있다. 단말 정점은 자식 정점이 없는 정점을 말한다. 주어진 트리를 인오더로 탐색하였을 때 단말 정점들이 나오는 순서대로 단말 정점들에 1, 2, …, n의 번호가 붙어 있다. 주어진 트리에서 만약 어떤 정점에 자식 정점이 있다면, 그 정점은 반드시 두 개의 자식 정점을 갖는다고 하자.</p>

<p>n보다 작은 자연수 k에 대해서, 우리는 k번 단말 정점과 k+1번 단말 정점의 거리를 알고 있다. 이러한 정보를 알고 있으면, 이를 이용하여 임의의 두 단말 정점 사이의 거리를 알 수 있다. 이를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 단말 정점의 개수 n(2 ≤ n ≤ 1,000)이 주어진다. 다음 n-1개의 줄에는 차례로 1, 2번 단말 정점 사이의 거리, 2, 3번 단말 정점 사이의 거리, …, n-1, n번 단말 정점 사이의 거리가 주어진다. 다음 줄에는 거리를 알고자 하는 서로 다른 두 단말 정점의 번호가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 거리를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
4
2
3
1 3
','4
','TREE'),
                                                                                                                (10542,'BAEKJOON','https://www.acmicpc.net/problem/2379',2379,'트리 탐색하기','2초','128 MB',17,'<p>n개의 정점으로 이루어진 트리가 있다. 이와 같은 트리를 DFS와 비슷한 방식으로 탐색하려 한다. 탐색을 시작할 때에는 트리의 한 정점에서 시작하여, 한 번도 지나지 않은 간선을 따라서 다음 정점으로 이동한다. 이때 한 번도 지나지 않은 간선이 여러 개 존재한다면 그 중 하나를 임의로 선택한다. 만약 한 번도 지나지 않은 간선이 존재하지 않는다면, 전 단계로 돌아간다. 이와 같은 과정을 반복하면 모든 간선을 두 번씩 지나게 된다.</p>

<p>이와 같은 탐색을 할 때, 시작 정점에서 멀어질 때 0을, 시작 정점에 가까워 질 때 1을 적으면 경로를 얻을 수 있다. 하지만 이와 같은 경로 저장 방식을 사용하면, 같은 트리라 하더라도 여러 개의 경로로 저장될 수 있다.</p>

<p><img alt="" src="/JudgeOnline/upload/201103/tretre.png" style="height:205px; width:280px"></p>

<p>예를 들어 위와 같은 트리를 살펴보면, 0010011101001011, 0100011011001011, 0100101100100111 등의 경로로 탐색될 수 있다. 탐색 시작 정점은 그림에서 크게 표시된 정점이다.</p>

<p>트리를 탐색한 경로가 두 개 주어졌을 때, 이 경로들이 같은 트리를 탐색한 것인지 알아내는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 데이터의 개수 T(1 ≤ T ≤ 10)이 주어진다. 다음 2×T개의 줄에는 트리를 탐색한 경로가 주어진다. 경로의 길이는 3,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력 데이터 순서대로 T개의 줄에 출력을 하는데, 만약 같은 트리라면 1을, 다른 트리라면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
0010011101001011
0100011011001011
0100101100100111
0011000111010101
','1
0
','TREE'),
                                                                                                                (10543,'BAEKJOON','https://www.acmicpc.net/problem/2430',2430,'거울대칭트리 그래프','1초','128 MB',25,'<p>T는 루트가 있는 트리이다. S는 T의 완벽한 복사본이다. 자 이제 T와 S를 합친다. 루트를 제외한 모든 단말 노드 (leaf node)를 합치면 된다. 이 그래프는 거울대칭트리 그래프이다.</p>

<p>임의의 무방향 연결 그래프가 주어졌을 때, 이 그래프가 거울대칭트리 그래프인지 아닌지 판별하는 프로그램을 작성하시오.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/f4a66743-daa1-41ff-971b-f3b5a29b62aa/-/preview/" style="width: 300px; height: 258px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 M이 주어진다. N은 정점의 개수 M은 간선의 개수이다. 그래프의 정점은 1부터 N까지 번호가 매겨져 있다. 다음 M개의 줄에는 x와 y가 주어진다. (x ≠ y, 1 ≤ x, y ≤ N) x와 y는 하나의 간선이고, x와 y가 이어져 있는 것이다. 두 정점 사이에는 많아야 하나의 간선만 있을 수 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 그래프가 거울대칭트리 그래프이면 <code>YES</code>를 아니면 <code>NO</code>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 7
1 2
2 3
3 4
4 5
5 6
6 7
7 1
','NO
','TREE'),
                                                                                                                (10546,'BAEKJOON','https://www.acmicpc.net/problem/2454',2454,'트리 분할','1초','128 MB',19,'<p>N개의 도시들과 이들 도시들을 연결하는 트리 형태의 도로망이 있다. 즉, 이 도로망은 임의의 두 도시 사이의 경로가 항상 하나만 있다. 다음은 11개의 도시들로 이루어진 트리 형태의 도로망의 예이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/e2a124f3-76aa-4835-ace4-6ec941508620/-/preview/" style="width: 244px; height: 218px;"></p>

<p>두 도시 u, v사이의 경로는 u로부터 인접한 도로들을 따라 v에 도달하는 길로서, 중간에 거치는 도시가 중복되어서는 안 된다. 이 경로는 u부터 시작하여 지나는 도시들을 순서대로 나열하여 나타낸다. 예를 들어, 9부터 10까지의 경로는 (9, 8, 2, 10)으로 나타낸다.</p>

<p>양의 정수 K에 대하여, 이 트리 형태의 도로망의 K-경로 분할은 다음 조건을 만족하는 경로들의 집합이다.&nbsp;</p>

<ol>
	<li>이들 경로들 중 임의의 두 경로가 같은 도시를 지나서는 안 된다,</li>
	<li>도로망의 각 도시는 반드시 이들 경로 중 하나에 포함되어야 한다.&nbsp;</li>
	<li>각 경로는 길이가 K 이하이어야 한다. 경로의 길이란, 이 경로 상에 있는 도로(간선)의 개수이다.</li>
</ol>

<p>예를 들어, 위 그림에 있는 도로망의 2-경로 분할 중 하나는 다음과 같다.</p>

<p style="text-align: center;">{(1, 2, 10), (8, 9), (3, 4), (6, 5, 7), (11)}</p>

<p>이 2-경로 분할에 있는 경로들은 아래 그림에서 점선 부분으로 표시되어 있으며, &nbsp;경로들의 개수가 5이다. 이는 경로들의 수가 최소인 2-경로 분할 중 하나이다.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/594e1072-23e4-4da9-b0f2-ded7729209b8/-/preview/" style="width: 274px; height: 244px;"></p>

<p>또 다른 예로, 다음은 3-경로 분할 중 하나이다.</p>

<p style="text-align: center;">{(1, 2, 3, 4), (8, 9), (10), (6, 5, 11), (7)}</p>

<p>이 분할에서 경로 개수는 5로서 3-경로 분할 중 경로 수가 가장 작다.&nbsp;</p>

<p>또 다른 예로, 다음은 1-경로 분할 중 하나이다.</p>

<p style="text-align: center;">{(1, 2), (10), (8, 9), (3, 4), (5, 6), (11), (7)}</p>

<p>이 분할에서 경로 개수는 7로서 1-경로 분할 중 경로 수가 가장 작다.&nbsp;</p>

<p>트리 형태의 도로망과 K가 주어질 때, 경로 개수가 가장 작은 K-경로 분할의 경로 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 도시의 수 N과 K-경로 분할을 위한 수 K가 빈칸을 사이에 두고 입력된다. N은 2 이상 300,000이하이다. K는 &nbsp;1이상 N-1이하인 정수이다. 다음 N-1개의 각 줄에 도로의 양 끝 도시를 나타내는 두 정수가 빈칸을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>경로 개수가 가장 작은 K-경로 분할의 경로 수를 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','11 2
1 2
2 10
2 3
3 4
3 5
5 11
5 7
6 5
2 8
8 9
','5
','TREE'),
                                                                                                                (10544,'BAEKJOON','https://www.acmicpc.net/problem/2483',2483,'병원','1초','128 MB',25,'<p>1부터 N까지 번호가 붙여진 N개의 마을과 이들 마을을 연결하는 도로망이 있다. 이 도로망에서는, 각 마을로부터 다른 모든 마을까지 가는 경로는 하나뿐이다. 각 마을에 사는 사람들의 수와 각 도로를 지나는데 걸리는 시간이 주어진다. 그리고 이들 마을 중 서로 다른 두 마을에만 병원이 있다.</p>

<p>마을 A에서 마을 B까지 가는데 걸리는 시간은 A에서 B까지의 경로 상에 있는 도로들의 통행시간의 합이다.</p>

<p>예를 들어, 다음과 같은 도로망을 고려해 보자.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/cd48ba8f-0ad0-446b-ba6d-88f671b17dd3/-/preview/" style="width: 305px; height: 227px;"></p>

<p style="text-align: center;">그림 1</p>

<p>동그라미는 마을을 나타내고, 동그라미 안에 있는 수는 마을의 번호이고, 바깥에 있는 수는 마을에 있는 사람들의 수이다. 선분은 도로를 나타내고, 선분 상의 수는 도로의 통행시간을 나타낸다. 또한 병원이 세워져 있는 두 마을은 회색으로 칠해져 있다.</p>

<p>예산을 도로개선에 투입하여 도로의 통행시간을 줄일 수 있다. 이때 각 도로는 예산 C를 들이면 통행시간을 C 시간 만큼 줄일 수 있다. 이제 다음의 제약조건을 만족하면서 전체 예산 B를 도로개선에 투입한다.</p>

<p><strong>제약조건</strong>:</p>

<ol>
	<li>도로에 예산을 아무리 많이 사용하더라도 각 도로의 통행시간을 L 미만으로 할 수는 없다.&nbsp;</li>
	<li>도로개선에 사용하는 전체예산은 B 이하이어야 한다.</li>
</ol>

<p>L과 B의 값은 입력으로 주어진다.</p>

<p>이때, 위의 제약조건을 만족하면서 다음 두 질문의 답을 구하는 프로그램을 작성하시오.</p>

<ul>
	<li><strong>질문 1</strong>: 각 사람이 가까운 병원까지 가는데 걸리는 시간의 합이 가장 작도록 할 때, 시간의 합의 최솟값은 얼마인가? &nbsp;</li>
	<li><strong>질문 2</strong>: 각 사람이 &nbsp;가까운 병원까지 가는데 걸리는 시간 중 가장 긴 시간이 최소가 되도록 할 때, 그 최소 시간은 얼마인가?</li>
</ul>

<p>그림 1의 도로망에서 전체예산 B = 7이고, L = 6일 경우, 질문 1의 해는 도로 (1,3)에 예산 3을 사용하여 도로 (1,3)의 통행시간을 6으로 만들고, 도로 (2,3)에 예산 1을 사용하여 통행시간을 7로 만들고, 예산 3을 도로 (5,7)에 사용하여 통행시간을 6으로 만들면 각 사람이 병원을 이용하는데 걸리는 시간의 합은 &nbsp; 50×6 + 20×7 + 10×5 + 20×5 +30×6 + 15×7 = 875이다.&nbsp;</p>

<p>질문 2의 해는 도로 (1,3), (4,5), (5,7)에 각각 비용 2를 사용하고, &nbsp;도로 (2,3)에 비용 1을 사용하면 각 사람이 가까운 병원까지 가는데 걸리는 가장 긴 시간은 7이 된다.&nbsp;</p>

<p>어떻게 하더라도 위의 두 답보다 좋게 할 수 없다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 B(1 ≤ B ≤ 4,000,000)와 L(1 ≤ L ≤ 1,000)을 나타내는 두개의 양의 정수가 빈칸을 사이에 두고 주어진다. 두 번째 줄에 마을의 수 N (2 ≤ N ≤ 4,000)이 주어진다. 세 번째 줄에 마을 1부터 마을 N까지 각 마을에 사는 사람들의 수(1 이상 500 이하)가 빈칸을 사이에 두고 차례로 주어진다. 그 다음 줄부터 N-1개의 각 줄에 도로의 정보 즉, 도로의 양끝 마을 번호와 도로의 통행시간(1 이상 1,000 이하)을 나타내는 세 개의 양의 정수가 빈칸을 사이에 두고 차례로 주어진다. 마지막 줄에 병원이 있는 서로 다른 두 마을의 번호가 빈칸을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><u>반드시</u> 질문 1의 답은 첫째 줄에, 질문 2의 답은 둘째 줄에 출력한다. <u>답이 2<sup>32</sup>을 넘을 수 있음에 유의하라.</u></p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 6
8
50 20 10 10 5 20 30 15
1 3 9
3 2 8
3 4 5
4 5 9
7 5 9
8 5 7
3 6 5
3 5
','875
7
','TREE'),
                                                                                                                (10545,'BAEKJOON','https://www.acmicpc.net/problem/2489',2489,'응급센터','1초','128 MB',25,'<p>지하철 망이 있다. 이 지하철 망은 하나의 순환선과 이 순환선상의 역에 연결되는 지선들로 구성되어 있고, 각 지선은 트리 형태이다. 각 역에는 지선들이 없을 수도 있어서, 지하철이 순환선만으로 구성될 수도 있다. 모든 역은 1부터 N까지의 번호로 나타낸다. 아래 그림은 이러한 형태의 지하철 망의 예를 보여준다. 그림에서 정점은 지하철역을 나타내고, 간선은 두 역을 잇는 선로를 나타내며 간선상의 값은 선로를 지나는데 걸리는 시간을 나타낸다. 지하철 망의 역의 개수와 선로의 개수는 항상 같음에 유의하라.</p>

<p style="text-align: center;"><img alt="" src=https://www.acmicpc.net/upload/images/grgr.png" style="width: 350px; height: 218.333px;"></p>

<p>지하철 사고 발생 시 응급치료를 위하여 2개의 역에 응급센터를 설치하기로 하였다. 각 역의 응급대처시간은 가까운 응급센터까지 가는데 걸리는 최단 시간이다. 모든 역들의 응급대처시간 중 가장 긴 시간이 최소가 되도록 2 개의 응급센터 설치 역을 구하는 프로그램을 작성하시오.</p>

<p>위의 그림에서 역 8과 역 12에 응급센터를 설치할 경우, 역 1에서부터 역 12까지의 응급대처시간은 각각 11, 13, 8, 6, 13, 11, 5, 0, 12, 7, 10, 0으로서 가장 긴 시간은 13이다. 또한, 두 응급센터를 어디에 설치하더라도, 모든 역들의 응급 대처시간 중 가장 긴 시간은 13보다 작아지지 않는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 역의 개수(선로의 개수)인 N(3 ≤ N ≤ 50,000)이 주어진다. 다음 줄부터 N줄에 걸쳐 각 줄에 하나의 선로를 나타내는 세 개의 양의 정수 u, v, x가 주어진다. 여기서 u, v는 선로를 통해 연결되는 두 역의 번호이고, x는 이 선로를 지나는데 걸리는 시간이다. 단, x는 1 이상 10,000 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 응급센터를 설치하는 두 역의 번호를 빈칸을 사이에 두고 출력한다. 만약 해가 두 가지 이상이면 그 중 한 가지만 출력한다. 다음 줄에 모든 역들의 응급대처시간 중 가장 긴 시간을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12
1 3 3
3 4 2
4 5 7
5 6 4
6 7 6
7 8 5
8 4 6
2 3 5
7 9 7
9 12 15
7 10 2
10 11 3
','8 12
13
','TREE'),
                                                                                                                (10548,'BAEKJOON','https://www.acmicpc.net/problem/2533',2533,'사회망 서비스(SNS)','3초','256 MB',13,'<p>페이스북, 트위터, 카카오톡과 같은 사회망 서비스(SNS)가 널리 사용됨에 따라, 사회망을 통하여 사람들이 어떻게 새로운 아이디어를 받아들이게 되는가를 이해하는 문제가 중요해졌다. 사회망에서 사람들의 친구 관계는 그래프로 표현할 수 있는데, &nbsp;이 그래프에서 사람은 정점으로 표현되고, 두 정점을 잇는 에지는 두 정점으로 표현되는 두 사람이 서로 친구 관계임을 표현한다.&nbsp;</p>

<p>예를 들어, 철수와 영희, 철수와 만수, 영희와 순희가 서로 친구 관계라면 이를 표현하는 친구 관계 그래프는 다음과 같다.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/c0d162b4-20d6-46eb-be8f-d06ae8bf1e9c/-/preview/" style="width: 203px; height: 81px;"></p>

<p>친구 관계 그래프를 이용하면 사회망 서비스에서 어떤 새로운 아이디어가 전파되는 과정을 이해하는데 도움을 줄 수 있다. 어떤 새로운 아이디어를 먼저 받아들인 사람을 얼리 아답터(early adaptor)라고 하는데, 사회망 서비스에 속한 사람들은 얼리 아답터이거나 얼리 아답터가 아니다. 얼리 아답터가 아닌 사람들은 자신의 모든 친구들이 얼리 아답터일 때만 이 아이디어를 받아들인다.&nbsp;</p>

<p>어떤 아이디어를 사회망 서비스에서 퍼뜨리고자 할 때, 가능한 한 최소의 수의 얼리 아답터를 확보하여 모든 사람이 이 아이디어를 받아들이게 하는 &nbsp;문제는 매우 중요하다.&nbsp;</p>

<p>일반적인 그래프에서 이 문제를 푸는 것이 매우 어렵다는 것이 알려져 있기 때문에, 친구 관계 그래프가 트리인 경우, 즉 모든 두 정점 사이에 이들을 잇는 경로가 존재하면서 사이클이 존재하지 않는 경우만 고려한다.&nbsp;</p>

<p>예를 들어, 8명의 사람으로 이루어진 다음 친구 관계 트리를 생각해보자. 2, 3, 4번 노드가 표현하는 사람들이 얼리 아답터라면, 얼리 아답터가 아닌 사람들은 자신의 모든 친구가 얼리 아답터이기 때문에 새로운 아이디어를 받아들인다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/ac2e6a89-2e66-4cab-8f07-951372ef7fcc/-/preview/" style="width: 191px; height: 127px;"></p>

<p>친구 관계 트리가 주어졌을 때, 모든 개인이 새로운 아이디어를 수용하기 위하여 필요한 최소 얼리 어답터의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 친구 관계 트리의 정점 개수 N이 주어진다. 단, 2 ≤ N ≤ 1,000,000이며, 각 정점은 1부터 N까지 일련번호로 표현된다. 두 번째 줄부터 N-1개의 줄에는 각 줄마다 친구 관계 트리의 에지 (u, v)를 나타내는 두 정수 u와 v가 하나의 빈칸을 사이에 두고 주어진다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>주어진 친구 관계 그래프에서 아이디어를 전파하는데 필요한 얼리 아답터의 최소 수를 하나의 정수로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
1 2
1 3
1 4
2 5
2 6
4 7
4 8
','3
','TREE'),
                                                                                                                (10549,'BAEKJOON','https://www.acmicpc.net/problem/2584',2584,'트리분할','1초','128 MB',22,'<p>N개의 정점과 이들 사이에 가중치를 갖는 간선으로 이루어진 트리가 있다. 주어진 자연수 K(K＜N)에 대해, 주어진 트리에서 K개의 정점을 선택하여 그 정점과 이들 사이에 이어진 간선으로 하나의 그래프를 만들고, 나머지 N-K개의 정점과 그들 사이에 이어진 간선으로 또 하나의 그래프를 만들려고 한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/179c0a29-cd5b-47b7-9684-1106d7191952/-/preview/" style="width: 243px; height: 237px;"></p>

<p style="text-align: center;"><그림 1></p>

<p>예를 들어 <그림 1>과 같이 7개의 정점으로 이루어진 트리에서 1번, 2번 정점을 선택하여 그래프를 만들려면 <그림 2>의 (A)와 같이 되고, 나머지 정점들로 그래프를 만들면 <그림 2>의 (B)와 같이 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/9b1b7b50-9658-48ef-855d-353c0a34a60b/-/preview/" style="width: 367px; height: 206px;"></p>

<p style="text-align: center;"><그림 2><br>
&nbsp;</p>

<p>또한 <그림 1>의 트리에서 3번, 4번 정점을 선택한 경우 마찬가지로 <그림 3>의 (A),(B)와 같이 두 그래프가 만들어진다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/ba833577-d4cc-445b-aa58-70e9dd651878/-/preview/" style="width: 367px; height: 206px;"></p>

<p style="text-align: center;"><그림 3></p>

<p><그림 2>의 두 그래프에서 모든 간선의 가중치의 합은 10+20+10+25=65가 되고<그림 3>의 두 그래프에서 모든 간선의 가충치의 합은 10이된다.</p>

<p>트리에 대한 정보와 K가 주어질 때, K개의 정점을 선택하여 위와 같은 방법으로 만들어진 두 그래프에 있는 모든 간선의 가중치 합의 최솟값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 중에는 N과 K가 빈 칸을 사이에 두고 차례로 주어진다. 트리의 정점에는 1번부터 N번까지 번호가 매겨진다. 이어 둘째 줄부터 N-1개의 각 줄에는 간선 하나의 정보가 주어진다. 간선의 정보는 양 끝 정점 번호와 가중치가 빈 칸을 사이에 두고 차례대도 주어진다. N은 1,000이하의 자연수, K는 N보다 작은 자연수이고 간선의 가중치는 1,000이하의 자연수 이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 K개 정점을 선택하여 만들어진 두 개의 그래프에 있는 모든 간선의 가중치 합의 최솟값을 출력하고, 둘째 줄에 그 때 선택한 K개 정점들의 번호를 오름차순으로 빈 칸을 사이에 두고 한 줄에 출력한다. K개의 정점을 선택하는 방법이 둘 이상인 경우 그 중 한 경우만 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 2
1 2 10
1 3 15
1 4 30
5 3 20
6 3 10
4 7 2
','10
3 4
','TREE'),
                                                                                                                (10550,'BAEKJOON','https://www.acmicpc.net/problem/2634',2634,'버스노선','1초','128 MB',19,'<p><span style="line-height:1.6em"><그림 1>은 어떤 도시의 도로망을 나타내고 있다.</span></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/6182a2d1-41b6-4eb1-b0b3-bba7a2fd2b08/-/preview/" style="width: 212px; height: 150px;"></p>

<p style="text-align: center;"><그림 1></p>

<p>이 도시의 지점은 숫자를 포함하는 동그라미로 표시되어 있고, 두 지점 사이에 있는 도로는 두 지점을 잇는 선으로 표시되어 있다. 이 도로망의 특성은 다음과 같다.</p>

<ul>
	<li>특성 1. 임의의 한 지점에서 도로와 지점을 거쳐 모든 다른 지점으로 갈 수 있다.&nbsp;</li>
	<li>특성 2. 한 지점에서 출발하여 어떤 도로를 두 번이상 거치지 않고는 출발지점으로 되돌아 올 수 없다.</li>
	<li>특성 3. 한 지점과 접한 도로의 개수는 10이하이다.</li>
</ul>

<p>위의 세 가지 특성을 만족하는 도로망을 트리도로망이라 한다. 이제 이 도시에서 몇 개의 버스노선을 신설하려고 한다. 각각의 버스노선은 한 종점에서 반대편 종점까지 가는 도로와 지점으로 이루어진다. 종점이 될 수 있는 지점은 도로망에서 단말지점(자신과 연결된 다른 지점이 하나 뿐인 곳)이어야 한다. 예를 들어, <그림 1>에서 버스 종점이 될 수 있는 지점은 색칠된 1, 2, 5, 6, 9, 10번 지점이다.</p>

<p><그림 1>과 같은 경우에 두 개씩의 단말지점으로 짝을 지어 세 개의 서로 다른 버스노선을 만들 수 있다. 단, 버스 노선을 설정하기 위해서는 다음 조건들을 만족해야 한다.</p>

<ul>
	<li>조건 1. 도시의 모든 지점은 반드시 하나의 노선에 포함되어야 하고, 두 개 이상의 버스 노선에 포함 될 수도 있다. 예를 들어, 1-3-8-10 노선과 9-7-8-4-5 노선과 같이 한 교차지점을 공유하는 것은 허용된다.</li>
	<li>조건 2. 도시의 모든 도로는 하나의 버스노선에는 포함되어야 한다. 그러나 한 도로는 두 개의 버스노선에 포함될 수는 없다. 예로 <그림 1>에서 6-7-8-10이 버스노선인 경우, 9-7-8-4-5는 도로 (7, 8)을 공유하게되므로 버스노선이 될 수 없다.</li>
	<li>조건 3. 버스노선의 종점은 단말지점이어야 한다. 그리고 버스노선은 지점과 도로를 한 번씩만 지나야 한다. 예로 <그림 1>에서 2-7-8-3-1은 버스노선으로 가능하지만 2-7-9-7-8-10은 도로 (7, 9)와 지점 7을 두 번 방문하기 때문에 버스노선이 될 수 없다.</li>
	<li>조건 4. 노선이 지나치게 길면 안되므로 위의 세 가지 조건을 만족하는 버스노선 중에서 가장 긴 노선의 길이가 최대한 짧게 설계되어야 한다. 단, 모든 도로의 길이는 1로 가정한다.</li>
</ul>

<p><그림 1>에서 제한조건을 만족하는 버스노선은 다음과 같다.</p>

<ul>
	<li>2-7-8-10</li>
	<li>9-7-6</li>
	<li>1-3-8-4-5</li>
</ul>

<p>이 경우 가장 긴 노선의 길이가 4이다.</p>

<p>다음 <그림 2>와 같은 경우라면 위의 조건들을 만족시키는 버스노선은 존재하지 않는다. 왜냐하면 6-2-7-9가 버스노선이 되면 도로 (7, 8)은 다른 노선에 포함될 수 없고, 6번에서 시작하여 9번이 아닌 다른 곳이 종점이 된다면 9번의 다른 쪽 종점을 정할 수 없기 때문이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/95f9b661-a0b9-4c18-a46a-8d80e8e58b02/-/preview/" style="width: 197px; height: 150px;"></p>

<p style="text-align: center;"><그림 2></p>

<p>트리도로망이 주어졌을 때, 위의 조건들을 만족하는 버스노선을 찾는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 도로망에 있는 지점 개수 n(2 ≤ n ≤ 500)이 주어진다. 둘째 줄부터 n-1개의 도로에 대한 정보가 한 줄에 하나씩 주어진다. 만일 지점 i와 지점 j 사이에 도로가 있다면 "i j"로 한 줄에 표시한다. 또는 "j i"라고 표시될 수도 있다. 숫자 사이에는 빈칸이 하나 있다. 지점은 1부터 n까지의 서로 다른 숫자로 표시된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에는 제일 긴 노선의 길이를 출력한다. 둘째 줄에는 버스노선의 개수 m 을 출력한다. 다음 m 줄의 각 줄에는 위의 조건을 만족하는 버스노선 을 한 줄에 하나씩 출력한다. 한 버스노선은 노선에 포함된 지점의 개수와 한 종점 번호에서부터 다른 종점까지 거치는 지점 번호들을 차례로 출력한다. 지점 번호 사이에는 빈칸을 하나 둔다. 답이 여러 개인 경우는 그 중에 하나만 출력한다. 만일 위 네 가지 조건을 만족하는 답이 존재하진 않을 경우에는 첫째 줄에 숫자 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 3
3 8
8 4
4 5
8 10
7 8
6 7
2 7
9 7
','4
3
2 7 8 10
9 7 6
1 3 8 4 5
','TREE'),
                                                                                                                (10551,'BAEKJOON','https://www.acmicpc.net/problem/2844',2844,'자료 구조','1초','128 MB',24,'<p>택희는 자료구조 수업시간에 다음과 같은 자료구조를 만들었다. 이 자료구조는 택희가 좋아하는 숫자 N개로 이루어진 수열에 아래와 같은 연산을 수행하는 것이다.</p>

<table class="table table-bordered">
	<thead>
		<tr>
			<td style="width:10%;">연산 형식</td>
			<td style="width:45%;">설명</td>
			<td style="width:45%;">예제</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1 A B X</td>
			<td>A번째부터 B번째까지 수를 X로 바꾼다.</td>
			<td>(9,8,7,6,5,4,3,2,1)&nbsp;→&nbsp;1 3 5 0 →&nbsp;(9,8,<strong>0,0,0,</strong>4,3,2,1)</td>
		</tr>
		<tr>
			<td>2 A B X</td>
			<td>A번째 수에는 X를, A+1번째 수에는 2×X를, ..., B번째 수에는 (B-A+1)×X를 더한다.</td>
			<td>(9,8,7,6,5,4,3,2,1)&nbsp;→&nbsp;2 3 5 2&nbsp;→ (9,8,<strong>9,10,11,</strong>4,3,2,1)</td>
		</tr>
		<tr>
			<td>3 C X</td>
			<td>C번째 숫자 바로 앞에 X를 삽입한다.</td>
			<td>(9,8,7,6,5,4,3,2,1) →&nbsp;3 4 100&nbsp;→ (9,8,7,<strong>100,</strong>6,5,4,3,2,1)</td>
		</tr>
		<tr>
			<td>4 A B</td>
			<td>A번째 수부터 B번째 수를 더해서 출력한다.</td>
			<td>(2,18,7,6,1,4,7,7,2)&nbsp;→&nbsp;4 6 7 →&nbsp;결과: 11</td>
		</tr>
	</tbody>
</table>

<p>택희가 좋아하는 숫자 N개로 이루어진 수열과 택희가 수행한 연산 목록이 주어졌을 때, 4번이 나올때 마다 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 Q가 주어진다. (1 ≤ N, Q ≤ 100,000) N은 처음 수열의 크기이고, Q는 택희가 수행한 연산의 개수이다.</p>

<p>둘째 줄에는 처음 수열이 주어진다. 수열의 수는 100,000을 넘지않는 음이 아닌 정수이며, 공백으로 구분되어져 있다.</p>

<p>셋째 줄부터 Q개의 줄에는 택희가 수행한 연산이 차례대로 주어진다. 0 ≤ X ≤ 100, 1 ≤ A ≤ B ≤ 현재 수열의 크기, 1 ≤ C ≤ 현재 수열의 크기+1</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>4번 연산이 나올때 마다 합을 출력한다. 합이 32비트 정수를 넘어갈 수 있다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
1 2 3 4 5
1 5 5 0
4 4 5
4 5 5
2 1 5 1
4 1 5
','4
0
25
','TREE'),
                                                                                                                (10552,'BAEKJOON','https://www.acmicpc.net/problem/3014',3014,'자전거 경주','1초','128 MB',24,'<p>상그니 아라비아는 세계에서 오일 머니를 가장 많이 보유하는 나라이다. 국왕으로 재직중인 고둘라 창지즈 영사우드는 천연 자원의 위대함을 알리기 위해서 자전거 레이싱 경기를 개최하기로 결심했다.&nbsp;</p>

<p>이 나라에는 도시가 N개가 있으며, 그 도시는 M개의 양방향 도로로 연결되어 있다. 도시는 1번부터 N번까지 번호가 매겨져 있다. 자전거 레이싱 트랙을 결정하기 위해서, 상근이는 아래와 같은 용어 세 가지를 사용할 것이다.</p>

<ul>
	<li>경로는 각 도로의 도착점과 다음 도로의 시작점이 같은 도로의 연속이다.</li>
	<li>단순 경로는 한 도시를 두 번 이상 방문하지 않는 경로이다.</li>
	<li>링은 시작 도시와 끝나는 도시가 같은 단순 경로이다.</li>
</ul>

<p>모든 도시 쌍 사이에는 적어도 하나의 경로가 있으며, 모든 도로는 많아야 한 링에 속한다.</p>

<p>다음 두 가지 조건을 만족하는 가장 긴 레이싱 경로를 찾는 프로그램을 작성하시오.</p>

<ul>
	<li>경로의 시작 도시는 어느 곳이 되어도 상관없지만, 도착 도시는 1이어야 한다.</li>
	<li>한 도시를 한 번 이상 방문해도 된다. 하지만, 도로는 최대 한 번만 지날 수 있다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 도시와 도로의 수 N과 M이 주어진다. (2 ≤ N ≤ 10,000, 1 ≤ M ≤ 2N-2)</p>

<p>다음 M개 줄에는 서로 다른 두 정수 A와 B가 주어진다. (1 ≤ A, B ≤ N) 두 숫자는 도로의 정보를 나타내며, A와 B를 연결하는 양방향 도로이다. 두 도시를 연결하는 도로가 두 개 이상인 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 가장 긴 레이싱 경로의 길이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
1 2
1 3
2 4
','2
','TREE'),
                                                                                                                (10553,'BAEKJOON','https://www.acmicpc.net/problem/3038',3038,'완전 이진 트리','1초','128 MB',18,'<p>완전 이진 트리의 각 노드는 계측적인 구조로 이루어져 있다. 루트 노드의 레벨은 0이며, 레벨 1의 두 자식 노드를 가지고 있다. 또, 레벨 1의 자식 노드의 레벨은 2이다.</p>

<p>보통 레벨이 N인 완전 이진 트리는 2<sup>N</sup>-1개의 노드를 가지고 있다. 레벨이 N-1이 아닌 모든 노드는 자식 노드를 두 개씩 가지고 있다.</p>

<p>1부터 2<sup>N</sup>-1까지 숫자를 레벨이 N인 완전 이진 트리의 각 노드에 적을 수 있다. 이때, 레벨이 D인 각각의 노드에 대해서 왼쪽 서브트리에 쓰여 있는 숫자의 합과 오른쪽 서브트리에 쓰여 있는 숫자의 합의 차이는 2<sup>D</sup>라는 조건을 만족해야 한다.</p>

<p>예를 들어, 루트의 왼쪽 서브 트리의 합과 오른쪽 서브 트리의 합의 차이는 1이어야 하며, 레벨이 1인 경우에는 2이어야 한다. 또, 모든 숫자는 한 번씩 사용해야 한다.</p>

<p>N이 주어졌을 때, 문제의 조건에 맞게 완전 이진 트리의 각 노드에 숫자를 정하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 트리의 레벨인 N이 주어진다. (1 ≤ N ≤ 15)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 문제의 조건에 맞게 숫자를 채운 완전 이진 트리를 프리오더로 순회한 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
','3 1 2
','TREE'),
                                                                                                                (10564,'BAEKJOON','https://www.acmicpc.net/problem/3584',3584,'가장 가까운 공통 조상','1초','128 MB',12,'<p>루트가 있는 트리(rooted tree)가 주어지고, 그 트리 상의 두 정점이 주어질 때 그들의 가장 가까운 공통 조상(Nearest Common Anscestor)은 다음과 같이 정의됩니다.</p>

<ul>
	<li>두 노드의 가장 가까운 공통 조상은, 두 노드를 모두 자손으로 가지면서 깊이가 가장 깊은(즉 두 노드에 가장 가까운) 노드를 말합니다.</li>
</ul>

<p style="text-align:center"><img alt="nca.png" src="https://upload.acmicpc.net/4f2eae58-31bf-445f-a7a3-625505e7102c/-/preview/" style="height:278px; width:304px"></p>

<p>예를 들어&nbsp; 15와 11를 모두 자손으로 갖는 노드는 4와 8이 있지만, 그 중 깊이가 가장 깊은(15와 11에 가장 가까운) 노드는 4 이므로 가장 가까운 공통 조상은 4가 됩니다.</p>

<p>루트가 있는 트리가 주어지고, 두 노드가 주어질 때 그 두 노드의 가장 가까운 공통 조상을 찾는 프로그램을 작성하세요</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 개수 T가 주어집니다.</p>

<p>각 테스트 케이스마다, 첫째 줄에 트리를 구성하는 노드의 수 N이 주어집니다. (2 ≤ N ≤ 10,000)</p>

<p>그리고 그 다음 N-1개의 줄에 트리를 구성하는 간선 정보가 주어집니다. 한 간선 당 한 줄에 두 개의 숫자 A B 가 순서대로 주어지는데, 이는 A가 B의 부모라는 뜻입니다. (당연히 정점이 N개인 트리는 항상 N-1개의 간선으로 이루어집니다!) A와 B는 1&nbsp;이상 N 이하의 정수로 이름 붙여집니다.</p>

<p>테스트 케이스의 마지막 줄에 가장 가까운 공통 조상을 구할 두 노드가 주어집니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스 별로, 첫 줄에 입력에서 주어진 두 노드의 가장 가까운 공통 조상을 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
16
1 14
8 5
10 16
5 9
4 6
8 4
4 10
1 13
6 15
10 11
6 7
10 2
16 3
8 1
16 12
16 7
5
2 3
3 4
3 1
1 5
3 5
','4
3
','TREE'),
                                                                                                                (10569,'BAEKJOON','https://www.acmicpc.net/problem/4009',4009,'순찰','1초','64 MB',24,'<p>
	1부터 N까지 번호가 붙여진 N개의 마을과, 이들 마을을 모두 연결하는 N-1개의 도로가 있다. 각 도로는 정확히 두 마을을 연결하며, 임의의 마을로부터 다른 모든 마을까지 이들 도로들만 이용하여 갈 수 있다. 각 도로의 길이는 1이다.</p>

<p>
	이들 모든 마을에 있는 사람들의 안전을 보장하기 위하여 순찰대가 매일 모든 도로를 방문하여야 한다. 경찰서는 마을 1에 있다. 그러므로 경찰관은 매일 마을 1에서 출발하여 마지막으로 마을 1로 돌아와야 한다.</p>

<p>
	8개의 마을로 구성된 아래의 예를 보자. 마을은 동그라미로 표시되어 있고, 경찰서가 있는 마을 1은 검은색 동그라미로 표시되어 있다. 마을을 연결하는 선분은 도로를 나타낸다. 순찰대가 매일 모든 도로를 방문하기 위하여, 순찰대가 방문해야 하는 전체거리는 14이다.</p>

<p>
	순찰대는 하루의 임무를 완성하기 위하여 각 도로를 2번만 방문해야 함에 유의하라.</p>

<p>
	<img alt="" src=https://www.acmicpc.net/upload/images/patrol1.png" style="width: 159px; height: 143px;"></p>

<p>
	순찰대가 모든 도로를 방문하는데 필요한 전체거리를 줄이기 위하여 이들 마을 사이에 K개의 지름길을 새로 만들기로 하였다. 각 지름길은 두 개의 마을을 연결한다. 두 지름길이 같은 마을에서 시작할 수 있다(아래 예 (c) 참고). 심지어 지름길이 루프일 수 있다; 즉 마을 자신을 연결할 수 있다.</p>

<p>
	예산이 제한되어 있으므로, K는 1 혹은 2이다. 또한, 돈이 쓸데없이 낭비되지 않도록 하기 위하여 순찰대는 하루에 각 지름길을 정확하게 한번 방문하여야 한다.&nbsp;</p>

<p>
	다음의 예를 보자.</p>

<p>
	<img alt="" src=https://www.acmicpc.net/upload/images/patrol2.png" style="width: 334.167px; height: 120.833px;"></p>

<p>
	예 (a)에서는 지름길 하나를 건설한 것으로 순찰대가 방문하는 도로의 전체 길이는 11이다. 예 (b)에서는 지름길 두 개를 건설한 것으로, 순찰대가 방문하는 도로의 전체 길이는 10이다. 예 (c)에서는 지름길을 두 개 건설하였는데 순찰대가 방문하는 도로의 전체 길이는 15이다. 이는 순찰대가 각 지름길을 정확하게 한번 지나가야 하는 조건 때문이다.&nbsp;</p>

<p>
	마을사이의 도로와 건설하여야 할 지름길의 수를 읽어 매일 순찰대가 방문하여야 하는 전체 거리를 최소하도록 하기위하여 지름길을 어디에 건설해야하는지를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>
	첫 번째 줄에 두 정수 N(3 ≤ N ≤ 100,000)과 K(1 ≤ K ≤ 2)가 주어진다. 다음의 N-1개의 각 줄에 각 도로의 정보가 주어진다. 각 줄은 하나의 도로가 연결하는 두 마을의 번호를 나타내는 두 개의 정수 A와 B(1 ≤ A, B ≤ N)를 포함한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	K개의 지름길을 건설하여, 순찰대가 방문하여야 하는 전체거리의 최솟값인 정수 하나를 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8 1
1 2
3 1
3 4
5 3
7 5
8 5
5 6
','11
','TREE'),
                                                                                                                (10558,'BAEKJOON','https://www.acmicpc.net/problem/4016',4016,'모빌','1초','128 MB',17,'<p>
	어린 남동생 Ike 를 위해 선물을 사려고 한다. 그러나 Ike 는 선물에 대해 아주 특이한 취향이 있다. Ike 는 특정 형태로 구성된 선물 만을 좋아한다.&nbsp;</p>

<p>
	한 가게에서 모빌을 팔고 있는 것을 발견하였다. 모빌은 여러 층으로 구성된 장식으로 보통 천정에 매달아 놓는다. 각각의 모빌은 수평인 막대들이 아래 그림과 같이 줄로 매어져 있는 것이다. 각 수평 막대의 양 끝에 줄이 매어 있으며, 이 줄은 또 다른 수평 막대에 묶여 있거나 아니면 장난감이 묶여 있다.&nbsp;</p>

<p>
	아래의 그림은 모빌의 한 예를 보여 준다:</p>

<p>
	<img alt="" src=https://www.acmicpc.net/upload/images/mobile.png" style="width: 378px; height: 122px;"></p>

<p>
	동생 Ike 를 만족 시키기 위하여, 다음과 같은 제약 조건을 만족하도록 구성을 바꿀 수 있는 모빌을 찾아야 한다:&nbsp;</p>

<p>
	(i) 모든 장난감은 같은 레벨에 매달려 있거나 또는 임의의 두 장난감이 같은 레벨이 아니라면 레벨의 차이는 1이다. (장난감의 레벨이란 천정까지 연결된 수평 막대의 수를 일컬은다.)&nbsp;</p>
<p>
	(ii) 만일 두 개의 장난감이 매달린 레벨이 다르다면, 왼쪽에 있는 장난감이 오른쪽의 장난감보다 아래에 있어야 한다.&nbsp;</p>

<p>
	모빌들은 막대의 양끝의 줄을 바꾸어 매어 구성을 바꿀 수 있다. 이는 막대의 왼쪽과 오른쪽 끝에 매어 있는 줄을 풀어 반대쪽 끝에 (즉, 각각 오른쪽과 왼쪽 끝에) 다시 매어 놓으면 된다. 이런 작업은 그 밑에 매달려있는 막대나 장난감의 구성을 변화시키지는 않는다.&nbsp;</p>

<p>
	여러분들은 정보올림피아드를 위하여 훈련하여 왔으므로, 단련한 실력을 발휘하여 주어진 모빌이 Ike 가 좋아하는 선물이 되도록 구성을 바꿀 수 있는지를 결정하는 알고리즘을 설계하여라.&nbsp;</p>

<p>
	예로서, 앞의 그림에 주어진 모빌을 고려하여 보자. Ike 는 이 모빌을 좋아하지 않을 것이다. 이 모빌은 제약조건 (i)을 만족하지만 조건 (ii)는 만족하지 못한다 ? 가장 왼쪽 끝에 있는 장난감이 오른쪽에 있는 장난감들 보다 높은 레벨에 놓여있다.&nbsp;</p>

<p>
	그러나 이 모빌은 Ike 가 좋아하는 모습으로 바꿀 수 있다. 아래와 같이 바꾸면 된다</p>

<p>
	1. 우선 1번 막대의 양쪽 끝을 서로 바꾼다. 이런 바꿈으로 2번 막대와 3번 막대의 위치가 바뀌게 되어, 그 결과는 아래의 그림과 같이 된다.&nbsp;</p>

<p>
	<img alt="" src=https://www.acmicpc.net/upload/images/mobile2.png" style="width: 373px; height: 118px;"></p>

<p>
	2. 그 다음으로, 2번 막대의 양쪽 끝을 서로 바꾼다. 이렇게 하면 4번 막대가 2번 막대의 왼쪽 끝으로, 장난감은 오른쪽 끝으로 옮겨지게 된다.</p>

<p>
	<img alt="" src=https://www.acmicpc.net/upload/images/mobile3.png" style="width: 335px; height: 99.1667px;"></p>

<p>
	이 결과는 Ike 가 좋아하는 구성이 된다. 모든 장난감들이 매달린 레벨의 차이는 많아야 1 이며, 아래 레벨에 있는 장난감들은 위 레벨에 있는 장난감들 보다 모두 왼쪽에 위치하고 있다.&nbsp;</p>

<p>
	여러분들이 수행하여야 할 작업은 주어진 모빌에 대하여, Ike 가 좋아하는 모습으로 다시 구성하려고 할 때 (만일 가능하다면), 막대의 양쪽 끝의 줄을 서로 바꾸어 매는 작업의 최소 회수를 결정하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">

<p>
	입력의 첫째 줄에 모빌에 있는 막대의 수를 나타내는 정수 n 이 주어진다 (1 ≤ n ≤ 100,000). 막대들은 1 부터 n 까지 번호가 매겨져 있다.&nbsp;</p>

<p>
	그 다음 n 줄은 각 막대의 연결을 보여준다. 이들 중 i 번째 줄은 i 번 막대의 연결을 보여준다. 이들 각 줄에는 두 개의 정수 l 과 r 이 빈칸 하나를 사이에 두고 주어진다. l 과 r 은 각각 막대의 왼쪽 끝과 오른쪽 끝에 무엇이 매달려 있는지를 보여준다. 만일 장난감이 매달려 있으면 해당되는 정수 l 또는 r 은 -1 이고, 막대가 매달려 있으면 해당되는 정수 l 또는 r 은 그 막대의 번호가 주어진다.&nbsp;</p>

<p>
	만일 i 번 막대 아래에 다른 막대가 매어져 있는 경우, 그 막대의 번호는 반드시 i 보다 크게 주어진다. 모빌의 맨 위에 위치한 막대의 번호는 1 번이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>
	첫 줄에 Ike 가 좋아하는 모습으로 모빌을 다시 구성할 때, 필요한 막대의 양쪽 끝의 줄을 서로 바꾸어 매는 작업의 최소 회수를 나타내는 정수 하나를 출력한다. 만일 구성이 불가능하면, -1 을 출력하여야 한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>
	입력 예는 제일 처음 주어진 그림에 대한 입력을 나타낸다.&nbsp;</p>

				</div>
				</div>','6
2 3
-1 4
5 6
-1 -1
-1 -1
-1 -1
','2
','TREE'),
                                                                                                                (10572,'BAEKJOON','https://www.acmicpc.net/problem/4256',4256,'트리','1초','192 MB',14,'<p>이진 트리는 매우 중요한 기본 자료 구조이다. 아래 그림은 루트 노드가 유일한 이진 트리이다. 모든 노드는 최대 2개의 자식 노드를 가질 수 있으며, 왼쪽 자식이 순서가 먼저이다. 노드 n개로 이루어진 이진 트리를 BT라고 하자. BT의 노드는 1부터 n까지 유일한 번호가 매겨져 있다.</p>

<p>아래 그림에 나와있는 BT의 루트는 3번 노드이다. 1번 노드는 오른쪽 자식만 가지고 있고, 4와 7은 왼쪽 자식만 가지고 있다. 3과 6은 왼쪽과 오른쪽 자식을 모두 가지고 있다. 나머지 노드는 모두 자식이 없으며, 이러한 노드는 리프 노드라고 부른다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/tree(2).png" style="height:183px; width:250px"></p>

<p>BT의 모든 노드를 순회하는 방법은 전위 순회(preorder), 중위 순회(inorder), 후위 순회(postorder)로 총 세 가지가 있다. 이 세 방법은 아래에 C 스타일의 의사 코드로 나와 있다. BT의 노드 v에 대해서, v.left는 왼쪽 자식, v.right는 오른쪽 자식을 나타낸다. v가 왼쪽 자식이 없으면 v.left는 ?와 같고, 오른쪽 자식이 없으면 v.right는 ?와 같다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/treeorder.png" style="height: 86.6667px; width: 395px;"></p>

<p>BT를 전위 순회, 중위&nbsp;순회한 결과가 주어진다. 즉, 위의 함수 중 preorder(root node of BT)와 inorder(root node of BT)를 호출해서 만든 리스트가 주어진다. 두 순회한 결과를 가지고 다시 BT를 만들 수 있다. BT의 전위, 중위 순회한&nbsp;결과가 주어졌을 때, 후위&nbsp;순회했을 때의 결과를 구하는 프로그램을 작성하시오.</p>

<p>예를 들어, 위의 그림을 전위 순회하면 3,6,5,4,8,7,1,2, 중위 순회하면 5,6,8,4,3,1,2,7이 된다. 이를 이용해 후위 순회하면 5,8,4,6,2,1,7,3이 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 노드의 개수 n이 주어진다. (1 ≤ n ≤ 1,000) BT의 모든 노드에는 1부터 n까지 서로 다른 번호가 매겨져 있다. 다음 줄에는 BT를 전위 순회한 결과, 그 다음 줄에는 중위 순회한 결과가 주어진다. 항상 두 순회 결과로 유일한 이진 트리가 만들어지는 경우만 입력으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 후위 순회한 결과를 출력 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
4
3 2 1 4
2 3 4 1
8
3 6 5 4 8 7 1 2
5 6 8 4 3 1 2 7
','2 4 1 3
5 8 4 6 2 1 7 3
','TREE'),
                                                                                                                (10571,'BAEKJOON','https://www.acmicpc.net/problem/4315',4315,'나무 위의 구슬','1초','128 MB',16,'<p>루트가 있는 트리의 정점 위에 박스 N개가 놓여져 있다. 각 정점은 1부터 n까지 번호가 매겨져 있으며, 1 ≤ n ≤ 10000이다. 박스는 구슬을 몇 개 포함하고 있거나 비어있다. 구슬의 총 개수는 n이다.</p>

<p>원섭이는 모든 박스에 들어있는 구슬의 개수를 1개로 만들려고 한다. 한 박스에 들어있는 구슬 하나를 인접한 정점으로 옮기는 것이 한 번 움직이는 것이다. 이때, 총 몇 번 움직이면 모든 박스에 들어있는 구슬의 개수가 1개가 되는지 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 n이 주어지며, n은 정점의 개수이다. 다음 n개 줄에는 각 정점의 정보가 주어진다. 첫 번째 숫자는 정점의 번호 v이다. v다음에 나오는 숫자는 처음에 v에 놓여져 있는 박스에 들어 있는 구슬의 개수이고, 그 다음에 나오는 숫자는 자식의 수 d이다. 다음 d개 숫자는 v의 자식 번호이다.</p>

<p>n = 0인 경우에 입력이 끝나며, 이 경우는 답을 구하면 안 된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 입력에 대해서, 모든 박스에 구슬을 한 개로 만드는 움직임 횟수의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9
1 2 3 2 3 4
2 1 0
3 0 2 5 6
4 1 3 7 8 9
5 3 0
6 0 0
7 0 0
8 2 0
9 0 0
9
1 0 3 2 3 4
2 0 0
3 0 2 5 6
4 9 3 7 8 9
5 0 0
6 0 0
7 0 0
8 0 0
9 0 0
9
1 0 3 2 3 4
2 9 0
3 0 2 5 6
4 0 3 7 8 9
5 0 0
6 0 0
7 0 0
8 0 0
9 0 0
0
','7
14
20
','TREE'),
                                                                                                                (10583,'BAEKJOON','https://www.acmicpc.net/problem/5477',5477,'마라톤 훈련 방해하기','1초','128 MB',23,'<p>상근이와 선영이는 보스턴 마라톤에 참가하기 위해 열심히 훈련하고 있다. 대회가 얼마 남지 않았기 때문에, 오늘은 훈련 계획을 세워보려고 한다.</p>

<p>두 사람이 살고있는 나라에는 도시가 N개, 도로가 M개 있다. 모든 도로는 두 도시를 연결하며, 양방향으로 이동할 수 있다. 도로 중에서 N-1개는 포장되어 있고, 나머지는 포장되어 있지 않다.</p>

<p>한 도시에서 다른 도시로 이동할 때, 항상 포장된 도로만을 사용해서 이동할 수 있다. 즉, N개의 도시와 N-1개의 포장된 도로는 트리 구조를 이루고 있다.</p>

<p>또, 한 도시와 연결되어 있는 도로는 최대 10개이다.</p>

<p>마라톤 훈련은 도시에서 시작해서, 도로를 돌아다닌 다음, 시작한 도시로 다시 돌아와서 끝난다. 상근이와 선영이는 훈련하면서 아름다운 풍경도 감상하려고 한다. 따라서, 그들은 이미 지나간 도시를 다시 지나가지 않을 것이고, 지난 도로도 다시 지나지 않을 것이다.</p>

<p>훈련을 시작 하는 도시는 어느곳이 되어도 상관없고, 모든 도시를 방문하지 않아도 된다.</p>

<p>뒤에서 달리는 것이 앞에서 달리는 것보다 더 편하다. 그 이유는 앞에서 달리는 사람이 바람을 막아주기 때문이다. 따라서, 상근이와 선영이는 도시에 들어갈 때 마다 자리를 서로 바꿀 것이다. 또, 서로 훈련한 양이 같아야 하기 때문에 짝수 개의 도로를 지나려고 한다.</p>

<p>상근이와 선영이의 경쟁자 상덕이와 희원이는 위의 조건을 만족시키는 경로를 없애기 위해 포장되어 있지 않은 도로의 일부를 폭파시키기로 했다. 각각의 포장되어 있지 않은 도로를 폭파시키는 비용은 입력으로 주어진다. (비용은 양수) 또, 포장된 도로는 폭파시킬 수 없다.</p>

<p>도시와 도로 네트워크가 주어졌을 때, 상근이와 선영이의 훈련 조건을 만족시키는 경로가 없게하기 위해서 필요한 폭파 비용의 최솟값을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 도시의 수 N과 도로의 수 M이 주어진다. (2 ≤ N ≤ 1,000, N-1 ≤ M ≤ 5,000)</p>

<p>다음 M개 줄에는 A, B, C가 주어진다. (1 ≤ A, B ≤ N, 0 ≤ C ≤ 10,000) A와 B는 서로 다르며, 도로가 연결하는 도시를 나타낸다. C가 0인 경우는 포장된 도로이다. 포장되어 있지 않은 도로인 경우에는 C값이 양수이며, 이 값은 그 도로를 폭파시키는데 필요한 비용이다.</p>

<p>모든 도시는 많아야 10개 도로와 연결되어져 있다. 또, 한 도시 쌍을 연결하는 도로는 한 개를 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 상근이와 선영이의 훈련 조건을 만족시키는 경로를 없애기 위한 폭파 비용의 최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p><img alt="" src=https://www.acmicpc.net/upload/images/pave.png" style="height:282px; width:334px"></p>

<p>위의 그림은 예제를 그래프로 나타낸 것이다. 굵은 도로는 포장된 도로이다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/pave2.png" style="height:158px; width:905px"></p>

<p>상근이와 선영이의 훈련 조건을 만족 시키는 경로는 위와 같이 다섯 가지가 있다. 만약, 도로 1-3, 3-5, 2-5를 폭파시킨다면, 상근이와 선영이는 훈련을 할 수 없다. 이때, 총 폭파 비용은 5이다.</p>

<p>도로 2-4와 2-5를 폭파시켜도 된다. 하지만, 총 폭파 비용이 6이 된다.&nbsp;</p>

				</div>
				</div>','5 8
2 1 0
3 2 0
4 3 0
5 4 0
1 3 2
3 5 2
2 4 5
2 5 1
','5
','TREE'),
                                                                                                                (10580,'BAEKJOON','https://www.acmicpc.net/problem/5639',5639,'이진 검색 트리','1초','256 MB',11,'<p>이진 검색 트리는 다음과 같은 세 가지 조건을 만족하는 이진 트리이다.</p>

<ul>
	<li>노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작다.</li>
	<li>노드의 오른쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 크다.</li>
	<li>왼쪽, 오른쪽 서브트리도 이진 검색 트리이다.</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/bsearchtree.png" style="height: 201.667px; width: 355px;"></p>

<p>전위 순회 (루트-왼쪽-오른쪽)은 루트를 방문하고, 왼쪽 서브트리, 오른쪽 서브 트리를 순서대로 방문하면서 노드의 키를 출력한다. 후위 순회 (왼쪽-오른쪽-루트)는 왼쪽 서브트리, 오른쪽 서브트리, 루트 노드 순서대로 키를 출력한다. 예를 들어, 위의 이진 검색 트리의 전위 순회 결과는 50 30 24 5 28 45 98 52 60 이고, 후위 순회 결과는 5 28 24 45 30 60 52 98 50 이다.</p>

<p>이진 검색 트리를 전위 순회한 결과가 주어졌을 때, 이 트리를 후위 순회한 결과를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>트리를 전위 순회한 결과가 주어진다. 노드에 들어있는 키의 값은 10<sup>6</sup>보다 작은 양의 정수이다. 모든 값은 한 줄에 하나씩 주어지며, 노드의 수는 10,000개 이하이다. 같은 키를 가지는 노드는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력으로 주어진 이진 검색 트리를 후위 순회한 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','50
30
24
5
28
45
98
52
60
','5
28
24
45
30
60
52
98
50
','TREE'),
                                                                                                                (10582,'BAEKJOON','https://www.acmicpc.net/problem/5646',5646,'트리 경로','1초','128 MB',20,'<p>간선에 방향성이 있는 트리(사이클이 없는 연결 그래프)가 주어진다. 트리에 특별 경로를 가능한 적게 추가해서, 모든 노드에서 다른 노드로 이동할 수 있게 하는 프로그램을 작성하시오.</p>

<p>특별 경로는 아래와 같은 규칙을 지켜야 한다.</p>

<ol>
	<li>특별 경로는 연속된 간선과 정점으로 이루어져 있어야 한다.</li>
	<li>특별 경로의 모든 간선은 원래 트리에 있던 간선과 반대 방향이어야 한다.</li>
	<li>특별 경로에서 모든 노드와 간선은 최대 1번 방문할 수 있다.</li>
	<li>두 개 이상의 특별 경로가 같은 노드나 간선을 공유할 수 있다.</li>
</ol>

<p>아래 트리를 살펴보자. 검정 간선은 원래 트리의 간선을 나타내고, 동그라미는 노드를 나타낸다. 그 다음, 두 개의 특별 경로 2-1-0(초록색)과 3-1(파란색)를 추가한다. 3-1대신에 3-1-0을 추가해도 된다. 하지만, 1-3이나 0-1-2는 규칙 2 때문에 추가할 수 없고, 0-2와 2-3-0은 규칙 1 때문에 추가할 수 없다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/specialpath.png" style="height:118px; width:110px"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T(≤30)이 주어진다.</p>

<p>각 테스트 케이스의 첫째 줄에는 노드의 수 N이 주어진다. (2 ≤ N ≤ 20000) 노드는 0번부터 N-1번까지 번호가 매겨져 있다. 다음 N-1줄에는 간선 정보를 나타내는 u와 v가 주어진다. (0 ≤ u, v < N, u ≠ v) u에서 v로 향하는 간선이라는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 케이스 번호와 모든 노드가 서로 연결될 수 있게 하기 위해서 추가해야 하는 특별 경로 개수의&nbsp;최솟값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
4
0 1
1 2
1 3
5
0 1
1 2
1 3
0 4
','Case 1: 2
Case 2: 3
','TREE'),
                                                                                                                (10585,'BAEKJOON','https://www.acmicpc.net/problem/5813',5813,'이상적인 도시','1초','256 MB',24,'<p>당대의 많은 이탈리아 과학자들과 예술가들처럼 다빈치는 도시 계획과 디자인에 대단한 관심이 있었다. 다빈치는 편안하고, 공간을 넓고 합리적으로 사용하며, 중세 시대 도시의 좁고 답답함과는 거리가 먼 이상적인 도시를 디자인할 계획을 가지고 있었다</p>

<p>무한 개 네모 셀들의 격자 위에 N 개의 블록들을 놓아서 도시를 만든다. 각 셀은 좌표들의 쌍 (행, 열)로 나타낸다. (i, j) 셀이 주어지면, 인접한 셀들은 (i-1, j), (i+1, j), (i, j-1) 그리고 (i, j+1) 이다. 그리드 위에 놓여질 때, 각 블록은 정확히 하나의 셀을 덮는다. 블록은 1 ≤ i, j ≤ 2<sup>31</sup>- 2 인 셀 (i, j) 에만 놓을 수 있다. 셀들 위에 놓여진 블록들을 나타낼 때, 셀들의 좌표를 사용할 것이다. 두 블록이 서로 인접한 셀들에 놓여지면 두 블록은 인접했다고 말한다. 이상적인 도시에서 모든 블록들은 도시안에 구멍이 없도록 연결된다. 다시 말해서, 셀들은 아래의 조건들을 만족해야만 한다.</p>

<ol>
	<li>임의의 두 비어 있는 셀들에 대해서, 인접한 비어 있는 셀들로만 이동하는 방법으로 한 셀에서 다른 셀에 도달할 수 있는 경로가 적어도 하나 이상 존재한다.</li>
	<li>임의의 두 비어있지 않은 셀들에 대해서, 인접한 비어있지 않은 셀들로만 이동하는 방법으로 한 셀에서 다른 셀에 도달할 수 있는 경로가 적어도 하나 이상 존재한다.</li>
</ol>

<p>아래 그림 모두는 이상적인 도시가 아니다. 처음 두 개는 첫 번째 조건을 만족하지 않고, 세 번째 그림은 두 번째 조건을 만족하지 않고, 네 번째 그림은 두 조건 모두를 만족하지 않는다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/efe39e13-9b18-42c7-9195-00bfb0ec8da0/-/preview/" style="width: 357.5px; height: 81.6667px;"></p>

<p>도시 안을 이동할 때, 걸음은 한 블록에서 인접한 블록으로 이동하는 것을 말한다. 비어있는 셀들로는 이동할 수 없다. v<sub>0</sub>, v<sub>1</sub>, …, v<sub>N-1</sub> 을 그리드 위에 놓여 있는 N 개 블록들의 좌표라고 하자. 좌표 v<sub>i</sub> 와 vj 를 가진 임의의 서로 다른 두 블록들에 대해서, 그들간의 거리 d(vi, vj)는 이 블록들 중 하나에서 다른 곳으로 가는데 요구되는 걸음들의 최소 수로 정의된다.</p>

<p>아래 그림은 좌표 v<sub>0</sub> = (2, 5), v<sub>1</sub> = (2, 6), v<sub>2</sub> = (3, 3), v<sub>3</sub> = (3, 6), v<sub>4</sub> = (4, 3), v<sub>5</sub> = (4, 4), v<sub>6</sub> = (4, 5), v<sub>7</sub> = (4, 6), v<sub>8</sub> = (5, 3), v<sub>9</sub> = (5, 4), 그리고 v<sub>10</sub> = (5, 6) 를 가지는 N = 11 개의 블록들로 이루어진 이상적인 도시를 나타낸다. 그러면, d(v<sub>1</sub>, v<sub>3</sub>) = 1, d(v<sub>1</sub>, v<sub>8</sub>) = 6, d(v<sub>6</sub>, v<sub>10</sub>) = 2, 그리고 d(v<sub>9</sub>, v<sub>10</sub>) = 4 이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/e68edeca-dfbf-4b6e-a99b-a3e77e008efb/-/preview/" style="width: 213px; height: 206px;"></p>

<p>당신은 모든 가능한 i < j 인 두 블록 쌍 v<sub>i</sub>와 v<sub>j</sub>에 대한 거리들의 합을 계산하는 프로그램을 작성해야 한다. 정확히 말하면, 프로그램은 다음의 합을 계산해야 한다.</p>

<p style="text-align: center;">∑d(v<sub>i</sub>, v<sub>j</sub>), 단, 0 ≤ i < j ≤ N - 1</p>

<p>구체적으로, 도시를 나타내는 N 과 두 배열 X 와 Y 가 주어 질때, 위 공식을 계산하는 함수 DistanceSum(N, X, Y) 를 구현해야 한다. 배열 X 와 Y 는 크기 N 이고, 0 ≤ i ≤ N - 1 에 대해서, 블록 i 는 좌표 (X[i], Y[i])를 가지고 1 ≤ X[i], Y[i] ≤ 2<sup>31</sup>- 2 이다. 결과가 32비트를 사용해서 표현하기에 너무 클 수 있기 때문에 결과를 1,000,000,000 으로 나눈 나머지로 계산한다.</p>

<p>위의 예제에서 11 × 10 / 2 = 55 개의 블록 쌍이 존재한다. 모든 쌍 간의 거리들의 합은 174 이다</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N이 주어진다. 다음 줄부터 N개 줄에는 블록의 좌표 X[i]와 Y[i]가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 가능한 i < j인 두 블록 쌍 v<sub>i</sub>와 v<sub>j</sub>에 대한 거리들의 합을 1,000,000,000 으로 나눈 나머지를&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','11
2 5
2 6
3 3
3 6
4 3
4 4
4 5
4 6
5 3
5 4
5 6
','174
','TREE'),
                                                                                                                (10596,'BAEKJOON','https://www.acmicpc.net/problem/5820',5820,'경주','3초','256 MB',22,'<p>IOI 를 개최하는 파타야 시는 경주대회인 IOR 2011 도 함께 개최하며 이를 위해 가장 적합한 경주코스를 찾고 있다.</p>

<p>파타야 인근 지역에는 N 개의 도시가 있고 N-1 개의 고속도로가 이 도시들을 연결하고 있다. 각 고속도로는 양방향이며 서로 다른 두 개의 도시를 연결한다. 각 고속도로의 길이는 킬로미터 단위로 나타내며 정수 값이다. 그리고 임의의 두 도시는 직접 고속도로로 연결되지 않더라도 단 하나의 경로에 의해 연결된다. 즉, 같은 도시를 두 번 이상 방문하지 않고 한 도시에서 출발하여 다른 도시에 도착하는 방법은 유일하다.</p>

<p>IOR 에 사용되는 경주코스는 출발 도시와 도착 도시가 서로 달라야 하며 길이는 정확하게 K 킬로미터인 경로이다. 그리고 충돌을 방지하기 위해 한 고속도로를 두 번 이상 사용하지 않는다. (따라서 한 도시도 두 번 이상 방문하지 않는다.) 또한 교통체증을 줄이기 위해 되도록 가장 작은 수의 고속도로를 사용하여 경주코스를 구성하려고 한다.</p>

<p>다음의 파라미터를 받는 best_path(N,K,H,L) 함수를 작성하라.</p>

<ul>
	<li>N ? 도시의 수. 각 도시는 0 번부터 N-1 번까지 정수로 나타낸다.</li>
	<li>K ? 경주코스의 길이.</li>
	<li>H ? 각 고속도로를 나타내는 2 차원 배열. 고속도로 i (0 ≤ i < N-1)는 도시 H[i][0]와 도시 H[i][1]를 연결하는 도로이다.</li>
	<li>L ? 고속도로의 길이를 나타내는 1 차원 배열. 고속도로 i (0 ≤ i < N-1)의 길이는 L[i]이다.</li>
</ul>

<p>배열 H 에 저장된 값은 0 이상 N-1 이하이다. 또한 배열 L 에 저장된 값은 0 이상 1 000 000 이하의 정수이다. 그리고 모든 도시들은 연결되어 있다.</p>

<p>당신이 작성한 함수는 길이가 K 인 경주코스 중에서 고속도로 수가 가장 작은 경주코스의 고속도로 수를 반환한다. 만약 길이가 K 인 경주코스가 없다면 -1 을 반환하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 K가 주어진다. 둘째 줄부터 N-1개 줄에는 H[i][0], H[i][1], L[i]가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>best_path(N,K,H,L)가 리턴한 값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
0 1 1
1 2 2
1 3 4
','2
','TREE'),
                                                                                                                (10603,'BAEKJOON','https://www.acmicpc.net/problem/5979',5979,'납땜하기','2초','128 MB',26,'<p>소들이 전선을 가지고 놀고 있다! 소들이 익힌&nbsp;납땜 기술은&nbsp;한 전선의 끝 부분을 다른 전선의 중간에 붙이는 것이다.(전선의 끝과 끝을 납땜하는 것은 허용되지 않는다.) 여러 전선이 한 부분에 납땜될 수도 있다.</p>

<p>소들은 자신들의 납땜 기술을 이용해 멋진 구조물을 만들고자 한다. 소들이 만들고자 하는 구조물은&nbsp;서로 이어진&nbsp;N개(1 <=&nbsp;N <=&nbsp;50,000)의 정점과 N-1개의 단위 길이 간선으로 이루어진다. 각 간선은 두 쌍의 정수&nbsp;A와 B로 구성되며,(1 <= A <= N; 1 <= B <= N; A != B) 이는 간선 양 끝의 정점 번호를 의미한다.</p>

<p>소들은 구조물을 만들기 위해 전선을 구입하려고 한다. 당연하게도 긴 전선은 비싸다. 구체적으로 말하자면 길이 L짜리 전선은 L*L 가격이 든다. 안타깝게도&nbsp;전선을 자르거나 붙여서 사용할 수는 없다.</p>

<p>구조물의 설계도가 주어질 때, 소들은 전선들을 납땜해 구조물을&nbsp;가장 저렴한 비용으로 만들고자 한다. 소들을 도와 소모되는&nbsp;최저비용을 계산해보자.</p>

<p>점수의 50%에 해당하는&nbsp;테스트&nbsp;데이터는 N이 2,000보다 작다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<ul>
	<li>첫 번째 줄: 정수 N</li>
	<li>2~N번째 줄:&nbsp;각 간선을 나타내는 정수 A와 B가 차례대로 입력된다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 멋진 구조물을 만드는데 드는 최소비용을 출력한다. 정답이 32비트 정수형을 넘을 수도 있다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>구조물의&nbsp;모든 정점이 1번 정점에 연결되어 있기 때문에, 길이 2짜리 전선 하나와 길이 1짜리 전선 세 개를 구매하면 된다. 총 비용은 2*2 + 1*1 * 3 = 7이 소모된다.</p>

				</div>
				</div>','6
1 2
1 3
1 4
1 5
1 6
','7
','TREE'),
                                                                                                                (10588,'BAEKJOON','https://www.acmicpc.net/problem/6597',6597,'트리 복구','1초','128 MB',13,'<p>창영이는 바이너리 트리를 매우 좋아한다. 그가 가장 좋아하는 게임은 바이너리 트리를 만들고, 노드에 알파벳 대문자를 하나씩 쓰는 것이다. 같은 알파벳을 여러 노드에 쓰지 않는다.</p>

<p>아래는 창영이가 만든 한 바이너리 트리이다.</p>

<pre>                                               D
                                              / \
                                             /   \
                                            B     E
                                           / \     \
                                          /   \     \
                                         A     C     G
                                                    /
                                                   /
                                                  F</pre>

<p>창영이는 후손들에게 물려주기 위해서, 만든 트리를 항상 종이에 적어놓는다. 이때, 트리를 프리오더 순회한 결과와 인오더로 순회한 결과를 적어 놓는다. 위의 트리를 프리오더로 순회하면 DBACEGF가 되고, 인오더로 순회하면 ABCDEFG가 된다. 창영이는 이 두 순서만 있으면, 트리를 만들 수 있다고 생각했기 때문에, 포스트오더로 순회한 결과는 적지 않았다.</p>

<p>몇 년이 지난 후, 종이를 보고 트리를 다시 만들려고 했다. 하지만 너무 귀찮은 나머지 프로그램을 작성하려고 한다. 트리를 프리오더와 인오더로 순회한 결과가 주어졌을 때, 포스트오더로 순회한 결과를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 하나 또는 그 이상의 테스트 케이스로 이루어져 있다.</p>

<p>각 테스트 케이스는 한 줄로 이루어져 있고, 프리오더로 순회한 결과와 인오더로 순회한 결과가 공백으로 구분되어져 있다. 두 문자열의 길이는 항상 같으며, 26자를 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스에 대해서, 입력으로 주어진 트리를 포스트오더로 순회한 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','DBACEGF ABCDEFG
BCAD CBAD
','ACBFGED
CDAB
','TREE'),
                                                                                                                (10614,'BAEKJOON','https://www.acmicpc.net/problem/7777',7777,'병원','2초','128 MB',22,'<p>선영이는 대형 병원에서 사용하는 인사 관리 프로그램을 만들고 있다. 가장 먼저 만들고 있는 부분은 직원들의 휴가 관리 프로그램이다.</p>

<p>병원에서 일하는 간호사는 두 종류가 있다. 일반 간호사는 입원해 있는 환자를 간호하는 간호사이고, 특수 간호사는 "수술 간호사", "간호부장"과 같이 특별히 맡은 자리가 있는 간호사이다.</p>

<p>일반 간호사가 휴가를 갔을 때는 다른 간호사가 그 간호사의 업무를 대신해 주면 되기 때문에, 큰 문제가 생기지 않는다. 하지만, 특수 간호사는 반드시 대체자가 있어야지만 휴가를 갈 수 있다. 따라서, 모든 특수 간호사는 자신을 대체할 수 있는 간호사의 목록을 가지고 있다. 만약, 대체 간호사도 특수 간호사인 경우에는 그 대체 간호사도 대체할 간호사를 찾아야 한다. 가끔, 특수 간호사는 대체를 할 수 없어서 휴가를 갈 수 없는 경우도 있다.</p>

<p>아래와 같은 예를 보자. 이 병원에는 총 일곱 명의 간호사가 있다. Alice, Bob, Clara, Dona, Emma는 특수 간호사이고, Fiona, Gloria는 일반 간호사이다. 누가 누구를 대체할 수 있는지는 아래 그림에 화살표로 나타나있다. (A에서 B로 가는 화살표는 A가 B를 대체할 수 있다는 의미)</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/nurse.png" style="height: 76.6667px; width: 361.667px;"></p>

<p>위의 예제에서 Dona와 Emma는 휴가를 절대로 갈 수 없다. 그 이유는 서로가 서로를 대체하기 때문에, 한 명이 휴가를 갔을 때, 휴가를 가지 않은 한 사람이 두 업무를 동시에 맡을 수 없기 때문이다. Alice, Bob, Clara는 휴가에 갈 수 있다. 하지만, Gloria는 동시에 Bob과 Clara를 대체할 수 없기 때문에, Bob과 Clara는 동시에 휴가를 갈 수 없다.</p>

<p>간호사의 정보가 주어졌을 때, 휴가를 절대로 갈 수 없는 간호사와 휴가를 갈 수는 있지만, 동시에 휴가를 갈 수 없는 간호사의 쌍을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 간호사의 수 n과 특수 간호사의 수 k가 주어진다. 간호사 1번부터 k번까지는 특수 간호사, k+1번부터 n번까지는 일반 간호사이다. (1 ≤ k < n ≤ 1000)</p>

<p>다음 k개 줄에는 가능한 대체 정보가 주어진다. (i+1)번째 줄의 첫 번째 숫자는 i번 간호사를 대체할 수 있는 간호사의 수 d<sub>i</sub>이다. 다음 d<sub>i</sub>개의 숫자는 그 간호사를 대체할 수 있는 간호사의 번호이다. 전체 리스트의 길이는 10,000을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 절대로 휴가를 갈 수 없는 간호사의 수를 출력하고, 다음 줄에는 그러한 간호사의 번호를 모두 출력한다.</p>

<p>다음 줄에는 휴가를 갈 수는 있지만, 동시에 휴가를 갈 수 없는 간호사 쌍의 수를 출력한다. 만약, 쌍의 수가 10,000보다 작거나 같다면, 다음 줄부터 한 줄에 하나씩 그러한 쌍을 출력한다. (쌍 (A,B)와 (B,A)는 같은 쌍이다)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 5
2 6 7
1 7
2 2 7
1 5
1 4
','2
4 5
3
2 3
2 7
3 7
','TREE'),
                                                                                                                (10615,'BAEKJOON','https://www.acmicpc.net/problem/7812',7812,'중앙 트리','3초','128 MB',16,'<p>트리는 사이클을 갖지 않는 연결된 그래프이다.</p>

<p>중앙 정점은 모든 정점으로 이르는 비용의 합이 가장 작은 정점이다. 트리의 정점 개수가 작은 경우에는 모든 경우의 수를 다 계산해보는 프로그램을 이용해 쉽게 구할 수 있다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/treemedian.gif" style="height:156px; opacity:0.9; width:250px"></p>

<p>위의 그림은 가중치가 있는 트리로, 정점의 개수는 5개이다. 이 트리의 중앙 정점은 B이다.</p>

<p>B-A = 2, B-D = 7, B-C = 1, B-E = 7+5=12, 총: 2+1+7+12 = 22</p>

<p>N이 큰 경우에 문제를 풀어보자.</p>

<p>트리를 입력 받아, 모든 정점과 중앙 정점까지 비용의 합을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫 줄에는 트리의 정점의 수 n이 주어진다. (1 ≤ n ≤ 10,000) 각 정점은 0번부터 n-1번까지 번호가 붙여져 있다. 다음 n-1개 줄에는 세 정수 a, b, w가 주어진다. (1 ≤ w ≤ 100) a와 b는 간선을 나타내고, w는 그 간선의 가중치이다.</p>

<p>입력의 마지막 줄에는 0이 하나 주어진다.</p>



					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 모든 정점과 중앙 정점 사이의 비용의 합을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
0 1 2
1 2 1
1 3 7
3 4 5
6
0 1 1
1 2 4
2 3 1
3 4 4
4 5 1
0
','22
21
','TREE'),
                                                                                                                (10622,'BAEKJOON','https://www.acmicpc.net/problem/7993',7993,'후르츠 치킨','3초','128 MB',21,'<p>한 달 가까이 구사과의 이상한 말들을 받아주느라 너무나 힘들었던 캇카흐는, 이제 대담한 복수를 하려고 합니다. 그 복수는 아니나 다를까, 멕카시나의 걸작,&nbsp;후르츠 치킨을 구사과의 집으로 주문하는 것이죠!</p>

<p>구사과가 사는 곳은 매우 특이한 구조를 가지고 있습니다. 이 곳은&nbsp;N개의 도시와 (N-1)개의 양방향 도로로 이루어져 있으며, 모든 도시 쌍 간에 그 두 도시를 잇는 경로가 존재합니다. 동쪽에 있는 도시들에는&nbsp;멕카시나&nbsp;가게들이 있고, 서쪽에 있는 도시들에는 구사과의 집들(맞아요, 구사과는 집이 여러 채 있는 부자에요!)이 있습니다. 물론 멕카시나도, 구사과의 집도 없는 도시도 있습니다.</p>

<p>그리고 이 곳에는 한 가지 더 특이한 점이 있습니다. 멕카시나가 있는 도시에서 구사과의 집으로 향하는 모든 경로는 어떤 특정한 도로를 지나도록 되어있습니다. 그 도로가 잇는 두 도시에는 멕카시나도, 구사과의 집도 없습니다.</p>

<p>캇카흐는 각 가게의 배달원들에게 연락하여, 그들이 어떻게 움직여야 하는지를 명령하려고 합니다. 구사과에게 들키지 않기 위해, 한 도로에 두 명 이상의 배달원(즉 둘 이상의 후르츠 치킨)이 동시에 있어서는 안 됩니다. 하지만 한 도시에 여러 명의 배달원이 대기하는 것은 가능합니다. 각각의 배달원들은 도로가 겹치지만 않는다면 동시에 이동이 가능합니다. 모든 도로를 지나는 데에는 1만큼의 시간이 걸립니다.</p>

<p>구사과에게 최대한 큰 정신적인 타격을 주기 위해서, 캇카흐는 후르츠 치킨이 서로 다른&nbsp;구사과의 집으로 배달되기를 원합니다.&nbsp;즉 어떤 두 치킨이 같은 집으로 배달되어서는 안 됩니다.</p>

<p>결전의 날이 왔습니다. 캇카흐는 모든 멕카시나 가게에 전화를 걸어, 오늘 영업하는 멕카시나 가게의 목록을 알아냈습니다. 캇카흐는 모든 후르츠 치킨이 배달되는 데에 필요한 시간을 최소화하고자 합니다. 구사과의 동네의 구조를 바탕으로, 치킨이 모두 배달되는 최소 시간을 구해주세요!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 번째 줄에는 도시의 수 N, 멕카시나의 가게의 수 W, 그리고 구사과의 집의 수 Z가 주어집니다. (1 ≤ N, W, Z ≤ 10<sup>6</sup>) 도시는 1부터 N까지의 번호가 붙어있으며,&nbsp;멕카시나 가게가 있는 도시는&nbsp;1번부터 W번까지이고, 구사과의 집이 있는 도시는 (N-Z+1)번부터 N번까지입니다.</p>

<p>그 뒤의 (N-1)개의 줄에는 구사과의 동네의 구조에 대한 설명이 주어집니다. 각각의 줄에는 1 이상 N 이하의 정수 a, b가 주어집니다. 이는 a번 도시와 b번 도시를 잇는 도로가 있다는 것을 나타냅니다.</p>

<p>그 다음 줄은 오늘 영업중인 멕카시나 가게의 수를 나타내는 1 이상 W 이하의 정수 P (1 ≤ p ≤&nbsp;min(W, Z))가 주어집니다. 다음 줄에는 1 이상 W 이하의 서로 다른 P개의 정수가 주어집니다. 각각의 정수는 오늘 영업하는 멕카시나 가게가 있는 도시의 번호를 나타냅니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 모든 후르츠 치킨이 배달되는 데에 필요한 최소 시간을 출력하세요.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>화살표는 치킨의 배달 과정을 나타냅니다. 제자리로 돌아오는 화살표는 배달원이 도로를 이용하기 위해 1의 시간만큼 기다렸음을 나타냅니다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/7993/1.png" style="height:223px; width:400px"></p>

				</div>
				</div>','9 2 3
1 3
2 3
4 3
4 5
4 6
7 4
5 8
9 6
2
1 2
','4
','TREE'),
                                                                                                                (10619,'BAEKJOON','https://www.acmicpc.net/problem/8012',8012,'한동이는 영업사원!','1초','128 MB',16,'<p>한동이는 경상도내를 돌아다니면서 열심히 일하는 영업사원이다. 예전에는 자기가 원하는 도시만 골라서 다닐 수 있었지만 시대가 바뀌어서 이제 그렇게는 하지 못하게 되었다. 시대가 바뀜에 따라, 한동이는 회사에서 돌아야 할 도시의 목록을 받고, 그 목록대로 도시를 여행한다. 회사에서 주는 여행지 목록은 정말 안타깝게도 최적화되어 있지가 않다. 여행을 떠나기 전에 한동이는 모든 도시를 방문하는데 걸리는 최소의 시간을 알고싶어하는데, 한동이는 경영학과라 컴퓨터를 하지 못 하기 때문에 여러분이 한동이를 도와주자.</p>

<p>포항 시내의 도시들은 1부터 n까지 번호 지어져 있다. 한동이는 항상 포항시청에서 여행을 시작하고, 포항시청의 번호는 항상 1번이다. 모든 도시들은 양방향 도로로 연결되어있는데 한 도시에서 바로 길이 이어져있는 다른 도시로 이동하는데는 항상 1의 시간이 걸린다. 포항시청에서는 어떤 도시든지 갈 수 있다. 또한 포항의 도로는 굉장히 잘 되어있어서 도로끼리 사이클을 만들지 않는다.</p>

<p>여러분의 목표는 한동이가 모든 도시를 방문하는데 걸리는 최소의 시간을 출력하는 것이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에는 포항에 있는 도시의 숫자 n이&nbsp;주어진다.&nbsp;1 ≤ n ≤ 30,000.&nbsp;</p>

<p>다음 n-1줄에는 도시를 잇는 도로가 주어진다. 각 줄에는 정수 a와 b가 주어진다. 이는 a도시와 b도시를 잇는 도로가 존재한다는 의미이다.&nbsp;(1 ≤ a,b ≤ n; a≠b)</p>

<p>n+1번째 줄에는 정수 m이 주어지는데, 이는 한동이가 방문해야 할 도시의 숫자를 의미한다. 1 ≤ m ≤ 5,000&nbsp;그 후 m개의 줄에는 한 줄에 하나씩 한동이가 방문해야 할 도시의 숫자가 순서대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 한동이가 방문해야 할 모든 도시를 방문 할 수 있는 최소 시간을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
1 5
3 5
4 5
4
1
3
2
5
','7
','TREE'),
                                                                                                                (10629,'BAEKJOON','https://www.acmicpc.net/problem/8169',8169,'소화기 설치','1초','128 MB',24,'<p>Byteasar는 새로운 궁전을 지었다. 그 궁전은 N개의 방과 N-1개의 통로가 방을 잇고 있다. 각각의 통로는 정확히 두 개의 방을 연결한다. 방은 1부터 N까지 번호를 가지며, 궁전으로 가는 유일한 입구는 1번 방이다. 모든 방은 입구에서부터의 경로가 유일하다. 즉, 방들은 트리 구조를 이루고 있다.</p>

<p>이 궁전의 소방국장은 건물 내부에 소화기를 배치하려 한다. 그는 다음의 규칙대로 소화기를 배치할 것이다.</p>

<ul>
	<li>소화기는 방 안에 배치되어야 하며, 하나의 방은 소화기를 몇 개라도 가질 수 있다.</li>
	<li>하나의 소화기는 그 소화기가 위치한 방에서 K개의 통로 이내에 떨어져 있는 방까지 지킬 수 있다. 이를 소화기의 영역이라 하자.</li>
	<li>각각의 방은 하나 이상의 소화기의 영역에 들어야 한다.&nbsp;</li>
	<li>각 소화기는 최대 S개의 방을 영역으로 가질 수 있다.</li>
</ul>

<p>Byteasar는 궁전을 짓느라 국고 대부분을 탕진한 상태다. 따라서 그는 궁전의 모든 방을 화재의 위험에서 벗어나도록 하는 소화기의 배치 중 최소 개수의 소화기가 배치되기를 원한다. Byteasar를 도와주자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>표준 입력의 첫 줄은 N, S, K가 공백을 두고 입력된다. (1 ≤ N&nbsp;≤ 100,000, 1 ≤ S&nbsp;≤ N, 1 ≤ K&nbsp;≤ 20) 다음으로 N-1줄 동안 두 개의 정수가 공백을 두고 입력된다. i+1번째 줄은 x<sub>i</sub>와 y<sub>i</sub>를 입력받는데, 이는 x<sub>i</sub>와 y<sub>i</sub>를 연결하는 간선이라는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>필요한 최소 개수의 소화기를 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p><img alt="" src="https://onlinejudgeimages.s3.amazonaws.com/problem/8169/1.gif" style="height:162px; width:288px"></p>

				</div>
				</div>','12 3 1
1 12
3 8
7 8
8 9
2 12
10 12
9 12
4 8
5 8
8 11
6 8
','4
','TREE'),
                                                                                                                (10632,'BAEKJOON','https://www.acmicpc.net/problem/8872',8872,'빌라봉','1초','256 MB',19,'<p>이 이야기는 세상의 태초에, IOI라는 것은 꿈꿀 수도 없었던 아주 먼 옛날에 생긴 일이다.</p>

<p>0, …, N - 1 까지 번호가 붙여진 N 개의 빌라봉(호수)이 있는 땅에 큰 뱀이 살고 있다. 이 땅에는 M 개의 길이 있고, 각각의 길은 한 쌍의 빌라봉을 연결하며, 이 길을 통해 뱀은 양방향으로 이동할 수 있다. 임의의 빌라봉 쌍은 길을 따라서 (직접 또는 간접적으로) 최대 하나의 경로로 연결이 되어 있다. 단, 어떤 빌라봉 쌍들은 연결되어 있지 않을 수도 있다 (즉, M ≤ N - 1 이다). 뱀이 하나의 길을 지나가는 데에는 며칠의 시간이 걸리는데, 이 시간은 길마다 다를 수 있다.</p>

<p>뱀의 친구 캥거루는 N - M - 1 개의 새로운 길을 만들어 뱀이 모든 빌라봉 쌍 사이를 오갈 수 있도록 하고 싶다. 캥거루는 임의의 두 빌라봉을 선택하여 그 사이에 길을 만들 수 있으며, 캥거루가 만든 길을 통행하는 데에는 항상 L 일이 걸린다.</p>

<p>캥거루는 또한 뱀이 최대한 빨리 이동할 수 있기를 원한다. 캥거루는 임의의 두 빌라봉 사이를 오가는데 드는 최대 시간이 최소가 되도록 길을 만들 것이다. 캥거루가 이렇게 길을 만든 뒤 뱀이 두 빌라봉 사이를 오가는데 드는 최대 시간을 계산하시오.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/9b6a5a7a-c614-4f14-a05a-b0877360a0e2/-/preview/" style="width: 362px; height: 271px;"></p>

<p>위 그림에는 N = 12 개의 빌라봉과 M = 8 개의 길이 있다. 새로 만들어지는 길을 뱀이 통행하는 데에는 2일이 걸린다고 가정하자 (즉, L = 2 이다). 그러면 캥거루는 아래와 같이 세 개의 길을 만들 수 있다.</p>

<ul>
	<li>빌라봉 1과 2 사이,</li>
	<li>빌라봉 1과 6 사이,</li>
	<li>빌라봉 4와 10 사이.</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3591f600-864b-48c7-ba8c-78ffe9311a6f/-/preview/" style="width: 362px; height: 271px;"></p>

<p>모든 길이 만들어진 뒤의 모습이 위 그림에 나타나 있다. 여기서 두 빌라봉 사이의 최대 통행 시간은 18일인데 (빌라봉 0과 11 사이), 이것이 가능한 가장 작은 값이다. 즉, 캥거루가 어떤 식으로 새로운 길을 만들더라도, 뱀이 통행하는 데 18일 이상이 걸리는 빌라봉 쌍이 항상 존재한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 N, M, L이 주어진다. 둘째 줄부터 M개 줄에는 A[i] B[i] T[i]가 주어진다.</p>

<ul>
	<li>N: 빌라봉의 개수</li>
	<li>M: 이미 존재하는 길들의 개수</li>
	<li>L:&nbsp;뱀이 새로 지어진 길을 통행하는데 걸리는 시간 (일 단위).</li>
	<li>A, B, T:&nbsp;이미 존재하는 길들이 연결하는 빌라봉들과 각각을 통행하는데 걸리는 시간을 나타내는 길이가 M인 배열들. i 번째 길은 빌라봉 A[i1]과 B[i-1]을 이으며, 통행 시간은 양방향 모두 T[i-1]일이다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 모든 빌라봉이 연결되고 최대 통행시간이 최소가 되도록 N-M-1개의 길을 만든 뒤의 최대 통행 시간을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12 8 2
0 8 4
8 2 2
2 7 4
5 11 3
5 1 7
1 3 1
1 9 5
10 6 3
','18
','TREE'),
                                                                                                                (10633,'BAEKJOON','https://www.acmicpc.net/problem/9279',9279,'얼어붙은 스프링쿨러','3초','128 MB',13,'<p>이번 겨울은 100년 만에 가장 추운 겨울이라고 한다. 해빈시는 겨울을 대비해서 공원이 망가지지 않다로고 조치를 취하려고 한다. 가장 먼저 스프링쿨러에 남아있는 물을 제거해야 한다.&nbsp;</p>

<p>중앙 노드에서 분배된 물은 모두 파이프를 통해 이웃한 노드로 흘러간다. 모든 노드는 스프링쿨러이거나 물을 분배하는 내부 노드이다. 자세한 설명은 아래에 나와있다.</p>

<ul>
	<li>우물과 직접 연결된 중앙 노드를 제외한 모든 노드는 모두 물을 공급받는 파이프를 단 하나 가지고 있다.</li>
	<li>모든 내부 노드는 다른 노드로 물을 분배하는 파이프를 하나 이상 가지고 있다.&nbsp;즉, 스프링클러는 물을 내보내는 파이프를 가지고 있지 않다.</li>
	<li>모든 파이프에는 밸브가 달려있어서&nbsp;물이 흐르지 않도록 할 수 있다.&nbsp;이때, 각 밸브를 잠그는 데 필요한 힘은&nbsp;다르다.</li>
</ul>

<p>해빈시의 공무원 신해빈은 스프링쿨러 시스템을 완벽하게 이해하고 있고, 각 밸브를 잠그는데 필요한 힘의 양을 알고 있다.</p>

<p>게으른 해빈이는 최소한의 힘을 사용해 몇 개의 밸브를 잠궈&nbsp;모든 스프링쿨러에 물이 공급되지 않도록 하려고 한다.</p>

<p>과연 힘이 얼마만큼 필요할까?</p>




					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력은 여러 개의 테스트 케이스로 이루어져있다.</p>

<p>각 테스트 케이스는 노드의 개수를 나타내는 N&nbsp;(2 ≤ N&nbsp;≤ 1 000)과 중앙 노드의 번호를 나타내는 C&nbsp;(1 ≤ C&nbsp;≤ N)로 시작된다.</p>

<p>이후 N-1개의 줄에는 각 파이프의 정보를 나타내는 세 정수 u, v&nbsp;(1 ≤ u, v ≤ n) 와&nbsp;w (1 ≤ w ≤ 1 000)가 주어지는데,&nbsp;이는 u와 v를 연결하는 파이프가 존재하고, 이 파이프의 밸브를 잠그는 데 w만큼의 힘이 필요하단 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 모든 스프링쿨러로 더 이상 물이 흘러들어가지 않도록 밸브를 잠그는 데 필요한 최소한의 힘을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 1
2 1 5
1 3 4
7 7
7 6 10
7 5 10
6 4 1
6 3 1
5 2 1
5 1 2
','9
5
','TREE'),
                                                                                                                (10635,'BAEKJOON','https://www.acmicpc.net/problem/9372',9372,'상근이의 여행','1초','256 MB',7,'<p>상근이는 겨울방학을 맞아 N개국을 여행하면서&nbsp;자아를 찾기로 마음먹었다.&nbsp;</p>

<p>하지만 상근이는 새로운 비행기를 무서워하기 때문에, 최대한 적은 종류의 비행기를 타고 국가들을 이동하려고 한다.</p>

<p>이번 방학 동안의 비행 스케줄이 주어졌을 때, 상근이가 <strong>가장 적은 종류</strong>의 비행기를 타고 모든 국가들을&nbsp;여행할 수 있도록 도와주자.</p>

<p>상근이가&nbsp;한 국가에서 다른 국가로 이동할 때 다른 국가를 거쳐 가도(심지어 이미 방문한 국가라도) 된다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 테스트 케이스의 수 T(T&nbsp;≤&nbsp;100)가 주어지고,</p>

<p>각 테스트 케이스마다 다음과 같은 정보가 주어진다.</p>

<ul>
	<li>첫 번째 줄에는 국가의 수 N(2 ≤ N ≤ 1 000)과 비행기의 종류 M(1 ≤ M ≤ 10 000) 가 주어진다.</li>
	<li>이후 M개의 줄에 a와 b 쌍들이 입력된다. a와 b를 왕복하는 비행기가 있다는 것을 의미한다.&nbsp;(1 ≤ a, b ≤ n; a ≠ b)&nbsp;</li>
	<li>주어지는 비행 스케줄은 항상 연결 그래프를 이룬다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>테스트 케이스마다 한 줄을 출력한다.</p>

<ul>
	<li>상근이가 모든 국가를 여행하기 위해 타야 하는 비행기 종류의 최소 개수를 출력한다.</li>
</ul>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
3 3
1 2
2 3
1 3
5 4
2 1
2 3
4 3
4 5
','2
4
','TREE'),
                                                                                                                (10647,'BAEKJOON','https://www.acmicpc.net/problem/9934',9934,'완전 이진 트리','1초','128 MB',10,'<p>상근이는 슬로베니아의 도시 Donji Andrijevci를 여행하고 있다. 이 도시의 도로는 깊이가 K인 완전 이진 트리를 이루고 있다. 깊이가 K인 완전 이진 트리는 총 2<sup>K</sup>-1개의 노드로 이루어져 있다. (아래 그림) 각 노드에는 그 곳에 위치한 빌딩의 번호가 붙여져 있다. 또, 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/2f3d1f78-7ef1-4be4-868c-6172f57f2db6/-/preview/" style="width: 357.5px; height: 122.5px;"></p>

<p style="text-align: center;">깊이가 2와 3인 완전 이진 트리</p>

<p>상근이는 도시에 있는 모든 빌딩에 들어갔고, 들어간 순서대로 번호를 종이에 적어 놓았다. 한국으로 돌아온 상근이는 도시가 어떻게 생겼는지 그림을 그려보려고 하였으나, 정확하게 기억이 나지 않아 실패했다. 하지만, 어떤 순서로 도시를 방문했는지 기억해냈다.</p>

<ol>
	<li>가장 처음에 상근이는 트리의 루트에 있는 빌딩 앞에 서있다.</li>
	<li>현재 빌딩의 왼쪽 자식에 있는 빌딩에 아직 들어가지 않았다면, 왼쪽 자식으로 이동한다.</li>
	<li>현재 있는 노드가 왼쪽 자식을 가지고 있지 않거나 왼쪽 자식에 있는 빌딩을 이미 들어갔다면, 현재 노드에 있는 빌딩을 들어가고 종이에 번호를 적는다.</li>
	<li>현재 빌딩을 이미 들어갔다 온 상태이고, 오른쪽 자식을 가지고 있는 경우에는 오른쪽 자식으로 이동한다.</li>
	<li>현재 빌딩과 왼쪽, 오른쪽 자식에 있는 빌딩을 모두 방문했다면, 부모 노드로 이동한다.</li>
</ol>

<p>왼쪽 그림에 나와있는 마을이라면, 상근이는 2-1-3 순서대로 빌딩을 들어갔을 것이고, 오른쪽 그림의 경우에는 1-6-4-3-5-2-7 순서로 들어갔을 것이다. 상근이가 종이에 적은 순서가 모두 주어졌을 때, 각 레벨에 있는 빌딩의 번호를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 K (1 ≤ K ≤ 10)가 주어진다.</p>

<p>둘째 줄에는 상근이가 방문한 빌딩의 번호가 들어간 순서대로 주어진다. 모든 빌딩의 번호는 중복되지 않으며, 구간 [1,2<sup>K</sup>)에 포함된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 K개의 줄에 걸쳐서 정답을 출력한다. i번째 줄에는 레벨이 i인 빌딩의 번호를 출력한다. 출력은 왼쪽에서부터 오른쪽 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
2 1 3
','1
2 3
','TREE'),
                                                                                                                (10650,'BAEKJOON','https://www.acmicpc.net/problem/10068',10068,'구슬이 서말이라도 꿰어야 보배','1초','128 MB',23,'<p>요즘 고려대학교에서 가장 유행하는 게임은 "구슬을 꿰어라" 이다. 게임 이름에서 알 수 있듯이 이 게임은 구슬과 실을 이용해서 한다. 실은 총 두 가지 색상이 있고, 빨간색과 파란색이다. 구슬은 1번부터 n번가지 번호가 매겨져 있다. 게임은 구슬 1개를 가지고 시작한다. 이제 다음과 같은 과정을 통해 새로운 구슬을 실을 이용해 추가할 수 있다.</p>

<ul>
	<li>Append(w, v): 새로운 구슬 w를 이미 가지고 있는 구슬 v에 빨간 실을 이용해 연결한다.</li>
	<li>Insert(w, u, v): 새로운 구슬 w를 이미 빨간 실로 연결된 구슬 u와 v사이에 파란 실 두 개를 이용해 연결한다. 이때, u와 v를 연결하는 빨간 실은 제거해야 한다. 즉, 이미 존재하는 빨간 실 u - v가 새로운 파란 실 두 개 u - w, w - v로 교체된다.</li>
</ul>

<p>모든 실은 특정 길이를 가진다. 게임이 종료되었을 때, 최종 점수는 구슬을 연결하는 파란 실 길이의 합이다.</p>

<p>게임이 모두 종료된 상태가 주어진다. 상태는 실이 연결하고 있는 두 구슬의 번호와 길이로 이루어져 있으며, 색상은 알 수 없다.</p>

<p>문제에서 주어진 연결 상태를 만드는 방법은 여러 가지가 있다. 이때, 모든 방법 중에서 가장 큰 최종 점수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 구슬의 수 n이 주어진다. (1 ≤ n ≤ 200000)&nbsp;구슬은 1번부터 n번가지 번호가 매겨져 있다. 다음 n-1개 줄에는 실의 정보 a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>가 주어진다. (1 ≤ a<sub>i</sub> < b<sub>i</sub> ≤ n, 1 ≤ c<sub>i</sub> ≤ 10000) a<sub>i</sub>와 b<sub>i</sub>는 실이 연결하는 구슬의 번호이고, c<sub>i</sub>는 길이이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가능한 점수 중에서 가장 큰 최종 점수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제의 경우에 아래와 같이 연결하면, 60점을 얻을 수 있다. 시작은 3번 구슬로 시작한다.</p>

<ul>
	<li>5와 3을 연결한다. (선의 길이는 상관없다)</li>
	<li>1을 3-5 사이에 넣는다. (길이 40, 20 선을 이용)</li>
	<li>2와 1을 길이가 10인 선을 이용해 연결한다.</li>
	<li>4와 1을 길이가 15인 선으로 연결한다.</li>
</ul>

<p>연결은 아래와 같아지고, 이 방법보다 더 큰 점수를 얻을 수 있는 방법은 없다.</p>

<p><img alt="" src=https://www.acmicpc.net/upload/images/bead.png" style="height:227px; width:240px"></p>

				</div>
				</div>','5
1 2 10
1 3 40
1 4 15
1 5 20
','60
','TREE'),
                                                                                                                (10655,'BAEKJOON','https://www.acmicpc.net/problem/10716',10716,'코딩 대회','1초','256 MB',23,'<p>BOJ에서는 수진이의 생일을 축하하기 위한 코딩 대회를 열기로 하였다.</p>

<p>이 대회에는 1부터 N까지 번호가 붙은 N명의 코더들이 참가할 예정이며, 그들에겐 각각 코딩 실력을 나타내는 수치가 정해져있다. (N은 홀수이고 코더 i의 코딩 실력은 D<sub>i</sub>이다)</p>

<p>대회는 2명이 짝을 이루어나가는 팀전이므로 수진이를 포함한 N + 1명의 코더들은 2명씩 팀을 이루게 된다. 팀간의 밸런스를 맞추기로한 BOJ에서는 아래와 같은 방법을 이용하여 팀을 정하기로 했다.</p>

<ul>
	<li>먼저, N명의 참가자를 1줄로 세운다.</li>
	<li>줄에 남아있는 참가자가 1명이 될 때가지, 이하의 과정을 반복한다.
	<ul>
		<li>가장 앞에 서있는 3명의 참가자의 실력을 조사한다.</li>
		<li>3명의 참가자 중, 가장 실력이 뛰어난 사람을 뽑는다. 실력이 뛰어난 사람이 여러명일 경우, 번호가 가장 작은 사람을 선택한다.</li>
		<li>3명의 참가자 중, 가장 실력이 부족한 사람을 뽑는다. 실력이 부족한 사람이 여러명일 경우, 번호가 가장 큰 사람을 선택한다.</li>
		<li>위에서 선택한 두 사람을 한 팀으로 한다.</li>
		<li>남은 한 명의 참가자를 줄의 가장 뒤로 보낸다.</li>
	</ul>
	</li>
	<li>마지막에 남은 1명이 수진이와 팀을 이룬다!</li>
</ul>

<p>번호가 M 이하인 코더들은 이미 줄에서의 초기 위치가 정해져있다. (1?M?N-2) 코딩 초보 수진이는 남은 N - M명의 코더들의 위치를 조정하여 최대한 코딩 실력이 뛰어난 코더와 팀을 이루고 싶어한다. 수진이를 위해 수진이와 팀을 이룰 수 있는 코더의 코딩 실력으로 가능한 것 중 최댓값을 계산하는 프로그램을 만들어주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>데이터의 입력은 아래와 같다.</p>

<ul>
	<li>1행에는 참가하는 코더의 수 N과 초기 위치가 정해진 코더의 수 M이 주어진다.</li>
	<li>이은 M열에는 코더 i의 코딩 실력 D<sub>i</sub>와 초기 위치 P<sub>i</sub>가 주어진다. (1 ? i ? M)</li>
	<li>이은 N - M열에는 코더 i의 코딩 실력 D<sub>i</sub>가 주어진다. (M+1 ? i ? N)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>수진이와 팀을 이루는 코더의 코딩 실력으로 가능한 값 중 최대치를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 3
5 2
5 5
8 6
6
2
8
9
','8
','TREE'),
                                                                                                                (10659,'BAEKJOON','https://www.acmicpc.net/problem/10724',10724,'판게아 2','20초','256 MB',26,'<p>태초에 세계는 \(n\)개의 도시와 이들 사이를 잇는 \(n - 1\)개의 도로로 이루어져 있었다. 각 도시에는 0 이상 \(n-1\) 이하의 정수 번호가 붙어 있었다.&nbsp;각 도로는 양방향으로 통행 가능하며, 양 끝에 서로 다른&nbsp;두&nbsp;개의 도시를 연결하고 있었다. 태초에&nbsp;세계는 임의의 도시에서 출발하여&nbsp;다른 모든 도시로 한 개 이상의 도로를 통하여&nbsp;걸어갈 수 있었다.&nbsp;</p>

<p>지혜를 갖춘 인간들은 어느새 찬란한 문명을 가지게 되었으나, 도시 사이에 새로운 도로를 놓는 일만큼은 어떻게 해도 해낼 수가 없었다.</p>

<p>이를 지켜보던&nbsp;조물주는 해마다 두 도시를 잇는 도로를 하나씩&nbsp;추가하기 시작했는데,&nbsp;동시에 인간들이 새로운 도로를 사용하기에 합당한 지적 능력을 갖추고&nbsp;있는지가 궁금해졌다. 그래서 인간들에게 아래와 같은 퍼즐 문제를 제시하였다.</p>

<blockquote>
<p style="text-align:center">매번 도로가 추가되고 나면 모든 도로 중 일부를 선택하여 모든 도시가&nbsp;서로 직간접적으로 연결되어 있도록 하며,</p>

<p style="text-align:center">이때 선택된 도로들의 길이의 합을 최소로 하는 도로의 부분집합을 알아내기.</p>
</blockquote>

<p>조물주에게 문제를 받은&nbsp;인간들은, 이 문제를 해결하여 조물주에게&nbsp;자신들이 도로를 사용하기에 합당한 존재라는 것을 보여주기로 하였다. 만약 문제를 해결하지 못한다면, 인간들에게 실망한 조물주가 어떤 일을 일으킬지 아무도 알 수 없다.&nbsp;당신은 인간계 대표로서,&nbsp;조물주가 내린 시련을 이겨내야만 한다!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 테스트 케이스의 수 \(T\)가 정수로 주어진다.&nbsp;이어서 매 테스트 케이스의 첫 줄에는 도시의 수 \(n\)과 도로가 건설된 횟수 \(m\)이 공백으로 구분되어 주어진다.&nbsp;다음 \(n - 1\)줄에 태초의 세계에 대한 정보가 주어진다. 이 중 \(i\) (\(1 \leq&nbsp;i \leq&nbsp;n - 1\))번째 줄에는 정수 \(u_i, c_i\) (\(0 \leq&nbsp;u_i <&nbsp;i, 0 \leq&nbsp;c_i \leq&nbsp;10,000,000\))가 공백으로 구분되어 주어지는데,&nbsp;이는 \(i\)번 도시와 \(u_i\)번 도시가 길이가&nbsp;\(c_i\)인&nbsp;도로로 연결되어 있다는 뜻이다.&nbsp;이어서 \(m\)개의 줄에&nbsp;조물주가 새로이 놓은 도로에 대한 정보가 주어진다. 이 중&nbsp;\(j\) (\(1 \leq&nbsp;j \leq&nbsp;m\))번째 줄에는 정수 \(u_j, v_j, c_j\) (\(0 \leq&nbsp;u_j, v_j <&nbsp;n, 0 \leq&nbsp;c_j \leq&nbsp;10,000,000\))가 공백으로 구분되어 주어지는데,&nbsp;이는 조물주가&nbsp;\(j\)번째로 놓은 도로는,&nbsp;\(u_j\)번 도시와 \(v_j\)번 도시 사이를 연결하며,&nbsp;길이가&nbsp;\(c_i\)라는 것을 의미한다.</p>

<p>이 문제는 두 개의 부분문제로 이루어져 있다.</p>

<p><a href="https://www.acmicpc.net/problem/10723">1번 문제</a>의 입력은 \(1 \leq n, m \leq 2,000\)을 만족하며 해결하면 20점을 얻을 수 있다.</p>

<p><a href="https://www.acmicpc.net/problem/10724">2번 문제</a>의 입력은 \(1 \leq n, m \leq 100,000\)을 만족하며 해결하면 80점을 얻을 수 있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 단 하나의 줄을 출력한다. 이 줄에는&nbsp;매번&nbsp;새 도로를 놓았을 때 문제에 대한 답을 모두 XOR한 값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
3 3
0 5
1 3
0 2 4
0 1 2
0 0 2
','7
','TREE'),
                                                                                                                (10661,'BAEKJOON','https://www.acmicpc.net/problem/10806',10806,'공중도시','1초','256 MB',22,'<p>서기 4,000년 현재, 지구의 황폐화로 인하여 사람들은 공중에 섬을 띄워 공중도시를 만들어 살아가고 있다. 각 공중도시는 부양무게의 한계로 작은 크기의 섬으로 만들고 대신 다리로 연결하여 모든 도시 사이에 이동이 가능하다. 아래 그림은 도시 1부터 도시 6까지 모두 6개의 공중도시가 서로 다리로 연결된 모습을 보여준다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10806/1.png" style="height:154px; width:288px"></p>

<p>두 도시는 서로 다른 두 개 이상의 다리로 직접 연결될 수도 있다. 위 그림에서 도시 2와 도시 4는 서로 다른 두 개의 다리로 연결되어 있다.&nbsp;</p>

<p>그런데, 간혹 발생하는 천재지변 때문에 다리가 끊어질 가능성이 있다. 위 그림에서 도시 5와 도시 6을 잇는 다리가 하나 끊어진다면 도시 6에서는 다른 도시로 이동할 수가 없지만, 도시 1과 도시 3을 잇는 다리가 하나 끊어지더라도 여전히 모든 도시 사이에 이동이 가능하다.&nbsp;</p>

<p>그래서 하나의 다리가 끊어지더라도 여전히 모든 두 도시 사이에 이동이 가능하도록 다리를 추가로 건설하려고 한다. 위 그림의 예에서는 다음 그림과 같이 도시 3과 도시 6을 잇는 다리를 하나 추가로 건설하면 임의의 다리가 하나 끊어지더라도 여전히 모든 도시 사이에 이동이 가능하다. 물론 도시 3 대신 다른 도시와 도시 6을 잇는 다리를 하나 추가해도 가능하다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10806/2.png" style="height:194px; width:287px"></p>

<p>공중도시와 현재 상태의 다리가 주어져 있을 때, 임의의 다리가 하나 끊어지더라도 여전히 모든 도시 사이에 이동이 가능할 수 있도록 다리의 길이에 상관없이 추가로 건설해야할 다리의 최소 개수와 그 위치를 찾는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 도시의 개수 N과 다리의 개수 M이 주어진다. 두 값의 범위는 3 ≤ N ≤ 100,000, N-1 ≤ M ≤ 200,000이다. 그 다음 M개의 줄에 걸쳐 각 줄에는 다리로 직접 연결된 두 도시 C1과 C2가 차례대로 주어진다. 이때 1 ≤ C1, C2 ≤ N이다. 주어진 다리를 이용하여 모든 도시 사이에 이동이 가능하다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에는 추가로 건설할 다리의 최소 개수 R을 출력한다. 그 다음 R개의 줄에 걸쳐 각 줄에는 추가로 건설할 다리로 직접 연결될 두 도시 D1과 D2를 차례대로 출력한다. 이때 1 ≤ D1, D2≤ N이다. 이때&nbsp;다리의 순서는 상관이 없으며, 답이 여러 가지인 경우에는 그 중 한가지만 출력하면 된다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 7
1 2
1 3
2 4
2 4
4 5
3 5
5 6
','1
3 6
','TREE'),
                                                                                                                (10667,'BAEKJOON','https://www.acmicpc.net/problem/10838',10838,'트리','3초','256 MB',16,'<p>N개의 노드로 구성된 루트가 있는 트리가 다음과 같이 주어진다. 각 노드는 0부터 N-1까지의 번호로 구별되고, 0번 노드는 루트 노드이고, 나머지 노드 각각은 0번 노드의 자식 노드이다.&nbsp;</p>

<p>트리에 적용할 수 있는 연산은 세 종류이며, 이를 통해 트리의 모양을 바꾸거나 트리 에지에 색칠을 할 수 있다. 각 연산과 그 의미는 다음과 같다.&nbsp;</p>

<ol>
	<li>paint(a, b, c): a번 노드와 b번 노드를 잇는 최단 경로를 찾은 후, 경로 상에 있는 모든 에지를 색깔 c로 칠한다.&nbsp;</li>
	<li>move(a, b): a번 노드의 부모 노드를&nbsp;b번 노드로 바꾼다. 단, b번 노드는 a번 노드를 루트로 하는 부트리(subtree)에 속하지 않는다. 부모 노드를 바꾸기 전 a번 노드의 부모 노드를 p라 할 때, 새로운 에지 (a,b)는 원래의 에지 (a,p)의 색깔을 갖는다.&nbsp;</li>
	<li>count(a, b): a번 노드와 b번 노드를 잇는 최단경로를 찾은 후, 그 경로 사이에 있는 에지에 칠해진 서로 다른 색깔의 개수를 출력한다.&nbsp;</li>
</ol>

<p>에지에 칠하는 색깔 c를 정수로 표시한다. 그리고 처음에는 모든 에지의 색깔이 0이라고 가정한다.&nbsp;</p>

<p>예를 들어, 그림 1에서 보인 것처럼 6개의 노드로 구성된 초기 트리에 적용된 연산이 차례로</p>

<p>move(1,3); move(5,3); paint(5,4,8); move(3,4); paint(0,3,7); count(2,5);</p>

<p>일 때, 각 연산을 실행한 후 어떻게 트리의 모양과 에지 색깔이 바뀌는지를 아래 그림 2부터 그림 4에서 차례대로 보였다.&nbsp;</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10838/1.png" style="height:103px; width:227px"></p>

<p style="text-align:center">그림 1. 초기 형태</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10838/2.png" style="height:170px; width:289px"></p>

<p style="text-align:center">그림 2. 좌측: move(1,3)을 실행한 후, 우측: move(5,3)을 실행 한 후</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10838/3.png" style="height:138px; width:161px"></p>

<p style="text-align:center">그림 3. paint(5,4,8)을 실행한 후</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/10838/4.png" style="height:150px; width:283px"></p>

<p style="text-align:center">그림 4. 좌측: move(3,4)를 실행한 후, 우측: paint(0,3,7)을 실행한 후</p>

<p>그리고, 마지막 연산 count(2,5)에 대한 결과로는 3을 출력하게 된다. 왜냐하면, 그림 4의 우측 그림에서 보듯이 2번 노드와 5번 노드 사이의 최단 경로 상에 있는 에지들에 칠해진 색깔이 {0,7,8}로 3가지이기 때문이다.&nbsp;</p>

<p>트리에 대한 정보와 일련의 연산이 주어질 때, 각 연산을 효과적으로 실행하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 앞에서 설명한 트리의 노드 개수를 나타내는 정수 N(1 ≤ N ≤ 10<sup>5</sup>)과 연산의 개수를 나타내는 정수 K(1 ≤ K ≤ 3×10<sup>5</sup>)가 주어진다. 이어서 K 줄에 걸쳐 각 연산에 관한 정보가 한 줄에 하나씩 주어지는데, 각 줄에는 연산의 종류를 나타내는 정수 r(1 ≤ r ≤ 3)이 첫 번째로 주어진다.</p>

<ul>
	<li>r = 1일 경우엔 연산이 paint 임을 의미하며, 세 정수 (a,b,c)가 추가로 같은 줄에 주어지는데, 여기서 a, b(0 ≤ a, b ≤ N-1)는 노드 번호를, c(0 ≤ c ≤10<sup>9</sup>)는 색의 번호를 나타낸다.</li>
	<li>r = 2일 경우엔 연산이 move임을 의미하며, 두 정수 a, b(1 ≤ a ≤ N-1, 0 ≤ b ≤ N-1)가 추가로 같은 줄에 주어지는데, 이는 노드 번호를 나타낸다.&nbsp;</li>
	<li>r = 3일 경우엔 연산이 count임을 의미하며, 두 정수 a, b(0 ≤ a, b ≤ N-1)가 추가로 같은 줄에 주어지는데, 이는 노드 번호를 나타낸다.&nbsp;</li>
</ul>

<p>노드의 개수가 N인 트리의 초기 모양은 그림 1에서 보인 것처럼 0번 노드가 루트이고, 나머지 노드들의 부모 노드는 0번 노드이며, 초기 트리의 모든 에지 색깔은 0이라고 가정한 사실을 기억하기 바란다.&nbsp;</p>

<p>또한, paint와 count 연산 시 a번 노드와 b번 노드 사이의 최단경로의 길이는 항상 1,000 이하이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>입력에서 주어진 count 연산 각각에 대해, 그 순서대로 그 때의 결과 값을 한 줄에 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 8
2 1 3
2 5 3
1 5 4 8
3 4 5
2 3 4
1 0 3 7
3 2 5
3 4 2
','1
3
2
','TREE'),
                                                                                                                (10652,'BAEKJOON','https://www.acmicpc.net/problem/11725',11725,'트리의 부모 찾기','1초','256 MB',9,'<p>루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 노드의 개수 N (2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 트리 상에서 연결된 두 정점이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1 6
6 3
3 5
4 1
2 4
4 7
','4
6
1
3
1
4
','TREE'),
                                                                                                                (10658,'BAEKJOON','https://www.acmicpc.net/problem/11808',11808,'마리오와 사악한 키노피오','3초','256 MB',22,'<p>마리오는 사악한 쿠파로부터 피치 공주를 구하기 위해 동분서주한다. 그러나 어떤 스테이지를 클리어하더라도, 어떤 작은 버섯 인간(키노피오)이 공주는 다른 성에 있다고 말할 뿐이었다. 마리오는 이 키노피오가 굉장히 사악한 존재이고, 단지 재미를 위해 마리오를 최대한 먼 성으로 보내려는 것이 틀림없다고 의심한다.</p>

<p>마리오의 세계는 N개의 노드를 가진 트리(N-1개의 간선이 존재하며, 연결 그래프이고, 각 노드는 1부터 N까지의 번호를 가짐)의 형태이다.(어째서?)&nbsp;각 노드에는 성이 하나씩 존재하며, 각 간선은 하나의 스테이지를 의미한다. 마리오는 트리의 루트 노드에서 여행을 시작하여, 트리 위에서 이동하며(같은 정점이나 간선을 여러 번 지날 수 있다) 만나는 성마다&nbsp;키노피오의 지시에 따라&nbsp;피치 공주를 찾아 헤맨다. 스테이지 하나를 진행할 때는 일정한 시간이 소요된다(이 시간은 양쪽 방향에서 동일하다).</p>

<p>키노피오는 K개의 서로 다른 성을 택하며(루트&nbsp;노드는 선택하지 않는다), 마리오는 이 성들을 반드시&nbsp;주어진 순서에 따라 방문해야만&nbsp;한다. 마리오는 반드시 여행을 루트 노드에서 시작하여, 루트 노드에서 끝내야 한다. 마리오는 항상 성으로 이동할 때마다 최단 경로를 통해서만 움직인다. 키노피오가 K개의 성을 뽑는 경우에 따라 마리오가 여행을 하는 데 걸리는 최장 시간은 얼마인가?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 테스트 케이스의 개수 T가 주어진다.&nbsp;(1 ≤ T ≤ 100)</p>

<p>각 테스트 케이스의 첫 번째 줄에는 2개의 정수 N,&nbsp;K가 주어지며,&nbsp;(2 ≤ N ≤ 1,000) (1 ≤ K ≤ 100) (1 ≤ K ≤ N - 1)&nbsp;N은 성의 개수이고 K는 키노피오가 선택할 성의 개수이다.</p>

<p>다음 N-1개의 줄에 걸쳐서 2~N번 노드의 정보가 순서대로 주어진다. 각 줄마다 2개의 정수&nbsp;P<sub>i,</sub>&nbsp;C<sub>i</sub>가 주어지며,&nbsp;(1 ≤ P<sub>i</sub>&nbsp;≤ N ) (0 ≤ C<sub>i</sub>&nbsp;≤ 100,000) 각각 해당 노드의 부모 노드 번호와, 부모와 자신 사이의 스테이지를 지나는 데 소요되는 시간을 의미한다.</p>

<p>항상 루트 노드는 1번 노드이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 한 줄에 걸쳐 “Case n:”의 양식과&nbsp;함께&nbsp;답을 출력한다. n은 테스트 케이스의 번호를 의미하며, 1부터 시작한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>세 번째 테스트 케이스의 경우, 키노피오가 5, 2, 4번 성을 순서대로 뽑으면&nbsp;가능하다. 4, 2, 5번도 가능하다.</p>

				</div>
				</div>','3
3 1
1 5
1 3
4 2
1 5
1 3
3 2
5 3
1 5
1 3
3 2
3 10
','Case 1: 10
Case 2: 20
Case 3: 46
','TREE'),
                                                                                                                (10669,'BAEKJOON','https://www.acmicpc.net/problem/11907',11907,'오두막집','6초','64 MB',22,'<p>어느 산의 강가에서 캠핑을 하는 수빈이와 진영이는 M채의 오두막집을 발견했습니다. 이 강에는 N개의 지역이 있는데, 1번 지역은 강의 하류에 위치해있고, 나머지 지역은 강의 중류 또는 상류에 위치해 있습니다. M채의 오두막집은 아래 그림과 같이(회색으로 색칠한 곳이 오두막집이 있는 지역) 각각 N개의 지역 중 한 곳에 있습니다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11907/1.png" style="height:167px; width:225px"></p>

<p>한 지역(1번 지역 제외)에서 강을 따라 내려가면 다른 지역이 나오는데, 이 지역의 번호는 기존 지역의 번호보다 항상 작습니다.</p>

<p>한편, 이 강은 물살이 별로 세지 않기 때문에 강을 따라 내려가는 시간과 강을 거슬러 올라가는 시간은 서로 같습니다.</p>

<p>오두막집은 협소하기 때문에 수빈이와 진영이가 같은 오두막집에 있을 수 없습니다. 따라서 이 둘은 서로 다른 오두막집에 자리 잡아야 합니다.</p>

<p>수빈이와 진영이는 절친한 사이이기 때문에 가장 가까운 두 오두막집에 자리를 잡았습니다. 하지만 싸움이 나서 사 이가 안 좋아지면 K번째로 가까운 두 오두막집으로 자리를 옮겨야 합니다.</p>

<p>수빈이는 만일의 경우에 대비해서 싸움이 난 경우에 어디 있는 오두막집에 자리를 잡아야 할지 구해야 합니다. 수빈이를 도와 K번째로 가까운 두 오두막집의 거리를 구해주세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 지역의 수 N, 오두막집의 수 M, 수빈이와 진영이의 관계 값 K가 주어집니다.</p>

<p>두 번째 줄에서부터 N?1개의 줄에는 2~N번 지역에서 강을 따라 내려가면 나오는 지역의 번호 R<sub>i</sub>와 그때의 소요시간 D<sub>i</sub>가 주어집니다. (2≤i≤N)</p>

<p>N+1번째 줄에는 각 오두막집의 위치 C<sub>i</sub>가 오름차순으로 주어집니다. 모든 오두막집은 서로 다른 곳에 있습니다.</p>

<p>2≤M≤N≤100,000</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>K번째로 가까운 두 오두막집의 거리를 출력합니다.</p>

<p>&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>만약 거리가 2인 오두막집의 쌍이 3쌍 있고 거리가 5인 오두막집의 쌍이 2쌍 있다면 K=1,2,3,4,5일 때의 답은 각각 2, 2, 2, 5, 5입니다.</p>

<p>&nbsp;</p>

				</div>
				</div>','5 3 2
1 3
1 5
2 3
2 1
3 4 5
','9
','TREE'),
                                                                                                                (10674,'BAEKJOON','https://www.acmicpc.net/problem/11933',11933,'공장들','6초','512 MB',22,'<p>IOI 왕국에서 0 이상 N?1 이하의 번호가 붙은 N개의 도시들이 있습니다. 이들 도시들은 양방향으로 통행이 가능한 N?1개의 도로로 연결되어 있습니다. 여러분은 이러한 도로들을 몇 개 통과하여 어떤 서로 다른 두 다시 사이도 이동할 수 있습니다.</p>

<p>IOI 왕국에는 특별한 제품들을 생산하는 많은 회사들이 있습니다. 각 회사는 단 한 종류의 제품만 생산하며, 어떤 두 회사도 같은 종류의 제품을 생산하지 않습니다. 각 도시는 한 개 이상의 공장을 가지고 있습니다. 각 공장은 도시들 중 하나에 지어져 있습니다. 같은 도시에 두 개 이상의 회사가 공장을 가지고 있을 수도 있습니다.</p>

<p>가끔 어떤 회사는 또다른 회사의 제품이 필요할 때가 있습니다. 회사 C<sub>A</sub>가 회사 C<sub>B</sub>의 제품이 필요하다고 가정해 봅시다. (C<sub>A</sub>≠C<sub>B</sub>) 이 경우, 그들은 C<sub>B</sub>에서 C<sub>A</sub>로 제품을 운반해야 합니다. 이를 위해 회사 C<sub>B</sub>의 아무 공장에서 회사 C<sub>A</sub>의 아무 공장으로 제품을 운반하면 됩니다. 그들은 공장들 사이의 거리를 최소화하기 위하여 공장들을 적절히 선택해야 합니다.</p>

<p>우선, 도시들의 수와 IOI 왕국의 도로의 정보가 주어집니다. 그 다음, Q개의 질의가 주어집니다. 각 질의는 다음과 같은 형태로 주어집니다: X<sub>j,0</sub>,?,X<sub>j,Sj?1</sub>번 도시들에 공장을 가지고 있는 회사 U<sub>j</sub>는 Y<sub>j,0</sub>,?,Y<sub>j,Tj?1</sub>번 도시들에 공장을 가지고 있는 회사 V<sub>j</sub>의 제품이 필요합니다. 각 질의마다, 제품을 운반하기 위해 필요한 최소 거리를 반환하는 프로그램을 작성하세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 두 개의 정수 N과 Q가 공백을 사이로 두고 주어집니다. 이는 IOI 왕국에 N개의 도시가 있고, 여러분의 프로그램에게 Q개의 질의가 주어진다는 것을 의미합니다.</p>

<p>다음 (N?1)개의 줄 중 (i+1)번째 줄 (0 ≤ i ≤ N?2)에는 세 개의 정수 A<sub>i</sub>, B<sub>i</sub>, D<sub>i</sub>가 공백을 사이로 두고 주어집니다. 이것은 도시 A<sub>i</sub>와 도시 B<sub>i</sub>를 잇는 길이가 D<sub>i</sub>인 도로가 있다는 것을 의미합니다.</p>

<p>다음 3Q개 줄 중에서 j번째 질의의 정보는 (3j+1)번째 줄부터 (3j+3)번째 줄까지 (0 ≤ j ≤ Q?1) 주어집니다.</p>

<p>(3j+1)번째 줄 (0 ≤ j ≤ Q?1)에는 두 개의 정수 S<sub>j</sub>와 T<sub>j</sub>가 공백을 사이로 두고 주어집니다. 이것은 회사 U<sub>j</sub>와 회사 V<sub>j</sub> 각각 S<sub>j</sub>개와 T<sub>j</sub>개의 도시에 공장을 두고 있다는 것을 의미합니다.</p>

<p>(3j+2)번째 줄 (0 ≤ j ≤ Q?1)에는 Sj개의 정수 X<sub>j,0</sub>,?,X<sub>j,Sj?1</sub>이 공백을 사이로 두고 주어집니다. 이것은 회사 Uj가 도시 X<sub>j,0</sub>,?,X<sub>j,Sj?1</sub>에 공장을 두고 있다는 것을 의미합니다.</p>

<p>(3j+3)번째 줄 (0 ≤ j ≤ Q?1)에는 T<sub>j</sub>개의 정수 Y<sub>j,0</sub>,?,Y<sub>j,Tj?1</sub>이 공백을 사이로 두고 주어집니다. 이것은 회사 V<sub>j</sub>가 도시 Y<sub>j,0</sub>,?,Y<sub>j,Tj?1</sub>에 공장을 두고 있다는 것을 의미합니다.</p>

<p>모든 입력 데이터는 다음 조건을 만족합니다.</p>

<ul>
	<li>2 ≤ N ≤ 500 000.</li>
	<li>1 ≤ Q ≤ 100 000.</li>
	<li>0 ≤ A<sub>i</sub> ≤ N ? 1 (0 ≤ i ≤ N ? 2).</li>
	<li>0 ≤ B<sub>i</sub> ≤ N ? 1 (0 ≤ i ≤ N ? 2).</li>
	<li>1 ≤ D<sub>i</sub> ≤ 100 000 000 (0 ≤ i ≤ N ? 2).</li>
	<li>A<sub>i</sub> ≠ B<sub>i</sub> (1 ≤ i ≤ N ? 2).</li>
	<li>여러분은 도로들을 통해 한 도시에서 다른 모든 도시로 이동할 수 있습니다.</li>
	<li>1 ≤ S<sub>j</sub> ≤ N ? 1 (0 ≤ j ≤ Q ? 1).</li>
	<li>0 ≤ X<sub>j,k</sub> ≤ N ? 1 (0 ≤ j ≤ Q ? 1, 0 ≤ k ≤ S<sub>j</sub> ? 1).</li>
	<li>1 ≤ T<sub>j</sub> ≤ N ? 1 (0 ≤ j ≤ Q ? 1).</li>
	<li>0 ≤ Y<sub>j,k</sub> ≤ N ? 1 (0 ≤ j ≤ Q ? 1, 0 ≤ k ≤ Tj ? 1).</li>
	<li>X<sub>j,0</sub>, X<sub>j,1</sub>, . . . , X<sub>j,Sj?1</sub>, Y<sub>j,0</sub>, Y<sub>j,1</sub>, . . . , Y<sub>j,Tj?1</sub> 은 서로 다릅니다 (0 ≤ j ≤ Q ? 1).</li>
	<li>S<sub>0</sub> + S<sub>1</sub> + · · · + S<sub>Q?1</sub> ≤ 1 000 000.</li>
	<li>T<sub>0</sub> + T<sub>1</sub> + · · · + T<sub>Q?1</sub> ≤ 1 000 000.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 질의에 대한 답을 한 줄에 하나씩 차례대로 출력합니다</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<ul>
	<li>0번 질의에서, 회사 U<sub>0</sub>는 0번, 6번 도시에 공장을 두었고, 회사 V<sub>0</sub>는 3번, 4번 도시에 공장을 두었습니다. 3번 도시에 있는 V<sub>0</sub>의 공장에서부터 6번 도시에 있는 U<sub>0</sub>의 공장까지의 거리가 최소입니다. 최소 거리는 12입니다.</li>
	<li>1번 질의에서, 회사 U<sub>1</sub>는 0번, 1번, 3번 도시에 공장을 두었고, 회사 V<sub>1</sub>는 4번, 6번 도시에 공장을 두었습니다. 6번 도시에 있는 V<sub>1</sub>의 공장에서부터 1번 도시에 있는 U<sub>1</sub>의 공장까지의 거리가 최소입니다. 최소 거리는 3입니다.</li>
	<li>2번 질의에서, 회사 U<sub>2</sub>는 2번 도시에 공장을 두었고, 회사 V<sub>2</sub>는 5번 도시에 공장을 두었습니다. 5번 도시에 있는 V<sub>2</sub>의 공장에서부터 2번 도시에 있는 U<sub>2</sub>의 공장까지의 거리가 최소입니다. 최소 거리는 11입니다.</li>
</ul>

				</div>
				</div>','7 3
0 1 4
1 2 4
2 3 5
2 4 6
4 5 5
1 6 3
2 2
0 6
3 4
3 2
0 1 3
4 6
1 1
2
5
','12
3
11
','TREE'),
                                                                                                                (10672,'BAEKJOON','https://www.acmicpc.net/problem/12023',12023,'연세대학교 포인트 게임','5초','128 MB',22,'<p>올 해 2학년이 된 연돌이는 새로운 신입생들을 맞아 오티에서 사용할 교내 포인트게임을 담당하게 되었다. 포인트 게임이란 교내 곳곳에 있는 시설 위치에 익숙해지기 위해 각각의 위치에서 미션을 수행하는 게임이다. 보통 해당 위치에 가서 미션을 수행하고 다음 위치로 이동하는 형태로 진행되나, 작년에 포인트 게임에 참가했었던 연돌이는 이와 같은 형태의 포인트 게임이 가지는 한계점에 대해서 고민하고 있었다. 한 번 방문한 장소에 다시는 방문하지 않기 때문에 실질적으로 위치 암기에는 그다지 도움이 되지 않았던 것이다.</p>

<p>이와 같은 문제를 해결하기 위해 연돌이는 새로운 포인트 게임을 고안해 내었다. 새로운 포인트 게임의 규칙은 다음과 같다:</p>

<p>교내 N 곳의 장소에 대하여 포인트 게임을 진행하고, N 곳의 장소는 트리 형태로 연결되어 있다. (N곳은 N ? 1 개의 두 장소를 잇는 도로를 통해서 결과적으로 모두 연결되어 있으며, 각 도로는 양방향성이고 사이클이 없다). 각 도로의 길이는 다를 수 있다.</p>

<p>이때 Q번의 미션을 수행해야 하며 수행해야 하는 미션의 종류는 2 종류인데,</p>

<ol>
	<li>주어진 장소 A에 방문해 파란 락커를 칠한다</li>
	<li>주어진 장소 A로부터 모든 파란 락커가 칠해진 곳까지의 길이의 합을 구한다.</li>
</ol>

<p>이다. 처음 시작할 때 모든 장소는 락커가 칠해져 있지 않다.</p>

<p>과거 방문했던 장소에 대해서도 지속적으로 알아야 하는 게임이기에 시설 위치 숙달에 좀 더 도움이 되는 게임이지만, 아뿔싸 게임이 너무 어려운 나머지 연돌이도 2번 미션들에 대한 답들을 알 수가 없었다. 당신은 우수한 프로그래머로써 연돌이를 도와 포인트 게임을 성공적으로 진행시켜야 한다!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>데이터의 첫 줄에는 장소의 개수 N(1 <= N <= 100,000)이 주어지며, 장소는 각각 0 ~ N ? 1로 숫자를 매겨 부른다.</p>

<p>이어지는 1 ~ N ? 1 줄에 걸쳐서 장소들의 연결 정보가 들어오며, 각 i번째 줄에 대하여 두 정수 Ai, Bi(0 <= Ai < i, 1 <= Bi <= 100)가 입력된다. 이는 장소 i가 장소 Ai와 거리 Bi의 도로로 연결되어 있음을 나타낸다.</p>

<p>이어서 미션의 개수 Q(1 <= Q <= 100,000)이 한 줄에 걸쳐 주어진다.</p>

<p>이어서 Q 줄에 걸쳐 정수 Ci, Di (Ci = 1 or 2, 0 <= Di < N)이 주어지며, 각 줄은 수행해야 하는 미션들을 순서대로 써 놓은 것이다. Ci = 1일 경우 Di번째 장소에 락커를 칠해야 하고, Ci = 2일 경우 여태까지 칠한 락커 정보를 바탕으로 Di번째에서 모든 락커가 칠해진 장소까지의 길이의 합을 구해서 출력해야 한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
0 1
1 2
2 4
6
2 2
1 2
2 0
2 1
2 2
2 3
','0
3
2
0
4
','TREE'),
                                                                                                                (10705,'BAEKJOON','https://www.acmicpc.net/problem/12754',12754,'스왑','1초','256 MB',24,'<p>1부터 n까지의 정수가 단 한 번씩만 등장하는 크기가 n인 수열 x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>이 주어진다.</p>

<p>두 수를 바꾸는 "스왑"이라는 연산을 통해 수열을 수정할 수 있다. k=2, 3, ..., n 순서대로 k를 증가시키면서 x<sub>k</sub>와&nbsp;x<sub>?k/2?</sub>를 바꿀지 말지 선택할 수 있다.</p>

<p>수열 a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>이 수열 b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub>보다 사전순으로 앞선다는 것은 k < j인 &nbsp;k에 대해 a<sub>k</sub> = b<sub>k</sub>를 만족하고 a<sub>j</sub> < b<sub>j</sub>를 만족하는 j (1 ≤ j ≤ n)가 존재한다는 것을 의미한다.</p>

<p>순서대로 "스왑" 연산을 하여 만들 수 있는 수열 중 가장 사전순으로 앞선 수열은 어떤 것일까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에 정수 n이 주어진다.</p>

<p>둘째 줄에는 수열을 나타내는 n개의 정수가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 줄에 순서대로 "스왑" 연산을 하여 만들 수 있는 수열 중 가장 사전순으로 앞선 수열을 나타내는 n개의 정수를 공백으로 구분하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
3 4 2 5 1
','2 1 3 4 5
','TREE'),
                                                                                                                (10712,'BAEKJOON','https://www.acmicpc.net/problem/12784',12784,'인하니카 공화국','1초','256 MB',13,'<p>인하니카 공화국은 1번~ <em>N</em>번까지 <em>N</em>개의 섬으로 이루어진 나라이다. 이 나라에서는 섬 간의 왕래가 매우 어려웠지만, 위대한 다리 설계자 ‘진’이 두 섬을 연결하는 다리를 최소한의 개수로 만들어 모든 섬 간의 왕래가 가능하도록 만들었다. 1번섬에서 살고 있는 진은 어느 날 위험한 소문을 듣게 되었다. 1번섬을 제외한 다리가 하나밖에 없는 어느 섬에서 유명한 연쇄 살인마 괴도‘루팡’이 자신의 목숨을 노리고 있다는 소문이었다. 너무 불안한 나머지 진은 몇 개의 다리를 폭파하여, 루팡이 있을 가능성이 있는 모든 섬에서 자신의 섬으로의 모든 경로를 차단하려고 한다. 하지만 각 다리를 폭파하려면 다리의 크기에 따라 다이너마이트의 개수가 다르다. 다이너마이트는 매우 비싸기 때문에 진은 사용하는 다이너마이트의 개수를 최소화하고 싶어 한다. 각 섬을 연결하는 다리를 폭파하기 위한 다이너마이트의 개수가 주어졌을 때, 진을 도와 필요한 최소 다이너마이트의 개수를 구하라.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12784/1.png" style="height:170px; width:340px"></p>

<p>예를 들어, 위의 그림과 같이 섬과 다리를 폭파하기 위한 다이너마이트의 수가 주어졌을 때, 빨간색 다리를 폭파하면 다이너마이트의 개수를 최소화하면서 루팡으로부터 안전할 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에는 테스트 케이스의 개수 <em>T</em>(1 ≤ <em>T</em> ≤ 100)가 주어진다.</p>

<p>각 테스트 케이스의 첫 번째 줄에는 섬의 수 <em>N</em>(1 ≤ <em>N</em> ≤ 1,000)과 다리의 수 <em>M</em>이 주어진다.</p>

<p>다음으로 <em>M</em>개의 줄에는 각 다리를 통해 이어진 두 섬의 번호와 다리를 파괴하기 위한 다이너마이트의 수 <em>D</em>(1 ≤ <em>D</em> ≤ 20)가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 필요한 최소 다이너마이트의 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
7 6
1 2 1
2 3 4
2 4 1
5 1 4
6 5 1
7 5 2
','4
','TREE'),
                                                                                                                (10713,'BAEKJOON','https://www.acmicpc.net/problem/12817',12817,'버스 노선','3초','1024 MB',16,'<p>Kocourkov라 불리는 체코 도시에는 화려한 공공 교통 시스템이 있다. 그것은 N개의 버스 정류장과 N - 1개의 양방향 도로로 이루어져있으며, 각각의 도로는 두개의 버스 정류장을 연결한다. 각각의 버스 정류장에서는 일련의 도로들을 이용하여 다른 모든 버스 정류장에 도달할 수 있다.</p>

<p>매일 아침, 모든 버스 정류장에서는 나머지 버스 정류장들로 정확히 한대의 버스가 출발한다.&nbsp;즉, 전체적으로 N(N - 1)개의 버스들이 있다. 버스들은 경로에 있는 모든 버스정류장에 한번씩 정차한다.</p>

<p>모든 버스 정류장에서는 그곳에 정차하는 모든 버스들(그곳에서 그 경로를 시작하거나 경로를 끝내는 버스들을 포함한)을 나열한 시간표가 있어야한다.</p>

<p>당신은 Kocourkov의 교통 시스템에 대한 설명을 받았다. 도시의 모든 버스 정류장을 위해서 특정한 정류장에 정차하는 버스들의 수를 계산하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 도시의 버스 정류장의 수, 정수 N이 주어진다. 버스 정류장은 1번부터 N번까지 있다. 이후의 N - 1개의 줄은 도시의 도로를 나타낸다. 각각의 줄은 도로에 의해 연결된 두개의 다른 버스 정류장 번호 x, y(&nbsp;1 ≤ x, y ≤ N)를 포함한다.</p>

<p>단 1 ≤ N ≤ 10<sup>6</sup>이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 N개의 줄로 구성된다. i번째 줄에서는 i번 버스 정류장에 멈추는 버스의 수를 하나의 정수로 나타내야한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6
1 2
2 3
3 4
4 5
5 6
','10
18
22
22
18
10
','TREE'),
                                                                                                                (10664,'BAEKJOON','https://www.acmicpc.net/problem/12896',12896,'스크루지 민호','2초','512 MB',14,'<p>구두쇠로 유명한 스크루지 민호가 다스리는 천나라가 있다. 천나라에는 N 개의 도시들이 있는데 각각의 도시들 사이에는 양방향 도로로 이어져 있다. 민호는 도시를 세울 때 최소한의 비용만을 들이고 싶어서 N - 1 개의 도로를 이용해 모든 도시들 사이에는 단 한개의 경로만이 존재하도록 도시를 세웠다.</p>

<p>도시를 세울 당시에 소방서를 여러개 건설하는 것이 아까웠던 스쿠르지 민호는 단 하나의 도시에 소방서를&nbsp; 건설하기로 했다. 하지만 최소한의 양심이 있어서인지 소방서는 최적의 위치가 될 수 있는 도시에 건설하기로 했다. 최적의 위치라는 것은 소방서에서 소방차가 출동해 다른 도시에 도착을 할 때 이동해야 하는 거리중의 최대가 최소가 되는 지점을 의미한다. 편의상 같은 도시 내에서 이동하는 거리는 없다고 생각하며 한 도시에서 다른 도시로 연결된 도로는 거리가 1이라고 생각한다.</p>

<p>천나라에 있는 도시의 수와 도로들의 연결 상태가 주어질 때 최적의 위치에 설치된 소방서에서 소방차가 출동해 다른 도시에 도착할 때 이동해야하는 거리들 중 최대 거리를 구하는 프로그램을 작성하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 천나라에 있는 도시의 수 N (2 ≤ N ≤ 100,000) 이 주어진다.&nbsp; 다음 N - 1 줄에 걸쳐 도시들의 연결 상태가 주어진다.</p>

<p>각각의 줄에는 공백을 기준으로 세개의 숫자가 u, v (1 ≤ u, v ≤ N) 가 주어지는데 이는 도시 u와 v가 양방향 도로로 연결이 되어 있다는 것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최적의 위치에 설치된 소방서에서 소방차가 출동해 다른 도시에 도착할 때까지 이동해야하는 거리들 중 최댓값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4 5
4 2
2 3
1 2
','2
','TREE'),
                                                                                                                (10680,'BAEKJOON','https://www.acmicpc.net/problem/12928',12928,'트리와 경로의 길이','2초','512 MB',17,'<p>N과 S과 주어졌을 때, 다음 두 조건을 만족하는 트리를 만들 수 있는지 없는지 구하는 프로그램을 작성하시오.</p>

<ul>
	<li>트리의 노드의 개수는 N이다.</li>
	<li>길이가 2인 단순 경로의 개수는 S개이다.</li>
</ul>

<p>단순 경로란 같은 정점을 두 번 이상 반복하지 않는 경로를 말한다.</p>

<p>경로에서 방향은 상관없다. A-B-C는&nbsp;C-B-A와 같은 경로이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N과 S가 주어진다. (1 ≤ N ≤ 50, 1 ≤ S ≤ 1,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>트리를 만들 수 있으면 1을, 없으면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
','1
','TREE'),
                                                                                                                (10682,'BAEKJOON','https://www.acmicpc.net/problem/12935',12935,'트리와 경로의 길이 2','2초','512 MB',16,'<p>S과 주어졌을 때, 다음 두 조건을 만족하는 트리를 만드는 프로그램을 작성하시오.</p>

<ul>
	<li>트리의 노드의 개수는 1보다 크거나 같고, 500보다 작거나 같다.</li>
	<li>길이가 3인 단순 경로의 개수는 S개이다.</li>
</ul>

<p>단순 경로란 같은 정점을 두 번 이상 반복하지 않는 경로를 말한다.</p>

<p>경로에서 방향은 상관없다. A-B-C-D는 D-C-B-A와 같은 경로이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에&nbsp;S가 주어진다. (1 ≤ S ≤ 10,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 정점의 개수 N을 출력한다.</p>

<p>둘째 줄부터 N-1개의 줄에 간선의 양 끝 점을 공백으로 구분해서 출력한다.</p>

<p>정점의 번호는 0보다 크거나 같고, N-1보다 작거나 같아야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','1
','4
0 1
1 2
2 3
','TREE'),
                                                                                                                (10688,'BAEKJOON','https://www.acmicpc.net/problem/12947',12947,'트리 만들기','2초','512 MB',12,'<p>트리는 사이클이 없는 연결 그래프이다. 정점 N개로 이루어진 트리는 N-1개의 간선으로 이루어져 있다.</p>

<p>트리의 두 정점 사이의 거리는 한 정점에서 다른 정점으로 갈 때, 지나는 간선 개수의 최솟값이다.</p>

<p>트리의 지름은 모든 두 정점 사이의 거리 중에서 가장 큰 값이다.</p>

<p>아래와 같은 조건을 만족하는 트리 중에서 지름이 가장 긴 것을 만들어보자.</p>

<ul>
	<li>트리의 루트를 V라고 하자.</li>
	<li>V에서 가장 거리가 먼 정점과의 거리를 D라고 하자.</li>
	<li>1보다 크거나 같고, D보다 작거나 같은 모든 i에 대해서, 거리가 i인 정점의 개수는 cnt[i] 이다.</li>
</ul>

<p>cnt배열이 주어졌을 때, 만들 수 있는 트리 중에서 지름이 가장 큰 것의 지름을 출력하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 cnt 배열의 크기 N (1 ≤ N ≤ 50)이 주어진다.</p>

<p>둘째 줄에는 cnt 배열의 값이 cnt[1]부터 cnt[N]까지 차례대로 주어진다. (1 ≤ cnt[i] ≤ 1000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 문제의 조건을 만족시키는 트리 중에서 지름이 가장 큰 것의 지름을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 1의 경우에 만들 수 있는 트리는 한 가지이다.</p>

<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12947/1.png" style="height:92px; width:124px"></p>

<p>예제 2의 경우에 다음과 같은 두 가지 트리를 만들 수 있다. 왼쪽 트리의 지름은 3, 오른쪽 트리의 지름은 4이다.</p>

<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12947/2.png" style="height:136px; width:270px"></p>

<p>예제 3의 경우에는 아래 그림과 같은 트리를 만들 수 있다.</p>

<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12947/3.png" style="height:241px; width:173px"></p>

				</div>
				</div>','1
3
','2
','TREE'),
                                                                                                                (10686,'BAEKJOON','https://www.acmicpc.net/problem/12978',12978,'스크루지 민호 2','2초','512 MB',13,'<p>구두쇠로 유명한 스크루지 민호가 다스리는 천나라가 있다. 천나라에는 N 개의 도시들이 있는데 각각의 도시들 사이에는 양방향 도로로 이어져 있다. 민호는 도시를 세울 때 최소한의 비용만을 들이고 싶어서 N - 1 개의 도로를 이용해 모든 도시들 사이에는 단 한개의 경로만이 존재하도록 도시를 세웠다.</p>

<p>도시를 건설 한 뒤 이번에는 경찰서를 세우려고 했지만 모든 도시에 경찰서를 걸설하기 아까웠던 민호는 몇몇 도시에 경찰서들을 세우지 않기로 했다. 하지만 경찰이 감시하지 못하는 도시들과 도로들이 생기게 된다면 시민들이 반란을 일으킬 수도 있다고 생각한 민호는 최소한의 도시에 경찰서를 세워 모든 도로들과 도시들을 감시하게 하고 싶어졌다.</p>

<p>한 도시에 경찰서를 세우면 해당 도시와 그 도시에 연결된 양방향 도로들로 연결된 도시들을 감시할 수 있다.</p>

<p>천나라에 있는 도시의 수와 도로들의 연결 상태가 주어질 때 최소 몇개의 도시들에 경찰서를 세워야 모든 도시들과 도로들을 감시할 수 있게 하는지 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 천나라에 있는 도시의 수 N (2 ≤ N ≤ 100,000) 이 주어진다.&nbsp; 다음 N - 1 줄에 걸쳐 도시들의 연결 상태가 주어진다.</p>

<p>각각의 줄에는 공백을 기준으로 세개의 숫자가 u, v (1 ≤ u, v ≤ N) 가 주어지는데 이는 도시 u와 v가 양방향 도로로 연결이 되어 있다는 것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 민호가 경설사를 건설해야 하는 최소 도시의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4 5
4 2
2 3
1 2
','2
','TREE'),
                                                                                                                (10687,'BAEKJOON','https://www.acmicpc.net/problem/12995',12995,'트리나라','2초','512 MB',19,'<p>트리나라는 N개의 도시로 이루어져 있고, 각각의 도시는 1번부터 N번까지 번호가 매겨져 있다. 트리나라의 도로 체계는 트리를 이룬다. 즉, 트리나라에는 N-1개의 양방향도로가 있다. 또, 모두 연결되어 있기 때문에, 임의의 두 도시 사이를 항상 오갈 수 있다.</p>

<p>스타트링크의 직원 K명은 트리나라로 이사를 가려고 한다. 모든 직원은 서로 다른 도시로 이사를 가야한다. 즉, 이사할 도시 K개를 선택해야 한다. 이사할 도시에는 중요한 조건이 하나 있는데, 모든 직원이 사는 도시는 연결되어 있어야 한다는 점이다. 예를 들어, 임의의 두 직원 사는 도시가 i와 j라면, i와 j를 연결하는 경로상에 있는 도시에도 직원이 살고 있어야 한다는 점이다.</p>

<p>트리나라의 트리 구조가 주어졌을 때, 이사할 도시 K개를 고르는 방법의 수를 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 도시의 수 N과 스타트링크 직원의 수 K가 주어진다. (2 ≤ N ≤ 50, 1 ≤ K ≤ N)</p>

<p>둘째 줄부터 N-1개의 줄에는 도로 정보가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 도시 K개를 선택하는 방법의 수를 1,000,000,007로 나눈 나머지를 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>예제 1의 경우에 도시 2개를 고르는 방법은 {1, 2}, {2, 3}, {3, 4}가 있다.</p>

<p>예제 2의 경우에는 {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}가 있다.</p>

				</div>
				</div>','4 2
1 2
2 3
3 4
','3
','TREE'),
                                                                                                                (10689,'BAEKJOON','https://www.acmicpc.net/problem/13000',13000,'홍준이와 가능한 집합','3초','512 MB',25,'<p>N개의 정점을 가진 트리가 있습니다. \(i\)번째 정점에는 가중치 \(a(i)\)가 부여되어 있습니다. 그리고 하나의 정수 d가 있을 때에, 다음 조건들을 만족하는 트리의 정점으로 구성된 집합 S를 ‘가능한 집합’이라고 합니다.</p>

<ol>
	<li>S는 공집합이 아닙니다.</li>
	<li>S에 속하는 정점들은 연결되어 있습니다, 즉, S에 속하는 두 정점 u와 v에 대해 그 둘을 잇는 경로에 속하는 모든 정점들은 S에 속해야합니다.</li>
	<li>\(max_{u \in S} {a_u} - min_{v \in S} {a_v} \le d\)</li>
</ol>

<p>‘가능한 집합’ S의 경우의 수를 계산하는 프로그램을 작성하세요. 답이 매우 커질 수 있으므로 10<sup>9</sup>+7로 나눈 나머지 값을 출력하세요.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 d와 N이 주어집니다. (0 ≤ d ≤ 20000, 1 ≤ N ≤ 20000)</p>

<p>둘째 줄에 \(a(i)\)를 나타내는 N개의 정수가 주어집니다. (1 ≤ \(a(i)\) ≤ 20000)</p>

<p>셋째 줄부터 N-1개의 줄에 걸쳐 트리의 간선을 나타내는 두 개의 정수 u와 v가 주어집니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>문제의 답을 10<sup>9</sup>+7로 나눈 나머지를 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>{1},?{2},?{3},?{4},?{1,?2},?{1,?3},?{3,?4}, {1,?3,?4}</p>

				</div>
				</div>','1 4
2 1 3 2
1 2
1 3
3 4
','8
','TREE'),
                                                                                                                (10695,'BAEKJOON','https://www.acmicpc.net/problem/13005',13005,'행복한 나무','2초','512 MB',16,'<p>어떤 나무가 있다. 이 나무는 우리가 익히 아는 자료구조인 트리와 같이 생겼는데, 1~N번까지 N개의 정점을 가지고 있다. 1번 정점을 루트로 하는 이 트리에는 각 노드와 간선에는 하나의 숫자가 쓰여져 있다. 민주는 알고리즘 캠프가 끝나고 휴양림을 갔다가 이 나무를 발견했다. 나무를 보던 민주는 문득 나무의 몇몇 정점이 슬퍼보였다. 민주는 알고리즘 캠프가 끝나서 너무 기쁘기 때문에, 몇몇 정점을 잘라 나무를 행복하게 만들어주고 싶다.</p>

<p>어떤 정점 v가 슬프다는 것은 v아래의 부분트리(subtree)들 중 dist(v, u) > au를 만족하는 정점 u가 하나 이상 존재한다는 것이다. 이때 au는 정점 u에 쓰여있는 숫자이며, dist(v, u)는 v에서 u로 가는 경로에 존재하는 간선들에 적힌 숫자들의 합이다.</p>

<p>민주는 키보드보다 무거운 물건은 들 수 없기 때문에, 정점을 자를 때에는 트리의 말단 정점(leaves)만 자를 수 있다. 트리의 말단 정점이란, 해당 정점으로부터 연결된 자식 정점이 존재하지 않는 정점을 말한다. 자세히 설명하자면 말단 정점과 연결된 정점은 해당 정점의 부모 정점밖에 없다. 즉, 연결된 정점이 하나밖에 없는 정점을 말단 노드라고 부를 수 있는데, 그 중 루트 정점은 트리를 구성하는 정점의 개수가 총 1개 -정점 노드밖에 존재하지 않을 때- 에만 말단 정점이라고 할 수 있다.</p>

<p>민주는 이 복잡한 나무가 행복해질 때까지 정점 노드를 자르려고 한다. 이때 민주가 잘라야하는 정점의 최소 개수는 몇 개일까?</p>

<p>아래 그림의 1)과 같은 나무가 있을 때, 이 나무에서 잘려나가는 정점들은 최소는 다음의 2) ~ 6)의 5개가 된다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13005/1.png" style="height: 385.833px; width: 391.667px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 나무의 노드의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 두 번째 줄에는 1번 노드부터 N번 노드에 쓰여있는 숫자 a<sub>i</sub>(1 ≤ N ≤ 1,000,000,000)가 N개 주어진다. 다음 N - 1개의 줄에는 각 노드들을 잇는 간선의 정보가 들어온다. i번째 간선 정보는 각각 p<sub>i</sub>(1 ≤ p<sub>i</sub> ≤ N)와 c<sub>i</sub>(-1,000,000,000 ≤ c<sub>i</sub> ≤ 1,000,000,000)를 가지는데, 이때 (i + 1)번 노드는 p<sub>i</sub>노드와 연결되어 있고 해당 간선에 쓰인 숫자는 c<sub>i</sub>가 된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄에 나무가 행복해지기 위해 잘라야하는 말단 정점의 최소 개수를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9
88 22 83 14 95 91 98 53 11
3 24
7 -8
1 67
1 64
9 65
5 12
6 -80
3 8
','5
','TREE'),
                                                                                                                (10691,'BAEKJOON','https://www.acmicpc.net/problem/13016',13016,'내 왼손에는 흑염룡이 잠들어 있다','2초','512 MB',16,'<p>철수는 항상 왼손을 붕대로 감고 다닌다. 붕대를 풀면 흑염룡이 날뛰어버리기 때문이다.</p>

<p>어느 날 갑자기 철수가 살고 있는 국가에 태풍이 불어닥쳤다. 태풍으로 인해 주체할 수 없이 날뛰게 된 흑염룡을 잠재우기 위해 철수는 긴 여행을 떠나기로 결심했다. 흑염룡을 잠재우려면 태풍에게서 최대한 멀리 떨어져야 하기 때문에, 현재 철수가 살고 있는 국가에서 가장 거리가 먼 국가로 가야 한다.</p>

<p>철수가 사는 세계는 N개의 국가로 이루어져있고, 그 사이에는 N-1개의 도로가 있어서 국가들을 연결하고 있다. 각 도로는 두 국가를 양방향으로 연결한다. 그리고 임의의 국가에서 다른 모든 국가들로 가는 경로가 항상 존재한다.</p>

<p>철수가 살고 있는 국가의 번호가 i일 때, 철수의 여행의 목적지가 되는 국가까지의 거리를 D[i] 라고 하자. 1 ≤ i ≤ N 인 모든 i에 대해 D[i]를 알아내보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 국가의 수 N(2 ≤ N ≤ 50,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 도로의 정보가 주어진다. 각 도로의 정보는 from, to, length 으로 이루어져 있으며, 이 도로는 국가 from과 국가 to를 연결하는 도로이며 길이는 length 라는 뜻이다. (1 ≤ from, to ≤ N, from ≠ to, 1 ≤ length ≤ 40,000, length는 정수)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>i번째 줄에 D[i]의 값을 출력한다. (1 ≤ i ≤ N)</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
2 1 3
2 4 10
2 3 4
3 5 9
','16
13
14
23
23
','TREE'),
                                                                                                                (10701,'BAEKJOON','https://www.acmicpc.net/problem/13031',13031,'쉽게 행복한 나무','2초','512 MB',14,'<p>어떤 나무가 있다. 이 나무는 우리가 익히 아는 자료구조인 트리와 같이 생겼는데, 1~N번까지 N개의 정점을 가지고 있다. 1번 정점을 루트로 하는 이 트리에는 각 노드와 간선에는 하나의 숫자가 쓰여져 있다. 민주는 알고리즘 캠프가 끝나고 휴양림을 갔다가 이 나무를 발견했다. 나무를 보던 민주는 문득 나무의 몇몇 정점이 슬퍼보였다. 민주는 알고리즘 캠프가 끝나서 너무 기쁘기 때문에, 몇몇 정점을 잘라 나무를 행복하게 만들어주고 싶다.</p>

<p>어떤 정점 v가 슬프다는 것은 v아래의 부분트리(subtree)들 중 dist(v, u) > au를 만족하는 정점 u가 하나 이상 존재한다는 것이다. 이때 au는 정점 u에 쓰여있는 숫자이며, dist(v, u)는 v에서 u로 가는 경로에 존재하는 간선들에 적힌 숫자들의 합이다.</p>

<p>민주는 키보드보다 무거운 물건은 들 수 없기 때문에, 정점을 자를 때에는 트리의 말단 정점(leaves)만 자를 수 있다. 트리의 말단 정점이란, 해당 정점으로부터 연결된 자식 정점이 존재하지 않는 정점을 말한다. 자세히 설명하자면 말단 정점과 연결된 정점은 해당 정점의 부모 정점밖에 없다. 즉, 연결된 정점이 하나밖에 없는 정점을 말단 노드라고 부를 수 있는데, 그 중 루트 정점은 트리를 구성하는 정점의 개수가 총 1개 -정점 노드밖에 존재하지 않을 때- 에만 말단 정점이라고 할 수 있다.</p>

<p>민주는 이 복잡한 나무가 행복해질 때까지 정점 노드를 자르려고 한다. 이때 민주가 잘라야하는 정점의 최소 개수는 몇 개일까?</p>

<p>아래 그림의 1)과 같은 나무가 있을 때, 이 나무에서 잘려나가는 정점들은 최소는 다음의 2) ~ 6)의 5개가 된다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13031/1.png" style="height: 354.167px; width: 363.333px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 나무의 노드의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 두 번째 줄에는 1번 노드부터 N번 노드에 쓰여있는 숫자 a<sub>i</sub>(1 ≤ N ≤ 1,000,000,000)가 N개 주어진다. 다음 N - 1개의 줄에는 각 노드들을 잇는 간선의 정보가 들어온다. i번째 간선 정보는 각각 p<sub>i</sub>(1 ≤ p<sub>i</sub> ≤ N)와 c<sub>i</sub>(0 ≤ c<sub>i</sub> ≤ 1,000,000,000)를 가지는데, 이때 (i + 1)번 노드는 p<sub>i</sub>노드와 연결되어 있고 해당 간선에 쓰인 숫자는 c<sub>i</sub>가 된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄에 나무가 행복해지기 위해 잘라야하는 말단 정점의 최소 개수를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9
88 22 83 14 95 91 98 53 11
3 24
7 7
1 67
1 64
9 65
5 12
6 1
3 8
','5
','TREE'),
                                                                                                                (10710,'BAEKJOON','https://www.acmicpc.net/problem/13120',13120,'트리의 변화','1초','512 MB',21,'<p>트리란 정점이 <em>n</em>개이고 간선이 <em>n</em> ? 1개인 연결 그래프를 의미한다. 수찬이는 최근 트리를 배양하여 관찰하는 일에 푹 빠져 있다. 여느 날과 같이 트리를 지켜보던 그는 모든 트리는 정점의 개수가 2의 거듭제곱 꼴(2<sup>0</sup>, 2<sup>1</sup>, 2<sup>2</sup>, ··· , 2<sup>k</sup>, ···)일 때 다른 트리와 전혀 반응하지 않고 움직임도 없다는 것을 우연히 발견하였다. 그는 이러한 트리가 안정적인 상태에 있다고 정의하였다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/pic1.png" style="height:110px; width:251px"></p>

<p style="text-align: center;">정점이 6개인 트리는 안정적인 상태가 아니고, 정점이 4개인 트리는 안정적인 상태이다.</p>

<p>수찬이는 동료 과학자 지학이에게 이 사실을 공유하였다. 지학이는 수찬이의 연구 노트를 읽어보더니 수찬이에게 “모든 트리는 안정적인 상태가 되는 방향으로 변하지 않을까?”라고 말했다. 지학이의 말이 일리가 있다고 생각한 수찬이는 여러 실험을 통해 지학이의 추측이 사실임을 알아냈다. 그가 발견한 성질은, 어떤 트리가 안정적인 상태가 아니라면, 트리 스스로 간선들을 끊어 자신을 적절히 쪼개어 몇 개의 트리로 나누는데, 이때 각 트리의 정점의 개수가 2의 거듭제곱 꼴이 되게 함으로써 자신을 안정적인 상태로 만든다는 것이었다. 수찬이는 자신이 밝혀낸 성질을 지학이와 공유했다. 지학이는 수찬이의 발견에 흥미를 느끼고 실험 데이터를 분석하다가, 트리의 간선을 끊는 데에 에너지가 필요하다는 것을 알게 되었고, 이를 통해 트리가 안정적인 상태로 변하는 과정에서 끊기는 간선의 개수를 최소화하는 방법으로 나뉜다는 성질을 추가로 밝혀냈다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/pic2.png" style="height:96px; width:268px"></p>

<p style="text-align: center;">정점이 6개인 어떤 트리가 안정적인 상태로 변하는 한 예.</p>

<p>수찬이와 지학이는 트리에는 더 많은 성질들이 있을 것이라고 보고, 새로운 성질을 발견하여 그들의 지적 호기심을 채우고자 한다. 그들은 트리가 정확히 어떤 방법으로 나뉘는지 알아보기 위해, 일단 자신들이 알아낸 성질을 따르면서 트리가 나뉘는 서로 다른 방법의 수를 관찰하여 그 특징을 찾고자 한다. 트리가 나뉘는 방법이 서로 다르다는 것은, 끊긴 간선의 집합이 서로 다르다는 것이다. (트리의 간선이 끊기는 순서는 상관이 없다!)</p>

<p>수찬이와 지학이를 돕기 위해, 정점이 <em>n</em>개인 트리가 주어졌을 때, 이 트리가 수찬이와 지학이가 발견한 성질을 따르면서 나뉘는 서로 다른 방법의 수를 구하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 트리의 정점의 수 <em>n</em>(2 ≤ <em>n</em> ≤ 4 095)이 주어진다. 트리의 각 정점에 1부터 <em>n</em>까지의 자연수 번호가 붙어 있다고 하자.</p>

<p>다음 (<em>n</em> ? 1)개의 줄에는 트리의 간선에 대한 정보가 주어진다. 각 줄에는 간선이 잇는 두 정점의 번호를 나타내는 두 개의 자연수 <em>u</em>와 <em>v</em> (1 ≤ <em>u</em>, <em>v</em> ≤ <em>n</em>, <em>u</em> ≠ <em>v</em>)가 공백을 사이로 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 트리가 수찬이와 지학이가 발견한 성질을 따르면서 나뉘는 방법의 수를 10<sup>9</sup> + 7로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>첫 번째 예제에 주어진 트리를 그림으로 그려 보면 아래와 같다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex1.png" style="height:26px; width:244px"></p>

<p>간선을 두 개 끊으면 정점이 4(= 2<sup>2</sup>)개인 트리, 2(= 2<sup>1</sup>)개인 트리, 1(= 2<sup>0</sup>)개인 트리로 나눌 수 있으며, 아래와 같이 여섯 가지 방법이 있다. 실선은 남아 있는 간선을, 점선은 끊긴 간선을 의미한다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex1-1.png" style="height:26px; line-height:20.8px; text-align:center; width:244px">&nbsp;&nbsp; <img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex1-2.png" style="height:26px; line-height:20.8px; text-align:center; width:244px"></p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex1-3.png" style="height:26px; line-height:20.8px; text-align:center; width:244px">&nbsp;&nbsp; <img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex1-4.png" style="height:26px; line-height:20.8px; text-align:center; width:244px"></p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex1-5.png" style="height:26px; line-height:20.8px; text-align:center; width:244px">&nbsp;&nbsp; <img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex1-6.png" style="height:26px; line-height:20.8px; text-align:center; width:244px"></p>

<p>두 번째 예제에 주어진 트리를 그림으로 그려 보면 아래와 같다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex3.png" style="height:80px; width:165px"></p>

<p>이 경우 간선을 세 개 끊어서 안정적인 상태로 만들 수 있다. 트리가 나누어진 결과는 나뉜 각 트리들의 정점의 개수에 따라 크게 아래의 두 가지로 분류할 수 있다.</p>

<ul>
	<li>정점이 4(= 2<sup>2</sup>)개인 트리 두 개와 정점이 2(= 2<sup>1</sup>)개인 트리 하나와 정점이 1(= 2<sup>0</sup>)개인 트리 하나로 나뉘는 경우:

	<ul>
		<li>모든 가능한 방법에서 6번 정점과 9번 정점을 잇는 간선, 6번 정점과 3번 정점을 잇는 간선은 반드시 끊긴다. 이를 통해 정점이 4개인 트리 하나와 정점이 2개인 트리 하나가 결정된다.</li>
		<li>3번 정점과 2, 5, 7, 11번 정점을 잇는 간선 중 하나를 선택해서 끊으면, 정점이 4개인 트리 하나와 정점이 1개인 트리 하나가 추가로 결정된다.</li>
		<li>따라서 이 방법으로 트리를 나눌 수 있는 경우의 수는 4이다.</li>
	</ul>
	</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex3-m1.png" style="height:80px; width:165px"></p>

<p style="text-align: center;">정점의 개수가 4, 4, 2, 1인 트리 네 개로 나누는 방법의 예</p>

<ul>
	<li>정점이 8(= 23)개인 트리 하나와 정점이 1(= 20)개인 트리 세 개로 나뉘는 경우:
	<ul>
		<li>단말 정점(간선으로 연결된 정점의 개수가 1개인 정점) 세 개를 골라서, 그 정점과 연결된 간선 3개를 끊으면 된다.</li>
		<li>단말 정점이 8개 있으므로, 이 방법으로 트리를 나눌 수 있는 경우의 수는 \(8 \choose 3\)= 56이다.</li>
	</ul>
	</li>
</ul>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13120/ex3-m2.png" style="height:80px; line-height:20.8px; opacity:0.9; text-align:center; width:165px"></p>

<p style="text-align: center;">정점의 개수가 8, 1, 1, 1인 트리 네 개로 나누는 방법의 예</p>

<p>따라서 총 경우의 수는 60이다.</p>

				</div>
				</div>','7
1 2
2 3
3 4
4 5
5 6
6 7
','6
','TREE'),
                                                                                                                (10706,'BAEKJOON','https://www.acmicpc.net/problem/13159',13159,'배열','1초','512 MB',24,'<p>UCPC 2015년도 우승자 범수, 상수 형제는 가끔 배열을 가지고 논다. 이들은 크기 N인 배열 A=[a<sub>1</sub>,…,a<sub>N</sub>]을 가지고 있다. 처음에는 모든 i(1≤i≤N)에 대해 a<sub>i</sub>=i이다. 이 형제들은 Q개의 질의를 받아 순서대로 해결하면서 논다. 질의는 다음과 같은 네 종류 중 하나이다.</p>

<ol>
	<li>&nbsp;“1 l r” (1 ≤ l ≤ r ≤ N): a<sub>l</sub>에서 a<sub>r</sub>사이의 수들에 대해 이들의 최솟값, 최댓값, 합을 구한다. 그리고 a<sub>l</sub>에서 a<sub>r</sub>사이의 수들을 뒤집는다. 배열을 뒤집고 나면 원래의 배열은 아래와 같이 변할 것이다.</li>
</ol>

<p style="text-align:center">[a<sub>1</sub>,…a<sub>l-1</sub>,a<sub>r</sub>,a<sub>r-1</sub>,…,a<sub>l+1</sub>,a<sub>l</sub>,a<sub>r+1</sub>,…,a<sub>N</sub>]</p>

<ol start="2">
	<li>&nbsp;“2 l r x” (1 ≤ l ≤ r ≤ N, -N < x < N): a<sub>l</sub>에서 a<sub>r</sub>사이의 수들에 대해 이들의 최솟값, 최댓값, 합을 구한다. 그리고 a<sub>l</sub>에서 a<sub>r</sub>사이의 수들을 오른쪽으로 x칸만큼 shift한다. 만약 x가 음수라면, 왼쪽으로 -x칸만큼 shift한다. 0 < x ≤ r-l인 경우 원래의 배열은 아래와 같이 변할 것이다.</li>
</ol>

<p style="text-align:center">[a<sub>1</sub>,…a<sub>l-1</sub>,a<sub>r-x+1</sub>,…,a<sub>r-1</sub>,a<sub>r</sub>,a<sub>l</sub>,a<sub>l+1</sub>,…,a<sub>r-x</sub>,a<sub>r+1</sub>,…,a<sub>N</sub>]</p>

<ol start="3">
	<li>&nbsp;“3 i” (1 ≤ i ≤ N): a<sub>i</sub>가 어떤 수인지 구한다.</li>
	<li>&nbsp;“4 x” (1 ≤ x ≤ N): a<sub>i</sub>=x인 i(1 ≤ i ≤ N)가 어떤 수인지 구한다.</li>
</ol>

<p>하나의 질의를 수행한 다음 배열이 바뀌고 나면, 그 결과는 다음의 질의에도 영향을 미친다. 이때, 범수, 상수 형제가 질의를 해결할 때마다 구한 값을 출력하고, 모든 질의를 해결한 뒤 마지막 배열의 모습을 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에는 배열의 크기를 나타내는 자연수 N과 질의의 수를 나타내는 자연수 Q가 주어진다.(1 ≤ N,&nbsp;Q ≤ 300,000) 그 다음 Q개의 줄에 걸쳐 각 질의의 정보가 네 종류 중 하나의 형식으로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q개의 줄에 걸쳐 각 질의마다 구해야 하는 값을 공백으로 구분하여 한 줄씩 출력한다. 1번과 2번 질의는 최솟값, 최댓값, 합 순서로 출력하고, 3번과 4번 질의는 구하는 값 하나를 출력한다. 마지막 (Q+1)번째 줄에는 모든 질의를 해결한 후 배열의 값을 공백으로 구분하여 한 줄에 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>[1, 2, 3, 4, 5]→[1, 4, 3, 2, 5]→[1, 4, 5, 3, 2]→[5, 1, 4, 3, 2]</p>

				</div>
				</div>','5 5
1 2 4
3 4
2 3 5 1
2 1 3 -2
4 3
','2 4 9
2
2 5 10
1 5 10
4
5 1 4 3 2
','TREE'),
                                                                                                                (10711,'BAEKJOON','https://www.acmicpc.net/problem/13209',13209,'검역소','3초','256 MB',19,'<p>연약한 사람들이 모여 사는 나라가 있다. 이 곳에는 <em>N</em> 개의 도시들이 있고, 두 도시 사이를 연결하는 길이 <em>N</em> ? 1개 있어 어느 두 도시도 오직 하나의 경로로만 서로 통행할 수 있게 되어 있다.</p>

<p>이 곳에는 몇 년에 한 번씩 전염병이 창궐하여 큰 피해가 일어난다. 정부에서는 이 문제를 해결하기 위해 <em>N</em> ?1 개의 길들 중 <em>K</em> 개의 길에 검역소를 운영하려고 한다. 검역소는 감염된 사람이 지나가지 못하게 함으로서 전염병이 전파될 수 없는 장벽과 같은 역할을 해 준다.</p>

<p>하지만 검역소들만으로는 전염병이 일어나지 못하게 할 수는 없다. 따라서 어떤 사람이 전염병에 감염될 경우를 대비하여 치료제를 비축해 두려고 한다. 어떤 한 사람이 전염병에 감염될 때에도 전염병에 걸릴 수 있는 모든 사람들이 치료제를 하나씩 받을 수 있게 하기 위해 비축해야 할 치료제의 최소 개수를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 테스트 케이스의 수 <em>T</em> 가 주어진다.</p>

<p>각 테스트 케이스의 첫 번째 줄에는 도시의 개수를 의미하는 자연수 <em>N</em>(2 ≤ <em>N</em> ≤ 100, 000)과 설치할 수 있는 검역소의 개수 <em>K</em>(1 ≤ <em>K</em> ≤ <em>N</em> ? 1)가 주어진다.</p>

<p>두 번째 줄에는 <em>N</em> 개의 자연수가 주어지며, <em>i</em>번째 자연수는 <em>i</em>번 도시의 인구 <em>X<sub>i</sub></em>(1 ≤ <em>X<sub>i</sub></em> ≤ 1, 000, 000, 000)를 의미한다.</p>

<p>세 번째 줄부터 <em>N</em> ? 1개의 줄에는 도로의 정보가 한 줄에 하나씩 주어진다. 한 줄에는 두 개의 정수 <em>A<sub>i</sub></em> , <em>B<sub>i</sub></em>&nbsp;(1 ≤ <em>A<sub>i</sub></em> ≤ N, 1 ≤ <em>B<sub>i</sub></em> ≤ N)가 주어지며 이것은 <em>A<sub>i</sub></em> 번 도시와 <em>B<sub>i</sub></em> 번 도시가 도로로 연결되어 있음을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>전염병이 퍼질 경우에 대비해 정부에서 비축해야 하는 치료제의 개수를 하나의 정수로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>3번 도시와 5번 도시를 잇는 도로와 4번 도시와 3번 도시를 잇는 도로에 검역소를 설치하면 치료제를 11 인분만 비축해도 된다. 1번 도시에 전염병이 발생할 경우 1번 도시와 3번 도시의 10명의 사람들이, 2번 도시에 전염병이 발생할 경우 2번 도시와 4번 도시의 11명의 사람들이, 3번 도시에 발생할 경우 10명, 4 번 도시에 발생할 경우 11명, 5번 도시에 발생할 경우 5명이 감염될 수 있으므로 어느 경우에도 11인분의 치료제로 충분히 전염병을 막을 수 있다.</p>

				</div>
				</div>','1
5 2
3 9 7 2 5
1 3
2 4
3 5
4 3
','11
','TREE'),
                                                                                                                (10720,'BAEKJOON','https://www.acmicpc.net/problem/13325',13325,'이진 트리','1초','512 MB',13,'<p>각 에지에 양수인 가중치가 부여된 높이가 k인 포화이진트리가 주어져 있다. 높이 k인 포화이진트리는 2<sup>k</sup>개의 리프를 포함하여 (2<sup>k+1</sup> ? 1)개의 노드를 가진다. 루트에서 어떤 리프까지의 거리는 루트에서 그 리프까지의 경로상에 있는 모든 에지들의 가중치를 더한 값이다. 이 문제에서는, 어떤 에지들의 가중치를 증가시켜서 루트에서 모든 리프까지의 거리가 같도록 하고, 또한 에지 가중치들의 총합을 최소화 하려고 한다.</p>

<p>예를 들어, 그림 1(a)에 있는 높이 2 인 포화이진트리를 살펴보자. 에지 옆에 있는 수는 그 에지의 가중치를 나타낸다. 이 경우에 대한 답이 그림 1(b)에 나타나 있다. 즉, 루트에서 모든 리프까지의 거리가 5 이고, 에지 가중치들의 총합은 이 경우에 가능한 최솟값인 15 이다.&nbsp;</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13325/1.png" style="height: 152.5px; width: 377.5px;"></p>

<p style="text-align:center">그림 1. 에지 가중치를 증가시키는 예.</p>

<p>포화이진트리에 들어 있는 모든 에지들의 가중치가 주어졌을 때, 어떤 에지들의 가중치를 증가시켜서 루트에서 모든 리프까지의 거리가 같게 하면서 에지 가중치들의 총합이 최소가 되도록 하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력 데이터는 표준입력을 사용한다. 입력의 첫째 줄에는 포화이진트리의 높이를 나타내는 양의 정수 k(1 ≤ k ≤ 20)가 주어진다. 두 번째 줄에는 모든 에지들의 가중치가 주어진다. 에지들의 가중치는 루트에서 가까운 레벨에 있는 것부터, 같은 레벨에 있는 경우는 왼쪽부터 오른쪽의 순서로 주어진다. 각 에지의 가중치는 1 이상 1,000 이하인 정수로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 표준출력을 사용한다. 에지들의 가중치를 증가시킨 다음에 얻어지는 트리에 있는 모든 에지들의 가중치들의 총합을 한 줄에 출력한다. 어떤 에지의 가중치는 경우에 따라 1,000 이상의 값으로 증가될 수도 있다는 점에 유의하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
2 2 2 1 1 3
','15
','TREE'),
                                                                                                                (10719,'BAEKJOON','https://www.acmicpc.net/problem/13431',13431,'트리 문제','5초','512 MB',22,'<p>N개의 정점으로 이루어진 트리가 있다. 정점 번호는 0번부터 N-1번까지이다. 처음에, 트리의 모든 정점은 흰색이다. 이제 다음과 같은 Q개의 쿼리를 처리해야 한다.</p>

<ul>
	<li>쿼리 1: x번 정점을 파란색으로 색칠한다.</li>
	<li>쿼리 2: x번 정점과 모든 파란&nbsp;정점 사이의 거리의 합을 계산한다.</li>
</ul>

<p>모든 쿼리 2의 정답을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 N(2 ≤ N ≤ 100,000)과 쿼리의 개수 Q(1 ≤ Q ≤ 100,000)가 주어진다.</p>

<p>둘째 줄부터 N-1개의 줄에는 트리의 간선 정보 u, v, w가 주어진다. u와 v는 간선이 연결하는 두 정점이며, w는 간선의 길이이다. (1 ≤ w ≤ 1,000,003)</p>

<p>다음 Q개의 줄에는 쿼리의 정보가 주어진다. 첫 번째 정수는 쿼리의 종류 (1 또는 2)이며, 두 번째 정수는 쿼리의 x이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>쿼리 2번이 주어질 때 마다 순서대로 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 6
1 0 2
2 1 1
3 2 3
2 2
1 3
2 2
2 3
2 1
1 3
','0
3
0
4
','TREE'),
                                                                                                                (10727,'BAEKJOON','https://www.acmicpc.net/problem/13518',13518,'트리와 쿼리 9','2초','512 MB',22,'<p>N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다.&nbsp;정점은&nbsp;가중치를 가지고 있다.</p>

<p>아래의 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>u v</code>: u에서 v로 가는 경로에 존재하는 서로 다른 정점의 가중치의 개수를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 정점의 가중치가 1번 정점부터 순서대로 주어진다.</p>

<p>셋째&nbsp;줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.</p>

<p>다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

<p>정점의 가중치는 항상&nbsp;1,000,000보다 작거나 같은 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8
105 2 9 3 8 5 7 7
1 2
1 3
1 4
3 5
3 6
3 7
4 8
2
2 5
7 8
','4
4
','TREE'),
                                                                                                                (10704,'BAEKJOON','https://www.acmicpc.net/problem/13539',13539,'트리와 쿼리 11','2초','512 MB',25,'<p>정점 하나로 이루어진 루트 있는 트리 N개가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있다.&nbsp;</p>

<p>아래의 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 u v</code>: u와 v 사이에 간선을 하나 연결한다. 이때, v가 u의 부모가 된다. 쿼리가 실행되기 전에 u는 u가 포함되어&nbsp;있는 트리의 루트이며, u와 v는 다른 트리에 속해 있음이 보장된다.</li>
	<li><code>2 v</code>: v와 v의 부모를 연결하는 간선을 끊는다. v는 루트가 아니다.</li>
	<li><code>3 u v</code>: u와 v의 LCA를 출력한다. u와 v는 같은 트리 안에 있다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 N (2 ≤ N ≤ 100,000)과&nbsp;쿼리의 개수 M (1 ≤ M ≤ 200,000)이 주어진다.</p>

<p>다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 3번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 9
3 1 1
1 1 2
1 3 2
1 4 3
3 1 4
3 3 4
2 4
1 5 3
3 1 5
','1
2
3
2
','TREE'),
                                                                                                                (10703,'BAEKJOON','https://www.acmicpc.net/problem/13543',13543,'수열과 쿼리 2','2초','512 MB',24,'<p>길이가 N인 수열 A<sub>0</sub>, A<sub><span style="font-size:10.8333px">1</span></sub>, ..., A<sub>N-1</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오. (0 ≤ A<sub>i</sub> < 2<sup>32</sup>)</p>

<ul>
	<li><code>1 p&nbsp;v</code>: A<sub>p</sub>의 앞에 v를 추가한다. p가 A의 길이와 같은 경우에는 가장 마지막에 추가하는 것이다.&nbsp;(0&nbsp;≤ p ≤ A의 길이, 0 ≤ v < 2<sup>32</sup>)</li>
	<li><code>2 p</code>: A<sub>p</sub>를 제거한다. (0 ≤ p < A의 길이)</li>
	<li><code>3 p&nbsp;v</code>: A<sub>p</sub>를&nbsp;v로 바꾼다. (0 ≤ p < A의 길이, 0 ≤ v < 2<sup>32</sup>)</li>
	<li><code>4 l&nbsp;r k</code>: l ≤ i ≤ r에 대해서 (ΣA<sub>i</sub>&nbsp;×&nbsp;(i - l + 1)<sup>k</sup>) mod 2<sup>32</sup>를 구한 다음 출력한다. (0 ≤ k ≤ 10)</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p>

<p>둘째 줄에는 A<sub>0</sub>, A<sub>1</sub>, ..., A<sub>N-1</sub>이 주어진다.</p>

<p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2 3 5
7
4 0 2 0
1 3 4
4 2 4 1
2 0
4 0 3 1
3 1 2
4 0 1 0
','6
26
40
4
','TREE'),
                                                                                                                (10728,'BAEKJOON','https://www.acmicpc.net/problem/14244',14244,'트리 만들기','2초','512 MB',7,'<p>n과 m이 주어졌을 때, n개의 노드로 이루어져 있고, m개의 리프로 이루어져 있는 트리를 만드는 프로그램을 작성하시오.</p>

<p>항상 정답이 존재하는 경우만 입력으로 주어진다.</p>

<p>트리는 사이클이 없는 연결 그래프이고, 리프는 차수가 1인 노드를 의미한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 n과 m이 주어진다. (3 ≤ n ≤ 50, 2 ≤ m ≤ n-1)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄부터 n-1개의 줄에 트리의 간선 정보를 출력한다. 트리의 정점은 0번부터 n-1번까지 이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 2
','0 1
1 2
2 3
','TREE'),
                                                                                                                (10730,'BAEKJOON','https://www.acmicpc.net/problem/14267',14267,'회사 문화 1','2초','512 MB',12,'<p>영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.</p>

<p>모든 칭찬에는 칭찬의 정도를 의미하는 수치가 있는데,&nbsp;이 수치 또한 부하들에게 똑같이 칭찬 받는다.</p>

<p>직속 상사와 직속 부하관계에 대해 주어지고, 칭찬에 대한 정보가 주어질 때, 각자 얼마의 칭찬을 받았는지 출력하시오,</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 회사의 직원 수 n명, 최초의 칭찬의 횟수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)</p>

<p>둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.</p>

<p>다음 m줄에는 직속 상사로부터 칭찬을 받은 직원 번호 i, 칭찬의 수치 w가 주어진다. (2 ≤ i ≤ n, 1 ≤ w ≤ 1,000)</p>

<p>사장은 상사가 없으므로 칭찬을 받지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>1번부터 n번의 직원까지 칭찬을 받은 정도를 출력하시오.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 3
-1 1 2 3 4
2 2
3 4
5 6
','0 2 6 6 12
','TREE'),
                                                                                                                (10731,'BAEKJOON','https://www.acmicpc.net/problem/14432',14432,'우물','2초','256 MB',16,'<p>현성이는 너무나 따뜻한 마음씨를 가지고 있다(대회 종료 후에 사실이 아닌 것으로 확인되었다 - @behind06). 현성이는 물을 마음껏 마시지 못하는 아프리카 아이들을 위해 마을에 우물을 설치하려고 한다.</p>

<p>마을마다 필요한 우물의 수가 다르며, 마을 A에 우물을 하나 설치하면 마을 A와 인접한 모든 마을의 우물도 하나씩 충족된다.</p>

<p>예를 들어, A-B A-C 마을이 연결되어 있고, A, B, C 마을이 각각 5, 10, 7개의 우물을 필요로 할 때, A 마을에 우물을 5개 설치하면 B와 C 마을에도 우물이 5개 충족되는 셈이다.</p>

<p>하지만 현성이는 평소에도 기부를 워낙 많이 해서 돈이 충분하지 않다. (이것도 역시 사실이 아닌 것으로 확인되었다 - @tonyjjw)</p>

<p>마을의 수가 n이고, 각 마을에 필요한 최소 우물 수는 W<sub>1</sub>, W<sub>2</sub>, ... , W<sub>n</sub>이고, 마을간 서로 이동할 수 있는 길의 수가 m일 때, 현성이를 위해 필요한 우물의 최소 개수를 구해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 마을의 개수 n(1 ≤ n ≤ 100,000)와 길의 개수 m(1 ≤ m < 100,000)개가 주어지고</p>

<p>둘째 줄에 각 마을에 필요한 최소 우물의 수 W<sub>1</sub>, W<sub>2</sub>, ... ,W<sub>n</sub> (0 ≤ W<sub>i</sub> ≤ 10,000,000)이 주어지고</p>

<p>세 번째 줄부터 m+2번째 줄까지 길의 정보가 주어진다. 길의 정보는 서로 이동할 수 있는 a마을, b마을로 이루어져 있다. 단, 임의의 마을 A에서 B까지 정확히 한 가지 경로가 존재한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에&nbsp;현성이를 위해 필요한 우물의 최소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 6
2 5 3 11 4 3 1
1 3
2 3
3 4
4 5
5 6
5 7
','11
','TREE'),
                                                                                                                (10734,'BAEKJOON','https://www.acmicpc.net/problem/14570',14570,'나무 위의 구슬','1초','128 MB',15,'<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14570/1.png" style="height:185px; width:193px"></p>

<p>이진 트리란, 위처럼 모든 노드의 자식의 수가 2개 이하인 트리이다.</p>

<p>각 노드에 쓰여 있는 수는 노드의 번호를 의미한다.</p>

<p>특히, 이 문제에서는 루트가 고정되어 있으며, 노드의 순서가 중요한(어떤 서브트리에서도 좌우를 변경할 수 없는) 이진 트리에 대해 다루기로 한다.</p>

<p>이진 트리의 루트에 구슬을 하나 올려놓으면 구슬은 아래와 같은 과정을 거쳐 떨어진다.</p>

<ol>
	<li>현재 구슬이 놓인 노드의 자식이 없다면 그 자리에서 멈춘다.</li>
	<li>1을 만족하지 않으며, 만일 현재 구슬이 놓인 노드의 자식 노드가 한 개라면 해당 자식 노드로 떨어진다.</li>
	<li>1, 2를 만족하지 않으며, 만일 현재 구슬이 놓인 노드의 자식 노드가 두 개라면,
	<ol>
		<li>현재 노드의 왼쪽 서브트리에 담긴 모든 구슬의 수 <= 오른쪽 서브트리에 담긴 모든 구슬의 수일 경우, 왼쪽 자식 노드로 떨어진다.</li>
		<li>그 외의 경우에는 오른쪽 자식 노드로 떨어진다.</li>
	</ol>
	</li>
	<li>1~3번의 조건을 다시 체크하고 되풀이한다.</li>
</ol>

<p>구슬은 위와 같은 과정을 거쳐 결국 단말 노드에 쌓이게 된다.</p>

<p>예를 들어, 위의 그림과 같은 트리에 구슬을 떨어뜨릴 경우,</p>

<p>첫 다섯 개의 구슬은 2번, 4번, 2번, 5번, 2번 노드에 차례대로 떨어지게 된다.</p>

<p>위처럼 트리가 충분히 작거나 구슬의 수가 충분히 적을 경우엔 직접 시뮬레이션을 통해</p>

<p>구슬이 떨어지는 순서를 유추할 수가 있다.</p>

<p>하지만, 우리가 관심있는 것은 큰 트리에서 많은 수의 구슬을 떨어뜨리는 과정이다.</p>

<p>임의의 이진 트리가 주어지고, K가 주어졌을 때</p>

<p>K번째 구슬이 어느 노드에서 멈추게 될 지 충분히 빠르게 계산해낼 수 있을까?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 이진 트리의 노드의 수 N이 주어진다. (1 ≤ N ≤ 200000)</p>

<p>둘째 줄부터 N개의 줄에 걸쳐, U V가 주어진다.</p>

<p>i번째 줄에 주어지는 U, V는 각각 i번 노드의 왼쪽 자식이 U, 오른쪽 자식이 V임을 의미한다.</p>

<p>만약 U = -1 또는 V = -1이라면, 해당 위치에 자식 노드가 존재하지 않는다는 것이다.</p>

<p>그 외의 경우엔 항상 2 ≤ U, V ≤ N을 만족한다.</p>

<p>이어 마지막 줄에 문제에서 설명한 K가 주어진다. (1 ≤ K ≤ 10<sup>18</sup>)</p>

<p>주어지는 트리는 항상 올바른 이진 트리임이 보장되며, 루트는 항상 1번 노드이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>K번째 구슬이 떨어지는 노드의 번호를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
2 3
-1 -1
4 5
-1 -1
-1 -1
5
','2
','TREE'),
                                                                                                                (10736,'BAEKJOON','https://www.acmicpc.net/problem/14657',14657,'준오는 최종인재야!!','2초','512 MB',14,'<p>심술쟁이 해커 임준오(동탄 주민)는 BOB에 불합격했다. 아주인싸 해커 이시훈(김포 주민)과 함께 KFC 숙대입구역점에서 햄버거를 먹다가 지원마감 시간이 지나버렸기 때문이다! 하지만 걱정하지 마시라. 준오는 1년의 기다림을 지나 BOB에 합격했다.</p>

<p>재수 끝에 기회를 잡은 준오는 꼭 최종인재가 되기로 결심했다. 하지만 안티준오 멘토 김영중(장평 주민)은 준오를 최종인재로 추천하고 싶지 않았다. 그래도 멘토는 공정해야 하기 때문에, 영중이는 준오에게 악랄한 과제를 내주기로 했다.</p>

<p>“네가 만약 제한 시간 안에 기준치 이상의 문제를 풀어온다면 너를 최종인재로 추천해주겠다. 하지만 그렇지 못한다면! 너는 영원히 BOB 센터에서 히어로즈 오브 더 스톰을 플레이해야 할 거야... 후후”</p>

<p>진정한 최고 해커라면 선택의 길에 운도 따라야하는 법. 영중이가 고안한 문제 풀이 시스템은 다음과 같다.</p>

<ol>
	<li>N개의 문제들과 임의의 두 문제를 연결하는 링크가 N-1개 존재한다. (링크는 양방향으로 동작한다)</li>
	<li>N개의 문제들 중 링크를 통해 도달할 수 없는 문제는 없다.</li>
	<li>임의의 문제 A에서 B까지 도달하는 경로는 유일하다.</li>
</ol>

<p>준오는 N개의 문제들 중 원하는 문제를 하나 골라서 테스트를 시작할 수 있다. 한 번 테스트를 시작하면 문제를 바꿀 수 없으며, 문제를 푼 이후에는 해당 문제에 연결된 링크들 중 하나를 골라 문제를 선택할 수 있다. 단, 문제를 풀고 난 후 링크를 통해 한 번 문제를 선택하고 나면, 이전에 풀었던 문제로 다시 돌아갈 수는 없다. 어떤 문제 A에 연결된 문제 B와 C가 있을 때, A를 풀고 나서 B를 푸는 시간과 A를 풀고 나서 C를 푸는 시간이 각각 다를 수 있다. 물론 B를 풀고 A를 푸는 시간은 A를 풀고 B를 푸는 시간과 동일하다. 처음 고른 문제는 보너스로 취급되어 무조건 정답처리 된다. 다시 말해, 첫 번째 문제를 푸는 데에는 0초의 시간이 소요된다.</p>

<p>준오는 영중이가 굉장히 건방지다고 생각했고, 화가 난 준오는 과제 따위는 잊어버리고 영중이의 시스템 내에서 풀 수 있는 최대한의 문제를 풀어 보이려고 한다. 하지만 준오도 사람이기 때문에 하루에 문제 풀이에 투자할 수 있는 시간은 정해져있다. 그래서 준오는 매일 투자할 수 있는 최대한의 시간 동안 문제를 풀고, 남은 문제는 그 다음날에 이어서 풀려고 한다. 예를 들어, 준오가 하루에 4시간을 투자할 수 있고 a->b->c->d를 푸는 시간이 모두 3이라면, 문제를 푸는데 걸리는 시간은 3+3+3=9가 되고 걸리는 날짜 수는 4+4+1=9로 3일이 된다.</p>

<p>당신은 딱히 궁금하지 않겠지만, 아무튼 문제가 이렇게 나왔으니 궁금하다고 치자. 당신은 준오가 최대한 많은 문제를 푸는 데 며칠이나 걸릴 지 궁금해졌다! 문제의 수 N, 하루에 문제 풀이에 투자할 수 있는 시간 T, 연결된 문제의 정보가 주어질 때, 준오가 시스템 내에서 최대한 많은 문제를 푸는 데 걸리는 최소의 날짜 수를 계산해보자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 문제의 수 N, 하루 풀이 시간 T가 주어진다. (2 ≤ N ≤&nbsp;50,000, 1 ≤&nbsp;T ≤ 100,000) 이후 둘째 줄 부터 N-1개의 줄에 걸쳐 각 줄마다 A, B, C가 주어진다. (1 ≤&nbsp;A, B ≤ N, 1 ≤&nbsp;C ≤&nbsp;1,000) A와 B는 서로 연결된 문제의 번호를 뜻하며, C는 A를 풀고 B를 풀거나 B를 풀고 A를 푸는데 걸리는 시간을 뜻한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>준오가 최대한 많은 문제를 푸는데 걸리는 최소 날짜 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 4
1 2 4
2 3 2
3 4 7
3 5 3
6 5 4
','4
','TREE'),
                                                                                                                (10743,'BAEKJOON','https://www.acmicpc.net/problem/14675',14675,'단절점과 단절선','1초','512 MB',10,'<p>그래프 이론에서 단절점(cut vertex)과 단절선(bridge)은 다음과 같이 정의 된다.</p>

<ul>
	<li>단절점(cut vertex) : 해당 정점을 제거하였을 때, 그 정점이 포함된 그래프가 2개 이상으로 나뉘는 경우, 이 정점을 단절점이라 한다.</li>
	<li>단절선(bridge) : 해당 간선을 제거하였을 때, 그 간선이 포함된 그래프가 2개 이상으로 나뉘는 경우, 이 간선을 단절선이라 한다.</li>
</ul>

<p>이 단절점과 단절선을 우리는 트리(tree)에서 구하려고 한다. 그래프 이론에서 트리(tree)의 정의는 다음과 같다.</p>

<ul>
	<li>트리(tree) : 사이클이 존재하지 않으며, 모든 정점이 연결되어 있는 그래프</li>
</ul>

<p>트리의 정보와 질의가 주어질 때, 질의에 대한 답을 하시오.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>프로그램의 입력은 표준 입력으로 받는다. 입력의 첫 줄에는 트리의 정점 개수 N이 주어진다. (2 ≤ N ≤ 100,000) 트리의 정점은 1번부터 n번까지 존재한다. 다음 줄부터 N-1개의 줄에 걸쳐 간선의 정보 a, b가 주어진다. 이는 a정점과 b정점이 연결되어 있다는 뜻이며, 입력으로 주어지는 정보는 트리임이 보장된다. (1 ≤ a, b ≤ N)</p>

<p>다음 줄에는 질의의 개수 q가 주어진다. (1 ≤ q ≤ 100,000) 다음 q줄에는 질의 t k가 주어진다. (1 ≤ t ≤ 2) t가 1일 때는 k번 정점이 단절점인지에 대한 질의, t가 2일 때는 입력에서 주어지는 k번째 간선이 단절선인지에 대한 질의이다. t가 1일 때는 (1 ≤ k ≤ n)이며, t가 2일 때는 (1 ≤ k ≤ n - 1)이다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>프로그램의 출력은 표준 출력으로 한다. q줄에 대하여 해당 질의에 대한 답을 한다. 각각은 개행으로 구분하며, 질의가 맞다면 ‘yes’를, 질의가 틀리면 ‘no’를 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
2 3
3 4
4 5
4
1 1
1 2
2 1
2 2
','no
yes
yes
yes
','TREE'),
                                                                                                                (10742,'BAEKJOON','https://www.acmicpc.net/problem/14678',14678,'어그로 끌린 영선','1초','512 MB',14,'<p>영우는 운동장에 크게 ‘트리’ 그림을 그려 놓으며 공부를 하고 있었다. ‘트리’ 란, 사이클이 없는 그래프를 뜻한다. 우연히 지나가던 영선이는 트리의 정점 크기가 정확히 자신의 발 사이즈와 일치 하는 것을 알게 되었고, 그걸 본 영우는 영선이에게 게임을 제안했다. 게임의 방식은 다음과 같다.</p>

<p>영선이가 임의의 한 정점에서 시작해서 왼 발, 오른 발을 번갈아 걷다가 더 이상 갈 수 없을 때까지 게임을 진행한다. 영선이는 왼 쪽 발을 디딘 채로 시작한다. 더 이상 진행할 수 없을 때 정점을 밟고 있는 발이 왼 발이면 영선이가 이기고, 오른 발이면 영우가 이긴다. 단, 영선이가 한 번 밟은 정점은 영선이의 발자국으로 인해 운동장에서 지워진다.</p>

<p>영선이는 운동장이 너무 커서 트리에 대한 정보를 하나도 모르기 때문에, 게임을 시작 할 정점을 찍어야 한다. 자신이 불리하다고 생각한 영선이가 게임을 하지 않으려고 하자, 영우는 영선이에게 “어떤 점 x에서 영선이가 이기는 경우의 수”를 알려주며 어그로를 끌어보려고 한다. 최대한 큰 값을 얘기하고 싶은 영우를 위해 트리 정보를 다 알고있는 여러분이 계산해주자.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14678/1.png" style="height:217px; width:194px"></p>

<p>예를 들어 운동장에 다음과 같은 트리 그림이 그려져 있었다고 하자.</p>

<p>1번에서 왼 발을 디딘 채로 시작해서 영선이가 이길 수 있는 경우의 수는 2다.</p>

<p>(1왼 -> 2오 -> 4왼) (1왼 ->2오 -> 5왼)</p>

<p>2번에서 왼 발을 디딘 채로 시작해서 영선이가 이길 수 있는 경우의 수는 1이다.</p>

<p>(2왼 -> 1오 -> 3왼)&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>프로그램의 입력은 표준 입력으로 받는다. 입력의 첫 줄에는 정점의 개수 N이 주어진다. (1 ≤ N ≤ 1,000,000) 두 번째 줄부터 N-1개의 줄에 정점 a와 정점 b가 주어진다. (1 ≤ a, b ≤ N) 정점 a와 정점 b가 연결 되어 있다는 것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>프로그램의 출력은 표준 출력으로 한다. 경우의 수가 최대인 위치에서의 경우의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
1 3
2 4
2 5
','2
','TREE'),
                                                                                                                (10756,'BAEKJOON','https://www.acmicpc.net/problem/14946',14946,'누가 크리스마스 소리를 내었는가','1초','512 MB',19,'<p>설레는 크리스마스가 얼마 남지 않았다. 하지만 슬프게도 여친이 없는 셈터는 외로움을 달래기 위해 크리스마스 트리나 장식하려고 한다. 트리에는 전구를 끼울 수 있는 소켓들이 달려 있다. 화려한 것을 좋아하는 셈터는 소켓에 색전구를 끼워서 반짝반짝 빛나게 만들고 싶다.</p>

<p>트리에 달려 있는 소켓 개수 V가 주어진다. 각 소켓들 사이에는 전선들이 연결되어 있는데, 1번 소켓에서부터 전선을 타고 모든 소켓까지 전기가 공급되도록 전선 V-1개로 연결되어 있다. V는 1000 이하의 자연수이다.</p>

<p>각 소켓에 대해 빨강, 초록, 파랑(R, G, B) 세 종류의 색전구 중 하나를 끼울 수 있다. i번 소켓에 빨강, 초록, 파랑 전구를 끼우는 데 R<sub>i</sub>, G<sub>i</sub>, B<sub>i</sub>의 비용이 든다. 단, 초록 전구가 달린 소켓끼리는 직접 연결되지 않고, 파랑 전구가 달린 소켓에는 초록 전구가 달린 소켓만 직접 연결된다. 모든 비용은 10 이하의 음이 아닌 정수이다.</p>

<p>셈터는 전구를 모두 끼우는 데 드는 비용이 K ≤ 10로 나누어 떨어지게 하고 싶다. 위의 모든 조건을 만족하면서 모든 소켓에 전구를 끼우는 방법의 수를 구하는 프로그램을 작성하시오. 단, 답이 매우 커질 수 있으므로 Q ≤ 1000로 나눈 나머지를 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 자연수 V, Q, K가 공백으로 구분되어 주어진다.</p>

<p>두 번째 줄부터 V-1개의 줄에는 소켓 번호 a, b가 공백으로 구분되어 주어진다. 이는 a와 b를 잇는 전선이 존재한다는 것을 의미한다.</p>

<p>그 다음 V개의 줄에는 각 소켓에 빨강, 초록, 파랑 전구를 끼우는 데 드는 비용 R<sub>i</sub>, G<sub>i</sub>, B<sub>i</sub> 가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 비용이 K로 나누어 떨어지도록 주어진 트리의 모든 소켓에 전구를 끼우는 방법의 수를 Q로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 997 5
1 2
2 3
1 3 5
2 3 4
1 2 3
','2
','TREE'),
                                                                                                                (10744,'BAEKJOON','https://www.acmicpc.net/problem/15480',15480,'LCA와 쿼리','2초','512 MB',19,'<p>N개의 정점으로 이루어져 있는 트리 T가 주어졌을 때, 다음 쿼리를 수행하는 프로그램을 작성하시오.&nbsp;</p>

<ul>
	<li><code>r u v</code>: T의 루트가 r이라고 했을 때, u와 v의 LCA를 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 개수 N(1 ≤&nbsp;N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에는 트리 T의 간선 정보 u와 v가 주어지다. u와 v는 트리의 간선을 나타내는 두 정점이다.</p>

<p>다음 줄에는 쿼리의 개수 M(1 ≤&nbsp;M ≤ 100,000)가 주어진다. 다음 M개의 줄에는 쿼리를 나타내는 r, u, v가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 쿼리마다 한 줄에 하나씩 결과를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7
1 2
2 3
2 4
1 5
5 6
4 7
5
1 2 7
3 1 5
2 1 7
5 6 2
6 2 3
','2
1
2
5
2
','TREE'),
                                                                                                                (10769,'BAEKJOON','https://www.acmicpc.net/problem/15647',15647,'로스팅하는 엠마도 바리스타입니다','1.5초','128 MB',16,'<p>로스팅하는 엠마는 바리스타입니다. 엠마는 <em>N</em>개의 정점을 가진 트리 형태의 농장 연결 시스템을 구축한 상태입니다. 트리의 정점은 1번부터 N번까지 번호가 매겨져 있습니다.&nbsp;각각의 간선은 그 농장에서 다른 농장으로 이동할 수 있음을 뜻하며, 간선의 가중치는 이동 거리를 뜻합니다.</p>

<p>엠마는 한 개의 농장을 정해 농장 옆에 로스팅 시설을 마련하려고 합니다. 이때, 다른 농장에서 로스팅 시설까지의 거리의 합들을 알아야, 효율적으로 로스팅 시설의 위치를 정할 수 있을 것입니다. 그러므로 각각의 농장마다 다른 농장들에서 그 농장으로 가는 최단 거리들의 합을 구해줍시다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 <em>N</em>이 입력됩니다.&nbsp;(1?≤?<em>N</em>?≤?3?×?10<sup>5</sup>)</p>

<p><em>N</em>-1 줄 동안 세 수 <em>u</em>, <em>v</em> 와 <em>d</em>가 주어집니다. 이는 <em>u</em>번째 농장과 <em>v</em>번째 농장은 서로 연결되어 있으며, 그 거리는 <em>d</em>임을 뜻합니다.&nbsp;(1?≤?<em>u</em>,?<em>v</em>?≤?<em>N</em>,?1?≤?<em>d</em>?≤?5)</p>

<p>주어지는 그래프는 트리입니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>N</em>개의 줄 동안 각각의 농장에 대해 다른 농장들에서 그 농장으로 가는 최단 거리들의 합을 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10
1 2 1
2 3 1
2 4 1
4 7 1
4 8 1
4 5 1
1 6 1
6 9 1
6 10 1
','19
17
25
19
27
23
27
27
31
31
','TREE'),
                                                                                                                (10760,'BAEKJOON','https://www.acmicpc.net/problem/15669',15669,'나무 위의 입자','1초','128 MB',16,'<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15669/1.png" style="width: 392.5px; height: 270px;"></p>

<p>트리란, 사이클이 없는 연결 그래프를 의미한다. 위 그림은 트리 모양의 입자가속기와 그 위의 어떤 정점에 놓인 특별한 입자 하나를 표시하고 있다. RB 입자라고 불리는 이 특이한 입자는 안정한 상태에서는 빨간색이지만, 불안정해질 경우 1초마다 색이 변하게 된다. 만일 빨간색이었다면 검은색이 되며, 검은색이었다면 빨간색으로 변하게 된다.</p>

<p>택희는 이 입자에 대한 간단한 실험을 해보려 한다. 우선 가속기 내에서 입자의 시작 정점과 끝 정점을 정해, 안정한 입자를 하나 꺼낸 뒤 불안정한 상태로 만들어 시작 지점에 놓는다. 이 과정에 걸리는 시간은 없다. 그 직후, 입자는 끝 정점을 향해 최단거리로 이동한다. 입자가 어떤 간선 하나를 통과하는 데에는 정확히 1초의 시간이 걸린다.</p>

<p>택희는 총 M번의 실험을 진행하였다. 하지만 실험에 몰두하던 택희는 실험 결과를 정리하는 것을 잊고 말았다. 택희가 각 실험에 대해 기억하는 정보는, 입자가 어떤 정점 U와 V를 잇는 간선을 U->V의 방향으로 통과한 적이 있다는 사실과 도착점에서의 입자의 색상 뿐이었다.</p>

<p>택희는 빠르게 실험보고서를 복원하려 한다. 그러기 위해, 우선 각 실험마다 가능한 (시작점, 도착점) 쌍의 수가 몇 개나 존재하는지를 알아보려 한다.</p>

<p>택희를 위해 실험보고서의 복원을 도와줘 보도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 입자가속기의 정점의 수 N (2 ≤ N ≤ 10<sup>5</sup>)과 진행한 실험의 수 M(1 ≤ M ≤ 10<sup>5</sup>) 이 주어진다.</p>

<p>이어 N-1줄에 걸쳐, 입자가속기에서 연결된 두 정점 U V가 주어진다. (1 ≤ U, V ≤ N, U ≠ V)</p>

<p>이어 M줄에 걸쳐, 실험에 대해 알고 있는 정보 U V C가 주어진다. (1 ≤ U, V ≤ N, C = 0 또는 1, U ≠ V)</p>

<p>이는 각 실험에서 입자가 U-V를 잇는 간선을 U->V의 방향으로 통과한 적이 있으며, 도착점에서의 색상은 C=0일 경우 빨간색, C=1일 경우 검은색이었음을 의미한다.</p>

<p>시작점에서의 입자는 항상 빨간색이며, 모든 실험에서 주어지는 U와 V에 대해 트리에는 반드시 U와 V를 잇는 간선이 존재함이 보장된다.</p>

<p>입력으로 주어지는 입자 가속기는 항상 올바른 트리 형태임이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>출력은 총 M줄로 이루어진다.</p>

<p>i번째 줄에는 i번째 실험에서 가능했던 서로 다른 (시작점, 도착점) 페어의 수를 출력한다.</p>

<p>계산 과정에서 32bit 부호 있는 정수 범위를 넘어갈 수 있음에 주의한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 3
2 4
2 5
2 6
1 2
3 1
1 3 0
1 3 1
2 1 1
','1
4
4
','TREE'),
                                                                                                                (10773,'BAEKJOON','https://www.acmicpc.net/problem/15681',15681,'트리와 쿼리','1초','128 MB',11,'<p>간선에 가중치와 방향성이 없는 임의의 루트 있는 트리가 주어졌을 때, 아래의 쿼리에 답해보도록 하자.</p>

<ul>
	<li>정점 U를 루트로 하는 서브트리에 속한 정점의 수를 출력한다.</li>
</ul>

<p>만약 이 문제를 해결하는 데에 어려움이 있다면, 하단의 힌트에 첨부한 문서를 참고하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>트리의 정점의 수 N과 루트의 번호 R, 쿼리의 수 Q가 주어진다. (2 ≤ N ≤ 10<sup>5</sup>, 1 ≤ R ≤ N, 1 ≤ Q ≤ 10<sup>5</sup>)</p>

<p>이어 N-1줄에 걸쳐, U V의 형태로 트리에 속한&nbsp;간선의 정보가 주어진다. (1 ≤ U, V ≤ N, U ≠ V)</p>

<p>이는 U와 V를 양 끝점으로 하는 간선이 트리에 속함을 의미한다.</p>

<p>이어 Q줄에 걸쳐, 문제에 설명한 U가 하나씩 주어진다. (1 ≤ U ≤ N)</p>

<p>입력으로 주어지는 트리는 항상 올바른 트리임이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>Q줄에 걸쳐 각 쿼리의 답을 정수 하나로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15681/1.png" style="width: 471px; height: 321px;"></p>

<p>그래프란, 정점들과 정점 둘을 잇는 간선들로 이루어진 집합을 의미한다.</p>

<p>위는 9개의 정점(원 모양)과, 10개의 간선(실선) 들로 이루어진 그래프이다. 각 원의 내부에 쓰여 있는 숫자는 편의상 정점에 매긴 번호를 의미한다.</p>

<p>붉은 간선은 차후 설명의 편의상 색칠해 둔 것으로, 우선은 다른 검은 간선과 동일한 것으로 간주하도록 하자.</p>

<p>간선은 항상 두 정점을 잇게 된다. 이제부터의 설명에서는, 각 정점을 번호로(1번 정점, 2번 정점.. ), 간선을 양 끝점의 정점의 번호로(1-3, 3-2… ) 표기하도록 하자.</p>

<p>그래프의 간선에는 가중치가 있을 수도 있다. 만일 특별한 언급이 없다면 모든 간선의 가중치가 1인 그래프로 간주할 수 있으며, 가중치가 존재한다면, 예를 들어 1-3 간선의 가중치가 3이라면, 1번 정점에서 3번 정점으로 가기 위해선 길이 3인 간선을 지나야 한다고 표현한다. 위의 그래프는 모든 간선의 길이가 1인 예시라고 보면 된다.</p>

<p>그래프의 간선에는 방향성이 있을 수도 있다. 예를 들어, 1번과 3번 정점 사이에 놓인 1-3 간선의 경우, 1->3 또는 3->1의 방향성을 가지는 것이 가능하다. 방향성 간선을 갖고 있는 그래프를 ‘유향 그래프’, 위의 그림처럼 방향성이 없는 간선만으로 이루어진 그래프를 ‘무향 그래프’ 라 한다. 간선의 방향성은 그래프에서 탐색을 진행할 때 결과를 달리할 수 있다. 예를 들어, 현재 위의 그래프에서 1번 정점에서 4번 정점까지 가면서, 간선을 최소한 거치는 경로는 1->3->4로, 총 2개의 간선을 거친다. 우리는 이것을 ‘1번 정점과 4번 정점의 최단 경로는 2다’ 라고 표현한다. 하지만 만약 3번 정점과 4번 정점 사이의 간선이 4->3의 방향성을 가진다면, 1번 정점에서 4번 정점으로 가는 최단 경로는 1->3->6->5->4 로, 총 4개의 간선을 지나야 한다. 즉, 최단 경로가 4가 된다.</p>

<p>그래프에서는 ‘사이클’ 을 정의할 수 있다. 무향 그래프에서의 사이클이란, 어떤 정점에서 출발해 시작점을 제외한 어떤 정점도, 어떤 간선도 두 번 이상 방문하지 않고 시작점으로 돌아올 수 있는 경로를 의미한다. 예를 들어, 위의 그림에서는 3-6-5-4-3 사이클과, 6-7-9 사이클이 존재한다. 1-3-1은 1-3 간선을 두 번 지났으므로 사이클이 될 수 없으며, 1-3-6-5-4-3은 시작점으로 돌아오지 않는 경로이므로 사이클이 아니다.</p>

<p>만일 그래프에 단 하나의 사이클도 없다면, 해당 그래프는 ‘트리’ 라고 부른다. 이는 그래프가 마치 하나의 정점에서 출발해 피어난 나무 모양과도 같음에 붙여진 이름으로, 예를 들어 위의 그림에서 빨간 간선 두 개를 제거한다면 위의 그래프는 트리가 된다. 예를 들어, 상단에 주어진 그래프에서 빨간 간선 두 개를 제거한 뒤 만들어진 트리의 모습은 아래와 같다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15681/2.png" style="width: 470px; height: 317px;"></p>

<p>일반적으로 그래프에서는 정점의 위치나 간선의 모양 등에 대한 조건은 전혀 고려하지 않으며, 오직 연결성만을 고려하므로, 간선의 집합이 변하지 않는다는 가정 하에 그래프를 얼마든지 다시 그릴 수가 있다. 위의 트리에서 5번 정점을 잡고 위로 들어올리는 예시를 생각해 보자. 아래쪽에 중력이 작용한다고 생각하고 5번 정점을 위쪽으로 들어올리게 되면 트리의 모양은 아래와 같이 변할 것이다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15681/3.png" style="width: 363px; height: 338px;"></p>

<p>간선의 집합에 변함이 없는 한, 그래프는 얼마든지 원하는 대로 다시 그릴 수가 있다. 예를 들어, 위의 트리를 거울에 비추어 좌우를 바꿀 경우에도 동일한 트리가 된다.</p>

<p>트리에는 루트(root)가 있을 수도 없을 수도 있지만, 편의를 위해서라면 아무 정점이나 루트로 선택할 수 있다. 5번 정점을 루트로 하였다고 생각한 뒤 위의 트리를 다시 보도록 하자.</p>

<p>트리는 항상 루트를 기준으로 다시 그릴 수 있기 때문에, 루트가 고정되지 않는 한 어떤 정점이 ‘위에’ 있는지 판정할 수는 없다. 하지만 루트가 고정된다면, 우리는 정점 간에 ‘부모’ 와 ‘자식’ 의 관계를 정의할 수가 있다. 예를 들어, 위의 트리에서는 4번 정점의 부모는 5번 정점이며, 3번 정점은 4번 정점의 자식이 된다. 5번 정점의 부모는 없으며, 4, 6번 정점을 두 자식으로 갖게 될 것이다.</p>

<p>트리에는 몇 가지 중요한 성질이 있는데, 그 중 두 가지만 추려보자면 아래와 같다.</p>

<ul>
	<li>임의의 두 정점 U와 V에 대해, U에서 V로 가는 최단경로는 유일하다.</li>
	<li>아무 정점이나 잡고 부모와의 연결을 끊었을 때, 해당 정점과 그 자식들, 그 자식들의 자식들… 로 이루어진 부분그래프는 트리가 된다.</li>
</ul>

<p>둘 모두 직관적이며 자명한 사실이므로 증명은 생략한다. 두 번째 성질에서, 끊어진 부분그래프로 만들어진 트리를 ‘서브트리’ 라고 부른다.</p>

<p>만약 트리에 대한 문제 하나가 출제되었다고 가정해보자. 입력이 위처럼 루트와 그 자식들로 이루어진다면 좋지만, 루트가 없는 일반 트리의 형태(두 번째 그림)의 형태로 입력이 주어질 수도 있다. 예를 들어, 정점의 개수와 간선의 목록만이 주어진다면, 어떻게 트리를 구성할 수 있을까?</p>

<p>예를 들어, 위의 트리에 대해 정점의 개수와 간선의 목록이 아래와 같이 입력된다고 하자.</p>

<pre>9
1 3
4 3
5 4
5 6
6 7
2 3
9 6
6 8
</pre>

<p>첫 줄의 9는 정점의 개수이며, 나머지 8쌍의 두 정수는 간선의 양 끝점 번호를 의미한다. 트리에서의 간선의 개수는 항상 정점의 수 - 1이라는 것은 익히 알려진 사실이며, 증명 또한 어렵지 않으므로 설명을 생략한다.</p>

<p>위와 같은 데이터를 트리로 구성하기 위해서는, 우선 루트 하나를 임의로 정의하는 것이 편하다. 5번 정점을 루트로 정해보도록 하자.</p>

<p>트리에는 부모와 자식 관계가 있으므로, 각 정점별로 부모가 누구인지, 자식들의 목록은 어떻게 되는지를 저장해 두면 요긴하게 쓰일 것이다. 이를 아래와 같이 구현할 수 있다.</p>

<pre>def makeTree(currentNode, parent) :
&nbsp;   for(Node in connect[currentNode]) :
        if Node != parent:
            add Node to currentNode’s child
            set Node’s parent to currentNode
            makeTree(Node, currentNode)
</pre>

<p><code>currentNode</code>는 현재 탐색 중인 정점이며, <code>parent</code>는 해당 정점의 부모 정점이다.</p>

<p>트리에서는 (눈치챘을 수도 있지만) 어떤 정점의 부모는 하나이거나 없다. 따라서, 어떤 정점에 대해 연결된 모든 정점은 최대 한 개의 정점을 제외하면 모두 해당 정점의 자식들이 될 것이다. 이에 따라, 부모 정점의 정보를 가져가면서, 부모 정점이 아니면서 자신과 연결되어 있는 모든 정점을 자신의 자식으로, 자신의 자식이 될 정점들의 부모 정점을 자신으로 연결한 뒤 재귀적으로 자식 정점들에게 트리 구성을 요청하는 형태의 함수이다.</p>

<p>위와 같이 정의한 뒤엔, 메인 함수에서 한 차례 <code>makeTree(5, -1)</code> 을 호출할 경우 5번 정점을 루트로 하는 트리를 구성할 수 있다. -1은 부모가 없음을 의미한다.</p>

<p>그렇다면, 일반적인 형태의 트리에서 루트가 주어진 뒤 여러 질의가 주어지는 상황을 생각해 보자. 예를 들어, 5번 정점을 루트로 하는 트리에 대해, ‘정점 U를 루트로 하는 서브트리의 정점의 수는 얼마인가?’ 라는 질의가 다수 주어진다고 해 보자. U를 루트로 하는 서브트리란, 위에도 언급하였지만 정점 U와 그 부모의 연결을 끊고 정점 U를 기준으로 그 자식들, 자식들의 자식들… 로 만든 트리를 말한다. 예를 들어, 5번 정점이 루트일 때 4번 정점을 루트로 하는 서브트리에서의 정점의 수는 4개이며, 8번 정점을 루트로 하는 서브트리에서의 정점의 수는 1개가 된다.</p>

<p>물론 직접 연결을 끊은 뒤 다시 정점의 수를 세는 방법도 가능하겠지만, 트리의 정점 수가 많고, 질의 또한 많다면 프로그램이 제한시간 내에 수행될 수 없을 확률이 높다. 아마 미리 모든 정점을 각각 루트로 하는 서브트리에서의 정점의 수를 빠르게 구해 둘 방법이 있다면 좋을 것이다.</p>

<p>이를 구현하기 위해, 트리를 구성하던 코드의 동작 과정을 살펴보도록 하자. 루트에서 출발하여, 자식 정점들에 대해 한 번씩 트리 구성을 요청하게 된다. 여기에서 알 수 있는 사실은, 자식 정점들에 대한 <code>makeTree</code>가 호출된 뒤엔, 해당 자식 정점을 서브트리로 하는 트리가 구성이 완료된다는 것이다. 이와 같은 원리로 모든 정점에 대해 해당 정점을 루트로 하는 서브트리에 속한 정점의 수를 계산하는 함수를 만들어보도록 하자.</p>

<pre>def countSubtreeNodes(currentNode) :
    size[currentNode] = 1 // 자신도 자신을 루트로 하는 서브트리에 포함되므로 0이 아닌 1에서 시작한다.
    for Node in currentNode’s child:
        countSubtreeNode(Node)
        size[currentNode] += size[Node]
</pre>

<p>자식 정점들에 대해 모두 서브트리에 속한 정점의 수를 계산하게 만든 뒤 각각의 정점 수를 더해 자신을 루트로 하는 서브트리에 속한 정점의 수를 만들게 된다. 이제 메인 함수 내에서 <code>makeTree(5, -1)</code>과 <code>countSubtreeNodes(5)</code> 를 차례대로 한 번씩 호출할 경우, 5번을 루트로 하는 트리에서 모든 정점에 대해 각 정점을 루트로 하는 서브트리에 속한 정점의 수를 계산해둘 수가 있다. 이를 이용하면, 모든 질의 U에 대해 <code>size[U]</code> 를 출력하기만 하면 되므로, 정점이 10만 개, 질의가 10만 개인 데이터에서도 충분히 빠른 시간 내에 모든 질의를 처리할 수가 있게 될 것이다.</p>

				</div>
				</div>','9 5 3
1 3
4 3
5 4
5 6
6 7
2 3
9 6
6 8
5
4
8
','9
4
1
','TREE'),
                                                                                                                (10774,'BAEKJOON','https://www.acmicpc.net/problem/15805',15805,'트리 나라 관광 가이드','1초','512 MB',10,'<p>윤호는 K개의 도시들이 트리 형태로 연결되어 있는 트리 나라의 관광 가이드이다. 윤호가 새롭게 맡게 된 패키지는 트리 나라의 루트 도시에서 시작해서 모든 도시를 순회하고 오는 상품이다. 이 상품은 컨셉만 결정된 상태이기 때문에 어떤 도시들을 방문할 지는 윤호가 결정할 수 있다. 윤호는 게임 폐인이기 때문에 빠르게 일을 끝내고 보틀 그라운드를 하러 가고 싶다. 그래서 방문할 도시를 최소한으로 하는 패키지 상품을 짜서 투어를 진행해왔다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15805/1.png" style="width: 361.667px; height: 213.333px;"></p>

<p>위와 같은 트리 나라가 있다고 해보자. 이 트리 나라의 경우에는 루트 도시가 0번이다. 따라서 위와 같은 트리 나라에서 윤호가 패키지를 짤 경우 그 중 하나는 아래와 같을 것이다.</p>

<p style="text-align: center;">0-1-2-1-3-4-3-5-3-1-6-1-0-7-8-7-9-7-0</p>

<p>어느 날 윤호는 지도를 잃어버렸다! 하지만 윤호의 관광 계획서에는 어떤 순서로 도시를 순회해야 하는지가 적혀있다. 이를 바탕으로 윤호는 다시 지도를 그리기로 마음 먹었다. 하지만 이 작업을 하기에 윤호는 너무 머리가 나빴고, 보다 답답한 당신이 모든 도시의 부모 도시를 알려주기로 마음을 먹었다.</p>

<p>위의 경우에는 0번 도시는 부모가 없고 1번 도시의 부모 도시는 0번, 2번 도시는 1번... 과 같이 표시해주면 된다.&nbsp;</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>프로그램의 입력은 표준 입력으로 받는다. 윤호의 경로의 길이 N(1 ≤ N ≤ 200,000)이 주어진다.</p>

<p>그 다음 줄에 N개의 정수가 주어지는데, i번째 정수 A<sub>i</sub>는 i번째로 방문할 도시의 번호를 의미하며, 주어진 도시대로 방문할 수 있는 트리가 존재함을 보장한다. 또, 도시가 K개 존재한다면 도시의 번호는 0번부터 K-1번사이의 정수로 중복없이 붙여지게 된다. 즉, 0 ≤ A<sub>i</sub> < K이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>프로그램의 출력은 표준 출력으로 한다. 첫째 줄에 트리 나라 도시의 총 개수 K를 출력한다.&nbsp;</p>

<p>그 다음 줄에 K개의 정수를 출력한다. 이때, i번째에는 i번 도시의 부모 도시 번호를 출력하면 된다. 만약 부모가 없다면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','19
0 1 2 1 3 4 3 5 3 1 6 1 0 7 8 7 9 7 0
','10
-1 0 1 1 3 3 1 0 7 7
','TREE'),
                                                                                                                (10776,'BAEKJOON','https://www.acmicpc.net/problem/15827',15827,'그날의 너','1초','512 MB',17,'<p>사람의 기분과 심리 상태는 쉽사리 예측할 수 없다. 주변의 환경 뿐만 아니라 그 사람의 성격이나 경험에 따라서도 서로 다른 특징을 가지기 때문이다. 하루 종일 울던 사람이 다음 날에는 편하게 웃고있을 수도 있다.</p>

<p>개인화 인공지능 시스템을 개발하고 있는 서지수 박사는 한 가지 가정을 세운다.</p>

<blockquote>
<p>‘오늘 한 사람의 행복도에 영향을 준 요인들과 각 요인들의 상관 관계를 알고 있다면 충분히 다음 날의 기분도 예측할 수 있을 것이다.’</p>
</blockquote>

<p>사람의 기분에 영향을 줄 수 있는 요인들은 환경적 요인과 복합적 요인 두 가지로 구분할 수 있다.</p>

<p>환경적 요인(Enviroment Factor)은 관찰을 통해 수치적으로 측정할 수 있는 요인을 말한다. 예를 들어서 그 날의 온도, 만난 친구의 수, 수면 시간 등이 있다.</p>

<p>복합적 요인(Complex Factor)은 서로 다른 두 개의 요인에 따라 복합적으로 결정되는 요인을 말한다. 복합적 요인은 두 요인들의 연산 결과로 표현될 수 있다. 예를 들어서 A(학습 만족도)라는 요인이 B(오늘 수강한 수업의 수)와 C(피로도)라는 두 요소의 합으로 결정되는 요인이라고 하자. 이때 A라는 요인은 두 개의 요인의 값에 따라서 결정되는 복합적 요인이 된다. 수식으로는 A=B+C와 같이 표현할 수 있다. 결과적으로 행복도또한 하나의 복합적 요소로 생각할 수 있다.</p>

<p>오늘의 행복도에 영향을 준 환경적 요인의 수치를 알고, 모든 환경적/복합적 요인들 간의 상관 관계를 알고 있다고 가정해보자. 이때, 각 요인들에 대해 행복도에 대한 영향력을 계산하려고 한다. 행복도에 대한 영향력이란, 각 요인의 행복도에 대한 순간 변화율을 의미한다.</p>

<p>예를 들어서 HAPPY(행복도)가 두 요인 A(그 날의 소득)와 B(근무 만족도)라는 두 요인의 곱으로 표현되는 복합적 요인이며 오늘의 측정 결과가 아래와 같다고 해보자.</p>

<ul>
	<li>A = 17</li>
	<li>B = 13</li>
	<li>HAPPY = A × B</li>
</ul>

<p>이 경우 행복도 HAPPY는 221이 되며, 행복도 대한 A의 순간 변화율은 13이 되므로 A의 영향력은 13이 된다. 마찬가지로 B의 영향력은 17이 된다. 당연히 HAPPY 자체의 행복도에 대한 순간 변화율은 1이다.</p>

<p>하지만 실제로는 행복도에 영향을 주는 요인들이 다양하고 상관 관계가 복잡하기 때문에 각 영향력을 계산하는 것이 쉽지 않다. 서지수 박사를 위해서 행복도를 결정하는 요인들의 종류와 정보가 주어질 때, 각 요인들의 영향력을 계산하는 프로그램을 작성해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 입력으로 주어질 요인들의 수를 나타내는 자연수 N이 주어진다. 이후 총 N개의 줄에 걸쳐서 한 줄에 하나의 요인에 대한 정보가 입력으로 주어진다.</p>

<ol>
	<li>환경적 요인의 경우 {요인의 이름} E {측정된 수치}와 같은 형식으로 주어진다.
	<ul>
		<li>요인의 이름은 20글자 이하의 알파벳 대문자다.</li>
		<li>측정된 수치는 절댓값이 20이하인 정수다.</li>
	</ul>
	</li>
	<li>복합적 요인의 경우 {요인의 이름} {연산의 종류} {피연산자 이름1} {피연산자 이름2}와 같은 형식으로 주어진다.
	<ul>
		<li>요인의 이름은 20글자 이하의 알파벳 대문자다. 행복도는 항상 HAPPY라는 이름을 가진다.</li>
		<li>피연산자의 이름은 N개의 요인들 중 서로 다른 두 개의 이름이 차례로 주어진다. 연산의 좌항과 우항 순서로 주어진다.</li>
		<li>연산의 종류는 A(덧셈), S(뺄셈), M(곱셈), D(나눗셈) 중 하나로 주어진다.</li>
	</ul>
	</li>
</ol>

<p>또한 모든 데이터는 아래의 규칙을 만족한다.</p>

<ul>
	<li>모든 요인의 연산 결과와 영향력은 유리수며, 기약분수로 표현했을 때 분모는 항상 1억 이하의 자연수이고 분자는 절댓값이 10억 이하인 정수다.</li>
	<li>복합적 요인이 자기 자신을 피 연산자로 가지거나, 계산 과정에서 자기 자신을 순환 참조하는 경우는 없다.</li>
	<li>하나의 요인이 두 개 이상의 복합적 요인에 피 연산자가 되는 경우는 존재하지 않는다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>총 N줄에 걸쳐서 각 요인들의 이름과 영향력을 한 줄에 하나씩 출력한다. 이때, 각 요인들의 이름에 대한 사전순으로 출력한다.</p>

<p>각 줄은 {요인의 이름} {행복도에 대한 영향력}와 같은 형식으로 출력한다.</p>

<ul>
	<li>각 요인의 영향력은 기약분수 형태로 출력되어야 한다. 예를 들어서 MONEY라는 요인의 영향력이 -0.25인 경우 MONEY -1/4와 같이 출력되어야 한다.</li>
	<li>행복도에 전혀 영향을 주지 않는 요인은 영향력이 0이다. 이때 영향력은 0/1과 같이 출력한다.</li>
</ul>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>2, 3번 예제는 Small에서는 나오지 않는다.</p>

				</div>
				</div>','3
A E 17
B E 13
HAPPY M A B
','A 13/1
B 17/1
HAPPY 1/1
','TREE'),
                                                                                                                (10780,'BAEKJOON','https://www.acmicpc.net/problem/15900',15900,'나무 탈출','2초(추가시간없음)','512 MB',10,'<p>평소에 사이가 좋지 않던 성원이와 형석이가 드디어 제대로 한 판 붙으려고 한다. 성원이와 형석이 둘과 모두 똑같이 친한 인섭이가 대결 종목을 정해 가져왔다. 바로 나무 탈출 이라는 보드게임이다.</p>

<p>나무 탈출 은 N개의 정점이 있는 트리 모양으로 생긴 게임판과 몇 개의 게임말로 이루어진다. 트리의 각 정점에는 1번부터 N번까지 번호가 붙어있다. 1번 정점은 루트 노드 라고 불리며, 이 루트 노드를 중심으로 정점 간에 부모-자식 관계가 만들어진다. 자식이 없는 노드는 리프 노드 라고 불린다.</p>

<p>이 게임은 두 사람이 번갈아 가면서 게임판에 놓여있는 게임말을 움직이는 게임이다. 처음에는 트리의 모든 리프 노드에 게임말이 하나씩 놓여있는 채로 시작한다. 어떤 사람의 차례가 오면, 그 사람은 현재 존재하는 게임말 중 아무거나 하나를 골라 그 말이 놓여있던 노드의 부모 노드로 옮긴다. 이 과정에서 한 노드에 여러 개의 게임말이 놓이게 될 수도 있다. 이렇게 옮긴 후에 만약 그 게임말이 루트 노드에 도착했다면 그 게임말을 즉시 제거한다. 모든 과정을 마치면 다음 사람에게 차례를 넘긴다. 이런 식으로 계속 진행하다가 게임말이 게임판에 존재하지 않아 고를 수 없는 사람이 지게 된다.</p>

<p>성원이를 얕본 형석이는 쿨하게 이 게임의 선을 성원이에게 줘버렸다. 따라서 성원이가 먼저 시작하고 형석이가 나중에 시작한다. 그동안 형석이와 대결을 하면 매번 지기만 했던 성원이는 마음속에 분노가 가득 쌓였다. 이번 대결에서는 반드시 이겨서 형석이의 코를 꺾어주고 싶다. 그래서 게임을 시작하기 전에 게임판의 모양만 보고 이 게임을 이길 수 있을지 미리 알아보고 싶어졌다. 성원이가 이 게임을 이길 수 있을지 없을지를 알려주는 프로그램을 만들어 성원이를 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 트리의 정점 개수 N(2 ≤ N ≤ 500,000)이 주어진다.</p>

<p>둘째 줄부터 N-1줄에 걸쳐 트리의 간선 정보가 주어진다. 줄마다 두개의 자연수 a, b(1 ≤ a, b ≤ N, a ≠ b)가 주어지는데, 이는 a와 b 사이에 간선이 존재한다는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>성원이가 최선을 다했을 때 이 게임을 이길 수 있으면 <code>Yes</code>, 아니면 <code>No</code>를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','2
2 1
','Yes
','TREE'),
                                                                                                                (10782,'BAEKJOON','https://www.acmicpc.net/problem/15940',15940,'네트워크 해킹','1초(추가시간없음)','512 MB',22,'<p>1번부터 N번까지 번호가 붙어있는 N개의 컴퓨터로 구성된 컴퓨터 네트워크가 있다. 그 사이에는 두 컴퓨터를 직접 연결하는 회선이 N-1개 설치되어있다. 이 네트워크는 모든 컴퓨터 사이에 통신이 가능하다. 즉, 임의의 컴퓨터에서 시작하여 직접 연결된 회선들을 계속 따라가면 다른 모든 컴퓨터와 연결되어 통신할 수 있다.</p>

<p>각 회선마다 그 회선에 직접 연결되어있는 한쪽 컴퓨터에서 다른쪽 컴퓨터로 데이터를 보내는데 걸리는 시간이 고유하게 존재한다. 따라서 데이터가 여러 회선을 통해 전송되는데 걸리는 총 전송시간은 그 데이터가 지나간 회선들의 전송시간 각각을 더한 값이 된다.</p>

<p>임의의 u번 컴퓨터에서 다른 v번 컴퓨터로 데이터를 전송할 때는, u번 컴퓨터에서 출발해 v번 컴퓨터로 도착하는 경로 중 총 전송시간이 가장 작은 경로로 데이터가 움직인다. 이 때의 총 전송시간이 u, v 사이의 데이터 전송시간이 된다.</p>

<p>‘최대 전송시간’은 네트워크 안의 임의의 두 컴퓨터 사이의 데이터 전송시간 중 가장 큰 값으로 정의된다. 이 ‘최대 전송시간’의 값으로 컴퓨터 네트워크의 가치가 결정된다. 즉, ‘최대 전송시간’ 이 작을 수록 가치가 높은 네트워크인 것이다.</p>

<p>세계 최고의 해커를 꿈꾸는 성원이는 해킹 실력을 기르려면 우선 물리적 해킹부터 연습해봐야겠다고 생각했다. 마침 평소에 이 네트워크에 대해 불만이 많았으므로, 이 네트워크를 타겟으로 삼아 물리적 해킹을 해보기로 했다. 구체적으로 다음과 같은 과정을 통해 이 네트워크를 공격하려고 한다.</p>

<ol>
	<li>네트워크에 존재하는 회선 중 하나를 골라 그 회선을 끊는다.</li>
	<li>서로 다른 두 컴퓨터를 고른 후, 아까 끊은 그 회선과 동일한 전송시간을 갖는 회선을 그 사이에 설치한다.</li>
	<li>사람들이 네트워크가 공격당했다는 것을 눈치채면 안되기 때문에, 회선을 끊고 다시 설치한 후에도 모든 컴퓨터 사이에 통신이 가능해야 한다.</li>
</ol>

<p>성원이는 위 과정을 딱 한 번만 수행해 이 네트워크의 가치를 최대한 떨어뜨리려고 한다. 즉, 해킹을 마친 상태에서 계산한 ‘최대 전송시간’ 이 가장 커지는 선택을 단 한 번만 할 것이다.</p>

<p>네트워크 안의 컴퓨터 수가 매우 많으므로 프로그램을 만들어 계산해야 하는데 성원이는 프로그래밍을 할 줄 모른다. 4차산업혁명 시대에 프로그래밍도 모르는 불쌍한 성원이를 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 네트워크 상의 컴퓨터 수 N(2 ≤ N ≤ 200,000)이 주어진다.</p>

<p>두 번째 줄부터 N-1줄에 걸쳐 네트워크의 회선 정보가 주어진다. 각 줄마다 세개의 자연수 a, b, t (1 ≤ a, b ≤ N, a ≠ b, 1 ≤ t ≤ 10<sup>7</sup>) 가 주어지는데, 이는 a번 컴퓨터와 b번 컴퓨터 사이를 직접 연결하는 회선이 존재하며, 그 회선의 전송시간이 t초 라는 뜻이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 최선의 해킹을 했을 때 가능한 ‘최대 전송시간’의 최댓값을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
3 5 2
3 1 5
1 2 1
4 1 3
','11
','TREE'),
                                                                                                                (10785,'BAEKJOON','https://www.acmicpc.net/problem/16121',16121,'사무실 이전','2초(추가시간없음)','512 MB',20,'<p>SNUPC(SNU Printing Company)는 서울대학교 컴퓨터공학부 학생들의 자료 인쇄를 책임지는 대기업이다. 최근 SNUPC의 사장 ntopia는 사무실이 301동에 있어 출근이 불편하다는 사원들의 의견을 받아들여 사무실을 지하철역 주변으로 옮기기로 했다.</p>

<p>서울 지하철에는 <em>N</em>개의 역이 있고, SNUPC의 직원들은 그 중 서로 다른 <em>M</em>개의 역 근처에 한 명씩 살고 있다. 지하철의 모든 역은 트리 구조로 연결되어 있어, 임의의 역에서 출발해 다른 모든 역으로 가는 경로가 유일하게 존재한다. 또한 모든 인접한 역 사이의 거리는 1로 같다. 직원들은 출근 경로의 거리의 제곱에 비례하여 스트레스를 받기 때문에, 출근 경로의 길이가 어떻게 바뀔지는 중요한 정보이다.</p>

<p>ntopia는 <em>K</em>개의 역 중 한 곳으로 사무실을 옮기기로 했으나, 오랜 시간 동안 결정을 하지 못했다. 그래서 ntopia는 대신 모든 후보에 대해 전 직원이 출근하는 경로의 길이의 제곱의 평균을 계산해서 미리 공지해 주기로 했다.</p>

<p>가능한 모든 사무실 후보에 대해 모든 직원의 출근 경로의 길이의 제곱을 모두 합한 값을 구하여라. 모든 직원은 가능한 가장 짧은 경로로 출근한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 지하철역의 개수 <em>N</em>(1 ≤ <em>N</em> ≤ 300,000)이 주어진다. 이는 1번부터 <em>N</em>번까지의 번호가 붙은 <em>N</em>개의 역이 있음을 의미한다.</p>

<p>이후 <em>N</em>-1 개의 줄에 걸쳐 서로 인접한 지하철역의 정보가 주어진다. 각 줄에 두 정수 <em>a</em>, <em>b</em>(1 ≤ <em>a</em>, <em>b</em> ≤ <em>N</em>, <em>a</em> ≠ <em>b</em>)가 주어지며, 이는 <em>a</em>번 역과 <em>b</em>번 역이 서로 인접해 있음을 의미한다. 주어지는 정보는 트리 구조임이 보장된다.</p>

<p>그 다음 줄에 직원들이 사는 지하철역의 수 <em>M</em>(1 ≤ <em>M</em> ≤ <em>N</em>)이 주어진다. 그 다음 줄에 <em>M</em>개의 서로 다른 지하철역의 번호가 공백을 사이에 두고 주어진다.</p>

<p>그 다음 줄에 사무실을 옮기려는 후보 지하철역의 수 <em>K</em>(1 ≤ <em>K</em> ≤ <em>N</em>)가 주어진다. 그 다음 줄에 <em>K</em>개의 서로 다른 지하철역의 번호가 공백을 사이에 두고 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 모든 사무실 후보에 대한 모든 직원의 출근 경로 길이의 제곱을 모두 합한 값을 998,244,353으로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
1 3
3 4
3 5
2
1 4
2
2 3
','12','TREE'),
                                                                                                                (10788,'BAEKJOON','https://www.acmicpc.net/problem/16216',16216,'우산','2초(추가시간없음)','1024 MB',23,'<blockquote>
<p><em>그대는 내 머리 위의 우산, 어깨 위에 차가운 비 내리는 밤, 내 곁에 그대가 없는 반쪽의 세상, 그댄 나 없이는 안 돼요.</em></p>

<p><em>- <우산>, 윤하</em></p>
</blockquote>

<p>윤하는 <a href="https://ko.wikipedia.org/wiki/%EB%82%98%EB%AC%B4_%EA%B7%B8%EB%9E%98%ED%94%84">트리</a> 구조를 한 도시에 살고 있다. 도시에는 비가 오고 있다.&nbsp;도시의 정점은 N개로, 1번부터 N번까지 번호가 붙어 있다.</p>

<p>윤하는 방문하고 싶은 K개의 서로 다른 정점들을 골랐다. 윤하는 지금&nbsp;1번 정점에 있다. 각 간선이 잇는 두&nbsp;정점 사이를&nbsp;이동하는 데에는 1초의 시간이 걸린다.&nbsp;윤하는 K개의&nbsp;정점들 중 몇 개를&nbsp;지금&nbsp;방문하려 한다. K개의 정점들 중 1개, 2개, …, K개를 방문하는 데 필요한 최소의 시간을 계산해 주자.</p>

<p>하나의 정점을&nbsp;여러 번 방문할 때에는 첫 번째 방문만 셈한다는 것, 그리고 정점들을 방문한&nbsp;뒤에 윤하가 1번 정점에 다시 돌아올 필요가 없다는 것에 유의하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 정점의 개수 N과 윤하가 방문하고 싶은&nbsp;정점의 개수 K가 주어진다. (1 ≤ N ≤ 300,000, 1 ≤ K ≤&nbsp;5,000, K <&nbsp;N)</p>

<p>둘째 줄부터 N-1개의 줄에는 윤하가 사는 도시의 간선들이 잇는 정점들의 번호를&nbsp;나타내는 두 정수 a<sub>i</sub>와 b<sub>i</sub>가 주어진다. (1 ≤ a<sub>i</sub>, b<sub>i</sub>&nbsp;≤&nbsp;N, a<sub>i</sub>&nbsp;≠ b<sub>i</sub>)</p>

<p>마지막 줄에는 윤하가 방문하고 싶은 정점들의 번호를&nbsp;나타내는 서로 다른&nbsp;K개의 정수 c<sub>1</sub>, ..., c<sub>K</sub>가 공백을 사이에 두고&nbsp;주어진다. (c<sub>i</sub>&nbsp;≠&nbsp;1)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>윤하가 방문하고 싶은 정점들 중 1개, 2개, …, K개를 방문하기 위해 필요한 최소 시간을 공백을 사이에 두고 순서대로 출력하라.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3
1 2
1 3
3 4
2 3 4
','1
2
4
','TREE'),
                                                                                                                (10796,'BAEKJOON','https://www.acmicpc.net/problem/16437',16437,'양 구출 작전','1초','256 MB',13,'<p><em>N</em>개의 섬으로 이루어진 나라가 있습니다. 섬들은 1번 섬부터 <em>N</em>번 섬까지 있습니다.</p>

<p>1번 섬에는 구명보트만 있고 다른 섬에는 양들 또는 늑대들이 살고 있습니다.</p>

<p>늘어나는 늑대의 개체 수를 감당할 수 없던 양들은 구명보트를 타고 늑대가&nbsp;없는 나라로 이주하기로 했습니다.</p>

<p>각 섬에서 1번 섬으로 가는 경로는 유일하며 <em>i</em>번 섬에는 <em>p</em><sub><em>i</em></sub>번 섬으로 가는 다리가 있습니다.&nbsp;</p>

<p>양들은 1번 섬으로 가는 경로로 이동하며 늑대들은 원래 있는 섬에서 움직이지 않고 섬으로 들어온 양들을 잡아먹습니다. 늑대는 날렵하기 때문에 섬에 들어온 양을 항상 잡을 수 있습니다. 그리고 늑대 한 마리는 최대 한 마리의 양만 잡아먹습니다.</p>

<p>얼마나 많은 양이 1번 섬에 도달할&nbsp;수 있을까요?</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 섬의 개수 <em>N</em> (2 ≤ <em>N</em> ≤ 123,456) 이 주어집니다.</p>

<p>두 번째 줄부터 <em>N</em>-1개에 줄에&nbsp;2번 섬부터 <em>N</em>번 섬까지 섬의 정보를 나타내는 <em>t<sub>i</sub></em>, <em>a<sub>i</sub></em>, <em>p<sub>i</sub></em> (1 ≤ <em>a<sub>i</sub></em> ≤ 10<sup>9</sup>, 1 ≤ <em>p<sub>i</sub></em>&nbsp;≤ <em>N</em>) 가 주어집니다.</p>

<p><em>t<sub>i</sub></em>가 <code>W</code> 인 경우 <em>i</em>번 섬에 늑대가 <em>a<sub>i</sub></em>마리가 살고 있음을,&nbsp;<em>t<sub>i</sub></em>가 <code>S</code>인 경우 <em>i</em>번 섬에 양이 a<sub>i</sub>마리가 살고 있음을 의미합니다. p<sub>i</sub>는 <em>i</em>번째 섬에서 p<sub>i</sub>번 섬으로 갈 수 있는 다리가 있음을 의미합니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 구출할 수 있는 양의 수를 출력합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
S 100 3
W 50 1
S 10 1','60','TREE'),
                                                                                                                (10797,'BAEKJOON','https://www.acmicpc.net/problem/16468',16468,'크리스마스 트리 꾸미기','1초','512 MB',17,'<p>한양대학교는 크리스마스 즈음이 되면 애지문에 트리를 꾸며 놓는다. 그리고 이번 년도에는 김하냥이 크리스마스 트리 꾸미기를 맡게 되었다. 하지만 김하냥은 트리라고는 이진트리 밖에 모르는 이진트리 바보이다. 그래서 김하냥은 애지문에 놓을 트리를 이진트리 모양으로 꾸미고 싶어 한다.</p>

<p>한양대에서는 김하냥에게 장식으로 트리 볼만을 제공한다. 하지만 이 볼의 개수에는 제한이 있고, 꾸며야 할 트리의 높이 또한 정해져 있다. 한양대에서 트리의 높이를 제한해 준다면, 김하냥은 꼭 그 트리 높이만큼의 트리를 만들어야 한다. 트리가 그 높이보다 작거나 클 수 없고, 볼도 한양대에서 제한해 준 개수로만 사용 가능하다. 또한 제공된 트리 볼도 반드시 모두 사용해야 한다.</p>

<p>김하냥은 볼의 개수와 트리의 높이에 제한이 있을 때, 자신이 트리를 꾸밀 수 있는 경우의 수가 궁금해졌다. 이진트리 밖에 모르는 김하냥을 위해 우리 한양대생들이 도와주자!</p>

<p>예를 들어, 볼의 개수가 5이고, 트리의 높이가 3이라면 트리를 꾸밀 수 있는 경우의 수는 다음과 같다.&nbsp;</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/45d93ffe-a755-4f55-ae89-2cf13bbc0071/-/preview/" width="1000" style="width: 335px; height: 47.5px;"></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/5528dc1d-238c-4b53-9195-9837d4afeb83/-/preview/" width="1000" style="width: 335px; height: 47.5px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 볼의 개수 N과 트리의 높이 L이 차례대로 주어진다. (1 ≤ N&nbsp;≤ 300, 1 ≤ L&nbsp;≤ 300)&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>트리를 꾸밀 수 있는 경우의 수를 100,030,001로 나눈 나머지를 출력한다.&nbsp;</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>이진트리란 각각의 노드가 최대 두개의 자식 노드를 가지는 트리 자료구조로, 자식 노드는 왼쪽 자식 노드와 오른쪽 자식 노드가 있다. 제일 위에 노드가 1개, 그 다음 2개… 와 같은 식으로 위에서 d번째 줄엔 2<sup>d?1</sup>개의 노드가 있을 수 있다.&nbsp;</p>

				</div>
				</div>','5 3
','6
','TREE'),
                                                                                                                (10808,'BAEKJOON','https://www.acmicpc.net/problem/16859',16859,'선인장의 최대 매칭','0.3초(추가시간없음)','1024 MB',22,'<p>그래프에서 서로 붙어 있지 않은 (끝점을 공유하지 않는) 최대 크기의 간선 부분집합을 <em>매칭</em>&nbsp;이라고 부른다.</p>

<p>임의의 서로 다른 두 단순 사이클이 최대 하나의 공통 정점을 가지는 무방향 “단순” 연결 그래프를 <em>선인장 그래프</em> 라고 부른다.</p>

<p>선인장 그래프에서 최대 매칭을 계산하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 정점의 개수 N (1 ≤ N ≤ 50,000)과 간선의 집합 개수 M (0 ≤ M ≤ 50,000)이 주어진다.</p>

<p>다음 M개의 줄에 M개의 간선의 집합에 대한 정보가 주어지는데, 각 줄에 첫 번째 수 K<sub>i</sub> (1 ≤ K<sub>i</sub> ≤ 1,000)는 i번째 에지 집합의 개수를 나타낸다. 다음 K<sub>i</sub>개의 수는 정점의 번호를 나타내는데 인접한 두 정점간의 에지가 집합에 포함되는 것을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>선인장 그래프의 최대 매칭의 크기를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0" height="315" src="https://www.youtube.com/embed/TphAhmJ0zS8" width="560"></iframe></p>

				</div>
				</div>','4 2
3 1 2 3
2 2 4
','1
','TREE'),
                                                                                                                (10814,'BAEKJOON','https://www.acmicpc.net/problem/17077',17077,'고양이 우선 탐색','1초','512 MB',22,'<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/9a165ced-a6be-441f-8b28-4196911283a9/-/preview/" style="height: 373px; width: 270px;"></p>

<p>택희는 어느 날 눈을 떠 보니 어떤 트리 위의 1번 정점에 놓여 있었다. 이 트리에는 택희 외에도, 고양이가 몇 마리 있을 수 있다.</p>

<p>이 트리에서는 매초마다 아래와 같은 일이 <strong>순서대로</strong>&nbsp;한 번씩 일어난다.</p>

<ul>
	<li>모든 고양이들이, 가만히 있거나, 인접한 다른 정점으로 한 번 이동한다. 각 고양이들은 독립적으로 움직인다.</li>
	<li>택희가 인접한 정점 중 하나로 한 번 이동한다. 택희는 가만히 있을 수 없다.</li>
</ul>

<p>택희는 그래프의 특성을 파악한 후, 아래와 같은 탐색 전략을 세웠다. 처음에 택희는 1이 적혀 있는 수첩과 펜을 들고 1번 정점 위에 서 있다.</p>

<ol>
	<li>현재 정점에 인접한 다른 정점들 중에 아직 수첩에 기록되지 않은 정점들의 집합을 <em>V</em>라고 하자.

	<ul>
		<li>만약 <em>V</em>가 비어 있는 집합이라면, <strong>현재 정점에 인접한&nbsp;정점</strong> 중 수첩에 적힌 지가 가장 오래 된 정점으로&nbsp;되돌아간다.</li>
		<li>만약 <em>V</em> 안에 고양이가 있는 정점이 있다면, 그러한 정점들 중 번호가 가장 작은 정점으로 간다.</li>
		<li>만약 그러한 정점이 없다면, 그냥 <em>V</em> 안에서 번호가 가장 작은 정점으로 간다.</li>
	</ul>
	</li>
	<li>도착한 정점의 번호가 수첩에 적혀 있지 않다면 도착한&nbsp;정점의 번호를 수첩에 기록한다.</li>
	<li>수첩에 <em>N</em>개의 정수가 적힐 때까지 (1,2)를 반복한다. (1,2)를 한 번 반복하는 데에는 1초가 걸린다.</li>
</ol>

<p>탐색 과정에서, 고양이들, 또는 고양이들과 택희는 동일한 정점 위에 있게 될 수도 있다.</p>

<p>택희는 무사히 탐색을 마친 뒤 수첩에 적힌 <em>N</em>개의 정수를 바라보았다. 그 순간 알람이 울렸고, 택희는 꿈에서 깨어나게 되었다.</p>

<p>택희는 꿈에서 본 <em>N</em>개의 정수를 기억하고 있으며, 트리의 구조 또한 정확히 기억하고 있다.</p>

<p>택희는 이러한 탐색을 가능하게 하는 최소 고양이의 수와, 각 고양이들의 시작점이 어디였는지가 궁금해졌다. 택희를 위해, 고양이가 가능한 최소한의 수만 트리 위에 있었을 때, 가능한 고양이들의 시작점의 집합의 개수를 세어 주도록 하자.</p>

<p>시작점의 집합이란, 고양이 수만큼의 길이를 갖는 배열로, 각 고양이가 서 있는 정점 번호를 비내림차순으로 나열한 것을 말한다. 이 배열에서 서로 다른 원소가 하나 이상 있을 경우 서로 다른 집합인 것으로 센다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 트리의 정점의 수 <em>N</em>이 주어진다. (2 ≤ <em>N</em> ≤ 10<sup>5</sup>)</p>

<p>둘째 줄부터 <em>N</em>-1개의 줄에 걸쳐, 간선의 정보 <em>U V</em>가 주어진다. 이는 두 정점 <em>U</em>와 <em>V</em>를 잇는 간선이 트리 위에 존재했다는 의미이다. (1 ≤ <em>U, V</em> ≤ <em>N</em>, <em>U&nbsp;</em>≠&nbsp;<em>V</em>)</p>

<p>주어지는 트리는 올바른 연결 트리임이 보장된다.</p>

<p>마지막 줄에는 공백으로 구분된 <em>N</em>개의 정수로 택희가 수첩에 적은 정수가 순서대로 주어진다. 수열의 첫 값은 항상 1이다. 이 수열에는 1부터 <em>N</em>까지의 정수가 정확히 한 번씩 등장하며, 고양이들이 최선을 다해 도울 경우 탐색의 순서로 이러한 수열이 가능함이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>고양이가 최소한의 수만 있었을 때, 고양이들의 가능한 서로 다른 시작점 집합의 수를 10<sup>9</sup>+7로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
1 3
3 4
3 5
1 3 4 5 2
','4
','TREE'),
                                                                                                                (10815,'BAEKJOON','https://www.acmicpc.net/problem/17231',17231,'이건 버그야!','2초','512 MB',22,'<p>상민이와 지수가 전쟁 시뮬레이션 게임을 한다. 게임에는 <em>N</em>개의 지역이 있으며, 각 지역은 전투력을 가지고 있다. 지역들은 <em>N</em>-1개의 길로 연결되어있으며, 연결된 지역 사이를 이동할 수 있다. 모든 지역이 하나의 방향 없는 트리구조를 이루고 있어 임의의 지역에서 다른 지역으로 언제나 이동할 수 있다.</p>

<p>게임 한 판은 다음과 같이 진행된다.</p>

<ol>
	<li>상민이는 먼저 하나의 지역을 골라 요새를 설치한다.</li>
	<li>지수는 요새가 설치되지 않은 지역을 골라 자신의 선봉으로 지정한다. 선봉의 전방은 상민이의 요새를 향하는 방향이다.</li>
	<li>지수의 선봉의 후방 지역들은 모두 지수의 세력에 편입되어 선봉과 함께 상민이의 요새를 공격한다.</li>
	<li>상민이의 요새는 지수의 공격을 막는다. 요새의 전방은 지수의 공격이 들어오는 방향이다.</li>
	<li>상민이의 요새의 후방 지역들은 모두 상민이의 세력에 편입되어 지수의 공격을 막는다.</li>
	<li>지수의 전투력이 상민이의 전투력보다 크다면 지수가 승리하고, 그렇지 않다면 패배한다.</li>
</ol>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/aef8be0f-9ba9-4426-bbb3-28c5702412d2/-/preview/" style="height: 175.833px; width: 387.5px;"></p>

<p style="text-align: center;"><그림 1> 지수의 세력 예시 (예제1)</p>

<p>각 세력의 전투력은 다음과 같이 계산된다.</p>

<p>$$\sum_{u\in\text{세력}} A_u\times(\max_{v\in\text{세력}}(dist(P, v)) - dist(P, u) + 1) $$</p>

<p>여기서 P는 플레이어가 각 세력의 요새 혹은 선봉으로 지정한 지역, dist(a,b)는 a 지역과 b 지역 간 거리이다.</p>

<p>예를들어, <그림 1> 에서 지수의 세력은 {(2) × 1} + {(3) × 2} + {(8 + 6 + 1) × 3} + {(2 + 7) × 4} + {(4) × 5} + {(5) × 6} = 139 의 전투력을 갖는다.</p>

<p>이 게임의 고인물인 지수는 게임에 버그가 있음을 알고 있다. 게임 내 전투력의 자료형이 unsigned int로 구현되어, 세력의 전투력이 2<sup>32</sup>-1을 넘어가는 순간 오버플로우가 발생해 0부터 다시 시작하게 되는 것이다. 이 버그를 잘 이해하고 있는 지수는 버그를 적극 활용해 상민이로부터 대승을 거두고자 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 지역의 개수 <em>N</em>, 진행될 게임의 횟수 <em>Q</em>가 주어진다.</p>

<p>두 번째 줄부터 <em>N</em>-1 줄에 걸쳐 지역 간 길의 정보를 나타내는 <em>u</em>, <em>v </em>(1 ≤ <em>u</em>, <em>v</em> ≤ <em>N</em>) 가 주어진다. 이는 <em>u</em>번 지역과 <em>v</em>번 지역이 연결되어있다는 의미이다.</p>

<p><em>N</em>+1번째 줄에는 각 지역의 전투력 <em>A<sub>i</sub></em> (1 ≤ <em>i</em> ≤ <em>N</em>) 가 1번 지역부터 <em>N</em>개에 걸쳐 차례로 주어진다.</p>

<p><em>N</em>+2번째 줄부터 <em>Q</em> 줄에 걸쳐 각 판마다 상민이가 요새를 설치한 지역의 번호 <em>x</em> (1 ≤ <em>x</em> ≤ <em>N</em>) 가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em> 줄에 걸쳐 각 판마다 상민이가 요새를 설치한 지역의 번호가 <em>x</em> (1 ≤ <em>x</em> ≤ <em>N</em>) 일 때, 지수가 선봉을 지정하여 얻을 수 있는 <code>"지수의 전투력 - 상민이의 전투력"</code>의 최댓값을 한 줄씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','10 3
1 2
2 3
3 4
3 5
4 6
5 7
5 8
8 9
9 10
0 5 4 2 7 8 6 1 3 2
1
2
5
','139
99
-23
','TREE'),
                                                                                                                (10817,'BAEKJOON','https://www.acmicpc.net/problem/17261',17261,'석유가 넘쳐흘러','1.5초','512 MB',20,'<p>욱제는 계곡에서 백숙을 팔아서 숭실대학교 근처의 조그만 땅을 샀다! 놀랍게도 이 땅의 지하에는 석유가 묻혀 있었다!! 그래서 욱제는 직접 땅을 파서 석유 분수를 만들기로 했다!!!</p>

<p>욱수르가 될 생각에 신이 난 욱제는 다음과 같은 구조로 석유 탱크를 연결하며 열심히 땅을 파내려 갔다. 각 용량이 W<sub>i</sub>인 N개의 탱크들이 N-1개의 파이프를 통해 포화&nbsp;이진 트리(노드가&nbsp;2<sup>k</sup>-1개인 이진 트리, k는 1 이상의 자연수)&nbsp;형태로 연결되어 있다. 자식 탱크가 없는 모든 (N+1)/2개의 잎 탱크에는 석유를 끌어 올리는 펌프가 연결되어 있는데, 펌프는 매 단위시간마다 한 번씩&nbsp;1만큼의 석유를 끌어 올리며&nbsp;모든 펌프의 성능은 동일하다.</p>

<p><img alt="" src="https://upload.acmicpc.net/0642b55a-1ad7-4f2f-a2a8-175ae9d378d9/-/preview/" style="height: 321.667px; width: 347.5px;"></p>

<p>&nbsp;</p>

<p>자식 탱크에 석유가 가득 차면 부모 탱크로 석유가 넘쳐 오른다. 만약 어떤 자식 탱크로부터 석유가 올라왔는데 다른 자식 탱크는 아직 가득 차지 않았다면, 석유는 자연스럽게 다른 자식 탱크로 흘러 들어가게 된다. (욕조에 하수구가 두 개 있고 한 하수구에서 물이 역류했을 때를 생각하면 된다) 두 자식 탱크가 가득 차면, 그제야 비로소 부모 탱크에 석유가 채워지기 시작한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/04067c44-6304-43fb-80ae-2024c239afbb/-/preview/" style="height: 305px; width: 347.5px;"></p>

<p>&nbsp;</p>

<p>시각 0에 모든 연료 탱크는 비어 있고,&nbsp;펌프는 시각 1부터 작동한다.&nbsp;펌프가 석유를 끌어 올리거나 파이프를 통해 석유가 이동하는데 걸리는 시간은 0이라고 하자. 가장 위에 있는 꼭대기 탱크의 번호는 항상 1이고, 부모 탱크 번호가 N일 때 좌우 자식 탱크 번호는 각 2×N, 2×N+1이다.</p>

<p>욱제는 이 탱크 구조물을 관리할 4차산업혁명인공지능빅데이터IoT미세먼지친환경5G블록체인스마트시스템을 개발하기로 했다. 그러기 위해서는 각 탱크에 석유가 가득차게 되는 시각을 알아야 한다. 하지만 탱크의 용량도 제각각이고, 석유가 어디로 어떻게 흘러갈 지 모르기 때문에 이러한 시각은 유일하게 결정되지 않을 수 있다. 욱제는 보수적이기 때문에, 각 탱크에 석유가 가득 찰&nbsp;수 있는&nbsp;가장 빠른 시각만을 계산하기로 했다.</p>

<p>욱제가&nbsp;4차산업혁명인공지능빅데이터IoT미세먼지친환경5G블록체인스마트시스템을 개발하기 위해 공인인증서와 싸우는 동안, 탱크가 언제 가득 차게 될지 알아보자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 탱크의 개수 N이 주어진다. 양의 정수 k에 대해, N = 2<sup>k</sup>-1이 항상 성립한다. (1 ≤&nbsp;N ≤ 262,143)</p>

<p>둘째 줄에 N개의 탱크 용량 W<sub>i</sub>이 1번 탱크부터 순서대로 주어진다. (1 ≤&nbsp;W<sub>i</sub> ≤ 100,000,000)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 탱크에 석유가 가득 찰 수&nbsp;있는&nbsp;가장 빠른 시각을 1번 탱크부터 순서대로 공백으로 구분하여 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','15
16 8 8 4 4 4 4 2 2 2 2 2 2 2 2
','8 6 6 4 4 4 4 2 2 2 2 2 2 2 2
','TREE'),
                                                                                                                (10821,'BAEKJOON','https://www.acmicpc.net/problem/17380',17380,'죽은 선인장의 사회','4초(추가시간없음)','1024 MB',26,'<p>최근, 애완 그래프를 찾는 사람이 많아지고 있다. 이런 사람들에게는 그래프 중에서 특히 귀여운 외형을 가진 <em>트리</em>(Tree)에 대한 수요가 많고, 수요의 대부분을 차지한다. 쿠는 예전부터 애완 그래프를 파는 업자였는데, 그래프 중에서도 특히 <em>캑터스</em>(Cactus)만 취급하는 별종이었다.</p>

<p>트리와 캑터스는 그래프의 종류 중 하나인데, 트리는 모든 정점이 연결되어 있으면서, 단순 사이클이 만들어지지 않는 그래프를 뜻하고, 캑터스는 모든 정점이 연결되어 있으면서, 단순 사이클이 만들어지지만, 서로 다른 두 단순 사이클에 동시에 들어가는 간선이 없는 그래프를 뜻한다. 예를 들어 보자.</p>

<p><img alt="cactus1" src="https://upload.acmicpc.net/3c443902-30e9-41f6-83d2-77cc0957f6ba/-/preview/" style="display: block; margin: 15px auto; width: 347.5px; max-width: 500px; height: 55.8333px;"></p>

<p>왼쪽에서 첫 번째 그림은 트리, 두 번째 그림은 캑터스, 세 번째 그림은 트리도 캑터스도 아닌 그래프를 나타낸다. 단순 사이클이 많아질수록 끔찍해지는 외형을 볼 수 있을 것이다.</p>

<p>쿠는 지난 25년간 애정으로 캑터스만을 다뤄왔지만, 이제는 지쳐버렸다. 애완 그래프에 관심을 가지는 사람들이 많아져 가게에 손님이 많아졌어도, 다들 캑터스는 모양이 징그럽다면서 떠나버리기 일쑤라 여전히 장사는 되지 않고, 생활은 점점 힘들어지고 있다. 그래서 쿠는 이제 냉엄한 현실과 타협하여 캑터스 판매업을 포기하고 새로운 시작을 하기로 했다. 바로 캑터스의 몇몇 간선을 잘라내 트리로 만들어 파는 트리 판매업을 하는 것이다.</p>

<p>그래프는 아주 섬세한 생물이기 때문에, 간선의 중간을 그냥 자르면 잘라낸 곳부터 썩어들어간다. 그러나 간선이 정점과 연결된 두 끝부분을 깨끗하게 잘라내면, 잘라낸 곳의 상처가 아물고 끝난다. 그래서 간선은 전체를 잘라내야 그래프가 썩지 않는다. 또한, 간선을 잘라내 연결이 끊어져 그래프가 여러 부분으로 나뉘면, 나뉜 그래프는 모두 썩어버린다. 그래서 모든 정점이 연결되어 있도록 철저히 관리하면서 간선을 잘라내야 한다.</p>

<p>간선을 잘라내면, 그 간선이 연결되어 있던 두 정점에는 상처가 하나씩 생긴다. 그래프의 억센 생명력은 이 상처를 곧바로 자가치유하여, 새로운 간선 하나와 그 끝의 새 정점 하나를 자라나게 한다. 각 간선과 정점에는 <em>회복 수치</em>가 있는데, 잘라낸 간선의 회복 수치가 <em>R<sub>e</sub></em>, 상처가 난 정점의 회복 수치가 <em>R<sub>v</sub></em>일 때, 상처 부위에서는 길이가 <em>R<sub>e</sub></em>+ <em>R<sub>v</sub></em>인 간선과 그 끝의 정점이 자라서 상처가 아문다.</p>

<p><img alt="cactus2" src="https://upload.acmicpc.net/8847ece8-5e71-4b4b-b920-2cfbc9d04e99/-/preview/" style="display: block; margin: 15px auto; width: 381.667px; max-width: 550px; height: 55.8333px;"></p>

<p>위의 그림에서 빨간색 간선이 잘라내는 간선이고, 초록색 간선이 새롭게 자란 간선이다. 이렇게 캑터스에 있는 모든 단순 사이클에서 간선을 정확히 하나씩 잘라내면 트리가 된다. 사람들은 트리의 <em>지름</em>이 작은 트리를 좋아하는 경향이 있는데, 트리의 지름이란 정점과 정점 사이의 최단 거리 중 최댓값을 말한다. 쿠는 잘 팔리는 트리를 만들기 위해 만들어지는 트리의 지름이 최소화되도록 캑터스의 간선을 잘라낼 것이다. 캑터스가 주어질 때, 쿠가 만들어낼 트리의 지름이 어떻게 될지 구하는 프로그램을 작성하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 캑터스의 정점 수를 나타내는 정수 <em>N</em>(3 ≤ <em>N</em> ≤ 100,000)과 간선 수를 나타내는 정수 <em>M</em>(<em>N</em> ≤ <em>M</em> ≤ 150,000)이 공백 하나를 사이에 두고 주어진다. 각 정점에는 <em>1</em> 에서 <em>N</em> 사이의 번호가 붙고, 각 간선에도 <em>1</em> 에서 <em>M </em>사이의 번호가 붙는다.</p>

<p>두 번째 줄에는 각 정점의 회복 수치를 나타내는 <em>N</em>개의 정수 <em>R<sub>v,1</sub></em>, <em>R<sub>v,2</sub></em>, ···, <em>R<sub>v,N</sub></em>(0 ≤ <em>R<sub>v,i</sub></em> ≤ 10<sup>9</sup>)가 공백 하나로 구분되어 주어진다. <em>R<sub>v,i</sub></em>는 <em>i</em> 번 정점의 회복 수치를 나타낸다.</p>

<p>다음 <em>M</em> 개의 줄의 <em>i</em> 번째 줄에는 <em>i</em> 번 간선의 정보를 나타내는 네 정수 <em>A<sub>i</sub></em>, <em>B<sub>i</sub></em>, <em>L<sub>i</sub></em>, <em>R<sub>e,i</sub></em>(1 ≤ <em>A<sub>i</sub></em>, <em>B<sub>i</sub></em> ≤ <em>N</em>, <em>A<sub>i</sub></em> ≠ <em>B<sub>i</sub></em>, 1 ≤ <em>L<sub>i</sub></em>, <em>R<sub>e,i</sub></em> ≤ 10<sup>9</sup>)가 공백 하나로 구분되어 주어진다. <em>A<sub>i</sub></em>와 <em>B<sub>i</sub></em>는 <em>i</em> 번 간선이 잇고 있는 두 정점의 번호를 나타내며, <em>L<sub>i</sub></em>는 <em>i</em> 번 간선의 길이, <em>R<sub>e,i</sub></em>는 <em>i</em> 번 간선의 회복 수치를 나타낸다. 주어진 그래프는 캑터스인 것이 보장되며, 같은 두 정점을 연결하는 간선이 여러 번 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 주어진 캑터스의 간선을 적절히 잘라 트리를 만들었을 때 가능한 최소의 지름을 가지는 트리의 지름을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 3
1 2 3
3 1 2 3
1 2 1 2
2 3 3 1
','10
','TREE'),
                                                                                                                (10819,'BAEKJOON','https://www.acmicpc.net/problem/17381',17381,'미로','2초(추가시간없음)','1024 MB',28,'<p>민제는 미로 게임장을 운영하고 있다. 게임장에 있는 미로는 <em>N</em>행 <em>M</em>열 크기의 격자 모양이고, 각 칸에는 상, 하, 좌, 우 네 방향 중 하나가 쓰여 있다. 미로 안을 돌아다닐 때는 네 방향으로 이동할 수 있으나, 자신이 위치한 칸에 적혀 있는 방향이나 미로를 벗어나는 방향으로는 이동할 수 없다.</p>

<p>민제는 미로에 참가자가 한 번 들어갔다 나올 때마다 미로를 청소하는데, 매번 <em>N</em> × <em>M</em>개의 칸을 모두 청소하다가 골병이 들고 말았다. 민제는 참가자가 돌아다니지 않은 칸은 굳이 청소할 필요가 없다는 걸 깨닫고, 앞으로는 참가자가 지나갔을 가능성이 있는 칸만 청소하기로 했다.</p>

<p>각 참가자가 미로 탐험을 시작한 위치와 끝낸 위치가 주어질 때, 민제가 청소해야 할 칸의 수를 구하는 프로그램을 작성하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 미로의 크기 <em>N</em>, <em>M</em> (1 ≤ <em>N</em>, <em>M</em> ≤ 1,000), 쿼리의 수 <em>Q</em> (1 ≤ <em>Q</em> ≤ 300,000)가 주어진다.</p>

<p>두 번째 줄에는 <em>N</em>개의 줄에는 미로의 형태에 해당하는 <em>M</em>개의 문자가 주어진다. 각 문자는 <code>U</code>, <code>D</code>, <code>L</code>, <code>R</code> 중 하나이며 이는 미로의 해당 칸에서 각각 위, 아래, 왼쪽, 오른쪽으로 이동할 수 없음을 의미한다.</p>

<p><em>N</em>+2번째 줄부터 <em>Q</em>개의 줄에는 시작점의 행 번호와 열 번호, 도착점의 행 번호와 열 번호가 주어진다. 시작점과 도착점이 같을 수 있으며 참가자가 도착점에 처음 도달한 다음에도 미로 탐험을 계속할 수 있음에 유의하여라.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em>개의 줄에 걸쳐 각 줄에 쿼리에 대한 정답을 출력하는데, 시작점에서 도착점까지 이동할 수 없으면 <code>0</code>을 출력하고 그렇지 않으면 민제가 청소해야 할 칸의 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5 5
DDDDD
RDDDL
RRDLL
RUUUL
UUUUU
1 1 5 5
2 2 5 5
3 3 5 5
4 4 5 5
5 5 5 5
','0
14
20
14
5
','TREE'),
                                                                                                                (10818,'BAEKJOON','https://www.acmicpc.net/problem/17399',17399,'트리의 외심','2초','512 MB',19,'<p>알고리즘에 푹 빠진 동관이가 트리에 심취한 나머지 트리에서&nbsp;외심을 정의하려 한다. 트리란, 모든 정점이 연결되어 있으면서 사이클이 존재하지 않는 그래프이다. 하지만 동관이는 트리에서 외심을 정의하기 위해서는 "트리에서 두 정점 사이의 거리"도 정의해야 한다는 사실을 깨달았다!</p>

<p>트리에서 두 정점 사이의&nbsp;거리는 한 정점에서 다른 정점으로 가기 위해 거쳐야 하는 최소한의 간선의 개수로 정의된다. 이 때 트리의 세 정점에 대해, 트리의 외심은 세 정점으로부터 거리가 같으면서, 그 거리를 최소로 하는 정점이 존재한다면 해당 정점으로 정의된다. 수학적으로 트리의 세 정점에 대해 외심이 존재한다면, 유일하다는 것을 보일 수 있다.</p>

<p>자명하게도, 외심을 정의하는 3개의 정점이 달라지면 같은 트리라 해도 외심이 달라진다. 동관이는 다양한 외심들을 찾아보고 싶지만 코딩에 귀찮음을 겪고 있다......동관이를 위해 여러분들이 대신 코드를 짜주도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정점의 개수 <em>N</em>이 주어진다. (1 ≤&nbsp;<em>N</em> ≤ 100,000) 이 트리는 1번 정점, 2번 정점, ..., <em>N</em>번 정점으로 구성된다.</p>

<p>두 번째 줄부터 <em>N</em>번째 줄까지, 트리의 간선 정보를 의미하는 두 자연수 <em>X</em>, <em>Y</em>가 공백으로 구분되어 주어진다. 이는 <em>X</em>번 정점과 <em>Y</em>번 정점이 연결되어있음을 의미한다. (1 ≤ <em>X</em>, <em>Y</em> ≤ <em>N, X </em>≠<em> Y</em>)</p>

<p>주어지는 연결관계는 트리를 구성한다.</p>

<p><em>N</em>+1 번째 줄에는 쿼리의 개수 <em>Q</em>가 주어진다. (1 ≤ <em>Q</em>&nbsp;≤ 100,000)</p>

<p>다음 <em>Q</em>개의 줄에 걸쳐,&nbsp;외심을 정의하기 위한 세 개의 정점 번호를 뜻하는 세 자연수 <em>A</em>, <em>B</em>, <em>C</em>가 공백으로 구분되어 주어진다. (1 ≤ <em>A</em>, <em>B</em>, <em>C</em> ≤ <em>N</em>)&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em>개의 줄에 걸쳐 각 쿼리마다 입력으로 주어진 세 정점에 대해 트리의 외심이 존재하면 외심의 정점 번호를, 존재하지 않으면 <code>-1</code>을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2
1 3
1 4
2
2 3 4
1 2 3
','1
-1
','TREE'),
                                                                                                                (10820,'BAEKJOON','https://www.acmicpc.net/problem/17422',17422,'지폐가 넘쳐흘러','2초(추가시간없음)','512 MB',16,'<p style="text-align: center;"><em>??&nbsp;DJ욱제는 디제잉으로 큰 돈을 벌어서 <strong>FLEX</strong> 하고 있다.&nbsp;??</em></p>

<p><em>DJ욱제</em>는 오늘 파티에서&nbsp;<strong><em>FLEX</em></strong> 하려고 한다.&nbsp;<em>DJ욱제</em>는&nbsp;각 <em>W<sub>i</sub></em>개의 지폐가&nbsp;들어 있는 <em>N</em>개의 금고를 포화 이진 트리(노드가&nbsp;2<em><sup>k</sup></em>-1개인 이진 트리, <em>k</em>는 1 이상의 자연수)&nbsp;형태로 연결했다. 가장 위에 있는 꼭대기 금고의 번호는 1이고, <i>N</i>번 금고의 좌우 자식 금고 번호는 각 2×<em>N</em>,&nbsp;2×<i>N</i>+1이다. <em>DJ욱제</em>는 이 트리를 가지고 놀다가, 가장 많은 지폐가&nbsp;들어 있는 금고를 털어서 <strong><em>FLEX</em></strong>&nbsp;할 작정이다.</p>

<p><em>DJ욱제</em>는 <em>Q</em>번의 놀이를 할 것이다. 매 놀이마다, 한 금고에 들어 있는 지폐 개수를 임의로 바꾸고&nbsp;아래와 같이 행동한다.</p>

<ol>
	<li>임의의 금고(지폐 개수를 바꾼 금고가 아니어도 됨)를 하나 선택해서, 그 금고를 루트 금고로 잡는다.</li>
	<li>1에서 선택한 루트 금고를 맨 위로 끌어 올리고, 나머지 금고들의 높이를 다시 맞춰서 루트 금고와의 거리가 같은 금고들이 같은 높이에 위치하도록 한다.&nbsp;이때, 금고끼리의 연결은 끊어지거나 변하지&nbsp;않는다.</li>
	<li>모든 금고의 문을 동시에 연다. 금고에 들어 있던 지폐들은 연결된 자식 금고들 중 어딘가로 떨어진다. 더 이상 떨어질 곳이 없다면, 그 금고에 쌓인다.</li>
	<li>지폐가 가장 많이 쌓인 금고를 확인하고, 그 금고의&nbsp;지폐&nbsp;개수를 센다.</li>
	<li>1번 과정을 실행하기 전으로 트리를 복원한다.&nbsp;놀이에서 바꾼 지폐 개수는 그 다음 놀이에서도 계속 유지된다.</li>
</ol>

<p><em>DJ욱제</em>는 최대한 많은 돈을 <strong><em>FLEX</em></strong> 하고 싶지만, 똑같은 금고를 루트로 삼더라도 지폐가&nbsp;어디로 어떻게 떨어지느냐에 따라서&nbsp;금고에 쌓이는 지폐의 양이 달라질 수 있다. 그래서&nbsp;<em>DJ욱제</em>는 온 우주의 힘을 믿고 간절히 기도하기로 했다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/4acd5ad8-1a7c-401f-9e5b-d9aa4d1ba34f/-/preview/" style="width: 365.833px; height: 185px;"></p>

<p><em>DJ욱제</em>와 함께, <em>Q+1</em>번에 걸쳐, 루트 금고를 잘 고르고 지폐들이&nbsp;최적으로 잘 떨어졌을 때, 지폐가&nbsp;가장 많이 쌓이는 금고에는 얼마만큼의 지폐가&nbsp;쌓이게 되는지 알아보자!</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 금고의 개수 <em>N</em>이 주어진다. 양의 정수 <em>k</em>에 대해, <em>N</em> = 2<em><sup>k</sup></em>-1이 항상 성립한다.</p>

<p>둘째 줄에 금고에 들어 있는 지폐의 개수&nbsp;<em>W<sub>i</sub></em>가&nbsp;1번 금고부터 순서대로 주어진다.</p>

<p>셋째 줄에 놀이의 횟수 <em>Q</em>가 주어진다.</p>

<p>이후 <em>Q</em>개의 줄에 걸쳐&nbsp;<em>i</em>와 <em>D<sub>i</sub></em>가 주어진다. 이는 <em>i</em>번 금고의 지폐 개수를 <em>D<sub>i</sub></em>로 변경한다는 의미이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 최초의&nbsp;트리에서 하나의 금고에&nbsp;쌓을 수 있는 지폐의 최대 개수를 출력한다.</p>

<p>이후 <em>Q</em>개의 줄에 걸쳐, <em>i</em>번째 놀이에서&nbsp;하나의 금고에 쌓을 수 있는 지폐의 최대 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 10 100
0
','111
','TREE'),
                                                                                                                (10822,'BAEKJOON','https://www.acmicpc.net/problem/17465',17465,'동적 연결성과 쿼리','3초','1024 MB',30,'<p>N개의 정점으로 이루어진 그래프가 있을 때 다음 쿼리를 해결하는 프로그램을 작성하시오.</p>

<ol>
	<li>x y : x와 y 사이에 간선이 존재하면 제거하고, 존재하지 않으면 추가하는 쿼리이다. (0 ≤ x < y < N)</li>
	<li>x y : x와 y가 같은 연결 요소에 속하는지 여부를 구하여 출력하는 쿼리이다.&nbsp; (0 ≤ y < x < N)</li>
</ol>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정점의 갯수 N과 쿼리의 갯수 Q가 공백으로 구분하여 주어진다. ( 2&nbsp;≤ N, Q ≤ 10<sup>5</sup>)</p>

<p>둘째 줄부터 Q개의 줄에 걸쳐 쿼리에 해당하는 두 정수 a b가 주어진다. (0 ≤ a, b < 2<sup>63</sup>????, a ≠ b)</p>

<p>x = (a xor F) mod&nbsp;N, y = (b xor F) mod N이며 F는 최초 0이고, 각 쿼리를 실행한 직후의 연결 요소의 갯수가 더해진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리의 결과를 각 줄에 출력하시오. 두 정점이 같은 연결 요소에 속할 경우 1을, 아니면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
1 2
5 7
5 6
14 15
6 7
','1
0
0
','TREE'),
                                                                                                                (10823,'BAEKJOON','https://www.acmicpc.net/problem/17493',17493,'동아리 홍보하기','2초','256 MB',18,'<p>건덕이는 건국대학교의 프로그래밍 동아리 알프스(ALPS)를 홍보하기 위해 전봇대에 전단지를 붙이고 있다. 하지만 전단지를 붙이는 것도 보통 일이 아니라서, 최소한의 전단지로 최고의 홍보 효과를 내고싶어한다.</p>

<p>전봇대와 전봇대 사이는 연결된 길로만 다닐 수 있다. 전단지는 전봇대에 붙이고, 전단지를 붙인 전봇대와 이웃한 전봇대까지 홍보 효과가 나타나며, 어떤 전봇대에서 출발하여 다른 길을 통해 다시 그 전봇대로 돌아올 수 있는 경로는 없다. 건덕이는 새이기 때문에, 길과 상관없이 날아서 다른 전봇대에 전단지를 붙일 수 있다.</p>

<p>두 전봇대 사이에 연결된 길들이 주어질 때, 건덕이가 붙여야 하는 최소 전단지의 개수를 구해 보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>전봇대의 수 <em>N</em>, 길의 개수 <em>M</em>이 공백으로 구분돼 주어진다.</p>

<p>이어지는 <em>M</em>개의 줄에는 두 자연수 <em>A</em>,<em> B</em>가 주어진다. <em>A</em>번째 전봇대와 <em>B</em>번째 전봇대 사이에 길이 있음을 의미한다. (전봇대는 1부터 <em>N</em>까지 번호매김된다)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>모든 전봇대에서 홍보효과를 누릴 수 있도록 하는 데 필요한 전단지의 최소 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','8 7
1 2
1 3
1 4
4 5
5 6
6 7
4 8
','3
','TREE'),
                                                                                                                (10827,'BAEKJOON','https://www.acmicpc.net/problem/17607',17607,'수열과 쿼리 31','2초','512 MB',24,'<p>길이가 N이고 0과 1로만 이루어진&nbsp;수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>1 L R</code>: A의 [L, R] 구간에 들어있는 수의 순서를 뒤집는다. 즉, 이 쿼리의 결과를 수열 B라고 했을 때, B<sub>L</sub> = A<sub>R</sub>, B<sub>L+1</sub> = A<sub>R-1</sub>, ..., B<sub>R</sub> = A<sub>L</sub>가 되는 것이고, L ≤ i ≤ R에 포함되지 않은 모든 i의 B<sub>i</sub> = A<sub>i</sub>이다.</li>
	<li><code>2 L R</code>: A의 연속하는 부분 수열 A<sub>L</sub>, A<sub>L+1</sub>, ..., A<sub>R</sub>에서 1로만 이루어진 가장 긴 연속하는 부분 수열의 길이를 출력한다. 1로만 이루어진 연속하는 부분 수열이 없는 경우에는 0을 출력한다.</li>
</ul>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄에는 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (0≤ A<sub>i</sub> ≤ 1)</p>

<p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 200,000)</p>

<p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ L ≤&nbsp;R ≤ N) 2번 쿼리는 한 번 이상 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>2번 쿼리의 결과를 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
0 1 0 1
3
2 2 4
1 3 4
2 2 4
','1
2
','TREE'),
                                                                                                                (10830,'BAEKJOON','https://www.acmicpc.net/problem/17624',17624,'검은 돌','1초','512 MB',22,'<p>정점들의 집합 V(≠ ?)와 간선들의 집합 E를 가진 그래프 T = (V, E)가 트리라 함은 T의 임의의 두 정점 u와 v사이에 항상 경로가 존재하고 그 경로는 하나뿐인 경우이다.</p>

<p>트리 T = (V, E)안의 서브트리 S = (<span style="text-decoration:overline;">V</span>, <span style="text-decoration:overline;">E</span>)란, <span style="text-decoration:overline;">V</span>&nbsp;⊆ V, <span style="text-decoration:overline;">E</span>&nbsp;⊆ E 이면서 위의 트리의 성질을 만족하는 그 자체로 트리인 그래프이다.</p>

<p>그런데 트리 T의 어떤 정점들에는 검은 돌이 놓여있다. 검은 돌은 한 정점에 많아야 하나씩만 놓일 수 있다.</p>

<p>우리는 다음과 같은 질의 q = (i, j)를 던질 것이고 여러분들은 이 질의에 답해야한다:</p>

<ul>
	<li>트리 T 안에 정확히 i개의 정점을 가지고 이중에 j개의 정점에 검은 돌이 놓여 있는 서브트리 S가 존재하는가?</li>
</ul>

<p>예를 들어서, 아래 <그림 1>에서 9개 정점을 가진 트리가 주어진다. 여기서 질의 q = (5, 3)에 대해서 위의 조건을 만족하는 정점 1, 2, 3, 4, 6으로 이루어진 서브트리가 존재한다. 하지만 질의 q<sub>2</sub> = (4, 3)에 대해서는 조건을 만족하는 서브트리는 존재하지 않는다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3f7be6eb-5029-4b54-99cb-49b5989f1438/-/preview/" style="width: 234px; height: 145px;"></p>

<p style="text-align: center;"><그림 1></p>

<p>N개의 정점을 가진 트리와 Q개의 질의 q가 주어질 때, 각각의 질의에 대한 답 중에서 ‘존재한다’는 답의 총 개수를 출력하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에는 트리 T의 정점의 개수를 나타내는 정수 N(1 ≤ N ≤ 5,000)과 정점들에 놓여있는 검은 돌의 개수 B(0 ≤ B ≤ N)가 주어진다. 여기서, 트리 T의 정점은 1부터 N까지 정수로 나타낸다. 두 번째 줄에는 검은 돌이 놓여 있는 정점을 나타내는 B개의 정수 x(1 ≤ x ≤ N)가 주어진다. 이어지는 N-1개 줄 각각에 T에서 간선이 존재하는 두 정점을 나타내는&nbsp;정수 u, v(1 ≤ u, v ≤ N)가 주어진다. 다음 줄에는 질의의 개수 Q(1 ≤ Q ≤ 1,000,000)가 주어지고, 이어지는 Q개의 줄 각각에 하나의 질의 q = (i, j)를 나타내는 두 정수 i, j(1 ≤ i ≤ N, 0 ≤ j ≤ min(i, B))가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각각의 질의에 대한 답 중에서 ‘존재한다’는 답의 총 개수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 0

1 2
2 3
4
1 0
2 0
1 0
3 0
','4
','TREE'),
                                                                                                                (10838,'BAEKJOON','https://www.acmicpc.net/problem/17824',17824,'아폴로니안 네트워크','3초','512 MB',27,'<p>아폴로니안 네트워크는 무방향 그래프로, 삼각형에서 시작하여 중간에 있는 삼각형을 3개의 작은 삼각형으로 재귀적으로 분할하는 방식으로 구성된다.&nbsp;</p>

<center><img alt="" src="https://upload.acmicpc.net/30a96eca-8e85-4f98-87a2-9966e359f318/-/preview/" style="width: 200px; height: 173px;"></center>

<p>가중치 있는 아폴로니안 네트워크에서, 가중치 합이 최대인&nbsp;단순 경로의 가중치 합을 출력하라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정점의 개수 n이 주어진다. (3 ≤ n ≤ 250)</p>

<p>이후 3(n-2) 개의 줄에 간선의 정보 a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub> 가 주어진다. 해당 간선이 두 정점 a<sub>i</sub>, b<sub>i</sub> 를 c<sub>i</sub>의 가중치로 잇는다는 것이다. (1 ≤ a<sub>i</sub>, b<sub>i</sub> ≤ n, 0 ≤ c<sub>i</sub> ≤ 10<sup>6</sup>)</p>

<p>주어진 그래프는 아폴로니안 네트워크이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가중치 합이 최대인&nbsp;단순 경로의 가중치 합을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2 1
2 3 1
3 1 2
','3
','TREE'),
                                                                                                                (10836,'BAEKJOON','https://www.acmicpc.net/problem/17831',17831,'대기업 승범이네','1초','512 MB',16,'<p><strong>㈜승범이네</strong>는 사장 승범이를 포함한 <em>N</em>명의 직원이 모두 판매원인 다단계 회사이다. 사장 승범이를 제외한 모든 판매원에게는 사수가 한 명씩 배정된다. 만약 판매원 A가 B의 사수라면, B를 A의 부사수라고 부른다.</p>

<p>작년에 창설된 <strong>㈜승범이네</strong>는 큰 수익률을 기록하고 대기업으로 거듭났다. <strong>㈜승범이네</strong>의 더 큰 성장을 위해 멘토링 제도를 도입하려고 한다. 승범이는 사수와 부사수 관계에 있는 두 판매원을 각각 서로의 멘토와 멘티로 만들 수 있으며, 이 경우 두 판매원이 멘토링 관계에 있다고 한다. 한 판매원은 최대 1개의 멘토링 관계에만 속할 수 있다. 즉, 한 판매원이 여러 명의 멘토가 되거나, 여러 명의 멘티가 되거나, 멘토인 동시에 멘티가 될 수는 없다. 물론 멘토링 관계에 속하지 않는 직원이 있을 수도 있다.</p>

<p>이렇게 만들어진 멘토링 관계에서는 시너지 효과가 발생한다. 승범이는 모든 판매원의 실력을 수치화시켰으며, 한 멘토링 관계에서 발생하는 시너지는 멘토와 멘티의 실력의 곱과 같다는 것을 발견했다. 승범이는 적절하게 멘토링 관계를 만들어, 모든 멘토링 관계에서 발생하는 시너지의 합을 최대로 만들려고 한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/3dd33770-33c1-424f-8547-a227b1654868/-/preview/" style="height: 276.667px; width: 333.333px;"> &nbsp;</p>

<p>위 그림은 <strong>㈜승범이네</strong>의 회사 구조와 멘토링 관계를 나타낸 예시이다. 각 원은 한 명의 판매원을 의미하며, 원 안에 쓰인 숫자는 그 판매원의 실력이다. 화살표는 사수-부사수 관계를 나타낸다. 이 경우 가능한 시너지의 최대 합은 5×7 + 4×3 + 3×3 + 4×5 + 3×1 = 79이다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 판매원들의 수 <em>N</em>(2&nbsp;≤ <em>N</em> ≤ 200,000)이 주어진다. 판매원들은 1번, 2번, …, <em>N</em>번으로 번호가 매겨지며, 승범이는 항상 1번이다.</p>

<p>두 번째 줄에 2번 판매원부터 <em>N</em>번 판매원의 사수가 순서대로 공백으로 구분되어 주어진다.&nbsp;</p>

<p>세 번째 줄에 i번 판매원의 실력을 나타내는 정수 <em>A<sub>1</sub></em>, <em>A<sub>2</sub></em>, …, <em>A<sub>N</sub></em> (0 ≤ <em>A<sub>i</sub></em> ≤ 100)이 순서대로 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫 번째 줄에 모든 멘토링 관계에서 발생하는 시너지의 합의 최댓값을 출력한다. 만약 멘토링 관계가 하나도 성립될 수 없을 경우, 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2
1 2 3
','6
','TREE'),
                                                                                                                (10840,'BAEKJOON','https://www.acmicpc.net/problem/17842',17842,'버스 노선','1초','512 MB',15,'<p>울산광역시는 큰 도시라 고도로 발달했으면서도 복잡한&nbsp;교통 체계를 가지고 있다. 울산광역시의 교통 체계는 정류장(정점)과 그 정류장을 잇는 도로(간선)들로 나타낼 수 있다. 정류장과 도로를&nbsp;모은 그래프는 순환하는 경로가 발생하지 않는 형태이며, 서로 다른 두 정류장을 잇는 경로는 항상 만들 수 있다. 즉, 트리 모양이다.</p>

<p>이번에 교통과에 취직한 윤표는 버스 노선이 너무 많다고 생각해&nbsp;이를&nbsp;정리하기로 마음먹었다. 과감하게도, 윤표는 기존에 있던 버스 노선들을 모두 없애 버리고 버스 노선들을 새롭게 구성하려고 한다. 각각의 버스 노선은 다음과 같이 정의할 수 있다.</p>

<ol>
	<li>출발 정류장과 도착 정류장이 있다.</li>
	<li>출발 정류장에서 도착 정류장에 가기까지 몇 개의 정류장을 정해진 순서대로 경유할 수 있다. 경유지의 수에는 제한이 없으며, 아무 정류장도 경유하지 않고 출발지에서 도착지로 바로 갈 수도 있다. 물론, 경유지를 지나가는 순서도 윤표가 정할 수 있다.</li>
	<li>어떤 버스 노선이 K개의 정류장을 방문하고, 방문하는 정류장들을 순서대로 정류장 1, 정류장 2, … ,정류장 K라고 할 때, 정류장 i(1 ≤ i ≤ K-1)와 정류장 i+1 사이에는 도로가 존재해야 한다. 이때 정류장 i와 i+1을 잇는 도로는&nbsp;이 버스 노선이 <strong>지나가는</strong> 도로라고 부른다.</li>
	<li>같은 정류장을 여러 번 방문해서는 안된다. 즉, 출발지와 도착지, 그리고 모든 경유지는 다른 정류장이어야 한다.</li>
</ol>

<p>윤표는 <strong>모든 도로에&nbsp;적어도 하나 이상의 버스 노선이 지나가도록</strong> 버스 노선을 구성하고 싶다.&nbsp;(도로에서 노선이 지나가는 방향은 어떤 방향도 상관없다.) 또한, 윤표는 버스 노선의 개수가 최소화되기를 원한다. 윤표를 도와, 모든 도로에 적어도 하나 이상의 버스 노선이 지나가도록 할 때 버스 노선의 최소 개수를 구하는 프로그램을 작성하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 정류장의 수 N(2&nbsp;≤&nbsp;N&nbsp;≤ 200,000)가&nbsp;주어지며 정류장은 0부터 N-1까지 고유한 번호를 가진다.</p>

<p>두 번째 줄부터 N번째 줄까지 도로로 연결된 두 정류장 쌍이 주어진다. 같은 도로가 여러 번&nbsp;주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>버스 노선을 정리했을 때 노선의 최소 개수를&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','9
1 2
6 7
8 2
4 5
3 4
2 6
0 3
5 8
','2
','TREE'),
                                                                                                                (10837,'BAEKJOON','https://www.acmicpc.net/problem/17936',17936,'트리와 쿼리 13','3초','512 MB',30,'<section id="description">
<p>N개의 정점으로 이루어진 루트 있는 트리가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있다. i번 정점은&nbsp;가중치 A<sub>i</sub>를 가지고 있다.&nbsp;초기에는 r번 정점이 루트이다.&nbsp;</p>

<p>아래의&nbsp;쿼리를 수행하는 프로그램을 작성하시오.</p>

<ul>
	<li><code>0 x y</code>: x의 서브트리에 있는 정점들의 가중치를 y로 바꾼다.</li>
	<li><code>1 r</code>: 트리의 루트를 r로 바꾼다.</li>
	<li><code>2 x y z</code>: x와 y를 잇는 경로에 있는&nbsp;정점들의 가중치를 z로 바꾼다.</li>
	<li><code>3 x</code>: x의 서브트리에 있는 정점들의 가중치의 최솟값을 출력한다.</li>
	<li><code>4 x</code>: x의 서브트리에 있는 정점들의 가중치의 최댓값을 출력한다.</li>
	<li><code>5 x y</code>: x의 서브트리에 있는 정점들의 가중치를 y만큼&nbsp;더한다.</li>
	<li><code>6 x y z</code>: x와 y를 잇는 경로에 있는&nbsp;정점들의 가중치를 z만큼 더한다.</li>
	<li><code>7 x y</code>: x와 y를 잇는 경로에 있는 정점들의 가중치의 최솟값을 출력한다.</li>
	<li><code>8 x y</code>: x와 y를 잇는 경로에 있는 정점들의 가중치의 최댓값을 출력한다.</li>
	<li><code>9 x y</code>: x의 부모를 y로 바꾼다. 만약 x의 서브트리 안에 정점 y가 존재한다면 이 쿼리를 무시한다.</li>
	<li><code>10 x y</code>: x와 y를 잇는 경로에 있는 정점들의 가중치의 합을 출력한다.</li>
	<li><code>11 x</code>: x의 서브트리에 있는 정점들의 가중치의 합을 출력한다.</li>
</ul>
</section>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 두 정수 N, M 이 주어진다. (1 ≤ N, M ≤ 10<sup>5</sup>)</p>

<p>이후 N-1개의 줄에는 각 간선이 연결하는 두 정점 번호 u,&nbsp;v가 주어진다. (1 ≤ u, v ≤ N)</p>

<p>이후 N개의 줄에 i번&nbsp;정점의 가중치 A<sub>i</sub>&nbsp;가 주어진다.</p>

<p>이후 초기 루트의 정점 번호 r이 주어진다. (1 ≤ r ≤ N)</p>

<p>이후 M개의 줄에 위에서 설명한 것과 같은 쿼리가 주어진다.&nbsp;</p>

<p>입력으로 주어지는 모든 정수는 C++ <code>int</code> 형으로 표현될 수 있으며, 쿼리를 처리하는 도중, 모든&nbsp;정점의 가중치의 합이&nbsp;<code>int</code> 범위를 초과하지 않도록 입력이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<section id="output">
<p>각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.</p>
</section>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5 5
2 1
3 1
4 1
5 2
4
1
4
1
2
1
10 2 3
3 1
7 3 4
6 3 3 2
9 5 1
','9
1
1
','TREE'),
                                                                                                                (10831,'BAEKJOON','https://www.acmicpc.net/problem/18123',18123,'평행우주','1초','1024 MB',22,'<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/0552deb0-f5fe-4ae9-96b0-73f4e6f8989f/-/preview/" style="height: 180px; width: 333.333px;"></p>

<p>서강 프로그래밍 대회가 열리고 있는 지금도 수많은 별들이 다산관의 하늘을 수놓고 있다.</p>

<p>태한이는 컴퓨터공학과지만, 취미로 별을 연구하고 있다. 이미 평행우주가 존재한다는 것을 증명하는 데 성공한 태한이는 별 연구에 너무 심취한 나머지 모든 평행우주의 모든 별들을 별자리로 만들었다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/4f21b866-8b7d-4c80-9abc-fd840739386c/-/preview/" style="width: 365.833px; height: 104.167px;"></p>

<p>별자리는 별 <em>n</em>개와 별을 잇는&nbsp;선 <em>n</em> ?&nbsp;1개로 정의되며, 한 별자리에 속한 모든 별들은 연결되어 있다. 태한이는 별자리를 정의할 때 한 평행우주에 같은 위상의 별자리가 있을 수 없도록 정의했다. 한 별자리의 별들의 연결 관계를 바꾸지 않고 위치만을 움직여서 다른 별자리를 만들 수 있다면 두 별자리의 위상이 같다고 말한다.</p>

<p>한편 한나는 우리가 살고 있는 평행우주에 존재하는 모든 별자리를 찍기 위해, 태한이에게서 별자리들의 정보가 담긴 연구 노트를 받았다. 태한이의 연구 노트에는 모든 평행우주의 모든 별자리에 대한 정보가 적혀 있었지만, 안타깝게도 각각의 별자리가 어떤 평행우주에 있는지는 적혀 있지 않았다.</p>

<p>태한이의 연구 노트를 토대로 한나가 찍을 사진의 최대 장 수를 계산해 주자. 한나는 별자리 하나당 한 장의 사진을 찍는다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 모든 평행우주에 존재하는 별자리의 총 수 <em>n</em>이 주어진다. (1 ≤ <em>n</em> ≤ 10<sup>6</sup>) 별의 수의 총합은 10<sup>6</sup>을 넘지 않는다.</p>

<p>두 번째 줄부터는 각 별자리의 정보가 주어진다.</p>

<p>각 별자리마다, 첫 번째 줄에는 별자리를 구성하는 별의 수 <em>s</em>가 주어진다.&nbsp;(1 ≤ <em>s</em> ≤ 30)</p>

<p>이후 <em>s</em> ?&nbsp;1개의 줄에 별들 사이의 연결 관계를 의미하는 두 정수 <em>u</em>, <em>v</em>가 주어진다. (0&nbsp;≤ <em>u</em>, <em>v</em> <&nbsp;<em>s</em>, <em>u</em>&nbsp;≠ <em>v</em>)</p>

<p>편의를 위해 각 별자리 안에서 별들은 0, 1, 2,&nbsp;?,&nbsp;<em>s</em> ?&nbsp;1번으로 번호가 붙어 있다고 생각하며, <em>u</em> <em>v</em>는 <em>u</em>번 별과 <em>v</em>번 별이 연결되어 있다는 의미이다. 별자리의 위상을 고려할 때는 별의 번호는 고려하지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한나가 찍을 사진의 최대 장 수를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
4
0 1
1 2
2 3
4
0 2
2 3
3 1
4
0 1
1 2
1 3
','2
','TREE'),
                                                                                                                (10824,'BAEKJOON','https://www.acmicpc.net/problem/18126',18126,'너구리 구구','1초','1024 MB',9,'<p>텔레토비 동산에 사는 너구리 구구는 입구, 거실, 주방, 안방, 공부방, 운동실, 음악실, 음식 창고 등&nbsp;<em>N</em>개의 방을 가지고 있다. 입구를 포함한 모든 방은 1부터 <em>N</em>까지의 번호가 있고, 입구는 1번이다.&nbsp;&nbsp;구구의 집으로 들어가는 입구는 한 개이며&nbsp;입구과&nbsp;모든 방들은&nbsp;총&nbsp;<em>N</em>-1개의 길로 서로 오고 갈 수&nbsp;있다.</p>

<p>구구는 스머프 동산에서 멜론아 아이스크림을 발견했다.&nbsp;구구는 무더운 여름 햇살을 피해 최대한 입구에서 먼 방에 아이스크림을 숨기려고&nbsp;한다.</p>

<p>구구가 집 입구에서 멜론아 아이스크림을 숨기려고 하는&nbsp;방까지 이동하는 거리를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 정수&nbsp;<em>N</em>(1 ≤&nbsp;<em>N</em>&nbsp;≤ 5,000)이 주어진다.</p>

<p>다음&nbsp;<em>N</em>-1개의 줄에 구구의 집의 모든 길의 정보가 정수&nbsp;<em>A</em>, <i>B,</i>&nbsp;<i>C</i>(1 ≤ <i>A</i>, <i>B</i>&nbsp;≤ <i>N</i>, 1 ≤ <i>C</i>&nbsp;≤ 1,000,000,000)로 주어진다.</p>

<p><em>A</em>번 방과 <em>B</em>번 방 사이를 양방향으로 연결하는 길의 길이가 <em>C</em>임을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>구구가 집 입구에서 멜론아 아이스크림을 숨기려고 하는&nbsp;방까지 이동하는 거리를 구하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 2 3
2 3 2
2 4 4
','7
','TREE'),
                                                                                                                (10851,'BAEKJOON','https://www.acmicpc.net/problem/18240',18240,'이진 탐색 트리 복원하기','1초','512 MB',14,'<p><strong>이진 트리</strong>란&nbsp;각각의 노드가 0, 1, 2개의 자식 노드를 가지는 트리 자료 구조이다.</p>

<p><strong>이진 탐색 트리</strong>란 각 노드의 왼쪽 서브트리(subtree)는 그 노드의 값보다 작은 노드 값들로, 오른쪽 서브트리(subtree)는 그 노드의 값보다 큰 노드 값들로 이루어져 있는 이진 트리를 말한다.</p>

<p>아래의 그림은 1부터 9까지의 수를 값으로 지닌 노드로 이루어져 있는&nbsp;이진 탐색 트리의 예시이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/806b4304-904e-4797-8db3-acf5261bc60c/-/crop/944x546/0,0/-/preview/" style="width: 360.833px; height: 208.333px;"></p>

<p>또한, 이진 탐색 트리에 새로운 노드를 삽입하는 과정은 다음과 같다.</p>

<p>루트 노드부터 탐색하여 Insert 하는&nbsp;값이 현재 노드의 값보다 크면 오른쪽 자식 노드를&nbsp;방문, 작으면 왼쪽 자식 노드을 방문하는 것을 반복하다가 비어있는 자리에 해당하는 값을 가진 노드를 삽입한다.</p>

<p>아래는 값이 4인 노드를 루트로 하는 트리에&nbsp;[2, 3, 5, 1]를 순차적으로 삽입하는 예시이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/2843b4f1-ebdc-4746-80d3-f7d7a90e8ba4/-/crop/1594x387/0,17/-/preview/" style="width: 398.333px; height: 96.6667px;"></p>

<p>1부터 N까지의 모든 정수를 한 번씩 포함하고 있는 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 있다.</p>

<p>값이 A<sub>1</sub>인 노드를&nbsp;루트로 하는 트리에&nbsp;A<sub>2</sub>,&nbsp;A<sub>3</sub><sub>,</sub>&nbsp;..., A<sub>N&nbsp;</sub>을 순서대로 삽입하려 한다.</p>

<p>N-1개의 노드를&nbsp;삽입할 때마다 루트에서 그&nbsp;노드에 도달하기 위해 거쳐야 하는 간선의 수, 즉 노드의 깊이가&nbsp;주어질 때&nbsp;A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>을 구하는 프로그램을 작성하시오.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 수열의 길이 N이 주어진다.&nbsp;(2&nbsp;≤ N&nbsp;≤ 300,000)</p>

<p>둘째 줄에는 A<sub>2</sub>부터 A<sub>N</sub>을&nbsp;순서대로 삽입할 때마다 삽입된 노드의 깊이가 공백으로 구분하여 주어진다.</p>

<p>이때 노드의 깊이는 1이상 N미만의&nbsp;자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>가능한 수열이 있다면 첫째 줄에 수열 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>의 값을 공백으로 구분하여&nbsp;출력한다.</p>

<p>가능한 수열이 여러 개라면 아무거나 출력해도 좋다.</p>

<p>가능한 수열이 없다면 첫째 줄에 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2 1 2
','4 2 3 5 1
','TREE'),
                                                                                                                (10857,'BAEKJOON','https://www.acmicpc.net/problem/18374',18374,'함수의 맛','1.5초(추가시간없음)','1024 MB',26,'<p>인덱스 트리 상인 탐레프는 인덱스국의 멸망 이후로 아무도 인덱스 트리를 사주지 않자, 인기 간식인 함수 f : {1, ..., N} →&nbsp;{1, ..., N}을 만들어 파는 중이다.</p>

<p>레프가 파는 함수에서 자연수 1, ..., N의 맛은 각각 A<sub>1</sub>, ...,A<sub>N</sub>으로 알려져 있는데, 이 값은 재료의 품질에 따라서 매일 바뀐다. 함수를 먹을 때는 마음에 드는 자연수 x를 정해서 x, f(x), f(f(x)), ...를 차례로 먹으면 되는데, 같은 수를 여러 번 먹지는 않는다. 즉, i = 1, ..., N에 대해 i = f<sup>k</sup>(x)인 k ≥&nbsp;0이 존재한다면 자연수 i를 먹는다. 이렇게 먹었을 때 느끼는 함수의 맛은 먹은 모든 자연수의 맛을 합한 값이다.</p>

<p>레프는 숙련된 주방장이 아니기 때문에, 종종 f의 구조를 바꿔버리기도 한다. 대신 레프는 손님의 "x부터 먹기 시작하면 이 함수의 맛은 얼마인가요?"라는 질문에 빠르게 답할 수 있는 기계를 만들기로 했다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>1번째 줄에는 함수의 정의역과 공역의 크기를 나타내는 자연수 N과 쿼리의 수 Q가 공백으로 구분되어 주어진다.<br>
2번째 줄에는 함숫값 f(1), ...,&nbsp;f(N)이 공백으로 구분되어 주어진다.<br>
3번째 줄에는 각 자연수의 맛 A<sub>1</sub>,&nbsp;A<sub>2</sub>, ..., A<sub>N</sub>이 공백으로 구분되어 주어진다.<br>
4번째 줄부터 Q줄에 걸쳐&nbsp;레프가 구현해야 하는 쿼리가 주어진다.</p>

<ul>
	<li>1 i j : f(i)를 j로 바꾼다. (1 ≤ i, j ≤ N)</li>
	<li>2 i x : 자연수 i의 맛 A<sub>i</sub>를 x로 바꾼다. (1 ≤ i ≤ N, 1 ≤ x ≤ 10<sup>9</sup>)</li>
	<li>3 x : 자연수 x부터 먹기 시작했을 때 이 함수의 맛이 얼마인지 출력한다. (1 ≤ x ≤ N)</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리에 대한 답을 순서대로 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 5
1 1 2
2 4 8
3 3
2 1 1
3 3
1 3 1
3 3
','14
13
9
','TREE'),
                                                                                                                (10855,'BAEKJOON','https://www.acmicpc.net/problem/18770',18770,'불안정한 물질','1.2초','256 MB',19,'<p>과학자 X는 최근 여러 종류의 초나노 스케일&nbsp;물질을 합성하는데 성공했다. 합성한 물질은 총 n개이고, 각 물질은 1부터 n까지 번호를 매겼다. 물질 i의 중량은 w<sub>i</sub> 이고 각 물질은 하나씩만 존재한다.</p>

<p>곧 열리는 세계적인 학회인 "불안정한 물질 박람회"에 이 물질 중 일부를 특수 용기에 담아 가져가려고 하는데, 불안정한 물질이라 한 가지 제약이 있다. 각 물질 i는 특정한 다른 물질과&nbsp;함께 특수 용기에 담기게 될 경우 불안정한 특성으로 인해 폭발한다. 다행히 과학자 X는 여러 번의 실험 끝에 각 물질 i는 하나의 다른 물질 Q<sub>i</sub>에만 이런식으로 반응한다는 사실을 알게 되었다.</p>

<p>이 정보가 주어졌을 때, 과학자 X는 폭발을 일으키지 않는 물질들의 조합을 골라서 특수 용기에 담아 가려고 한다.</p>

<p>예를 들어, 총 3개의 물질을 합성했고, 각 물질의 중량이 w<sub>1</sub> = 3, w<sub>2</sub>&nbsp;= 5, w<sub>3</sub> = 1 이라 하자. 각 물질과 반응이 일어나는 다른 물질의 번호는 Q<sub>1</sub>&nbsp;= 2, Q<sub>2</sub>&nbsp;= 1, Q<sub>3</sub>&nbsp;= 2라고 하자.</p>

<p>즉, 1번 물질은 2번 물질과 함께 있을 경우 반응하여 폭발하고, 2번도&nbsp;1번 물질과 함께 있으면 불안정해지며&nbsp;폭발한다. 마지막으로, 3번 물질은 2번 물질과 함께 있으면 폭발한다.</p>

<p>이 경우 1, 3번 물질은 함께 두어도 안전하고,&nbsp;중량의 총합은 4이다. 하지만, 2번 물질 하나만 가져가는&nbsp;경우 중량 총합이 5이므로 2번 물질만 가져가는 것이 최적의 방법이다.</p>

<p>과학자 X는&nbsp;폭발을 일으키지 않는 물질의 조합 중에서 중량의 최대를 구하려고 한다. 이를 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 테스트 케이스의 수 T가 주어진다.</p>

<p>각 테스트 케이스의 첫째 줄에는 물질의 종류 수 n이 주어진다. 다음 n개의 줄에는 w<sub>i</sub>와 Q<sub>i</sub>가 한 줄에 하나씩 1번 물질부터 순서대로 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 과학자 X가 가져갈 수 있는 불안정한 물질의 조합 중에서 중량의 최댓값을 한 줄에 하나씩 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>중량의 합이 2<sup>31</sup>-1을 넘을 수 있다.</p>

				</div>
				</div>','4
3
3 2
5 1
1 2
3
3 2
2 3
2 1
4
1 3
2 3
3 4
4 2
4
2 2
3 1
4 4
3 3
','5
3
5
7
','TREE'),
                                                                                                                (10865,'BAEKJOON','https://www.acmicpc.net/problem/18860',18860,'대문 밖을 나설 때','1초','1024 MB',19,'<p>대문 밖을 나설 때 욱제는 깨달았다. 석유 관련주 주식을 <em><strong>풀매수</strong></em> 해놓고 그냥 나왔다는 것을! 하지만 열차 시간이 다가오기 때문에 욱제는 눈에서 석유를&nbsp;흘리는 것 외에 아무것도 할 수 없었다.</p>

<p>욱제네 집&nbsp;대문 아래 지하에는 <a href="https://www.acmicpc.net/problem/17261">과거에 건설한 석유 탱크</a>가 있다.&nbsp;각 용량이 W<sub>i</sub>인 N개의 탱크들이 N - 1개의 파이프를 통해 포화&nbsp;이진 트리&nbsp;형태로 연결되어 있다. 탱크는 <strong>정수 단위</strong>의 석유만 저장할 수 있다. 자식 탱크가 없는 모든 잎 탱크에는 석유를 끌어 올리는 펌프가 연결되어 있다.&nbsp;작동을 시작한 펌프는 매 정수 시각마다 1만큼의 석유를 끌어 올린다. 단, <strong>작동을 시작한 시각에는 석유가 차오르지 않는다</strong>. 시각 T에 작동을 시작했으면 시각 T + 1부터 석유가 차오른다.</p>

<p style="text-align: center;"><img src="https://upload.acmicpc.net/0642b55a-1ad7-4f2f-a2a8-175ae9d378d9/-/preview/" style="width: 347.5px; height: 321.667px;"></p>

<p style="text-align: justify;">자식 탱크에 석유가 가득 차면 부모 탱크로 석유가 넘쳐 오른다. 만약 어떤 자식 탱크로부터 석유가 올라왔는데 다른 자식 탱크는 아직 가득 차지 않았다면, 석유는 자연스럽게 다른 자식 탱크로 흘러 들어가게 된다. (욕조에 하수구가 두 개 있고 한 하수구에서 물이 역류했을 때를 생각하면 된다.) 두 자식 탱크가 가득 차면, 그때부터 부모 탱크에 석유가 채워지기 시작한다.</p>

<p style="text-align: center;"><img src="https://upload.acmicpc.net/04067c44-6304-43fb-80ae-2024c239afbb/-/preview/" style="height: 305px; width: 347.5px;"></p>

<p style="text-align: justify;">최초에 모든 연료 탱크는 비어 있고, 모든 펌프는 멈춰있다. 펌프는 오래되어서 기름칠이 되어야 작동을 시작한다. 놀랍게도, 시각 0에 욱제 눈에서 흘린 석유가&nbsp;어떤 펌프 하나를 작동시켰다. 어떤 탱크의 석유가 넘쳐서 다른 펌프에 도달하면 그 펌프가 즉시 작동하기 시작한다.</p>

<p style="text-align: justify;">파이프를 통해 석유가 이동하는데 걸리는 시간은 0이라고 하자. 가장 위에 있는 꼭대기 탱크의 번호는 1이고, 부모 탱크 번호가 N일 때 좌우 자식 탱크 번호는 각 2 × N, 2 × N + 1이다.</p>

<p style="text-align: justify;">수찬이는 욱제가 훈련소에 간 틈을 타 욱제의 석유를 꿀꺽하려고 준비하고 있다. 수찬이는 탱크가 가득 차서&nbsp;유전이 터지는 시각이&nbsp;언제인지 궁금해졌다. 하지만 탱크의 용량도 제각각이고, 석유가 어디로 어떻게 흘러갈 지 모르기 때문에 모든 탱크가 가득 차는 시각은 유일하게 결정되지 않을 수 있다.</p>

<p style="text-align: justify;">수찬이를 위해 유전이 터지는(모든 탱크의 용량이 가득 차는)&nbsp;가장 빠른 시각을 계산해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째&nbsp;줄에 탱크의 개수 N이 주어진다. 양의 정수 k가 존재하여&nbsp;N = 2<sup>k</sup> - 1이 성립한다.</p>

<p>둘째 줄에 N개의&nbsp;탱크&nbsp;용량 W<sub>1</sub>, ..., W<sub>N</sub>이 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>탱크 전체에 석유가 가득 차는 가장 빠른 시각을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>석유가 정수 단위로만 저장될 수 있음에 유의하라. 예를 들어, 4만큼 넘친 석유가 1, 1, 2로 나누어져 3개의 탱크로 흘러들 수는 있지만 0.5, 1.0, 2.5로 나누어지는 것은 불가능하다.</p>

<p>시각 0에 어떤 하나의 펌프가 작동되기 시작하므로, 석유가 차오르기 시작하는 시각은 1이다.</p>

<p><strong>처음으로 작동되는 펌프가 무엇인지에 따라 모든 탱크가 가득 차는 시각이 달라질 수 있음에 유의하라.</strong></p>

				</div>
				</div>','15
16 8 8 4 4 4 4 2 2 2 2 2 2 2 2
','16
','TREE'),
                                                                                                                (10866,'BAEKJOON','https://www.acmicpc.net/problem/18861',18861,'가슴 속에 무엇인가','3초','1024 MB',26,'<p>대문 밖을 나서고 입대가 초읽기로 다가오자,&nbsp;초조해지는 마음에 욱제는 가슴을 마구 내리쳤다. 그러자 평소 심혈관계 건강이 좋지 않았던 욱제의 모세 혈관들이 모두 파열되어 버렸다.</p>

<p>젊은 욱제의 심혈관계는 1번부터 <em>N</em>번까지 번호가 붙은 <em>N</em>개의 세포와 서로 다른 두 세포 사이를 연결하여 혈액을 공급하는&nbsp;혈관으로 표현할 수 있다. 몇 개의 혈관들을 통해 연결된 두 세포 사이에는 혈액이 흐를 수 있다. 욱제가 가슴을 마구 내리쳤기 때문에 처음에는 어떤 혈관도 남아있지 않다. 시간이 흐름에 따라 젊은 욱제의 혈관은 생성되고 터지기를 반복한다. 혈관 x의 강도는 한계 심박수 D<span style="font-size: 10.8333px;">x</span>로 표현되는데, 긴장한 욱제의 심박수가 D<span style="font-size: 10.8333px;">x</span>를 초과하면 이 혈관은 견디지 못하고 터져버린다.&nbsp;</p>

<p>계속 혈관이 생기고 터지면서 멍이 들자, 욱제는 세포들 사이에 혈액이 원활하게 공급되고 있는지 걱정되어&nbsp;자가 진단 기계를 만들고자 한다.&nbsp;즉, 욱제는 위에 주어진 3가지 쿼리를 처리하는 기계를 만들고자 한다.</p>

<ul>
	<li>1 i j d : i번 세포와 j번 세포를 직접 잇는 한계 심박수&nbsp;d인 혈관이 생성된다. (i ≠ j)&nbsp;두 세포 사이에 여러 개의 온전한 혈관이 동시에 존재하는 일은 없다.</li>
	<li>2 x : 욱제의 심박수가 순간적으로 x로 변화한다.&nbsp;이 사건이 일어나는 시점 이외에 욱제의 심박수는 충분히 낮아 0으로 가정해도 좋다.</li>
	<li>3 i j : 이 쿼리가 주어진 시점에 i번 세포와&nbsp;j번 세포 사이에 혈액이 흐를 수 있는 욱제의 최대 심박수 x를&nbsp;출력한다. (i ≠ j)</li>
</ul>

<p>하지만 욱제는 계속 가슴을 내리치느라 손에 멍이 들어 코딩을 할 수가 없다. 여러분이 이 질문을 대신 처리해주도록 하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 세포의 개수 <em>N</em>과 쿼리의 개수 <em>Q</em>가 주어진다.</p>

<p>둘째 줄부터 <em>Q</em>개의 줄에 걸쳐 쿼리들이 입력으로 주어진다.&nbsp;</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>3번 쿼리가 주어질 때마다 그에 대한 답을 출력한다. 해당 시점에 두 세포 사이에 혈액이 흐를 수 없다면 0을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3 6
1 1 2 100
1 2 3 200
1 1 3 300
3 1 2
3 1 3
3 2 3
','200
300
200
','TREE'),
                                                                                                                (10867,'BAEKJOON','https://www.acmicpc.net/problem/18862',18862,'아쉬움이 남지만','3초','1024 MB',22,'<p>욱제는 자신이 냈던 문제 <a href="https://www.acmicpc.net/problem/17260">계곡이 넘쳐흘러</a>에 아쉬움이 남아 백숙 장수 욱제가 미래에 어떤 삶을 살고 있을지 상상하는 중이다.</p>

<p>논산 훈련소 깊은 산속 논산골 계곡에, 4차산업혁명으로 선물 포장 공장이 망해서 계곡에서 백숙을 팔며 연명하다 훈련병으로 끌려간 욱제가 살고 있다. 논산골에는 N개의 계단식 계곡이 있고, 이 계곡들은 N - 1개의 물길을 통해 트리 형태로 연결되어 있다. 즉, 임의의 두 계곡 사이에는 항상 유일한 경로가 존재한다. i번째 계곡은 해발 H<sub>i</sub>미터에 위치해&nbsp;있다. 1번째 계곡은&nbsp;<strong>수원</strong>으로, 모든 물길은 수원에서 멀어지는 방향으로 흐른다.</p>

<p>안타깝게도 욱제는 사격 훈련 도중 탄피를 분실하고 말았다. 욱제가 잃어버린 탄피 N개는 모든 계곡에 하나씩 떨어졌다고 한다. 욱제는 탄피를 회수하기 위해 점프를 통해 탄피를 찾아 이동하려고 한다.</p>

<p>해발&nbsp;<strong>H<sub>a</sub></strong>미터인 계곡에서 해발 <strong>H<sub>b</sub></strong>미터인&nbsp;계곡으로 점프한 욱제는 <strong>H<sub>b</sub></strong>로부터 <strong>(H<sub>a</sub> - H<sub>b</sub>) /&nbsp;2</strong>미터만큼 튀어 오른다. (<strong>H</strong><sub><strong>a</strong>&nbsp;</sub>≥ <strong>H<sub>b</sub></strong>) 그러면 욱제가 해발&nbsp;<strong>H<sub>b</sub>&nbsp;+ (H<sub>a</sub> - H<sub>b</sub>) /&nbsp;2</strong>미터까지 올라가서&nbsp;<strong>H<sub>c</sub></strong>&nbsp;≤&nbsp;<strong>H<sub>b</sub>&nbsp;+ (H<sub>a</sub> - H<sub>b</sub>) /&nbsp;2</strong>를 만족하는 계곡으로 이동할 수 있다. 그러면 욱제는 또 <strong>(H<sub>b</sub>&nbsp;+ (H<sub>a</sub> - H<sub>b</sub>) /&nbsp;2 - H<sub>c</sub>) / 2</strong>미터만큼 점프하게 된다. 욱제의 점프는&nbsp;<strong>물길과 같은 방향</strong>으로만 이동할 수 있다. 욱제의 점프로 인해 계곡의 높이가 변하거나 물길의 방향이 바뀌는 일은 없다고 하자.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/2cfd4712-62fc-4313-ae8c-3625e7bc08e4/-/preview/" style="width: 360px; height: 178.333px;"></p>

<p>(a → b는 욱제가 a에서 b로 점프함을 나타내며, a와 b는 편의상 두 계곡의 높이라고 하자)&nbsp;<strong>8 → 2</strong>인 경우 욱제는&nbsp;<strong>(8 - 2) / 2 = 3</strong>미터만큼 점프하여&nbsp;해발 5미터까지 올라간다. 그러면 최대&nbsp;<strong>8 → 2 → 5</strong>까지 이동할 수 있다.&nbsp;<strong>8 → 2 → 6</strong>,&nbsp;<strong>8 → 2 → 7</strong>&nbsp;등은 불가능하다.&nbsp;<strong>8 → 2 → 2</strong>인 경우,&nbsp;<strong>8 → 2</strong>를 통해 해발 5미터까지 점프한 욱제가&nbsp;그 다음&nbsp;해발 2미터의 계곡으로 떨어져서,&nbsp;<strong>(5 - 2) / 2 = 1.5</strong>미터만큼 점프하여&nbsp;마지막에는 해발 3.5미터가 된다. 위 예제는 8에서 출발하면 모든 계곡에 도달할 수 있다.&nbsp;&nbsp;</p>

<p>욱제는 자기가 있는 계곡이 어디인지조차 모른다. 욱제를 위해 각각의 계곡에 욱제가 있다고 가정할 때, 회수 가능한 탄피는 몇 개인지 구해주자! 단, 욱제는 스스로를 무한히 복제할 수 있기&nbsp;때문에 각각의 복제된 욱제가 다른 길로 가서 탄피를 회수할 수도 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에는 계곡의 개수 N이 주어진다.</p>

<p>둘째 줄에는 계곡의 해발 고도 H<sub>1</sub>, H<sub>2</sub>, ...,&nbsp;&nbsp;H<sub>N</sub>이 공백으로 구분되어 주어진다.</p>

<p>셋째 줄부터 N - 1개의 줄에는 각 물길이 연결하는 두 계곡의 번호가 공백으로 구분되어 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>하나의 줄에 N개의 수를 공백으로 구분하여 출력한다. i번째 수에는 욱제가 i번째 계곡에 있다고 가정했을 때 회수 가능한 탄피의 개수를 출력해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
8 2 2 3 2
1 2
2 3
3 4
2 5
','5 3 1 1 1
','TREE'),
                                                                                                                (10874,'BAEKJOON','https://www.acmicpc.net/problem/19540',19540,'인버스 ㄷㄷㄷㅈ','2초(추가시간없음)','1024 MB',21,'<p>UCPC 출제진들은 D번:ㄷㄷㄷㅈ 문제의 데이터를 만들던 중, 정점이 많은 DUDUDUNGA-트리를 만드는 것이 어렵다는 것을 알게 되었다. $N$이 주어졌을 때, 정점이 $N$개인 DUDUDUNGA-트리를 출력하는 프로그램을 만들어보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 트리의 정점 수 $N$이 주어진다. ($6 \le N \le 300\ 000$)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$N-1$개의 줄에 간선의 양 끝 점을 공백으로 구분해서 출력한다. 정점의 번호는 $1$ 이상 $N$ 이하의 정수여야 한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>DUDUDUNGA-트리의 정의는 D번:ㄷㄷㄷㅈ 문제를 참고하자. 입력으로 주어지는 $N$에 대해 언제나 정점의 개수가 $N$개인 DUDUDUNGA-트리가 존재한다.</p>

				</div>
				</div>','6
','1 2
2 3
3 4
4 5
4 6
','TREE'),
                                                                                                                (10878,'BAEKJOON','https://www.acmicpc.net/problem/19542',19542,'전단지 돌리기','1초(추가시간없음)','1024 MB',13,'<p>현민이는 트리 모양의 길 위에서 오토바이를 타고 전단지를 돌리려고 한다. 현민이의 목표는 케니소프트에서 출발하여 모든 노드에 전단지를 돌리고, 다시 케니소프트로 돌아오는 것이다. 현민이는 힘이 좋기 때문에 현재 노드에서 거리가 $D$ 이하인 모든 노드에 전단지를 돌릴 수 있다.</p>

<p>날씨가 매우 덥기 때문에, 현민이는 최소한만 이동해서 목표를 달성하고 싶다! 현민이를 위해 현민이가 이동해야 하는 총 거리를 구해주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫번째 줄에는 노드의 개수 $N$($ 1 \leq N \leq 100\ 000 $)과 케니소프트의 위치 $S$($ 1 \leq S \leq N $), 힘 $D$($ 0 \leq D \leq N $)이 주어진다.</p>

<p>두 번째 줄부터 $N$번째 줄까지, 트리의 간선 정보를 의미하는 두 자연수 $x$, $y$가 공백으로 구분되어 주어진다. 이는 $x$번 노드와 $y$번 노드가 연결되어 있음을 의미한다. ($1 \leq x, y \leq N$, $x \neq y$)</p>

<p>주어지는 연결관계는 트리를 구성하며, 모든 간선의 길이는 $1$이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>현민이가 목표를 완수하기 위해 이동해야 하는 최소 거리를 출력하여라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 1 1
1 2
2 3
2 4
3 5
5 6
','6
','TREE'),
                                                                                                                (10876,'BAEKJOON','https://www.acmicpc.net/problem/19547',19547,'애완 트리','8초(추가시간없음)','1024 MB',23,'<p>종영이는 애완 트리를 키우고 있다. 이 트리는 $N$개의 정점이 있으며 $i$번째 간선은 두 정점 $u_i$와 $v_i$를 잇는다.</p>

<p>요즘 트리에게도 사춘기가 와서, 변덕이 심해 간선들의 길이가 매일 바뀐다. $i$번째 간선의 길이는 $\left[L_i, R_i\right]$ 범위의 자연수의 값들 중 하나를 가질 수 있다.</p>

<p>트리의 변덕에 짜증이 난 종영이는 참을성이 부족해 트리를 팔아버리기로 했다. 트리는 지름이 $S$ 이상 $E$ 이하이면 크기가 적절한 좋은 트리라 생각되어 비싸게 취급된다. 트리의 지름은 트리 상에서 임의의 두 정점 사이의 거리 중 최댓값을 뜻한다.</p>

<p>간선들의 가능한 길이들의 조합은 총 $\prod_{i=1}^{N-1} \left(R_i-L_i+1\right)$가지임을 알 수 있다. 종영이가 트리를 비싸게 팔아치우는 것을 도와주기 위해 가능한 모든 조합에 대해 트리의 지름이 $S$ 이상 $E$ 이하인 경우의 수를 구하여라.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 $N$, $S$, $E$가 주어진다. ($2 \leq N \leq 400$, $1 \leq S \leq E \leq 10^9$)</p>

<p>그 후 $N-1$개의 줄에 걸쳐 트리의 간선들의 정보가 주어진다. 정보는 $u_i$, $v_i$, $L_i$, $R_i$ 순서로 주어진다. ($1 \leq u_i$, $v_i \leq N$, $1 \leq L_i \leq R_i \leq 400$)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>트리의 지름이 $S$ 이상 $E$ 이하인 경우의 수를 $10^9+7$로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3 14
1 2 1 10
1 3 1 10
1 4 1 10
','573
','TREE'),
                                                                                                                (10881,'BAEKJOON','https://www.acmicpc.net/problem/19551',19551,'관광 사업','5초(추가시간없음)','1024 MB',26,'<p>옥토끼나라는 $N$개의 도시를 잇는 $N-1$개의 도로로 이루어진 나라다. 어떤 도시에서도 원하는 다른 도시로 도로만을 통해 이동할 수 있다. 즉, 옥토끼나라는 트리 구조를 이룬다. 각 도로는 자연수 길이를 가지고 있으며, 두 도시 간의 거리는 두 도시를 잇는 단순 경로 위의 도로의 길이의 합이다.</p>

<p>옥토끼나라의 새로운 관광 사업으로 두 도시 $X$와 $Y$를 골라, 두 도시간에 관광 자매결연 관계를 맺을 것이다. 자매결연을 맺으면 두 도시의 사람들이 서로 관광을 하기 위해 이동할 것이다. 그렇기에 $D\left(X,Y\right)$를 $X$와 $Y$ 사이의 거리, $C_X$와 $C_Y$를 각각 $X$와 $Y$에 거주하는 인구 수라고 하면 교통료로 $\left(C_X+C_Y\right) \times D\left(X,Y\right)$의 수익을 얻을 수 있다.</p>

<p>옥토끼나라는 요즘 격변을 겪고 있어 도시의 인구 수가 계속 바뀌고, 자매결연 계획에 참가하려는 도시들도 상황에 따라 다양하기 때문에 다양한 상황에서 자매결연 관계를 맺을 도시들을 구해야 한다.</p>

<p>$Q$개의 자매결연 계획이 주어진다. 각 계획은 $X$의 후보 도시 의 집합 $A$, $Y$의 후보 도시의 집합 $B$가 주어지며, 각 후보 도시의 인구 수 $C_u$가 주어진다. $A$와 $B$에 동시에 포함되는 도시는 없다.</p>

<p>각 자매결연 계획마다, $X$와 $Y$를 정해서 얻을 수 있는 최대의 교통료 수익을 구해야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 $N$과 $Q$가 공백으로 구분되어 주어진다. ($1 \leq N \leq 300\ 000$, $1 \leq Q \leq 100\ 000$)</p>

<p>그 다음 $N-1$개의 줄에 걸쳐 도로의 정보 $u$, $v$, $d$가 공백으로 구분되어 주어진다. 이는 $i$번째 도로가 도시 $u$와 도시 $v$를 이으며 길이는 $d$라는 뜻이다. ($1 \leq u,v \leq N$, $1 \leq d \leq 30$)</p>

<p>이후 $Q$개의 자매결연 계획이 다음과 같은 형식으로 주어진다.</p>

<ul>
	<li>첫 줄에 $N_A$와 $N_B$가 공백으로 구분되어 주어진다. $N_A$는 $A$의 크기, $N_B$는 $B$의 크기다. ($1 \leq N_A,N_B, N_A+N_B \leq N$)</li>
	<li>이후 $N_A$개의 줄에 걸쳐 $u$와 $p$가 공백으로 구분되어 주어진다. 이는 도시 $u$가 집합 $A$에 속하며 거주하는 인구 수가 $p$명, 즉 $C_u=p$라는 뜻이다. ($1 \leq u \leq N$, $1 \leq p \leq 3 \times 10^6$)</li>
	<li>이후 $N_B$개의 줄에 걸쳐 $v$와 $q$가 공백으로 구분되어 주어진다. 이는 도시 $v$가 집합 $B$에 속하며 거주하는 인구 수가 $q$명, 즉 $C_v=q$라는 뜻이다. ($1 \leq v \leq N$, $1 \leq q \leq 3 \times 10^6$)</li>
</ul>

<p>$\sum_{i=1}^{Q} (N_A+N_B)$는 $200\ 000$ 이하다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>한 줄에 하나씩 순서대로 각 자매결연 계획의 최대 교통료 수익을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>노트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/0d7ff76d-77eb-42f4-bc39-827dcc04d923/-/preview/" style="max-width: 100%; width: 420px;"></p>

<p><strong>예제 2</strong>에서, $X=3$이고 $Y=7$인 경우 교통료 수익이 $(5+1) \times 17=102$로 최적이다. $X=1$이고 $Y=5$인 경우 또한 최적이다.</p>

				</div>
				</div>','3 3
1 2 1
2 3 1
1 2
1 1
2 2
3 3
1 2
2 2
1 1
3 3
1 2
3 3
1 1
2 2
','8
5
8
','TREE'),
                                                                                                                (10883,'BAEKJOON','https://www.acmicpc.net/problem/19581',19581,'두 번째 트리의 지름','1초(추가시간없음)','1024 MB',15,'<p>트리에 N개의 정점이 있고, 각 정점 별로 1부터 <em>N</em>까지의 번호가 붙어있다.</p>

<p>트리에서 가장 먼 두 정점 간의 거리를 트리의 지름이라고 한다. 트리의 지름을 구하는 문제는 너무 많기 때문에&nbsp;우리는 두 번째 트리의 지름을 구하려고 한다.</p>

<p>두 번째 트리의 지름은 무엇이냐? 바로 두 번째로 가장 먼 두 정점 간의 거리를 의미한다. (두 번째 트리의 지름은 트리의 지름과 같을 수 있다.)</p>

<p>바로 두 번째 트리의 지름을 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 정점의 개수 <em>N</em>(3 ≤ <em>N</em> ≤ 100,000)이&nbsp;들어온다.</p>

<p>둘째 줄부터 <em>N</em>번째 줄까지 각 간선에 대한 정보가 들어온다. 간선에 대한 정보는 세 개의 정수로 이루어져 있다. 첫 번째 정수와 두 번째 정수는&nbsp;간선과 연결된 정점 번호를 나타내고, 세 번째 정수는 간선의 가중치를 나타낸다. 간선의 가중치는 20,000 이하의 자연수이다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>첫째 줄에 두 번째 트리의 지름을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
1 2 3
2 3 4
','4
','TREE'),
                                                                                                                (10885,'BAEKJOON','https://www.acmicpc.net/problem/19589',19589,'카드 셔플','10초(추가시간없음)','1024 MB',24,'<p>위에서부터 1, 2, ..., <em>N</em>이 적혀 있는 카드 한 벌이 있다. 이 때, 1 ≤ <em>x</em> ≤ <em>y</em> ≤ <em>N</em>인 두 정수 <em>x</em>, <em>y</em>에 대해&nbsp;다음 쿼리를 수행한다.</p>

<ul>
	<li><tt><span style="background-color:#dddddd;">1 x y</span></tt> : 위에서부터 <em>x</em>번째에 있는 카드부터&nbsp;<em>y</em>번째에 있는 카드까지를 제일 위로 올린다.</li>
	<li><tt><span style="background-color:#dddddd;">2 x y</span></tt> : 위에서부터 <em>x</em>번째에 있는 카드부터&nbsp;<em>y</em>번째에 있는 카드까지를 제일 아래로 내린다.</li>
	<li><tt><span style="background-color:#dddddd;">3 x y</span></tt> : 위에서부터 <em>x</em>번째에 있는 카드부터&nbsp;<em>y</em>번째에 있는 카드까지&nbsp;<strong>리플 셔플</strong>을 한다.&nbsp;<em>y</em> ? <em>x</em> + 1은&nbsp;1,000 이하이다.</li>
</ul>

<p><strong>리플 셔플</strong>은 <em>N</em>장의 카드가 있을 때 카드를 위에서부터 ?(<em>N</em> + 1) / 2?장의 카드 덩어리와 나머지 덩어리로 나눈 후&nbsp;교대로 카드를 두는 방식으로 카드를 섞는 것이다. 섞기 전에 제일 위에 있었던&nbsp;카드가&nbsp;섞은 후에도 제일 위로 오도록&nbsp;한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 카드 수 <em>N</em>(1 ≤ <em>N</em> ≤ 10<sup>6</sup>)과 쿼리의 수 <em>Q</em>(1 ≤ <em>Q&nbsp;</em>≤ 2 × 10<sup>5</sup>)가 주어진다. 다음 <em>Q</em>개의 줄에 쿼리가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>카드를 다 섞고 난 뒤 카드에 어떤 숫자가 적혀 있는지 위에서부터 순서대로 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>카드 6장이 있을 때 쿼리 <tt><span style="background-color:#dddddd;">3 1 6</span></tt>을 처리하면</p>

<p style="text-align: center;">1 2 3 4 5 6 ⇒ 1 4 2 5 3 6</p>

<p>이 되고, 카드 7장이 있을 때 <tt><span style="background-color:#dddddd;">3 1 7</span></tt>이 입력으로 들어오면&nbsp;</p>

<p style="text-align: center;">1 2 3 4 5 6 7 ⇒ 1 5 2 6 3 7 4</p>

<p>가 된다.</p>

				</div>
				</div>','6 3
1 2 3
2 4 5
3 1 6
','2 6 3 4 1 5
','TREE'),
                                                                                                                (10886,'BAEKJOON','https://www.acmicpc.net/problem/19641',19641,'중첩 집합 모델','1초','1024 MB',11,'<p>SQL은 릴레이션으로 나타낼 수 있는 데이터를 나타내기에는 훌륭한 표현력을 갖고 있지만, 계층적인 구조를 표현하기에는 한계가 있다. 이러한 한계를 보완하고자 나온 모델 중 하나가 중첩 집합 모델이다.</p>

<p>중첩 집합 모델은 구간의 포함관계를 이용해서 계층적인 구조를 나타내는 방식이며, 각각의 데이터는 서로 겹치지 않거나 한 데이터가 다른 데이터를 포함하는 관계를 가진다. 중첩 집합 모델은 트리 구조로 구성된 각 노드의 <span style="color:#e74c3c;"><code>left</code></span>, <span style="color:#e74c3c;"><code>right</code></span> 필드에 <strong>트리의 방문 순서</strong>로 번호를 매겨서 <span style="color:#e74c3c;"><code>left</code></span>, <span style="color:#e74c3c;"><code>right</code></span> 필드가 구간을 나타내도록 한다. 이 때, 각 노드의 <span style="color:#e74c3c;"><code>left</code></span> 필드와 <span style="color:#e74c3c;"><code>right</code></span> 필드는 <span style="color:#e74c3c;"><code> left < right</code></span>임이 보장된다.</p>

<p>중첩 집합 모델을 구성하는 A 노드와 B 노드가 있을 때, A.left < B.left이고&nbsp;B.right < A.right이면 <strong>A는 B를 포함한다</strong>고 할 수 있다. A 노드가 포함하는 모든 노드들을 불러올 때는 SQL로는 <span style="color:#e74c3c;"><code><strong>SELECT</strong> * <strong>FROM</strong> tree <strong>WHERE</strong> left > A.left <strong>AND</strong> right < A.right;</code></span> 명령을 수행하면 된다.</p>

<p>예를 들면, 한 회사의 조직도를 나타낸다고 가정해 보자. HI-ARC라는 회사에는&nbsp;여러 개의 부서가 있으며, 각 부서는 여러 개의 팀을 가질 수 있다. 그리고 각 팀은 여러 명의 사원을 포함할 수 있다.</p>

<p>아래와 같이 조직이 구성되어 있다고 생각해 보자.</p>

<blockquote>
<p><strong>1레벨</strong></p>

<ul>
	<li>HI-ARC - (경영지원실, 개발부)</li>
</ul>

<p><strong>2레벨</strong></p>

<ul>
	<li>경영지원실 - (사업전략팀, 법무팀)</li>
	<li>개발부 - (개발1팀, 개발2팀, 운영팀)</li>
</ul>

<p><strong>3레벨</strong></p>

<ul>
	<li>사업전략팀 - 사원1, 사원2</li>
	<li>법무팀 - 사원3</li>
	<li>개발1팀 - 사원4, 사원5</li>
	<li>개발2팀 - 사원6, 사원7, 사원8</li>
	<li>운영팀 - 사원9</li>
</ul>
</blockquote>

<p>그렇다면, 위와 같은 조직 구성을 중첩 집합 모델로 아래와 같이 나타낼 수 있다.</p>

<table class="table table-bordered table-center-30">
	<tbody>
		<tr>
			<td><strong>부서명/이름</strong></td>
			<td><strong>left</strong></td>
			<td><strong>right</strong></td>
			<td><strong>level</strong></td>
		</tr>
		<tr>
			<td>HI-ARC</td>
			<td>1</td>
			<td>34</td>
			<td>1</td>
		</tr>
		<tr>
			<td>경영지원실</td>
			<td>2</td>
			<td>13</td>
			<td>2</td>
		</tr>
		<tr>
			<td>사업전략팀</td>
			<td>3</td>
			<td>8</td>
			<td>3</td>
		</tr>
		<tr>
			<td>사원1</td>
			<td>4</td>
			<td>5</td>
			<td>4</td>
		</tr>
		<tr>
			<td>사원2</td>
			<td>6</td>
			<td>7</td>
			<td>4</td>
		</tr>
		<tr>
			<td>법무팀</td>
			<td>9</td>
			<td>12</td>
			<td>3</td>
		</tr>
		<tr>
			<td>사원3</td>
			<td>10</td>
			<td>11</td>
			<td>4</td>
		</tr>
		<tr>
			<td>개발부</td>
			<td>14</td>
			<td>33</td>
			<td>2</td>
		</tr>
		<tr>
			<td>개발1팀</td>
			<td>15</td>
			<td>20</td>
			<td>3</td>
		</tr>
		<tr>
			<td>사원4</td>
			<td>16</td>
			<td>17</td>
			<td>4</td>
		</tr>
		<tr>
			<td>사원5</td>
			<td>18</td>
			<td>19</td>
			<td>4</td>
		</tr>
		<tr>
			<td>개발2팀</td>
			<td>21</td>
			<td>28</td>
			<td>3</td>
		</tr>
		<tr>
			<td>사원6</td>
			<td>22</td>
			<td>23</td>
			<td>4</td>
		</tr>
		<tr>
			<td>사원7</td>
			<td>24</td>
			<td>25</td>
			<td>4</td>
		</tr>
		<tr>
			<td>사원8</td>
			<td>26</td>
			<td>27</td>
			<td>4</td>
		</tr>
		<tr>
			<td>운영팀</td>
			<td>29</td>
			<td>32</td>
			<td>3</td>
		</tr>
		<tr>
			<td>사원9</td>
			<td>30</td>
			<td>31</td>
			<td>4</td>
		</tr>
	</tbody>
</table>

<p>사이클이 없는 임의의 그래프가 주어졌을 때, 한 노드를 루트 노드로 하여 구성된 트리를 중첩 집합으로 나타냈을 때 각 노드의 <span style="color:#e74c3c;"><code>left</code></span> 필드, <span style="color:#e74c3c;"><code>right</code></span> 필드를 출력한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 트리를 구성하는 정점의 개수 <em>N</em> (2&nbsp;≤ <em>N</em>&nbsp;≤ 10<sup>5</sup>)가 주어진다.</p>

<p>두 번째 줄부터 <em>N&nbsp;</em>+ 1번째 줄까지는 정점에 연결된 간선에 대한 정보가 주어진다. 각 줄의 처음에는 간선이 연결될 정점의 번호 <em>V<sub>i</sub></em> (1&nbsp;≤ <em>V<sub>i</sub></em>&nbsp;≤ <em>N</em>)가 주어지며, -1을 입력받기 전까지는 해당 노드에서 연결된 모든 노드에 대한 정보가 주어진다.</p>

<p><em>N&nbsp;</em>+ 2 번째 줄에는 루트 노드의 역할을 하게 될 정점의 번호 <em>S</em>가&nbsp;주어진다.</p>

<p>이 때, 트리의 구성하는 간선은 단방향 그래프의 간선처럼 입력받지만, 양방향 그래프의 입력임이 보장된다. 2번 노드에서 3번 노드로의 간선을 입력받으면, 3번 노드에 연결된 노드의 정보를 입력받을 때는 3번 노드에서 2번 노드로의 간선이 입력으로 들어온다.</p>

<p>트리를 구성하는 양방향 간선의 정보를 입력받기 때문에, 간선의 개수의 총합은 <strong>2&nbsp;× (<em>N</em> - 1) </strong>개이며, 모든 정점들은&nbsp;간선을 통해 서로 직/간접적으로 연결되있다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>S</em>번 노드가 루트 노드일 때, <strong>번호가 가장 낮은 노드부터 오름차순으로 방문</strong>해서 중첩 집합을 구성했을 때, 각 노드의 번호&nbsp;<span style="color:#e74c3c;"><code>left</code></span> 필드와 <span style="color:#e74c3c;"><code>right</code></span> 필드를 출력한다.</p>

<p>총 <em>N</em>개의 줄에 걸쳐 <em>i</em>번째 줄에 <em>i</em>번 노드의 번호와&nbsp;<span style="color:#e74c3c;"><code>left&nbsp;</code></span>/&nbsp;<span style="color:#e74c3c;"><code>right</code></span> 필드를 출력한다.</p>

<p>이 때, 출력되는 모든 <span style="color:#e74c3c;"><code>left</code></span> 필드와 <span style="color:#e74c3c;"><code>right</code></span> 필드는 <strong>1 이상</strong> <strong>2&nbsp;× <em>N</em>&nbsp;이하</strong>의 서로 다른 자연수이다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
2 1 3 -1
3 2 -1
1 2 -1
2
','1 2 3
2 1 6
3 4 5
','TREE'),
                                                                                                                (10938,'BAEKJOON','https://www.acmicpc.net/problem/20364',20364,'부동산 다툼','2초','1024 MB',10,'<p>이진 트리 모양의 땅으로 이루어진 꽉꽉마을에는 오리들이 살고 있다. 땅 번호는 다음과 같이 매겨진다.</p>

<ol>
	<li>루트 땅의 번호는 1이다.</li>
	<li>어떤 땅의 번호가 <em>K</em>라면, 왼쪽 자식 땅의 번호는 2 ×&nbsp;<em>K</em>, 오른쪽 자식 땅의 번호는 2 ×&nbsp;<em>K&nbsp;</em>+&nbsp;1이다.</li>
</ol>

<p>어느날 오리들끼리 부동산 다툼이 일어나서 꽉꽉마을 촌장 경완이가&nbsp;해결책을 가져왔고, 그 내용은 다음과 같다.</p>

<ol>
	<li>오리들을 한 줄로 대기시킨다. 맨 처음 오리들은 1번 땅에 위치해 있다.</li>
	<li>오리들이 서있는 순서대로 원하는 땅을 가지도록 한다.</li>
</ol>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/1916169a-8540-4a0d-a7c9-889d6afe2842/-/preview/" style="height: 326.667px; width: 333.333px;"></p>

<p>만약, 한 오리가 원하는 땅까지 가는 길에 이미 다른 오리가 점유한&nbsp;땅이 있다면 막대한 세금을 내야 하는 이유로 해당 땅을 지나가지 못해 그 오리는 땅을 가지지 못한다. 오리가 원하는 땅까지 가는 길에는 오리가 원하는 땅도 포함된다.</p>

<ol>
</ol>

<p>경완이의 해결책대로 땅 분배를 했을 때 각 오리별로 원하는 땅을 가질 수 있는지, 가질 수 없다면 처음 마주치는 점유된 땅의 번호를 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 땅 개수&nbsp;<em>N</em>과 꽉꽉나라에 사는 오리 수&nbsp;<em>Q</em>가 공백으로 구분되어 주어진다.&nbsp;(2 ≤&nbsp;<em>N</em>&nbsp;<&nbsp;2<sup>20</sup>, 1 ≤ <em>Q</em> ≤ 200,000)</p>

<p>두 번째 줄부터 차례로 <em>Q</em>개의 줄에 걸쳐 <em>i</em>+1번째 줄에는&nbsp;<em>i</em>번째 오리가 원하는 땅 번호 <em>x<sub>i</sub></em>가 주어진다. (2 ≤ <em>x<sub>i</sub></em>&nbsp;≤ <em>N</em>)</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><em>Q</em>개의 줄에 원하는 땅에 갈 수 있다면 0을, 갈 수 없다면 처음 마주치는 점유된 땅의 번호를&nbsp;출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','6 4
3
5
6
2
','0
0
3
0
','TREE'),
                                                                                                                (10907,'BAEKJOON','https://www.acmicpc.net/problem/20426',20426,'아침은 고구마야 (Normal)','3초','512 MB',20,'<p><u><strong>입력 제한 외 난이도에 따른 문제의 차이는 없다.</strong></u></p>

<p>준표는 살이 쪄버렸다. 무려 체지방 25%의 비만이다. 준표는 균형 잡힌 식습관을 위해 아침마다 고구마를 먹기 시작했다. 아침마다 고구마를 먹던 준표는 고구마의 진정한 맛에 눈을 뜨고, 직접 고구마밭을 꾸려 매일 아침 최고의 고구마를 캐 먹기로 했다.</p>

<p><img alt="고구마 그래프" src="https://upload.acmicpc.net/67b454e0-968e-46c6-adb9-6adc1c7e0531/-/preview/" style="max-width: 100%; width: 347.5px; height: 172.5px;"></p>

<p><그림 1> 고구마 그래프 예시</p>

<p>고구마는 크게 지상부와 지하부로 나뉘어 있으며, 준표는 지하부에만 관심이 있다. 준표는 고구마의 지하부를 추상화한 그래프를 <strong>고구마 그래프</strong> 라고 부르기로 했다.</p>

<p>고구마 그래프는 크게 다섯 종류의 그래프로 나눌 수 있는 <strong>연결된 방향성 없는 그래프</strong> 이며, 각 간선마다 <strong>간선의 강도 <em>c</em></strong>를 가지고 있다.</p>

<ol>
	<li>
	<p>고구마 그래프의 루트</p>

	<p>고구마 그래프를 구성하는 정점 중 지상부와 연결된 단 하나의 정점이다. 이 정점은 언제나 1번 정점이다.</p>
	</li>
	<li>
	<p>굳은 뿌리</p>

	<p>굳은 뿌리는 고구마 그래프의 루트, 즉 1번 정점을 루트로 하는 트리 구조로 되어있다. 즉 임의의 두 정점은 모두 연결되어 있으며 경로가 하나뿐이다.</p>
	</li>
	<li>
	<p>덩이뿌리(고구마)</p>

	<p>우리가 흔히 말하는 고구마의 먹는 부분이다. 하나의 덩이뿌리는 굳은 뿌리의 끝 중 하나에 연결되어있으며, 덩이뿌리를 구성하는 정점이 N개라면 볼록 N각형과 같은 모양으로 그려진다. 즉 <strong>단순 사이클</strong>이다.</p>

	<p>덩이뿌리의 질량은 덩이뿌리를 구성하는 정점 개수의 제곱으로 계산된다. 예를 들어, 덩이뿌리가 5개의 정점으로 구성되어있다면 덩이뿌리의 질량은 5<sup>2</sup>=25이다.</p>
	</li>
	<li>
	<p>가는 뿌리</p>

	<p>가는 뿌리는 덩이뿌리의 <em>굳은 뿌리와 연결된 정점</em>을 제외한 모든 정점에 달려있으며, 트리 구조로 되어있다.</p>
	</li>
	<li>
	<p>뿌리의 끝</p>

	<p>덩이뿌리가 달려있지 않은 굳은 뿌리의 끝과 가는 뿌리의 끝, 즉 고구마 그래프의 단말 정점이다. 뿌리의 끝은 땅과 강하게 얽혀있어 뿌리를 뽑게 되면 땅속에 남을 수밖에 없다.</p>
	</li>
</ol>

<p>준표는 고구마를 얻기 위해 "고구마 그래프의 루트"를 잡고 일 순간 아주 강한 힘으로 잡아당겨 땅에서 뽑아낸다. 고구마 그래프를 뽑아내면 고구마 그래프는 "밖으로 뽑혀 나오는 정점" 과 "땅속에 남는 정점"으로 양분된다. 고구마 그래프의 모든 정점은 두 부분 중 하나에 속해야만 하며, 모든 "밖으로 뽑혀 나오는 정점"은 고구마 그래프의 루트와 연결되어있으며, 모든 "땅속에 남는 정점"은 임의의 뿌리의 끝과 연결되어있다.</p>

<p>그래프가 양분되기 위해선 고구마 그래프의 간선 중 일부가 끊겨야 할 것이다. <strong>고구마 그래프는 항상 "끊기는 간선 강도의 총합"이 최소가 되도록 끊긴다</strong>. 운이 나쁘면, 덩이뿌리(고구마)를 구성하는 간선이 끊어지는 경우가 있을 수 있다. 이러한 경우를 <strong>고구마가 깨졌다</strong>고 표현한다. 당연하지만 준표는 고구마 마스터이기 때문에 <strong>뽑히는 덩이뿌리의 질량이 최대가 되도록</strong>&nbsp;고구마 그래프를 뽑을 수 있고, 준표는 최고의 고구마만을 취급하므로 깨진 고구마는 셈에 포함하지 않는다.</p>

<p>준표가 고구마 그래프를 뽑아 수확하는 고구마의 총 질량을 알려주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 고구마 그래프를 구성하는 정점의 개수 <em>N</em>, 간선의 개수 <em>M</em>를 입력받는다.</p>

<p>이후 <em>M</em> 줄에 걸쳐 간선의 정보가 주어진다. 간선의 정보는 세 정수 <em>u</em>, <em>v</em>, <em>c</em>로 주어진다. 이는 정점 <em>u</em>와 정점 <em>v</em>를 연결하는 강도 <em>c</em>의 간선을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>준표가 수확하게 되는 고구마의 총 질량을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','19 19
1 2 23
2 3 7
3 4 6
4 5 8
2 6 17
6 7 4
7 8 9
8 9 7
9 10 4
10 6 12
7 11 4
11 12 1
11 13 2
8 14 2
14 15 1
9 16 4
16 17 3
16 18 3
10 19 6
','25
','TREE'),
                                                                                                                (10906,'BAEKJOON','https://www.acmicpc.net/problem/20427',20427,'아침은 고구마야 (Hard)','3초','512 MB',22,'<p><u><strong>입력 제한 외 난이도에 따른 문제의 차이는 없다.</strong></u></p>

<p>준표는 살이 쪄버렸다. 무려 체지방 25%의 비만이다. 준표는 균형 잡힌 식습관을 위해 아침마다 고구마를 먹기 시작했다. 아침마다 고구마를 먹던 준표는 고구마의 진정한 맛에 눈을 뜨고, 직접 고구마밭을 꾸려 매일 아침 최고의 고구마를 캐 먹기로 했다.</p>

<p><img alt="고구마 그래프" src="https://upload.acmicpc.net/67b454e0-968e-46c6-adb9-6adc1c7e0531/-/preview/" style="max-width: 100%; width: 347.5px; height: 172.5px;"></p>

<p><그림 1> 고구마 그래프 예시</p>

<p>고구마는 크게 지상부와 지하부로 나뉘어 있으며, 준표는 지하부에만 관심이 있다. 준표는 고구마의 지하부를 추상화한 그래프를 <strong>고구마 그래프</strong> 라고 부르기로 했다.</p>

<p>고구마 그래프는 크게 다섯 종류의 그래프로 나눌 수 있는 <strong>연결된 방향성 없는 그래프</strong> 이며, 각 간선마다 <strong>간선의 강도 <em>c</em></strong>를 가지고 있다.</p>

<ol>
	<li>
	<p>고구마 그래프의 루트</p>

	<p>고구마 그래프를 구성하는 정점 중 지상부와 연결된 단 하나의 정점이다. 이 정점은 언제나 1번 정점이다.</p>
	</li>
	<li>
	<p>굳은 뿌리</p>

	<p>굳은 뿌리는 고구마 그래프의 루트, 즉 1번 정점을 루트로 하는 트리 구조로 되어있다. 즉 임의의 두 정점은 모두 연결되어 있으며 경로가 하나뿐이다.</p>
	</li>
	<li>
	<p>덩이뿌리(고구마)</p>

	<p>우리가 흔히 말하는 고구마의 먹는 부분이다. 하나의 덩이뿌리는 굳은 뿌리의 끝 중 하나에 연결되어있으며, 덩이뿌리를 구성하는 정점이 N개라면 볼록 N각형과 같은 모양으로 그려진다. 즉 <strong>단순 사이클</strong>이다.</p>

	<p>덩이뿌리의 질량은 덩이뿌리를 구성하는 정점 개수의 제곱으로 계산된다. 예를 들어, 덩이뿌리가 5개의 정점으로 구성되어있다면 덩이뿌리의 질량은 5<sup>2</sup>=25이다.</p>
	</li>
	<li>
	<p>가는 뿌리</p>

	<p>가는 뿌리는 덩이뿌리의 <em>굳은 뿌리와 연결된 정점</em>을 제외한 모든 정점에 달려있으며, 트리 구조로 되어있다.</p>
	</li>
	<li>
	<p>뿌리의 끝</p>

	<p>덩이뿌리가 달려있지 않은 굳은 뿌리의 끝과 가는 뿌리의 끝, 즉 고구마 그래프의 단말 정점이다. 뿌리의 끝은 땅과 강하게 얽혀있어 뿌리를 뽑게 되면 땅속에 남을 수밖에 없다.</p>
	</li>
</ol>

<p>준표는 고구마를 얻기 위해 "고구마 그래프의 루트"를 잡고 일 순간 아주 강한 힘으로 잡아당겨 땅에서 뽑아낸다. 고구마 그래프를 뽑아내면 고구마 그래프는 "밖으로 뽑혀 나오는 정점" 과 "땅속에 남는 정점"으로 양분된다. 고구마 그래프의 모든 정점은 두 부분 중 하나에 속해야만 하며, 모든 "밖으로 뽑혀 나오는 정점"은 고구마 그래프의 루트와 연결되어있으며, 모든 "땅속에 남는 정점"은 임의의 뿌리의 끝과 연결되어있다.</p>

<p>그래프가 양분되기 위해선 고구마 그래프의 간선 중 일부가 끊겨야 할 것이다. <strong>고구마 그래프는 항상 "끊기는 간선 강도의 총합"이 최소가 되도록 끊긴다</strong>. 운이 나쁘면, 덩이뿌리(고구마)를 구성하는 간선이 끊어지는 경우가 있을 수 있다. 이러한 경우를 <strong>고구마가 깨졌다</strong>고 표현한다. 당연하지만 준표는 고구마 마스터이기 때문에 <strong>뽑히는 덩이뿌리의 질량이 최대가 되도록</strong>&nbsp;고구마 그래프를 뽑을 수 있고, 준표는 최고의 고구마만을 취급하므로 깨진 고구마는 셈에 포함하지 않는다.</p>

<p>준표가 고구마 그래프를 뽑아 수확하는 고구마의 총 질량을 알려주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에 고구마 그래프를 구성하는 정점의 개수 <em>N</em>, 간선의 개수 <em>M</em>를 입력받는다.</p>

<p>이후 <em>M</em> 줄에 걸쳐 간선의 정보가 주어진다. 간선의 정보는 세 정수 <em>u</em>, <em>v</em>, <em>c</em>&nbsp;로 주어진다. 이는 정점 <em>u</em>와 정점 <em>v</em>를 연결하는 강도 <em>c</em>의 간선을 의미한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>준표가 수확하게 되는 고구마의 총 질량을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','19 19
1 2 23
2 3 7
3 4 6
4 5 8
2 6 17
6 7 4
7 8 9
8 9 7
9 10 4
10 6 12
7 11 4
11 12 1
11 13 2
8 14 2
14 15 1
9 16 4
16 17 3
16 18 3
10 19 6
','25
','TREE'),
                                                                                                                (10935,'BAEKJOON','https://www.acmicpc.net/problem/20659',20659,'해군','25초','1024 MB',26,'<p>Byteland에는 $N$ 개의 호수가 있으며, 몇 개의 강이 두 호수를 직접 연결하고 있다. 당신은 Byteland의 해군 지휘관으로, 다가오는 전쟁에 대비한 전략을 세우려고 한다.</p>

<p>Byteland의 정보부에서는 다가오는 전쟁이&nbsp;$T+1$ 일 동안 계속될 것이며, 각 날 사이에 있는 밤마다 전투가 있을 것이라는 첩보를 주었다. 즉, 모든 $1 \le i \le T$ 에 대해서, $i$ 일 과 $i+1$일 사이의 밤에 전투가 이루어 지는 것이다.</p>

<p>Byteland의 호수와 강은 그래프로 생각할 수 있다. 어떠한 강이 제거되었을 때 연결 컴포넌트의 개수가 증가하면, 이 강은 <strong>격전지</strong>로 분류된다. (그래프 이론에서 이러한 강은 "절선" 이라고 부른다.)</p>

<p>호수에는 항상 물이 차 있지만, 강은 그 때의 날씨에 따라서 물이 빠질 수도 있다. 즉, 어떠한 호수의 쌍이 날씨에 따라 강으로 직접 연결될 수도 있고, 아닐 수도 있다.&nbsp;Byteland에는 $M$ 개 종류의 날씨가 있고, $i$ 번 날씨는 집합 $A_i$ 에 있는 두 호수의 쌍을 강으로 만든다.&nbsp;</p>

<p>과학자들은 모든 $1 \le i \le T + 1$ 에 대해, $i$일의 낮의 날씨 $B_i$ 를 찾았다. 과학자들은, $i$ 일 과 $i+1$일 사이의 밤에 전투가 이루어 질 때, 강의&nbsp;집합은 $A_{B_i}&nbsp;\cup A_{B_{i + 1}}$ 이라고 예측했다.</p>

<p>이 예측들을&nbsp;사용하여, 매 $T$ 번의 전투에서 격전지의 개수를 출력하라.</p>

<p>집합은 같은 원소를 두 개 이상 포함할 수 있으며 (Multiset), 호수와 강이 평면 그래프를 이루지 않을 수 있다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫번째 줄에 세 정수 $N, M, T$ 가 주어진다. ($1 \le N, M \le 100\,000, 1 \le T \le 200\,000$)</p>

<p>두번째 줄에&nbsp;$T+1$ 개의 정수 $B_1, B_2, \ldots, B_{T + 1}$ 이 주어진다. ($1 \le B_i \le M$)</p>

<p>이후 $M$ 개의 줄에 집합 $A_i$ 가 주어진다. 이 집합은 $2K_i + 1$ 개의 정수로 포함된다. 첫 번째 정수는 $A_i$ 의 크기 $K_i$ 이다. 이후 $2K_{i}$ 개의 정수로 해당 날씨에서 강으로 직접 연결되는 두 호수의 번호가 순서대로 주어진다. 두 호수의 번호는 서로 다르다.</p>

<p>$K_i$ 의 합은 $200\,000$ 을 넘지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>$T$ 개의 줄에 걸쳐 문제의 정답을 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 3 4
1 1 2 3 1
1 1 2
1 3 4
2 2 3 2 3
','0
2
1
1
','TREE'),
                                                                                                                (10958,'BAEKJOON','https://www.acmicpc.net/problem/20924',20924,'트리의 기둥과 가지','2.5초(추가시간없음)','1024 MB',12,'<p style="text-align: center;"><img alt="" height="400px" src="https://upload.acmicpc.net/cb157759-0c85-4c0d-a121-771c6f25d688/-/preview/" style="width: 337.5px; height: 277.5px;"></p>

<p>시청 공무원 마이크로는 과장으로부터 시에 있는 나무의 기둥의 길이와&nbsp;가장 긴 가지의 길이를 파악하라는 업무 지시를 받았다.</p>

<p>마이크로는 ICPC Sinchon Winter Algorithm Camp에서 배운 트리 자료 구조를 이용하면 이 작업을 좀 더 수월하게 할 수 있으리라 판단했다.&nbsp;</p>

<p style="text-align: center;"><img alt="" height="400px" src="https://upload.acmicpc.net/4f327bb2-ffff-403c-9c45-ca27b8ba384f/-/preview/" style="width: 335px; height: 333.333px;"></p>

<p>마이크로는 트리의 기둥과 가지를 분류하기 위해 기가 노드를 추가로 정의하였다.</p>

<p>기가 노드는 루트 노드에서 순회를 시작했을 때, 처음으로 자식 노드가 $2$개 이상인 노드다. 기둥-가지를 줄여 기가 노드라 이름 붙였다. 위 그림에서 기가 노드는 $4$번 노드다.</p>

<p style="text-align: center;"><img alt="" height="400px" src="https://upload.acmicpc.net/a5e04b5d-e28b-4a9c-97ce-dd45f500b824/-/preview/"></p>

<p>단, 위 그림과 같이 리프 노드가 단 $1$개인 경우 리프 노드가 동시에 기가 노드가 된다.</p>

<p style="text-align: center;"><img alt="" height="400px" src="https://upload.acmicpc.net/cc15e14f-82e2-4c5c-9dbc-7919b7b96649/-/preview/" style="width: 334.167px; height: 231.667px;"></p>

<p>또한, 위 그림과 같이 루트 노드가 동시에 기가 노드인 경우도 가능하다.</p>

<p style="text-align: center;"><img alt="" height="400px" src="https://upload.acmicpc.net/1a596e90-2416-4c7e-aa8f-f8bdf035dbaa/-/preview/" style="width: 371.667px; height: 333.333px;"><img alt="" height="400px" src="https://upload.acmicpc.net/86b4fbd7-b49b-4c58-9e10-a06d0365f8eb/-/preview/" style="width: 396.667px; height: 333.333px;"></p>

<ul>
	<li>트리의 기둥은 루트 노드에서부터 기가 노드까지다. 위 그림에서 기둥은 $1-2-3-4$ 이다.<br>
	기둥의 길이는 기둥의 간선 길이의 합인 $1 + 2 + 3 = 6$ 이 된다.</li>
	<li>트리의 가지는 기가 노드에서부터 임의의 리프 노드까지다. 위 그림에서 가지는 $4-5-6-7$, $4-5-8$, $4-9$, $4-10-11$, $4-10-12$ 총 $5$개가 있다.<br>
	가지의 길이는 가지의 간선 길이의 합이다. 다행히도 가장 긴 가지의 길이 하나만 기재하면 된다. $4-10-12$ 가지가 간선 길이의 합 $3 + 3 = 6$ 으로 가장 긴 가지이다.</li>
</ul>

<p>마이크로는 시의 나무를 트리 자료 구조로 옮겼다. 그런데 과장이 마이크로에게 또 다른 업무를 지시했다! 너무 바쁜 마이크로를 대신해 트리의 기둥과 가장 긴 가지의 길이를 측정하자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 노드의 개수 $N$($1 \le N&nbsp;\le 200\,000$)과 루트 노드의 번호 $R$($1 \le R \le N$)이 주어진다.</p>

<p>이후 $N-1$개의 줄에 세 개의 정수 $a$, $b$, $d$($1 \le a, b \le N$, $ a \ne b$)가 주어진다.&nbsp;이는 $a$번 노드와 $b$번 노드가 연결되어있으며 이 간선의 길이가 $d$($1 \le d&nbsp;\le 1\,000$)임을 의미한다.&nbsp;노드는&nbsp;$1$번부터 $N$번까지 정수 번호가 매겨져 있으며 같은 간선은 여러 번 주어지지 않는다.&nbsp;</p>

<p>트리가 아닌 그래프는 입력으로 주어지지 않는다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>나무의 기둥의 길이와 가장 긴 가지의 길이를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','12 1
1 2 1
2 3 2
3 4 3
4 5 1
5 6 2
6 7 1
5 8 1
4 9 2
4 10 3
10 11 1
10 12 3
','6 6
','TREE'),
                                                                                                                (10915,'BAEKJOON','https://www.acmicpc.net/problem/21320',21320,'순간이동 여행','1초','1024 MB',15,'<p>민겸이는 높이가 <em>N</em>인 포화 이진 트리를 여행하기로 했다. 높이가 <em>N</em>인 포화 이진 트리란,&nbsp;루트 노드에서 어떤 리프 노드까지 이동할 때 최소 <em>N&nbsp;</em>- 1번 이동해야 하는 포화 이진 트리를 말한다. 각 노드에는 번호가 매겨져 있는데, 루트 노드는 1번이고, 모든 인터널 노드(리프 노드가 아닌 노드)에 대해 인터널 노드가 <em>P</em>번 노드일 때, 해당 노드의 왼쪽 자식은 <em>P&nbsp;</em>× 2번 노드이고, 오른쪽 자식은 <em>P&nbsp;</em>× 2 + 1번 노드이다.</p>

<p>아래 그림은 높이가 4인 포화 이진 트리의 예시이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/673f1e3d-c966-45ed-a512-590510ce16c2/-/preview/" style="width: 344.167px; height: 127.5px;"></p>

<p>민겸이는 여행을 위해 어떤 노드에 도착했다. 민겸이는 자신이 위치한 노드와 연결된 인접한 노드로 걸어서 이동할 수 있다. 하지만 민겸이는 한 번 방문했던 노드를 다시는 방문하지 않는다. 이 때문에 모든 노드를 방문할 수 없을 수도 있다는 것을 깨달은 민겸이는 순간이동기를 준비했다. 순간이동기는 민겸이를 방문하지 않은 노드 중 원하는 노드로 순간이동시켜준다. 하지만, 순간이동 할 때마다 엄청난 돈이 들기 때문에, 민겸이는 순간이동 횟수를&nbsp;최소화하고 싶다.</p>

<p>민겸이가 여행을 시작할 노드 번호가 주어질 때, 민겸이가 모든 노드를 방문하기 위해서 순간이동을&nbsp;최소 몇 번 해야 하는지 알아보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>포화 이진 트리의 높이 <em>N</em>(1&nbsp;≤ <em>N</em>&nbsp;≤ 3,000), 정수 <em>K</em>(1&nbsp;≤ <em>K</em>&nbsp;≤ <em>N</em>)가 주어진다. 민겸이는 2<sup><em>K&nbsp;</em>- 1</sup>번 노드에서 여행을 시작한다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>민겸이가 모든 노드를 방문할 때까지 순간이동을 최소 몇 번 해야&nbsp;하는지 출력한다. 단, 답이&nbsp;너무 커질 수 있으므로, 답을 10<sup>9&nbsp;</sup>+ 7로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4 1
','5
','TREE'),
                                                                                                                (10919,'BAEKJOON','https://www.acmicpc.net/problem/21566',21566,'트리 정리하기','1초','256 MB',18,'<p>제2회 PMCC의 성공적인 개최를 기원하기 위해, 작년 크리스마스에 대회 운영진들은 크리스마스 트리를 꾸몄습니다. 물론 모두가 한 곳에 모여서 꾸미면 5인 이상 집합 금지 규정을 위반하는 것이기 때문에, 한 번에 네 명을 넘는 인원이 크리스마스 트리를 꾸밀 수 없었습니다.</p>

<p>크리스마스 트리는 $N$개의 정점을 $N-1$개의 간선이 연결하는 연결 그래프, 즉 트리(tree)의 형태를 하고 있었습니다. 그런데 트리의 구조가 너무 복잡했기 때문에, 운영진은 트리를 꾸미기 전에 먼저 트리를 정리하기로 했습니다.</p>

<p>한 번에 네 명 이상이 모일 수 없었기 때문에, 운영진은 아래와 같은 ‘작업’을 반복해서 트리를 정리하기로 했습니다.</p>

<ul>
	<li>운영진 네 명은 각각 네 개의 정점 $A$, $B$, $C$, $D$를 한 명당 하나씩 잡습니다. 이때 운영진들이 코로나 시국에서 외로움을 느끼지 않게 하기 위해서, $A$와 $B$, $B$와 $C$, $C$와 $D$는 각각 간선으로 이어져 있어야 합니다.</li>
	<li>$A$, $B$, $C$, $D$ 사이의 모든 간선을 제거합니다.</li>
	<li>$A$와 $C$, $A$와 $D$, $B$와 $D$ 사이에 간선을 추가합니다.</li>
</ul>

<p>이를 그림으로 나타내면 다음과 같습니다.</p>

<table class="table table-bordered td-center">
	<tbody>
		<tr>
			<td><img alt="" src="https://upload.acmicpc.net/8eeb7b46-ff2e-4459-b13b-0801c757683f/-/preview/"></td>
			<td><img alt="" src="https://upload.acmicpc.net/1d74067c-4950-4672-b500-ced8b88c904a/-/preview/"></td>
		</tr>
		<tr>
			<td>초기 상태</td>
			<td>작업 뒤의 상태</td>
		</tr>
	</tbody>
</table>

<p>운영진의 목표는 트리에 몇 번의 작업을 거쳐, 트리의 ‘지름’을 4 이하로 만드는 것입니다. 트리의 지름은 가장 먼 두 정점 사이의 거리를 말합니다. 운영진이 트리를 정리할 수 있는지 판별하고, 정리할 수 있으면 방법을 아무거나 하나 찾는 프로그램을 만들어 봅시다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 줄에는 트리의 정점의 수 $N$이 주어집니다. 다음 줄부터 개의 줄에는 트리의 각 간선으로 연결된 정점의 번호 $u_i$, $v_i$가 주어집니다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>만약 유한 번의 작업으로 트리를 정리하는 것이 불가능하다면, $-1$을 출력하고 프로그램을 종료합니다.</p>

<p>만약 트리를 정리하는 것이 가능하다면, 첫 줄에는 작업의 횟수 $Q$를 출력합니다.</p>

<p>다음 줄부터 개의 줄에는 네 정수 $A$, $B$, $C$, $D$를 출력합니다. 각 정수는 위에서 언급된 ‘작업’의 규칙에 해당하는 네 정점의 번호여야 합니다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
1 2
2 3
3 4
4 5
','1
1 2 3 4
','TREE'),
                                                                                                                (10920,'BAEKJOON','https://www.acmicpc.net/problem/21728',21728,'트리와 2개의 지름','4초(추가시간없음)','1536 MB',29,'<p>이메이미 교수의 알고리즘 과목을 재수강하게 된 메시는 작년과 같은 실수를 반복하지 않기 위해 중간고사를 철저히 대비하려고 한다. 작년에 가중치 없는 트리의 지름에 관련된 문제가 나왔던 것을 참고하여, 메시는 다음과 같은 문제를 스스로 고안해내었다.</p>

<p>"가중치 없는 트리 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$T$</span></mjx-container>에 대해, 두 정점을 잇는 최단경로 중 가장 긴 것들을 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$T$</span></mjx-container>의 지름이라고 한다. <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$T$</span></mjx-container>의 지름들의 모임을 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-texatom texclass="ORD"><mjx-mi class="mjx-cal mjx-i"><mjx-c class="mjx-c44 TEX-C"></mjx-c></mjx-mi></mjx-texatom><mjx-script style="vertical-align: -0.15em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mrow data-mjx-texclass="ORD"><mi data-mjx-variant="-tex-calligraphic" mathvariant="script">D</mi></mrow><mrow data-mjx-texclass="ORD"><mi>T</mi></mrow></msub></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$\mathcal{D}_{T}$</span></mjx-container>라고 하자. <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$T$</span></mjx-container>의 두 지름 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2208"></mjx-c></mjx-mo><mjx-msub space="4"><mjx-texatom texclass="ORD"><mjx-mi class="mjx-cal mjx-i"><mjx-c class="mjx-c44 TEX-C"></mjx-c></mjx-mi></mjx-texatom><mjx-script style="vertical-align: -0.15em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mo>,</mo><mi>E</mi><mo>∈</mo><msub><mrow data-mjx-texclass="ORD"><mi data-mjx-variant="-tex-calligraphic" mathvariant="script">D</mi></mrow><mrow data-mjx-texclass="ORD"><mi>T</mi></mrow></msub></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$D, E \in \mathcal{D}_{T}$</span></mjx-container>에 대해 (둘은 같을 수 있다), 둘 모두에 공통으로 속하는 정점의 개수를 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>D</mi><mo>,</mo><mi>E</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$f(D, E)$</span></mjx-container>라 하자. 가능한 모든 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mo>,</mo><mi>E</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$D, E$</span></mjx-container>에 대한 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>D</mi><mo>,</mo><mi>E</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$f(D, E)$</span></mjx-container>의 합 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D439 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-munder space="4" limits="false"><mjx-mo class="mjx-sop"><mjx-c class="mjx-c2211 TEX-S1"></mjx-c></mjx-mo><mjx-script style="vertical-align: -0.285em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2208"></mjx-c></mjx-mo><mjx-texatom texclass="ORD"><mjx-mi class="mjx-cal mjx-i"><mjx-c class="mjx-c44 TEX-C"></mjx-c></mjx-mi></mjx-texatom></mjx-texatom></mjx-script></mjx-munder><mjx-munder space="2" limits="false"><mjx-mo class="mjx-sop"><mjx-c class="mjx-c2211 TEX-S1"></mjx-c></mjx-mo><mjx-script style="vertical-align: -0.285em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2208"></mjx-c></mjx-mo><mjx-texatom texclass="ORD"><mjx-mi class="mjx-cal mjx-i"><mjx-c class="mjx-c44 TEX-C"></mjx-c></mjx-mi></mjx-texatom></mjx-texatom></mjx-script></mjx-munder><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D437 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D438 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>D</mi><mo>∈</mo><mrow data-mjx-texclass="ORD"><mi data-mjx-variant="-tex-calligraphic" mathvariant="script">D</mi></mrow></mrow></munder><munder><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>E</mi><mo>∈</mo><mrow data-mjx-texclass="ORD"><mi data-mjx-variant="-tex-calligraphic" mathvariant="script">D</mi></mrow></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>D</mi><mo>,</mo><mi>E</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$F(T) = \sum_{D \in \mathcal{D}} \sum_{E \in \mathcal{D}} f(D, E)$</span></mjx-container>를 구하여라."</p>

<p><mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;">?<mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$N$</span></mjx-container>개의 정점을 가진 트리에는 최대 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em; margin-left: 0.054em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$O(N^2)$</span></mjx-container>개의 지름이 있기 때문에, 메시는 모든 지름을 구해서 각각이 공통으로 소유하는 정점 개수를 구하는 방식으로 훌륭한 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em; margin-left: 0.054em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>5</mn></msup><mo stretchy="false">)</mo></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$O(N^5)$</span></mjx-container> 코드를 구현해냈다. 이 정도라면 아무리 어려운 이메이미 교수의 시험이라도 통과할 수 있을 것만 같았다.</p>

<p>하지만 작년 시험에서 메시를 좌절시켰던 것은 무수한 양의 쿼리였기 때문에, 심기일전한 메시는 쿼리에 대한 대비도 미리 하고자 한다. 간선을 연결하거나 제거하는 쿼리를 추가하기 위해, 맨 처음에 주어지는 그래프를&nbsp;트리가 아니라 포레스트로 바꿨다. 즉, 그래프에 여러 개의 연결 컴포넌트가 있을 수도 있다.</p>

<p>쿼리는 다음 중 하나로, 총 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D444 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$Q$</span></mjx-container>개 주어진다.</p>

<p><mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;">?<mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$1$</span></mjx-container> <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x$</span></mjx-container> <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$y$</span></mjx-container> : 정점 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x$</span></mjx-container>와 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$y$</span></mjx-container>를 연결한다. 이 쿼리가 들어올 때 정점 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x$</span></mjx-container>와 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$y$</span></mjx-container>는 서로 다른 연결 컴포넌트에 있다.</p>

<p><mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;">?<mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$2$</span></mjx-container> <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x$</span></mjx-container> <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$y$</span></mjx-container> : 정점 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x$</span></mjx-container>와 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$y$</span></mjx-container>를 연결하는 간선을 제거한다. 이 쿼리가 들어오기 전에 정점 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x$</span></mjx-container>와 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$y$</span></mjx-container>를 연결하는 간선이 존재한다.</p>

<p><mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;">?<mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$3$</span></mjx-container> <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x$</span></mjx-container> : 정점 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x$</span></mjx-container>가 포함되는 트리 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$T$</span></mjx-container>에 대해 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D439 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$F(T)$</span></mjx-container>를&nbsp;<mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.393em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c39"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c37"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$10^9+7$</span></mjx-container>로 나눈 나머지를&nbsp;출력한다. 이 쿼리가 들어오기 전에 정점 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x$</span></mjx-container>가 포함된 연결 컴포넌트에는 정점이 2개 이상 존재한다.</p>

<p>메시는 훌륭한 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D444 TEX-I"></mjx-c></mjx-mi><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em; margin-left: 0.054em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>Q</mi><msup><mi>N</mi><mrow data-mjx-texclass="ORD"><mn>5</mn></mrow></msup><mo stretchy="false">)</mo></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$O(QN^{5})$</span></mjx-container> 코드를 완성한 뒤 당신에게 검수를 부탁했다. 이 문제를 풀고 큰 데이터를 추가해서 메시가 중간고사를 잘 볼 수 있도록 도와주자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>입력의 첫 줄에 정점의 개수 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$N$</span></mjx-container>, 간선의 개수 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D440 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$M$</span></mjx-container>, 쿼리의 개수 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D444 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$Q$</span></mjx-container>가 주어진다.</p>

<p>다음 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D440 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$M$</span></mjx-container>줄에는 초기 상태의 간선이 연결하는 두 정점의 번호 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>,</mo><mi>y</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$x, y$</span></mjx-container>가 주어진다. 정점의 번호는 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$1$</span></mjx-container>번부터 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$N$</span></mjx-container>번까지이다.</p>

<p>다음 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D444 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$Q$</span></mjx-container>줄에는 각 쿼리를 나타내는 정보가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p><mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;">?<mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$3$</span></mjx-container>번 쿼리가 들어올 때마다 <mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D439 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$F(T)$</span></mjx-container>를&nbsp;<mjx-container class="MathJax" jax="CHTML" style="font-size: 109%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.393em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c39"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c37"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></math></mjx-assistive-mml><span aria-hidden="true" class="no-mathjax mjx-copytext">$10^9+7$</span></mjx-container>로 나눈 나머지를 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','7 5 5
1 2
1 3
2 4
2 5
3 6
3 1
1 3 7
3 1
2 2 1
3 1
','18
64
21
','TREE'),
                                                                                                                (10927,'BAEKJOON','https://www.acmicpc.net/problem/21738',21738,'얼음깨기 펭귄','1초(하단참고)','1024 MB',11,'<p>도도는 심심해서 보드게임 카페에 갔다. 마침 평소에 즐겨 했던 얼음 깨기 펭귄의 업그레이드 버전으로 특수 얼음 깨기 펭귄 보드게임이 나와 직접 플레이해 보기로 결정했다. 특수 얼음 깨기 펭귄 게임은 특수 안경이 있어 특수 안경을 끼고 얼음들을 보면 얼음들 간의 연결 관계가 보인다.</p>

<p>특수 얼음 깨기 펭귄 게임에 있는 얼음의 종류로는 지지대의 역할을 하는 얼음과 일반 얼음 총 2가지의 얼음이 존재한다. 지지대의 역할을 하는 얼음의 경우,&nbsp;빨간색으로 구분하여 볼 수 있으며 일반 얼음을 지탱해 주어 일반 얼음들이 깨지지 않도록 도와준다.&nbsp;일반 얼음의 경우에는 1개의 지지대만이&nbsp;연결되어 있어도 얼음이 깨지지 않지만 펭귄이 올라가 있는 얼음은 2개 이상의 지지대의 역할을 하는 얼음이 연결되어 있어야만 얼음이 깨지지 않는다. 이때, 지지대가 연결되어 있다는 것은 지지대로부터&nbsp;서로 다른 일반 얼음들을 통해&nbsp;연결 관계가&nbsp;이어져 있는 것을&nbsp;이야기한다.&nbsp;특수 얼음 깨기 펭귄 게임에서 도도가 펭귄을 떨어뜨리지 않고 최대 몇 개의 얼음을 깰 수 있을까?</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/e83176f5-a229-45b0-b7bf-7be5e1dd26dd/-/preview/" style="height: 298.333px; width: 347.5px;"></p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 얼음 블록의 개수 $N$($ 3&nbsp;\leq N \leq 328\,000$)과 지지대의 역할을 하게 되는 얼음의 개수 $S$($ 2 \leq S \leq N-1$), 펭귄이 위치한 얼음 블록의 번호 $P$($ S&nbsp;\lt&nbsp;P \leq N$)가 주어진다. 지지대의 역할을 하게 되는 얼음의 개수가 $S$일 때, $1$번부터 $S$번까지의 얼음은 지지대의 역할을 한다.</p>

<p>둘째 줄부터 $N-1$개의 줄에 두 개의 정수 $A$, $B$가 주어진다. 이는 $A$번 얼음과 $B$번 얼음이 연결되어 있음을 의미하며 같은 연결은 여러 번 주어지지 않는다.</p>

<p>게임 시작 시&nbsp;펭귄은 일반 얼음 위에 위치해 있고&nbsp;어떤 얼음도 깨지지 않은 상태로 시작하게 된다. 각 얼음들은 $1$번부터 $N$번까지 정수 번호로&nbsp;주어져 있으며 서로 다른 두 얼음을 잇는 경로는 하나뿐이다. 더불어 서로 다른 지지대가 펭귄이 올라가 있는 얼음을 거치지 않고 연결되어 있는 경우는 없다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>플레이어가 펭귄을 떨어트리지 않고 깰 수 있는 얼음의 최대 개수를 구하여라. 지지대의 역할을 하는 얼음 역시 깰 수 있는 얼음에 속한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','21 6 12
1 9
1 10
10 12
2 13
13 11
11 12
3 8
8 7
8 12
5 19
5 14
14 12
6 20
6 21
20 15
15 12
4 18
4 17
17 16
16 12
','16
','TREE'),
                                                                                                                (10925,'BAEKJOON','https://www.acmicpc.net/problem/21759',21759,'두 개의 팀','2초','512 MB',18,'<p>$N$명의 사원으로 구성되는 어느 회사의 조직도는 루트 트리(rooted tree)로 표현된다. 트리의 각 노드는 한 명의 사원을 의미하고, 간선은 직속 상사-부하의 관계를 나타낸다. 각 사원은 $1$부터 $N$까지 번호가 부여되어 있다. 사원 $1$은 회사의 사장이며, 트리의 루트이다. 각 사원의 실력 또한 정수로 표현되는데, 실력은 음수일수도 있다. 아래 그림은 조직도의 한 예를 보여준다. 노드 안의 수는 사원 번호를 의미한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/1ff64e35-0ebe-43ff-9588-dbc823273c82/-/preview/" style="width: 395px; height: 340px;"></p>

<p>사원 중 일부를 팀장으로 선택하려 한다. 팀장으로 선발되면, 팀장은 자신을 포함하여 팀을 구성해야 하는데, 각 팀은 다음 조건을 만족해야 한다.</p>

<ol>
	<li>팀원은 팀장의 부하 직원이어야 한다. (단, 직속 부하일 필요는 없다.) 예를 들어, 사원 $3$이 팀장이라면, 사원 $8$이나 $11$은 팀원이 될 수 있지만, 사원 $1$이나 $9$는 팀원이 될 수 없다.</li>
	<li>어떤 사원이 팀원으로 포함되면, 그 사원의 직속 상사도 반드시 같은 팀의 팀원으로 포함되어야 한다 (단, 팀장 제외). 예를 들어, 사원 3이 팀장인 경우, 팀 구성이 $\{3, 6, 11\}$인 경우는 가능하나, $\{3, 8, 11\}$은 사원 $11$의 상사인 사원 $6$이 포함되지 않아 불가능하다.</li>
	<li>팀의 점수(팀장을 포함한 팀원 전체의 실력의 합으로 정의)가 최대가 되도록 팀원을 구성해야 한다. (팀의 점수가 최대가 되도록 하는 팀 구성이 유일하지 않으면, 그 중 아무거나 골라도 된다.) 예들 들어, 모든 사원의 실력이 모두 양수라고 가정했을 때, 사원 $3$을 팀장으로 선발하면, 팀 구성은 반드시 $\{3, 6, 7, 8, 11, 12\}$가 되어야 되고, 이 중 한명이라도 팀원에서 빠지는 경우는 허용되지 않는다.</li>
	<li>팀원은 다른 팀의 팀원(팀장 포함)이 될 수 없다. 따라서 어떤 사원 A가 팀장일 때, 부하직원 B가 조건 $3$에 의해 팀장 A의 팀원이 되어야 한다면, 사원 A와 B를 모두 팀장으로 선발하는 것은 불가능한다.</li>
</ol>

<p>회사에서는 두 명의 팀장을 선택하여 두 개의 팀을 구성하되, <strong>두 팀의 점수를 합산</strong>한 결과(즉, 두 팀의 팀원 전체의 실력의 합)가 최대가 되도록 하려고 한다. 두 팀 점수의 합으로 가능한 최댓값을 계산하는 프로그램을 작성하라. 위 조건을 만족하도록 두 팀을 구성할 수 있는 경우만 입력으로 주어진다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에 하나의 정수 $N$이 주어진다.</p>

<p>다음 $N$개의 줄에는 사원들에 대한 정보가 주어진다. 이 중 $i$ ($1 \le i \le N$)번째 줄에는 사원 $i$의 실력과 직속 상사 번호를 나타내는 두 개의 정수가 공백 하나를 사이로 두고 주어진다.</p>

<p>사원 1은 직속 상사가 없으므로, 사원 $1$의 직속 상사 번호의 자리에는 대신 $-1$이 들어온다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>두 팀 점수의 합으로 가능한 최댓값을 출력하라. 출력 값이 매우 클 수 있으므로 C, C++ 언어에서는 <code>long long</code> 형의 변수를, Java에서는 <code>long</code> 형의 변수를 사용해야 한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
3 -1
-2 1
2 2
-1 1
','5
','TREE'),
                                                                                                                (10946,'BAEKJOON','https://www.acmicpc.net/problem/21954',21954,'D-균형 트리','2초','512 MB',20,'<p>D-균형 트리는 다음 세 조건을 만족하는 트리이다.</p>

<ul>
	<li>트리의 각 정점은 검정색 또는 흰색이다.</li>
	<li>각 검정색 정점에서&nbsp;거리가 최대 D인 다른 검정색 정점이&nbsp;존재한다.</li>
	<li>각 흰색 정점에서 거리가 최대 D인 다른 흰색 정점이&nbsp;존재한다.</li>
</ul>

<p>트리의 정보와 정점의 색이 주어졌을 때, 만족하는 D의 값 중에서 최솟값을 구해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.</p>

<ul>
	<li>첫째 줄에 정점의 수 N이 주어진다.</li>
	<li>둘째 줄부터 N-1개의 줄에 두 정수 x, y가 주어진다. 정점 x와 y를 연결하는 간선을 의미한다.</li>
	<li>마지막 줄에 정점의 색이 1번 정점부터 N번 정점까지 순서대로 주어진다. 0은 흰색, 1은 검정색을 의미한다.</li>
</ul>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>각 테스트 케이스마다 만족하는 D의 값 중에서 최솟값을 한 줄에 하나씩 출력한다. 가능한 D의 값이 존재하지 않으면 -1을 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','3
3
1 2
2 3
0 0 0
4
1 2
2 3
2 4
0 1 0 0
6
1 2
2 3
2 4
4 5
4 6
1 0 0 1 1 0
','1
-1
2
','TREE'),
                                                                                                                (10960,'BAEKJOON','https://www.acmicpc.net/problem/21973',21973,'남극 탐험','30초','512 MB',25,'<p>상근이는 "얼음을 꿈꾸다" 여행사의 사장이다. 이 여행사는 남극 근처의 섬 N개를 구매해 당일치기 여행을 제공하고 있다. 관광객들에게 가장 인기 있는 동물은 황제 펭귄으로 섬에서 쉽게 찾을 수 있다.</p>

<p>여행사는 점점 인기를 얻게 되었고, 이제 보트를 이용하는 것이 효율적이지 않은 상황까지 이르렀다. 상근이는 섬 사이에 다리를 건설해 관광객을 버스로 이동시키려고 한다. 상근이는 컴퓨터 프로그램을 이용해서 다리를 건설하는 과정을 관리하려고 한다.</p>

<p>섬은 1번부터 N번까지 번호가 매겨져 있다. 가장 처음에는 아무 다리도 없으며, 각 섬에 펭귄이 몇 마리 살고있는지는 모두 알고있다. 펭귄의 수는 변할 수 있다. 하지만, 항상 0보다 크거나 같고, 1000보다 작거나 같다.</p>

<p>상근이의 프로그램은 다음과 같은 세 가지 명령을 수행할 수 있어야 한다.</p>

<ul>
	<li>"bridge A B" - 섬 A와 B사이에 다리를 건설하는 명령이다. (A와 B는 다르다) 이전까지 지어진 다리를 이용해서 이동할 수 없는 경우에만 다리를 지어야 한다. 다리를 지어야 하면 "yes", 지을 필요가 없이 이미 이동할 수 있으면 "no"를 출력한다.</li>
	<li>"penguins A X" - 섬 A에 살고있는 펭귄의 수를 다시 세보니 X마리가 되었다는 명령이다. 아무것도 출력할 필요가 없다.</li>
	<li>"excursion A B" - 관광객들이 섬 A에서 시작해 B에서 끝나는 여행 경로를 이용하는 명령이다. A에서 B로 갈 수 있는 경우에는 이동하는 섬에 있는 모든 펭귄의 수를 구해 출력한다. (A와 B 포함) 이동할 수 없는 경우에는 "impossible"를 출력한다.</li>
</ul>

<p>상근이의 프로그램을 작성하시오.</p>

<p>"bridge", "excursion" 명령에 대한 답을 출력하기 전에는&nbsp;이후 명령이 주어지지 않는다. 따라서, 출력한 후에는 표준 출력 버퍼를 flush 해주어야 한다.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫째 줄에 섬의 수 N (1 ≤ N ≤ 30,000)이 주어진다.</p>

<p>둘째 줄에는 각 섬에 있는 펭귄의 수가 주어진다.</p>

<p>셋째 줄에는 명령의 개수 Q (1 ≤ Q ≤ 300,000)가 주어진다.</p>

<p>다음 Q개 줄에는 문제에서 주어진 명령 중 하나가 주어진다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>"bridge"나 "excursion" 명령이 주어질 때 마다 출력한다.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','5
4 2 4 5 6
10
excursion 1 1
excursion 1 2
bridge 1 2
excursion 1 2
bridge 3 4
bridge 3 5
excursion 4 5
bridge 1 3
excursion 2 4
excursion 2 5
','4
impossible
yes
6
yes
yes
15
yes
15
16
','TREE'),
                                                                                                                (10972,'BAEKJOON','https://www.acmicpc.net/problem/22253',22253,'트리 디자이너 호석','1초','1024 MB',15,'<p>트리를 너무나 사랑하는 효성이는 트리 분재 전문가이다. 효성이가 기르는 모든 트리는 정점과 간선으로 이루어져 있다. 정점은 $1$번부터 $N$번 정점까지 존재하며, 간선은 서로 다른 두 정점을 연결해준다. 정점의 개수는 간선의 개수보다 정확히 한 개가 많으며,&nbsp;사이클을 이루지 않는다. 트리의 뿌리는 정점 중 하나로, 모든 정점 중 가장 낮은 높이에 존재한다.&nbsp;항상 1번 정점이 트리의 뿌리임이 보장되고, 이파리란 연결된 간선이 1개 이하인 정점을 의미한다. 정점이 뿌리에 가까울수록 낮은 높이에 존재하며, 멀수록 높은 높이에 존재한다.</p>

<p>효성이가 기르는 트리는 특별하기 때문에,&nbsp;각 정점에 $0$ 이상 $9$ 이하의 정수가 적혀 있다. 어느 날 문득 크리스마스 트리를 만들고 싶어진 효성이는 1개 이상의 정점을 골라서 전구를 달고 싶어졌다. 이 때,&nbsp;정점을 고르는 방법은 뿌리에서 특정 이파리까지 가는 경로 위에서 고르는 것이다. 이 때 고른 전구들이 꼭 연속적으로 존재할 필요는 없다. 전구가 달린 정점들은 불빛이 들어오면서 정점에 적혀 있던 숫자가 밝게 빛나게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/cbac2bf9-b43b-44dd-9842-e769c922b8ef/-/preview/" style="width: 369.167px; height: 94.1667px;"></p>

<p>제일 왼쪽 그림이 효성이가 가지고 있는 나무라고 하자. 가운데와 오른쪽 그림은&nbsp;올바르게 전구를 고른 예시이다. 각 그림에서 밝혀진 전구에 적힌 숫자를 아래부터 순서대로 읽으면 $\{0, 0, 8\}$ 과 $\{3, 6, 3\}$ 이 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/a6c90ed3-9d5b-442d-b126-23a4fcf39c41/-/preview/" style="width: 340px; height: 135px;"></p>

<p>만약 고른 전구가 1번, 7번, 10번이라면 왼쪽과 같은데, 이런 경우에는 뿌리부터 특정 이파리까지의 경로 위에서 고른 것이 아니기 때문에 올바르지 못한 방법이다. 같은 이유로 4번, 5번, 8번, 9번 전구들을 골라도 안 된다.</p>

<p>트리 디자이너 호석은 효성이의 요구 사항을 들은 뒤에 한 가지 문제를 생각해냈다. 전구를 달았을 때, 낮은 높이부터 높은 높이까지 순서대로 숫자를 보았을 때, 오름차순을 만족하도록 전구를 다는&nbsp;경우의 수는 몇 가지인지 궁금해졌다.&nbsp;오름차순 수열이란 각 수가 이전보다 작아지지 않는 수열을 의미한다. 즉, 이전과 수가 같아도 여전히 오름차순을 만족한다. 예를 들어&nbsp;$\{0, 0, 8\}$은 오름차순이지만 $\{3, 6, 3\}$은 오름차순이 아니다.</p>

<p>효성이의 나무 정보가 주어졌을 때, 호석이가 궁금한 결과를 계산해보자.</p>


					<div class="headline">
					<h2>입력</h2>
					</div>
					<div id="problem_input" class="problem-text">
					<p>첫 번째 줄에는 정점의 개수 $N$이 주어진다.</p>

<p>두 번째 줄에는 $1$번부터 $N$번 정점에 써 있는 숫자가 공백으로 구분되어 주어진다. 각 숫자는 $0$ 이상 $9$ 이하의 자연수 이다.</p>

<p>세 번째 줄부터 $N-1$개의 줄에 걸쳐서 각 간선이 잇는 두 정점의 번호가 주어진다.</p>

<p>주어지는 나무는 하나의 연결된 그래프임이 보장된다.</p>

					</div>

					<div class="headline">
					<h2>출력</h2>
					</div>
					<div id="problem_output" class="problem-text">
					<p>전구를 달 수 있는 경우의 수를 10억 7로 나눈 나머지를 출력하라.</p>

					</div>

				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">

				</div>
				</div>','4
1 1 2 2
1 2
3 2
3 4
','15
','TREE');